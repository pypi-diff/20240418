# Comparing `tmp/yolov8-pose-triton-8.1.0.tar.gz` & `tmp/yolov8_pose_triton-8.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "yolov8-pose-triton-8.1.0.tar", last modified: Mon Nov 27 00:16:58 2023, max compression
+gzip compressed data, was "yolov8_pose_triton-8.2.0.tar", last modified: Thu Apr 18 19:55:58 2024, max compression
```

## Comparing `yolov8-pose-triton-8.1.0.tar` & `yolov8_pose_triton-8.2.0.tar`

### file list

```diff
@@ -1,214 +1,261 @@
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.753275 yolov8-pose-triton-8.1.0/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     5597 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/CONTRIBUTING.md
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    34523 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/LICENSE
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      200 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/MANIFEST.in
--rw-r--r--   0 harsh     (1000) harsh     (1000)    31588 2023-11-27 00:16:58.753275 yolov8-pose-triton-8.1.0/PKG-INFO
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    28854 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/README.md
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    27878 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/README.zh-CN.md
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1253 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/requirements.txt
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      973 2023-11-27 00:16:58.753275 yolov8-pose-triton-8.1.0/setup.cfg
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4072 2023-11-27 00:00:42.000000 yolov8-pose-triton-8.1.0/setup.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.725283 yolov8-pose-triton-8.1.0/tests/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3193 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/tests/conftest.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     5024 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/tests/test_cli.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3476 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/tests/test_cuda.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4562 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/tests/test_engine.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4682 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/tests/test_integrations.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    17975 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/tests/test_python.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.725283 yolov8-pose-triton-8.1.0/ultralytics/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      461 2023-11-27 00:14:17.000000 yolov8-pose-triton-8.1.0/ultralytics/__init__.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.725283 yolov8-pose-triton-8.1.0/ultralytics/assets/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)   137419 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/assets/bus.jpg
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    50427 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/assets/zidane.jpg
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.729282 yolov8-pose-triton-8.1.0/ultralytics/cfg/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    19816 2023-11-26 23:08:47.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/__init__.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.729282 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2856 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/Argoverse.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1149 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/DOTAv2.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1981 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/GlobalWheat2020.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    42439 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/ImageNet.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     9255 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/Objects365.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2427 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/SKU-110K.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3505 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/VOC.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3007 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/VisDrone.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1542 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco-pose.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2521 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1862 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco128-seg.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1846 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco128.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      895 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco8-pose.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1797 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco8-seg.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1777 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco8.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    12421 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/open-images-v7.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      797 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/tiger-pose.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     5153 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/xView.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     7584 2023-11-26 23:08:47.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/default.yaml
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.721284 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.729282 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/rt-detr/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1970 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/rt-detr/rtdetr-l.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2177 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/rt-detr/rtdetr-x.yaml
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.729282 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v3/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1550 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v3/yolov3-spp.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1252 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v3/yolov3-tiny.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1537 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v3/yolov3.yaml
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.729282 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v5/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1923 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v5/yolov5-p6.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1550 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v5/yolov5.yaml
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.729282 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v6/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1735 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v6/yolov6.yaml
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.733281 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      920 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-cls.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1751 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-p2.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1856 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-p6.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1949 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-pose-p6.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1580 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-pose.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1920 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-rtdetr.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1866 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-seg-p6.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1490 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-seg.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1913 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8.yaml
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.733281 yolov8-pose-triton-8.1.0/ultralytics/cfg/trackers/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      890 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/trackers/botsort.yaml
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      694 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/cfg/trackers/bytetrack.yaml
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.733281 yolov8-pose-triton-8.1.0/ultralytics/data/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      389 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/data/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2122 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/data/annotator.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    46710 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/data/augment.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    13309 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/data/base.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     6691 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/data/build.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    12444 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/data/converter.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    16019 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/data/dataset.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    22200 2023-11-26 23:08:47.000000 yolov8-pose-triton-8.1.0/ultralytics/data/loaders.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    29704 2023-11-26 23:08:47.000000 yolov8-pose-triton-8.1.0/ultralytics/data/utils.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.733281 yolov8-pose-triton-8.1.0/ultralytics/engine/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/engine/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    50375 2023-11-21 07:06:05.000000 yolov8-pose-triton-8.1.0/ultralytics/engine/exporter.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    19208 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/engine/model.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    17018 2023-11-26 23:08:47.000000 yolov8-pose-triton-8.1.0/ultralytics/engine/predictor.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    23454 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/engine/results.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    32553 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/engine/trainer.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    11374 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/engine/tuner.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    14484 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/engine/validator.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.733281 yolov8-pose-triton-8.1.0/ultralytics/hub/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3685 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/hub/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     5364 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/hub/auth.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     8423 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/hub/session.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     9581 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/hub/utils.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.733281 yolov8-pose-triton-8.1.0/ultralytics/models/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      173 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/__init__.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.737280 yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      254 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1055 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/model.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4111 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/predict.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    16279 2023-11-26 23:08:47.000000 yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/prompt.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2157 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/utils.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1967 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/val.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.737280 yolov8-pose-triton-8.1.0/ultralytics/models/nas/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      179 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/nas/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2864 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/nas/model.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2253 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/nas/predict.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1846 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/nas/val.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.737280 yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      197 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2144 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/model.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3425 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/predict.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3798 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/train.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     6619 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/val.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.737280 yolov8-pose-triton-8.1.0/ultralytics/models/sam/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      144 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     8107 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/amg.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4871 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/build.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4707 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/model.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.737280 yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     7795 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/decoders.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    25003 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/encoders.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2781 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/sam.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    28980 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/tiny_encoder.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    11157 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/transformer.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    23719 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/sam/predict.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.737280 yolov8-pose-triton-8.1.0/ultralytics/models/utils/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/utils/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    15961 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/utils/loss.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    13283 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/utils/ops.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.737280 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      195 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/__init__.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.741279 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/classify/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      355 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/classify/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1987 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/classify/predict.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     6738 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/classify/train.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4959 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/classify/val.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.741279 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/detect/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      229 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/detect/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1627 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/detect/predict.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     5531 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/detect/train.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    12964 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/detect/val.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1448 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/model.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.741279 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/pose/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      199 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/pose/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2517 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/pose/predict.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2891 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/pose/train.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    10656 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/pose/val.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.741279 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/segment/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      247 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/segment/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2612 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/segment/predict.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2276 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/segment/train.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    11956 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/models/yolo/segment/val.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.741279 yolov8-pose-triton-8.1.0/ultralytics/nn/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      555 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    27171 2023-11-26 23:08:47.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/autobackend.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.745278 yolov8-pose-triton-8.1.0/ultralytics/nn/modules/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1670 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/modules/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    13030 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/modules/block.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    12774 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/modules/conv.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    18323 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/modules/head.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    17895 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/modules/transformer.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3436 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/modules/utils.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    36513 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/nn/tasks.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.745278 yolov8-pose-triton-8.1.0/ultralytics/trackers/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      227 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     1609 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/basetrack.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     8602 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/bot_sort.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    18381 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/byte_tracker.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2551 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/track.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.745278 yolov8-pose-triton-8.1.0/ultralytics/trackers/utils/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/utils/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    12366 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/utils/gmc.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    14850 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/utils/kalman_filter.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4841 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/trackers/utils/matching.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.749276 yolov8-pose-triton-8.1.0/ultralytics/utils/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    33795 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3862 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/autobatch.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    18217 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/benchmarks.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.749276 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      214 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/__init__.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     5775 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/base.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     6010 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/clearml.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    13870 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/comet.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4997 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/dvc.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3350 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/hub.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4487 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/mlflow.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     3697 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/neptune.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      608 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/raytune.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2830 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/tensorboard.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     6762 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/wb.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    27524 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/checks.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2396 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/dist.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    18198 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/downloads.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      816 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/errors.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     5277 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/files.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    15936 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/instance.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    25731 2023-11-26 23:08:47.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/loss.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    47438 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/metrics.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    31353 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/ops.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     2233 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/patches.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    31687 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/plotting.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    13675 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/tal.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)    24547 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/torch_utils.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     4378 2023-11-26 23:09:11.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/triton.py
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     6227 2023-11-21 07:01:32.000000 yolov8-pose-triton-8.1.0/ultralytics/utils/tuner.py
-drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2023-11-27 00:16:58.753275 yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/
--rw-r--r--   0 harsh     (1000) harsh     (1000)    31588 2023-11-27 00:16:58.000000 yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/PKG-INFO
--rw-rw-r--   0 harsh     (1000) harsh     (1000)     6052 2023-11-27 00:16:58.000000 yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/SOURCES.txt
--rw-rw-r--   0 harsh     (1000) harsh     (1000)        1 2023-11-27 00:16:58.000000 yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/dependency_links.txt
--rw-rw-r--   0 harsh     (1000) harsh     (1000)       93 2023-11-27 00:16:58.000000 yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/entry_points.txt
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      452 2023-11-27 00:16:58.000000 yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/requires.txt
--rw-rw-r--   0 harsh     (1000) harsh     (1000)      787 2023-11-27 00:16:58.000000 yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/top_level.txt
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.816675 yolov8_pose_triton-8.2.0/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5585 2024-04-17 22:48:28.000000 yolov8_pose_triton-8.2.0/CONTRIBUTING.md
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    34523 2023-11-21 07:01:32.000000 yolov8_pose_triton-8.2.0/LICENSE
+-rw-r--r--   0 harsh     (1000) harsh     (1000)    40390 2024-04-18 19:55:58.812675 yolov8_pose_triton-8.2.0/PKG-INFO
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    36684 2024-04-17 22:49:55.000000 yolov8_pose_triton-8.2.0/README.md
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    35511 2024-04-17 22:49:55.000000 yolov8_pose_triton-8.2.0/README.zh-CN.md
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     7316 2024-04-18 19:55:39.000000 yolov8_pose_triton-8.2.0/pyproject.toml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       38 2024-04-18 19:55:58.816675 yolov8_pose_triton-8.2.0/setup.cfg
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.760675 yolov8_pose_triton-8.2.0/tests/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2602 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/tests/conftest.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5155 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/tests/test_cli.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3762 2024-04-17 22:49:55.000000 yolov8_pose_triton-8.2.0/tests/test_cuda.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     4712 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/tests/test_engine.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2167 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/tests/test_explorer.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6053 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/tests/test_integrations.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    22960 2024-04-17 22:49:55.000000 yolov8_pose_triton-8.2.0/tests/test_python.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.760675 yolov8_pose_triton-8.2.0/ultralytics/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      632 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/__init__.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.760675 yolov8_pose_triton-8.2.0/ultralytics/assets/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)   137419 2023-11-21 07:01:32.000000 yolov8_pose_triton-8.2.0/ultralytics/assets/bus.jpg
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    50427 2023-11-21 07:01:32.000000 yolov8_pose_triton-8.2.0/ultralytics/assets/zidane.jpg
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.760675 yolov8_pose_triton-8.2.0/ultralytics/cfg/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    21316 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/__init__.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.772675 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3134 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/Argoverse.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1193 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/DOTAv1.5.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1163 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/DOTAv1.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2058 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/GlobalWheat2020.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    42507 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/ImageNet.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     9324 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/Objects365.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2493 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/SKU-110K.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3655 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/VOC.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3073 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/VisDrone.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      869 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/african-wildlife.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      795 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/brain-tumor.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1207 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/carparts-seg.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1603 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco-pose.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2584 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1925 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco128-seg.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1908 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco128.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      961 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco8-pose.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1865 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco8-seg.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1840 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco8.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      791 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/crack-seg.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1042 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/dota8.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    29705 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/lvis.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    12493 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/open-images-v7.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      801 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/package-seg.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      864 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/tiger-pose.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5217 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/xView.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     8213 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/default.yaml
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.752675 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.772675 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/rt-detr/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1934 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/rt-detr/rtdetr-l.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1512 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/rt-detr/rtdetr-resnet101.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1510 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/rt-detr/rtdetr-resnet50.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2141 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/rt-detr/rtdetr-x.yaml
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.776675 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v3/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1525 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v3/yolov3-spp.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1229 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v3/yolov3-tiny.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1512 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v3/yolov3.yaml
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.776675 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v5/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1894 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v5/yolov5-p6.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1526 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v5/yolov5.yaml
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.780675 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v6/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1718 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v6/yolov6.yaml
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.784675 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      883 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-cls-resnet101.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      882 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-cls-resnet50.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      913 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-cls.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2288 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-ghost-p2.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2356 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-ghost-p6.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2096 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-ghost.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1899 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-obb.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1731 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-p2.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1835 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-p6.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1927 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-pose-p6.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1563 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-pose.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1896 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-rtdetr.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1845 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-seg-p6.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1474 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-seg.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2019 2024-04-17 22:48:31.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-world.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1956 2024-04-17 22:48:31.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-worldv2.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1889 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8.yaml
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.784675 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v9/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1271 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v9/yolov9c-seg.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1256 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v9/yolov9c.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2212 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v9/yolov9e-seg.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2196 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v9/yolov9e.yaml
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.784675 yolov8_pose_triton-8.2.0/ultralytics/cfg/trackers/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      883 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/trackers/botsort.yaml
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      688 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/cfg/trackers/bytetrack.yaml
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.784675 yolov8_pose_triton-8.2.0/ultralytics/data/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      616 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2117 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/annotator.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    57741 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/augment.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    13481 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/base.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     7266 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/build.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    17528 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/converter.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    22201 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/dataset.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.788675 yolov8_pose_triton-8.2.0/ultralytics/data/explorer/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      113 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/data/explorer/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    18711 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/explorer/explorer.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.788675 yolov8_pose_triton-8.2.0/ultralytics/data/explorer/gui/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/data/explorer/gui/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    10087 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/explorer/gui/dash.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     7085 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/explorer/utils.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    23142 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/loaders.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    10010 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/split_dota.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    30869 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/data/utils.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.788675 yolov8_pose_triton-8.2.0/ultralytics/engine/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2023-11-21 07:01:32.000000 yolov8_pose_triton-8.2.0/ultralytics/engine/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    54476 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/engine/exporter.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    40019 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/engine/model.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    17022 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/engine/predictor.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    30667 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/engine/results.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    34933 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/engine/trainer.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    11844 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/engine/tuner.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    14645 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/engine/validator.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.788675 yolov8_pose_triton-8.2.0/ultralytics/hub/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5068 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/hub/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5399 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/hub/auth.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    15197 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/hub/session.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     9721 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/hub/utils.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.788675 yolov8_pose_triton-8.2.0/ultralytics/models/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      197 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/__init__.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.792675 yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      254 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1055 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/model.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     4121 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/predict.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    16182 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/prompt.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2157 2023-11-21 07:01:32.000000 yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/utils.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1967 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/val.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.792675 yolov8_pose_triton-8.2.0/ultralytics/models/nas/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      179 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/nas/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2865 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/nas/model.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2136 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/nas/predict.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1680 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/nas/val.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.792675 yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      197 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1988 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/model.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3584 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/predict.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3685 2024-04-17 22:49:55.000000 yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/train.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5566 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/val.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.792675 yolov8_pose_triton-8.2.0/ultralytics/models/sam/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      144 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     7935 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/amg.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     4944 2024-04-17 22:49:55.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/build.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     4707 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/model.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.796675 yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2023-11-21 07:01:32.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     7816 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/decoders.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    24746 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/encoders.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2783 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/sam.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    29125 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/tiny_encoder.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    11164 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/transformer.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    23614 2024-04-17 22:49:55.000000 yolov8_pose_triton-8.2.0/ultralytics/models/sam/predict.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.796675 yolov8_pose_triton-8.2.0/ultralytics/models/utils/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2023-11-21 07:01:32.000000 yolov8_pose_triton-8.2.0/ultralytics/models/utils/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    15135 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/utils/loss.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    13244 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/utils/ops.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.796675 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      247 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/__init__.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.796675 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/classify/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      355 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/classify/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2513 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/classify/predict.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6888 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/classify/train.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     4861 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/classify/val.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.796675 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/detect/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      229 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/detect/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1510 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/detect/predict.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6353 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/detect/train.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    14427 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/detect/val.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3991 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/model.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.796675 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/obb/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      193 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/obb/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2037 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/obb/predict.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     1473 2024-04-17 22:48:31.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/obb/train.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     8511 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/obb/val.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.796675 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/pose/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      199 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/pose/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2404 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/pose/predict.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2926 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/pose/train.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    10607 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/pose/val.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.796675 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/segment/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      247 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/segment/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2491 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/segment/predict.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2298 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/segment/train.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    11745 2024-04-17 22:48:30.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/segment/val.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.800675 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/world/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      103 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/world/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3686 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/world/train.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     4805 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/models/yolo/world/train_world.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.800675 yolov8_pose_triton-8.2.0/ultralytics/nn/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      587 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    30896 2024-04-17 23:10:10.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/autobackend.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.800675 yolov8_pose_triton-8.2.0/ultralytics/nn/modules/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2326 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/modules/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    25251 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/modules/block.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    12722 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/modules/conv.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    22338 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/modules/head.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    17909 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/modules/transformer.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3196 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/modules/utils.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    43623 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/nn/tasks.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.804674 yolov8_pose_triton-8.2.0/ultralytics/solutions/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2024-04-17 22:48:28.000000 yolov8_pose_triton-8.2.0/ultralytics/solutions/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5696 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/solutions/ai_gym.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6334 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/solutions/distance_calculation.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    12276 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/solutions/heatmap.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    11558 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/solutions/object_counter.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6684 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/solutions/queue_management.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6714 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/solutions/speed_estimation.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.804674 yolov8_pose_triton-8.2.0/ultralytics/trackers/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      227 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3675 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/basetrack.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     8601 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/bot_sort.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    18871 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/byte_tracker.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3463 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/track.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.804674 yolov8_pose_triton-8.2.0/ultralytics/trackers/utils/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       42 2023-11-21 07:01:32.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/utils/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    13688 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/utils/gmc.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    15168 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/utils/kalman_filter.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5404 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/trackers/utils/matching.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.808674 yolov8_pose_triton-8.2.0/ultralytics/utils/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    39292 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3863 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/autobatch.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    18539 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/benchmarks.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.808674 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      214 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/__init__.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5776 2024-04-17 22:49:55.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/base.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5923 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/clearml.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    13744 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/comet.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5045 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/dvc.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3586 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/hub.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     5323 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/mlflow.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     3756 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/neptune.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      705 2024-04-17 22:49:54.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/raytune.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     4135 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/tensorboard.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6674 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/wb.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    27971 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/checks.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2267 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/dist.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    21496 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/downloads.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      816 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/errors.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6761 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/files.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    15575 2024-04-17 22:48:29.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/instance.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    32717 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/loss.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    53518 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/metrics.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    33309 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/ops.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     2750 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/patches.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    47558 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/plotting.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    16017 2024-04-17 22:48:31.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/tal.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)    25848 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/torch_utils.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     4365 2024-04-17 23:09:32.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/triton.py
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     6171 2024-04-17 23:05:20.000000 yolov8_pose_triton-8.2.0/ultralytics/utils/tuner.py
+drwxrwxr-x   0 harsh     (1000) harsh     (1000)        0 2024-04-18 19:55:58.808674 yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/
+-rw-r--r--   0 harsh     (1000) harsh     (1000)    40390 2024-04-18 19:55:58.000000 yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/PKG-INFO
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)     7776 2024-04-18 19:55:58.000000 yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/SOURCES.txt
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)        1 2024-04-18 19:55:58.000000 yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/dependency_links.txt
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       93 2024-04-18 19:55:58.000000 yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/entry_points.txt
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)      824 2024-04-18 19:55:58.000000 yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/requires.txt
+-rw-rw-r--   0 harsh     (1000) harsh     (1000)       12 2024-04-18 19:55:58.000000 yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/top_level.txt
```

### Comparing `yolov8-pose-triton-8.1.0/CONTRIBUTING.md` & `yolov8_pose_triton-8.2.0/CONTRIBUTING.md`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-## Contributing to YOLOv8 
+# Contributing to YOLOv8 
 
 We love your input! We want to make contributing to YOLOv8 as easy and transparent as possible, whether it's:
 
 - Reporting a bug
 - Discussing the current state of the code
 - Submitting a fix
 - Proposing a new feature
 - Becoming a maintainer
 
-YOLOv8 works so well due to our combined community effort, and for every small improvement you contribute you will be
-helping push the frontiers of what's possible in AI !
+YOLOv8 works so well due to our combined community effort, and for every small improvement you contribute you will be helping push the frontiers of what's possible in AI !
 
 ## Submitting a Pull Request (PR) 
 
 Submitting a PR is easy! This example shows how to submit a PR for updating `requirements.txt` in 4 steps:
 
 ### 1. Select File to Update
 
@@ -31,41 +30,35 @@
 
 Change `matplotlib` version from `3.2.2` to `3.3`.
 
 <p align="center"><img width="800" alt="PR_step3" src="https://user-images.githubusercontent.com/26833433/122260853-0a87e980-ced4-11eb-9fd2-3650fb6e0842.png"></p>
 
 ### 4. Preview Changes and Submit PR
 
-Click on the **Preview changes** tab to verify your updates. At the bottom of the screen select 'Create a **new branch**
-for this commit', assign your branch a descriptive name such as `fix/matplotlib_version` and click the green **Propose
-changes** button. All done, your PR is now submitted to YOLOv8 for review and approval !
+Click on the **Preview changes** tab to verify your updates. At the bottom of the screen select 'Create a **new branch** for this commit', assign your branch a descriptive name such as `fix/matplotlib_version` and click the green **Propose changes** button. All done, your PR is now submitted to YOLOv8 for review and approval !
 
 <p align="center"><img width="800" alt="PR_step4" src="https://user-images.githubusercontent.com/26833433/122260856-0b208000-ced4-11eb-8e8e-77b6151cbcc3.png"></p>
 
 ### PR recommendations
 
 To allow your work to be integrated as seamlessly as possible, we advise you to:
 
--  Verify your PR is **up-to-date** with `ultralytics/ultralytics` `main` branch. If your PR is behind you can update
-  your code by clicking the 'Update branch' button or by running `git pull` and `git merge main` locally.
+-  Verify your PR is **up-to-date** with `ultralytics/ultralytics` `main` branch. If your PR is behind you can update your code by clicking the 'Update branch' button or by running `git pull` and `git merge main` locally.
 
 <p align="center"><img width="751" alt="PR recommendation 1" src="https://user-images.githubusercontent.com/26833433/187295893-50ed9f44-b2c9-4138-a614-de69bd1753d7.png"></p>
 
 -  Verify all YOLOv8 Continuous Integration (CI) **checks are passing**.
 
 <p align="center"><img width="751" alt="PR recommendation 2" src="https://user-images.githubusercontent.com/26833433/187296922-545c5498-f64a-4d8c-8300-5fa764360da6.png"></p>
 
--  Reduce changes to the absolute **minimum** required for your bug fix or feature addition. _"It is not daily increase
-  but daily decrease, hack away the unessential. The closer to the source, the less wastage there is."_   Bruce Lee
+-  Reduce changes to the absolute **minimum** required for your bug fix or feature addition. _"It is not daily increase but daily decrease, hack away the unessential. The closer to the source, the less wastage there is."_  Bruce Lee
 
 ### Docstrings
 
-Not all functions or classes require docstrings but when they do, we
-follow [google-style docstrings format](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings).
-Here is an example:
+Not all functions or classes require docstrings but when they do, we follow [google-style docstrings format](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings). Here is an example:
 
 ```python
 """
     What the function does. Performs NMS on given detection predictions.
 
     Args:
         arg1: The description of the 1st argument
@@ -79,37 +72,25 @@
 """
 ```
 
 ## Submitting a Bug Report 
 
 If you spot a problem with YOLOv8 please submit a Bug Report!
 
-For us to start investigating a possible problem we need to be able to reproduce it ourselves first. We've created a few
-short guidelines below to help users provide what we need in order to get started.
+For us to start investigating a possible problem we need to be able to reproduce it ourselves first. We've created a few short guidelines below to help users provide what we need in order to get started.
 
-When asking a question, people will be better able to provide help if you provide **code** that they can easily
-understand and use to **reproduce** the problem. This is referred to by community members as creating
-a [minimum reproducible example](https://docs.ultralytics.com/help/minimum_reproducible_example/). Your code that reproduces
-the problem should be:
+When asking a question, people will be better able to provide help if you provide **code** that they can easily understand and use to **reproduce** the problem. This is referred to by community members as creating a [minimum reproducible example](https://docs.ultralytics.com/help/minimum_reproducible_example/). Your code that reproduces the problem should be:
 
 -  **Minimal**  Use as little code as possible that still produces the same problem
 -  **Complete**  Provide **all** parts someone else needs to reproduce your problem in the question itself
 -  **Reproducible**  Test the code you're about to provide to make sure it reproduces the problem
 
-In addition to the above requirements, for [Ultralytics](https://ultralytics.com/) to provide assistance your code
-should be:
+In addition to the above requirements, for [Ultralytics](https://ultralytics.com/) to provide assistance your code should be:
 
--  **Current**  Verify that your code is up-to-date with current
-  GitHub [main](https://github.com/ultralytics/ultralytics/tree/main) branch, and if necessary `git pull` or `git clone`
-  a new copy to ensure your problem has not already been resolved by previous commits.
--  **Unmodified**  Your problem must be reproducible without any modifications to the codebase in this
-  repository. [Ultralytics](https://ultralytics.com/) does not provide support for custom code .
-
-If you believe your problem meets all of the above criteria, please close this issue and raise a new one using the 
-**Bug Report** [template](https://github.com/ultralytics/ultralytics/issues/new/choose) and providing
-a [minimum reproducible example](https://docs.ultralytics.com/help/minimum_reproducible_example/) to help us better
-understand and diagnose your problem.
+-  **Current**  Verify that your code is up-to-date with current GitHub [main](https://github.com/ultralytics/ultralytics/tree/main) branch, and if necessary `git pull` or `git clone` a new copy to ensure your problem has not already been resolved by previous commits.
+-  **Unmodified**  Your problem must be reproducible without any modifications to the codebase in this repository. [Ultralytics](https://ultralytics.com/) does not provide support for custom code .
+
+If you believe your problem meets all of the above criteria, please close this issue and raise a new one using the  **Bug Report** [template](https://github.com/ultralytics/ultralytics/issues/new/choose) and providing a [minimum reproducible example](https://docs.ultralytics.com/help/minimum_reproducible_example/) to help us better understand and diagnose your problem.
 
 ## License
 
-By contributing, you agree that your contributions will be licensed under
-the [AGPL-3.0 license](https://choosealicense.com/licenses/agpl-3.0/)
+By contributing, you agree that your contributions will be licensed under the [AGPL-3.0 license](https://choosealicense.com/licenses/agpl-3.0/)
```

### Comparing `yolov8-pose-triton-8.1.0/LICENSE` & `yolov8_pose_triton-8.2.0/LICENSE`

 * *Files identical despite different names*

### Comparing `yolov8-pose-triton-8.1.0/PKG-INFO` & `yolov8_pose_triton-8.2.0/README.md`

 * *Files 10% similar despite different names*

```diff
@@ -1,150 +1,86 @@
-Metadata-Version: 2.1
-Name: yolov8-pose-triton
-Version: 8.1.0
-Summary: Ultralytics YOLOv8 for SOTA object detection, multi-object tracking, instance segmentation, pose estimation and image classification.
-Home-page: https://github.com/ultralytics/ultralytics
-Author: Ultralytics
-Author-email: hello@ultralytics.com
-License: AGPL-3.0
-Project-URL: Bug Reports, https://github.com/ultralytics/ultralytics/issues
-Project-URL: Funding, https://ultralytics.com
-Project-URL: Source, https://github.com/hmurari/ultralytics
-Keywords: machine-learning,deep-learning,vision,ML,DL,AI,YOLO,YOLOv3,YOLOv5,YOLOv8,HUB,Ultralytics
-Classifier: Development Status :: 4 - Beta
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Education
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Software Development
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
-Classifier: Topic :: Scientific/Engineering :: Image Recognition
-Classifier: Operating System :: POSIX :: Linux
-Classifier: Operating System :: MacOS
-Classifier: Operating System :: Microsoft :: Windows
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: matplotlib>=3.3.0
-Requires-Dist: numpy>=1.22.2
-Requires-Dist: opencv-python>=4.6.0
-Requires-Dist: pillow>=7.1.2
-Requires-Dist: pyyaml>=5.3.1
-Requires-Dist: requests>=2.23.0
-Requires-Dist: scipy>=1.4.1
-Requires-Dist: torch>=1.8.0
-Requires-Dist: torchvision>=0.9.0
-Requires-Dist: tqdm>=4.64.0
-Requires-Dist: pandas>=1.1.4
-Requires-Dist: seaborn>=0.11.0
-Requires-Dist: psutil
-Requires-Dist: py-cpuinfo
-Requires-Dist: thop>=0.1.1
-Provides-Extra: dev
-Requires-Dist: ipython; extra == "dev"
-Requires-Dist: check-manifest; extra == "dev"
-Requires-Dist: pre-commit; extra == "dev"
-Requires-Dist: pytest; extra == "dev"
-Requires-Dist: pytest-cov; extra == "dev"
-Requires-Dist: coverage; extra == "dev"
-Requires-Dist: mkdocs-material; extra == "dev"
-Requires-Dist: mkdocstrings[python]; extra == "dev"
-Requires-Dist: mkdocs-redirects; extra == "dev"
-Requires-Dist: mkdocs-ultralytics-plugin>=0.0.34; extra == "dev"
-Provides-Extra: export
-Requires-Dist: coremltools>=7.0; extra == "export"
-Requires-Dist: openvino-dev>=2023.0; extra == "export"
-Requires-Dist: tensorflow<=2.13.1; extra == "export"
-Requires-Dist: tensorflowjs; extra == "export"
-
 <div align="center">
   <p>
-    <a href="https://yolovision.ultralytics.com/" target="_blank">
-      <img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/im/banner-yolo-vision-2023.png"></a>
+    <a href="https://github.com/ultralytics/assets/releases/tag/v8.2.0" target="_blank">
+      <img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/banner-yolov8.png" alt="YOLO Vision banner"></a>
   </p>
 
-[](https://docs.ultralytics.com/zh/) | [](https://docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) | [](https://docs.ultralytics.com/ru/) | [Deutsch](https://docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) | [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/hi/) | [](https://docs.ultralytics.com/ar/)
-<br>
+[](https://docs.ultralytics.com/zh/) | [](https://docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) | [](https://docs.ultralytics.com/ru/) | [Deutsch](https://docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) | [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/hi/) | [](https://docs.ultralytics.com/ar/) <br>
 
 <div>
     <a href="https://github.com/ultralytics/ultralytics/actions/workflows/ci.yaml"><img src="https://github.com/ultralytics/ultralytics/actions/workflows/ci.yaml/badge.svg" alt="Ultralytics CI"></a>
     <a href="https://codecov.io/github/ultralytics/ultralytics"><img src="https://codecov.io/github/ultralytics/ultralytics/branch/main/graph/badge.svg?token=HHW7IIVFVY" alt="Ultralytics Code Coverage"></a>
     <a href="https://zenodo.org/badge/latestdoi/264818686"><img src="https://zenodo.org/badge/264818686.svg" alt="YOLOv8 Citation"></a>
     <a href="https://hub.docker.com/r/ultralytics/ultralytics"><img src="https://img.shields.io/docker/pulls/ultralytics/ultralytics?logo=docker" alt="Docker Pulls"></a>
+    <a href="https://ultralytics.com/discord"><img alt="Discord" src="https://img.shields.io/discord/1089800235347353640?logo=discord&logoColor=white&label=Discord&color=blue"></a>
     <br>
-    <a href="https://console.paperspace.com/github/ultralytics/ultralytics"><img src="https://assets.paperspace.io/img/gradient-badge.svg" alt="Run on Gradient"/></a>
+    <a href="https://console.paperspace.com/github/ultralytics/ultralytics"><img src="https://assets.paperspace.io/img/gradient-badge.svg" alt="Run on Gradient"></a>
     <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/tutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>
     <a href="https://www.kaggle.com/ultralytics/yolov8"><img src="https://kaggle.com/static/images/open-in-kaggle.svg" alt="Open In Kaggle"></a>
 </div>
 <br>
 
 [Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/ultralytics) is a cutting-edge, state-of-the-art (SOTA) model that builds upon the success of previous YOLO versions and introduces new features and improvements to further boost performance and flexibility. YOLOv8 is designed to be fast, accurate, and easy to use, making it an excellent choice for a wide range of object detection and tracking, instance segmentation, image classification and pose estimation tasks.
 
 We hope that the resources here will help you get the most out of YOLOv8. Please browse the YOLOv8 <a href="https://docs.ultralytics.com/">Docs</a> for details, raise an issue on <a href="https://github.com/ultralytics/ultralytics/issues/new/choose">GitHub</a> for support, and join our <a href="https://ultralytics.com/discord">Discord</a> community for questions and discussions!
 
 To request an Enterprise License please complete the form at [Ultralytics Licensing](https://ultralytics.com/license).
 
-<img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-plots.png"></a>
+<img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-plots.png" alt="YOLOv8 performance plots"></a>
 
 <div align="center">
   <a href="https://github.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-github.png" width="2%" alt="Ultralytics GitHub"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.linkedin.com/company/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-linkedin.png" width="2%" alt="Ultralytics LinkedIn"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://twitter.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-twitter.png" width="2%" alt="Ultralytics Twitter"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://youtube.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-youtube.png" width="2%" alt="Ultralytics YouTube"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.tiktok.com/@ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-tiktok.png" width="2%" alt="Ultralytics TikTok"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.instagram.com/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-instagram.png" width="2%" alt="Ultralytics Instagram"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://ultralytics.com/discord"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-discord.png" width="2%" alt="Ultralytics Discord"></a>
 </div>
 </div>
 
 ## <div align="center">Documentation</div>
 
 See below for a quickstart installation and usage example, and see the [YOLOv8 Docs](https://docs.ultralytics.com) for full documentation on training, validation, prediction and deployment.
 
 <details open>
 <summary>Install</summary>
 
-Pip install the ultralytics package including all [requirements](https://github.com/ultralytics/ultralytics/blob/main/requirements.txt) in a [**Python>=3.8**](https://www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-started/locally/).
+Pip install the ultralytics package including all [requirements](https://github.com/ultralytics/ultralytics/blob/main/pyproject.toml) in a [**Python>=3.8**](https://www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-started/locally/).
 
 [![PyPI version](https://badge.fury.io/py/ultralytics.svg)](https://badge.fury.io/py/ultralytics) [![Downloads](https://static.pepy.tech/badge/ultralytics)](https://pepy.tech/project/ultralytics)
 
 ```bash
 pip install ultralytics
 ```
 
 For alternative installation methods including [Conda](https://anaconda.org/conda-forge/ultralytics), [Docker](https://hub.docker.com/r/ultralytics/ultralytics), and Git, please refer to the [Quickstart Guide](https://docs.ultralytics.com/quickstart).
 
 </details>
 
 <details open>
 <summary>Usage</summary>
 
-#### CLI
+### CLI
 
 YOLOv8 may be used directly in the Command Line Interface (CLI) with a `yolo` command:
 
 ```bash
 yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'
 ```
 
 `yolo` can be used for a variety of tasks and modes and accepts additional arguments, i.e. `imgsz=640`. See the YOLOv8 [CLI Docs](https://docs.ultralytics.com/usage/cli) for examples.
 
-#### Python
+### Python
 
 YOLOv8 may also be used directly in a Python environment, and accepts the same [arguments](https://docs.ultralytics.com/usage/cfg/) as in the CLI example above:
 
 ```python
 from ultralytics import YOLO
 
 # Load a model
@@ -158,146 +94,165 @@
 path = model.export(format="onnx")  # export the model to ONNX format
 ```
 
 See YOLOv8 [Python Docs](https://docs.ultralytics.com/usage/python) for more examples.
 
 </details>
 
+### Notebooks
+
+Ultralytics provides interactive notebooks for YOLOv8, covering training, validation, tracking, and more. Each notebook is paired with a [YouTube](https://youtube.com/ultralytics) tutorial, making it easy to learn and implement advanced YOLOv8 features.
+
+| Docs                                                                                                                              | Notebook                                                                                                                                                                                                                   |                                                                                                     YouTube                                                                                                     |
+| --------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
+| <a href="https://docs.ultralytics.com/modes/">YOLOv8 Train, Val, Predict and Export Modes</a>                                     | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/tutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                  | <a href="https://youtu.be/j8uQc0qB91s"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/hub/quickstart/">Ultralytics HUB QuickStart</a>                                             | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/hub.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                       | <a href="https://youtu.be/lveF9iCMIzc"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/modes/track/">YOLOv8 Multi-Object Tracking in Videos</a>                                    | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/object_tracking.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>           | <a href="https://youtu.be/hHyHmOtmEgs"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/guides/object-counting/">YOLOv8 Object Counting in Videos</a>                               | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/object_counting.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>           | <a href="https://youtu.be/Ag2e-5_NpS0"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/guides/heatmaps/">YOLOv8 Heatmaps in Videos</a>                                             | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/heatmaps.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                  | <a href="https://youtu.be/4ezde5-nZZw"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/datasets/explorer/">Ultralytics Datasets Explorer with SQL and OpenAI Integration  New</a> | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/docs/en/datasets/explorer/explorer.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a> | <a href="https://youtu.be/3VryynorQeo"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+
 ## <div align="center">Models</div>
 
 YOLOv8 [Detect](https://docs.ultralytics.com/tasks/detect), [Segment](https://docs.ultralytics.com/tasks/segment) and [Pose](https://docs.ultralytics.com/tasks/pose) models pretrained on the [COCO](https://docs.ultralytics.com/datasets/detect/coco) dataset are available here, as well as YOLOv8 [Classify](https://docs.ultralytics.com/tasks/classify) models pretrained on the [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet) dataset. [Track](https://docs.ultralytics.com/modes/track) mode is available for all Detect, Segment and Pose models.
 
 <img width="1024" src="https://raw.githubusercontent.com/ultralytics/assets/main/im/banner-tasks.png" alt="Ultralytics YOLO supported tasks">
 
 All [Models](https://github.com/ultralytics/ultralytics/tree/main/ultralytics/cfg/models) download automatically from the latest Ultralytics [release](https://github.com/ultralytics/assets/releases) on first use.
 
 <details open><summary>Detection (COCO)</summary>
 
 See [Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples with these models trained on [COCO](https://docs.ultralytics.com/datasets/detect/coco/), which include 80 pre-trained classes.
 
 | Model                                                                                | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
 | ------------------------------------------------------------------------------------ | --------------------- | -------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt) | 640                   | 37.3                 | 80.4                           | 0.99                                | 3.2                | 8.7               |
-| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s.pt) | 640                   | 44.9                 | 128.4                          | 1.20                                | 11.2               | 28.6              |
-| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m.pt) | 640                   | 50.2                 | 234.7                          | 1.83                                | 25.9               | 78.9              |
-| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l.pt) | 640                   | 52.9                 | 375.2                          | 2.39                                | 43.7               | 165.2             |
-| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x.pt) | 640                   | 53.9                 | 479.1                          | 3.53                                | 68.2               | 257.8             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](http://cocodataset.org) dataset.
-  <br>Reproduce by `yolo val detect data=coco.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu`
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n.pt) | 640                   | 37.3                 | 80.4                           | 0.99                                | 3.2                | 8.7               |
+| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s.pt) | 640                   | 44.9                 | 128.4                          | 1.20                                | 11.2               | 28.6              |
+| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m.pt) | 640                   | 50.2                 | 234.7                          | 1.83                                | 25.9               | 78.9              |
+| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l.pt) | 640                   | 52.9                 | 375.2                          | 2.39                                | 43.7               | 165.2             |
+| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x.pt) | 640                   | 53.9                 | 479.1                          | 3.53                                | 68.2               | 257.8             |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val detect data=coco.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu`
 
 </details>
 
 <details><summary>Detection (Open Image V7)</summary>
 
 See [Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples with these models trained on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/), which include 600 pre-trained classes.
 
 | Model                                                                                     | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
 | ----------------------------------------------------------------------------------------- | --------------------- | -------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-oiv7.pt) | 640                   | 18.4                 | 142.4                          | 1.21                                | 3.5                | 10.5              |
-| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-oiv7.pt) | 640                   | 27.7                 | 183.1                          | 1.40                                | 11.4               | 29.7              |
-| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-oiv7.pt) | 640                   | 33.6                 | 408.5                          | 2.26                                | 26.2               | 80.6              |
-| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-oiv7.pt) | 640                   | 34.9                 | 596.9                          | 2.43                                | 44.1               | 167.4             |
-| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-oiv7.pt) | 640                   | 36.3                 | 860.6                          | 3.56                                | 68.7               | 260.6             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/) dataset.
-  <br>Reproduce by `yolo val detect data=open-images-v7.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-oiv7.pt) | 640                   | 18.4                 | 142.4                          | 1.21                                | 3.5                | 10.5              |
+| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-oiv7.pt) | 640                   | 27.7                 | 183.1                          | 1.40                                | 11.4               | 29.7              |
+| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-oiv7.pt) | 640                   | 33.6                 | 408.5                          | 2.26                                | 26.2               | 80.6              |
+| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-oiv7.pt) | 640                   | 34.9                 | 596.9                          | 2.43                                | 44.1               | 167.4             |
+| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-oiv7.pt) | 640                   | 36.3                 | 860.6                          | 3.56                                | 68.7               | 260.6             |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/) dataset. <br>Reproduce by `yolo val detect data=open-images-v7.yaml device=0`
+- **Speed** averaged over Open Image V7 val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
 
 </details>
 
 <details><summary>Segmentation (COCO)</summary>
 
 See [Segmentation Docs](https://docs.ultralytics.com/tasks/segment/) for usage examples with these models trained on [COCO-Seg](https://docs.ultralytics.com/datasets/segment/coco/), which include 80 pre-trained classes.
 
 | Model                                                                                        | size<br><sup>(pixels) | mAP<sup>box<br>50-95 | mAP<sup>mask<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
 | -------------------------------------------------------------------------------------------- | --------------------- | -------------------- | --------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-seg.pt) | 640                   | 36.7                 | 30.5                  | 96.1                           | 1.21                                | 3.4                | 12.6              |
-| [YOLOv8s-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-seg.pt) | 640                   | 44.6                 | 36.8                  | 155.7                          | 1.47                                | 11.8               | 42.6              |
-| [YOLOv8m-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-seg.pt) | 640                   | 49.9                 | 40.8                  | 317.0                          | 2.18                                | 27.3               | 110.2             |
-| [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-seg.pt) | 640                   | 52.3                 | 42.6                  | 572.4                          | 2.79                                | 46.0               | 220.5             |
-| [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-seg.pt) | 640                   | 53.4                 | 43.4                  | 712.1                          | 4.02                                | 71.8               | 344.1             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](http://cocodataset.org) dataset.
-  <br>Reproduce by `yolo val segment data=coco-seg.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu`
+| [YOLOv8n-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-seg.pt) | 640                   | 36.7                 | 30.5                  | 96.1                           | 1.21                                | 3.4                | 12.6              |
+| [YOLOv8s-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-seg.pt) | 640                   | 44.6                 | 36.8                  | 155.7                          | 1.47                                | 11.8               | 42.6              |
+| [YOLOv8m-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-seg.pt) | 640                   | 49.9                 | 40.8                  | 317.0                          | 2.18                                | 27.3               | 110.2             |
+| [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-seg.pt) | 640                   | 52.3                 | 42.6                  | 572.4                          | 2.79                                | 46.0               | 220.5             |
+| [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-seg.pt) | 640                   | 53.4                 | 43.4                  | 712.1                          | 4.02                                | 71.8               | 344.1             |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val segment data=coco-seg.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu`
 
 </details>
 
 <details><summary>Pose (COCO)</summary>
 
 See [Pose Docs](https://docs.ultralytics.com/tasks/pose/) for usage examples with these models trained on [COCO-Pose](https://docs.ultralytics.com/datasets/pose/coco/), which include 1 pre-trained class, person.
 
 | Model                                                                                                | size<br><sup>(pixels) | mAP<sup>pose<br>50-95 | mAP<sup>pose<br>50 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
 | ---------------------------------------------------------------------------------------------------- | --------------------- | --------------------- | ------------------ | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-pose.pt)       | 640                   | 50.4                  | 80.1               | 131.8                          | 1.18                                | 3.3                | 9.2               |
-| [YOLOv8s-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-pose.pt)       | 640                   | 60.0                  | 86.2               | 233.2                          | 1.42                                | 11.6               | 30.2              |
-| [YOLOv8m-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-pose.pt)       | 640                   | 65.0                  | 88.8               | 456.3                          | 2.00                                | 26.4               | 81.0              |
-| [YOLOv8l-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-pose.pt)       | 640                   | 67.6                  | 90.0               | 784.5                          | 2.59                                | 44.4               | 168.6             |
-| [YOLOv8x-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-pose.pt)       | 640                   | 69.2                  | 90.2               | 1607.1                         | 3.73                                | 69.4               | 263.2             |
-| [YOLOv8x-pose-p6](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-pose-p6.pt) | 1280                  | 71.6                  | 91.2               | 4088.7                         | 10.04                               | 99.1               | 1066.4            |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO Keypoints val2017](http://cocodataset.org)
-  dataset.
-  <br>Reproduce by `yolo val pose data=coco-pose.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
+| [YOLOv8n-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-pose.pt)       | 640                   | 50.4                  | 80.1               | 131.8                          | 1.18                                | 3.3                | 9.2               |
+| [YOLOv8s-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-pose.pt)       | 640                   | 60.0                  | 86.2               | 233.2                          | 1.42                                | 11.6               | 30.2              |
+| [YOLOv8m-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-pose.pt)       | 640                   | 65.0                  | 88.8               | 456.3                          | 2.00                                | 26.4               | 81.0              |
+| [YOLOv8l-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-pose.pt)       | 640                   | 67.6                  | 90.0               | 784.5                          | 2.59                                | 44.4               | 168.6             |
+| [YOLOv8x-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-pose.pt)       | 640                   | 69.2                  | 90.2               | 1607.1                         | 3.73                                | 69.4               | 263.2             |
+| [YOLOv8x-pose-p6](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-pose-p6.pt) | 1280                  | 71.6                  | 91.2               | 4088.7                         | 10.04                               | 99.1               | 1066.4            |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO Keypoints val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val pose data=coco-pose.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
+
+</details>
+
+<details><summary>OBB (DOTAv1)</summary>
+
+See [OBB Docs](https://docs.ultralytics.com/tasks/obb/) for usage examples with these models trained on [DOTAv1](https://docs.ultralytics.com/datasets/obb/dota-v2/#dota-v10/), which include 15 pre-trained classes.
+
+| Model                                                                                        | size<br><sup>(pixels) | mAP<sup>test<br>50 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
+| -------------------------------------------------------------------------------------------- | --------------------- | ------------------ | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
+| [YOLOv8n-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-obb.pt) | 1024                  | 78.0               | 204.77                         | 3.57                                | 3.1                | 23.3              |
+| [YOLOv8s-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-obb.pt) | 1024                  | 79.5               | 424.88                         | 4.07                                | 11.4               | 76.3              |
+| [YOLOv8m-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-obb.pt) | 1024                  | 80.5               | 763.48                         | 7.61                                | 26.4               | 208.6             |
+| [YOLOv8l-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-obb.pt) | 1024                  | 80.7               | 1278.42                        | 11.83                               | 44.5               | 433.8             |
+| [YOLOv8x-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-obb.pt) | 1024                  | 81.36              | 1759.10                        | 13.23                               | 69.5               | 676.7             |
+
+- **mAP<sup>test</sup>** values are for single-model multiscale on [DOTAv1](https://captain-whu.github.io/DOTA/index.html) dataset. <br>Reproduce by `yolo val obb data=DOTAv1.yaml device=0 split=test` and submit merged results to [DOTA evaluation](https://captain-whu.github.io/DOTA/evaluation.html).
+- **Speed** averaged over DOTAv1 val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu`
 
 </details>
 
 <details><summary>Classification (ImageNet)</summary>
 
 See [Classification Docs](https://docs.ultralytics.com/tasks/classify/) for usage examples with these models trained on [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/), which include 1000 pretrained classes.
 
 | Model                                                                                        | size<br><sup>(pixels) | acc<br><sup>top1 | acc<br><sup>top5 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) at 640 |
 | -------------------------------------------------------------------------------------------- | --------------------- | ---------------- | ---------------- | ------------------------------ | ----------------------------------- | ------------------ | ------------------------ |
-| [YOLOv8n-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-cls.pt) | 224                   | 66.6             | 87.0             | 12.9                           | 0.31                                | 2.7                | 4.3                      |
-| [YOLOv8s-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-cls.pt) | 224                   | 72.3             | 91.1             | 23.4                           | 0.35                                | 6.4                | 13.5                     |
-| [YOLOv8m-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-cls.pt) | 224                   | 76.4             | 93.2             | 85.4                           | 0.62                                | 17.0               | 42.7                     |
-| [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-cls.pt) | 224                   | 78.0             | 94.1             | 163.0                          | 0.87                                | 37.5               | 99.7                     |
-| [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-cls.pt) | 224                   | 78.4             | 94.3             | 232.0                          | 1.01                                | 57.4               | 154.8                    |
-
-- **acc** values are model accuracies on the [ImageNet](https://www.image-net.org/) dataset validation set.
-  <br>Reproduce by `yolo val classify data=path/to/ImageNet device=0`
-- **Speed** averaged over ImageNet val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu`
+| [YOLOv8n-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-cls.pt) | 224                   | 69.0             | 88.3             | 12.9                           | 0.31                                | 2.7                | 4.3                      |
+| [YOLOv8s-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-cls.pt) | 224                   | 73.8             | 91.7             | 23.4                           | 0.35                                | 6.4                | 13.5                     |
+| [YOLOv8m-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-cls.pt) | 224                   | 76.8             | 93.5             | 85.4                           | 0.62                                | 17.0               | 42.7                     |
+| [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-cls.pt) | 224                   | 76.8             | 93.5             | 163.0                          | 0.87                                | 37.5               | 99.7                     |
+| [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-cls.pt) | 224                   | 79.0             | 94.6             | 232.0                          | 1.01                                | 57.4               | 154.8                    |
+
+- **acc** values are model accuracies on the [ImageNet](https://www.image-net.org/) dataset validation set. <br>Reproduce by `yolo val classify data=path/to/ImageNet device=0`
+- **Speed** averaged over ImageNet val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu`
 
 </details>
 
 ## <div align="center">Integrations</div>
 
 Our key integrations with leading AI platforms extend the functionality of Ultralytics' offerings, enhancing tasks like dataset labeling, training, visualization, and model management. Discover how Ultralytics, in collaboration with [Roboflow](https://roboflow.com/?ref=ultralytics), ClearML, [Comet](https://bit.ly/yolov8-readme-comet), Neural Magic and [OpenVINO](https://docs.ultralytics.com/integrations/openvino), can optimize your AI workflow.
 
 <br>
 <a href="https://bit.ly/ultralytics_hub" target="_blank">
-<img width="100%" src="https://github.com/ultralytics/assets/raw/main/yolov8/banner-integrations.png"></a>
+<img width="100%" src="https://github.com/ultralytics/assets/raw/main/yolov8/banner-integrations.png" alt="Ultralytics active learning integrations"></a>
 <br>
 <br>
 
 <div align="center">
   <a href="https://roboflow.com/?ref=ultralytics">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-roboflow.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
-  <a href="https://cutt.ly/yolov5-readme-clearml">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-clearml.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-roboflow.png" width="10%" alt="Roboflow logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
+  <a href="https://clear.ml/">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-clearml.png" width="10%" alt="ClearML logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
   <a href="https://bit.ly/yolov8-readme-comet">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-comet.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-comet.png" width="10%" alt="Comet ML logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
   <a href="https://bit.ly/yolov5-neuralmagic">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-neuralmagic.png" width="10%"></a>
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-neuralmagic.png" width="10%" alt="NeuralMagic logo"></a>
 </div>
 
-|                                                           Roboflow                                                           |                                                            ClearML  NEW                                                            |                                                                        Comet  NEW                                                                        |                                           Neural Magic  NEW                                           |
-| :--------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------: |
-| Label and export your custom datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/?ref=ultralytics) | Automatically track, visualize and even remotely train YOLOv8 using [ClearML](https://cutt.ly/yolov5-readme-clearml) (open-source!) | Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8 models, resume training, and interactively visualize and debug predictions | Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) |
+|                                                           Roboflow                                                           |                                                  ClearML  NEW                                                  |                                                                        Comet  NEW                                                                        |                                           Neural Magic  NEW                                           |
+| :--------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------: |
+| Label and export your custom datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/?ref=ultralytics) | Automatically track, visualize and even remotely train YOLOv8 using [ClearML](https://clear.ml/) (open-source!) | Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8 models, resume training, and interactively visualize and debug predictions | Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) |
 
 ## <div align="center">Ultralytics HUB</div>
 
 Experience seamless AI with [Ultralytics HUB](https://bit.ly/ultralytics_hub) , the all-in-one solution for data visualization, YOLOv5 and YOLOv8  model training and deployment, without any coding. Transform images into actionable insights and bring your AI visions to life with ease using our cutting-edge platform and user-friendly [Ultralytics App](https://ultralytics.com/app_install). Start your journey for **Free** now!
 
 <a href="https://bit.ly/ultralytics_hub" target="_blank">
 <img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/ultralytics-hub.png" alt="Ultralytics HUB preview image"></a>
@@ -305,15 +260,15 @@
 ## <div align="center">Contribute</div>
 
 We love your input! YOLOv5 and YOLOv8 would not be possible without help from our community. Please see our [Contributing Guide](https://docs.ultralytics.com/help/contributing) to get started, and fill out our [Survey](https://ultralytics.com/survey?utm_source=github&utm_medium=social&utm_campaign=Survey) to send us feedback on your experience. Thank you  to all our contributors!
 
 <!-- SVG image from https://opencollective.com/ultralytics/contributors.svg?width=990 -->
 
 <a href="https://github.com/ultralytics/yolov5/graphs/contributors">
-<img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/image-contributors.png"></a>
+<img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/image-contributors.png" alt="Ultralytics open-source contributors"></a>
 
 ## <div align="center">License</div>
 
 Ultralytics offers two licensing options to accommodate diverse use cases:
 
 - **AGPL-3.0 License**: This [OSI-approved](https://opensource.org/licenses/) open-source license is ideal for students and enthusiasts, promoting open collaboration and knowledge sharing. See the [LICENSE](https://github.com/ultralytics/ultralytics/blob/main/LICENSE) file for more details.
 - **Enterprise License**: Designed for commercial use, this license permits seamless integration of Ultralytics software and AI models into commercial goods and services, bypassing the open-source requirements of AGPL-3.0. If your scenario involves embedding our solutions into a commercial offering, reach out through [Ultralytics Licensing](https://ultralytics.com/license).
@@ -321,20 +276,20 @@
 ## <div align="center">Contact</div>
 
 For Ultralytics bug reports and feature requests please visit [GitHub Issues](https://github.com/ultralytics/ultralytics/issues), and join our [Discord](https://ultralytics.com/discord) community for questions and discussions!
 
 <br>
 <div align="center">
   <a href="https://github.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-github.png" width="3%" alt="Ultralytics GitHub"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.linkedin.com/company/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-linkedin.png" width="3%" alt="Ultralytics LinkedIn"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://twitter.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-twitter.png" width="3%" alt="Ultralytics Twitter"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://youtube.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-youtube.png" width="3%" alt="Ultralytics YouTube"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.tiktok.com/@ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-tiktok.png" width="3%" alt="Ultralytics TikTok"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.instagram.com/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-instagram.png" width="3%" alt="Ultralytics Instagram"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://ultralytics.com/discord"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-discord.png" width="3%" alt="Ultralytics Discord"></a>
 </div>
```

#### html2text {}

```diff
@@ -1,107 +1,89 @@
-Metadata-Version: 2.1 Name: yolov8-pose-triton Version: 8.1.0 Summary:
-Ultralytics YOLOv8 for SOTA object detection, multi-object tracking, instance
-segmentation, pose estimation and image classification. Home-page: https://
-github.com/ultralytics/ultralytics Author: Ultralytics Author-email:
-hello@ultralytics.com License: AGPL-3.0 Project-URL: Bug Reports, https://
-github.com/ultralytics/ultralytics/issues Project-URL: Funding, https://
-ultralytics.com Project-URL: Source, https://github.com/hmurari/ultralytics
-Keywords: machine-learning,deep-
-learning,vision,ML,DL,AI,YOLO,YOLOv3,YOLOv5,YOLOv8,HUB,Ultralytics Classifier:
-Development Status :: 4 - Beta Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Education Classifier: Intended Audience ::
-Science/Research Classifier: License :: OSI Approved :: GNU Affero General
-Public License v3 or later (AGPLv3+) Classifier: Programming Language :: Python
-:: 3 Classifier: Programming Language :: Python :: 3.8 Classifier: Programming
-Language :: Python :: 3.9 Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11 Classifier: Topic ::
-Software Development Classifier: Topic :: Scientific/Engineering Classifier:
-Topic :: Scientific/Engineering :: Artificial Intelligence Classifier: Topic ::
-Scientific/Engineering :: Image Recognition Classifier: Operating System ::
-POSIX :: Linux Classifier: Operating System :: MacOS Classifier: Operating
-System :: Microsoft :: Windows Requires-Python: >=3.8 Description-Content-Type:
-text/markdown License-File: LICENSE Requires-Dist: matplotlib>=3.3.0 Requires-
-Dist: numpy>=1.22.2 Requires-Dist: opencv-python>=4.6.0 Requires-Dist:
-pillow>=7.1.2 Requires-Dist: pyyaml>=5.3.1 Requires-Dist: requests>=2.23.0
-Requires-Dist: scipy>=1.4.1 Requires-Dist: torch>=1.8.0 Requires-Dist:
-torchvision>=0.9.0 Requires-Dist: tqdm>=4.64.0 Requires-Dist: pandas>=1.1.4
-Requires-Dist: seaborn>=0.11.0 Requires-Dist: psutil Requires-Dist: py-cpuinfo
-Requires-Dist: thop>=0.1.1 Provides-Extra: dev Requires-Dist: ipython; extra ==
-"dev" Requires-Dist: check-manifest; extra == "dev" Requires-Dist: pre-commit;
-extra == "dev" Requires-Dist: pytest; extra == "dev" Requires-Dist: pytest-cov;
-extra == "dev" Requires-Dist: coverage; extra == "dev" Requires-Dist: mkdocs-
-material; extra == "dev" Requires-Dist: mkdocstrings[python]; extra == "dev"
-Requires-Dist: mkdocs-redirects; extra == "dev" Requires-Dist: mkdocs-
-ultralytics-plugin>=0.0.34; extra == "dev" Provides-Extra: export Requires-
-Dist: coremltools>=7.0; extra == "export" Requires-Dist: openvino-dev>=2023.0;
-extra == "export" Requires-Dist: tensorflow<=2.13.1; extra == "export"
-Requires-Dist: tensorflowjs; extra == "export"
-  _[_h_t_t_p_s_:_/_/_r_a_w_._g_i_t_h_u_b_u_s_e_r_c_o_n_t_e_n_t_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_m_a_i_n_/_i_m_/_b_a_n_n_e_r_-_y_o_l_o_-
-                               _v_i_s_i_o_n_-_2_0_2_3_._p_n_g_]
+                             _[_Y_O_L_O_ _V_i_s_i_o_n_ _b_a_n_n_e_r_]
        [](https://docs.ultralytics.com/zh/) | [](https://
  docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) |
     [](https://docs.ultralytics.com/ru/) | [Deutsch](https://
  docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) |
      [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://
 docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/
            hi/) | [](https://docs.ultralytics.com/ar/)
   _[_U_l_t_r_a_l_y_t_i_c_s_ _C_I_]_[_U_l_t_r_a_l_y_t_i_c_s_ _C_o_d_e_ _C_o_v_e_r_a_g_e_]_[_Y_O_L_O_v_8_ _C_i_t_a_t_i_o_n_]_[_D_o_c_k_e_r_ _P_u_l_l_s_]
+                                   _[_D_i_s_c_o_r_d_]
                _[_R_u_n_ _o_n_ _G_r_a_d_i_e_n_t_]_[_O_p_e_n_ _I_n_ _C_o_l_a_b_]_[_O_p_e_n_ _I_n_ _K_a_g_g_l_e_]
 
 [Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/
 ultralytics) is a cutting-edge, state-of-the-art (SOTA) model that builds upon
      the success of previous YOLO versions and introduces new features and
  improvements to further boost performance and flexibility. YOLOv8 is designed
 to be fast, accurate, and easy to use, making it an excellent choice for a wide
      range of object detection and tracking, instance segmentation, image
 classification and pose estimation tasks. We hope that the resources here will
 help you get the most out of YOLOv8. Please browse the YOLOv8 _D_o_c_s for details,
    raise an issue on _G_i_t_H_u_b for support, and join our _D_i_s_c_o_r_d community for
 questions and discussions! To request an Enterprise License please complete the
-  form at [Ultralytics Licensing](https://ultralytics.com/license).[https://
-   raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-
-                                  plots.png]
-  _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][https://github.com/ultralytics/assets/raw/main/social/
-  logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][https://github.com/ultralytics/
-  assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_][https://
-github.com/ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s
-     _Y_o_u_T_u_b_e_][https://github.com/ultralytics/assets/raw/main/social/logo-
-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][https://github.com/ultralytics/assets/raw/
- main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _I_n_s_t_a_g_r_a_m_][https://github.com/
- ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
+   form at [Ultralytics Licensing](https://ultralytics.com/license).[YOLOv8
+                              performance plots]
+ _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_]
+  [space]_[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_T_u_b_e_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][space]_[_U_l_t_r_a_l_y_t_i_c_s
+                    _I_n_s_t_a_g_r_a_m_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
 ##
                                  Documentation
 See below for a quickstart installation and usage example, and see the [YOLOv8
 Docs](https://docs.ultralytics.com) for full documentation on training,
 validation, prediction and deployment. Install Pip install the ultralytics
 package including all [requirements](https://github.com/ultralytics/
-ultralytics/blob/main/requirements.txt) in a [**Python>=3.8**](https://
+ultralytics/blob/main/pyproject.toml) in a [**Python>=3.8**](https://
 www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-
 started/locally/). [![PyPI version](https://badge.fury.io/py/ultralytics.svg)]
 (https://badge.fury.io/py/ultralytics) [![Downloads](https://static.pepy.tech/
 badge/ultralytics)](https://pepy.tech/project/ultralytics) ```bash pip install
 ultralytics ``` For alternative installation methods including [Conda](https://
 anaconda.org/conda-forge/ultralytics), [Docker](https://hub.docker.com/r/
 ultralytics/ultralytics), and Git, please refer to the [Quickstart Guide]
-(https://docs.ultralytics.com/quickstart). Usage #### CLI YOLOv8 may be used
+(https://docs.ultralytics.com/quickstart). Usage ### CLI YOLOv8 may be used
 directly in the Command Line Interface (CLI) with a `yolo` command: ```bash
 yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'
 ``` `yolo` can be used for a variety of tasks and modes and accepts additional
 arguments, i.e. `imgsz=640`. See the YOLOv8 [CLI Docs](https://
-docs.ultralytics.com/usage/cli) for examples. #### Python YOLOv8 may also be
+docs.ultralytics.com/usage/cli) for examples. ### Python YOLOv8 may also be
 used directly in a Python environment, and accepts the same [arguments](https:/
 /docs.ultralytics.com/usage/cfg/) as in the CLI example above: ```python from
 ultralytics import YOLO # Load a model model = YOLO("yolov8n.yaml") # build a
 new model from scratch model = YOLO("yolov8n.pt") # load a pretrained model
 (recommended for training) # Use the model model.train(data="coco128.yaml",
 epochs=3) # train the model metrics = model.val() # evaluate model performance
 on the validation set results = model("https://ultralytics.com/images/bus.jpg")
 # predict on an image path = model.export(format="onnx") # export the model to
 ONNX format ``` See YOLOv8 [Python Docs](https://docs.ultralytics.com/usage/
-python) for more examples. ##
+python) for more examples. ### Notebooks Ultralytics provides interactive
+notebooks for YOLOv8, covering training, validation, tracking, and more. Each
+notebook is paired with a [YouTube](https://youtube.com/ultralytics) tutorial,
+making it easy to learn and implement advanced YOLOv8 features. | Docs |
+Notebook | YouTube | | --------------------------------------------------------
+------------------------------------------------------------------------- | ---
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+--------------------------------------------------------- | :------------------
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+-----------------------------: | | _Y_O_L_O_v_8_ _T_r_a_i_n_,_ _V_a_l_,_ _P_r_e_d_i_c_t_ _a_n_d_ _E_x_p_o_r_t_ _M_o_d_e_s
+| _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _U_l_t_r_a_l_y_t_i_c_s_ _H_U_B_ _Q_u_i_c_k_S_t_a_r_t | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _M_u_l_t_i_-_O_b_j_e_c_t_ _T_r_a_c_k_i_n_g_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _O_b_j_e_c_t_ _C_o_u_n_t_i_n_g_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _H_e_a_t_m_a_p_s_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _U_l_t_r_a_l_y_t_i_c_s_ _D_a_t_a_s_e_t_s_ _E_x_p_l_o_r_e_r_ _w_i_t_h_ _S_Q_L_ _a_n_d_ _O_p_e_n_A_I_ _I_n_t_e_g_r_a_t_i_o_n_ _____ _N_e_w |
+_[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| ##
                                     Models
 YOLOv8 [Detect](https://docs.ultralytics.com/tasks/detect), [Segment](https://
 docs.ultralytics.com/tasks/segment) and [Pose](https://docs.ultralytics.com/
 tasks/pose) models pretrained on the [COCO](https://docs.ultralytics.com/
 datasets/detect/coco) dataset are available here, as well as YOLOv8 [Classify]
 (https://docs.ultralytics.com/tasks/classify) models pretrained on the
 [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet) dataset.
@@ -120,23 +102,23 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
 ------------- | --------------------- | -------------------- | ----------------
 -------------- | ----------------------------------- | ------------------ | ---
 -------------- | | [YOLOv8n](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8n.pt) | 640 | 37.3 | 80.4 | 0.99 | 3.2 | 8.7 | |
-[YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/
+download/v8.1.0/yolov8n.pt) | 640 | 37.3 | 80.4 | 0.99 | 3.2 | 8.7 | |
+[YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/
 yolov8s.pt) | 640 | 44.9 | 128.4 | 1.20 | 11.2 | 28.6 | | [YOLOv8m](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m.pt) | 640 | 50.2
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m.pt) | 640 | 50.2
 | 234.7 | 1.83 | 25.9 | 78.9 | | [YOLOv8l](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8l.pt) | 640 | 52.9 | 375.2 | 2.39 | 43.7
+assets/releases/download/v8.1.0/yolov8l.pt) | 640 | 52.9 | 375.2 | 2.39 | 43.7
 | 165.2 | | [YOLOv8x](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8x.pt) | 640 | 53.9 | 479.1 | 3.53 | 68.2 | 257.8 | - **mAPval**
-values are for single-model single-scale on [COCO val2017](http://
+v8.1.0/yolov8x.pt) | 640 | 53.9 | 479.1 | 3.53 | 68.2 | 257.8 | - **mAPval**
+values are for single-model single-scale on [COCO val2017](https://
 cocodataset.org) dataset.
 Reproduce by `yolo val detect data=coco.yaml device=0` - **Speed** averaged
 over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/
 instance-types/p4/) instance.
 Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu` Detection
 (Open Image V7) See [Detection Docs](https://docs.ultralytics.com/tasks/detect/
 ) for usage examples with these models trained on [Open Image V7](https://
@@ -149,28 +131,28 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
 ------------------ | --------------------- | -------------------- | -----------
 ------------------- | ----------------------------------- | -----------------
 - | ----------------- | | [YOLOv8n](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8n-oiv7.pt) | 640 | 18.4 | 142.4 | 1.21 | 3.5 |
+releases/download/v8.1.0/yolov8n-oiv7.pt) | 640 | 18.4 | 142.4 | 1.21 | 3.5 |
 10.5 | | [YOLOv8s](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8s-oiv7.pt) | 640 | 27.7 | 183.1 | 1.40 | 11.4 | 29.7 | | [YOLOv8m]
-(https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-
+v8.1.0/yolov8s-oiv7.pt) | 640 | 27.7 | 183.1 | 1.40 | 11.4 | 29.7 | | [YOLOv8m]
+(https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-
 oiv7.pt) | 640 | 33.6 | 408.5 | 2.26 | 26.2 | 80.6 | | [YOLOv8l](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-oiv7.pt) | 640 |
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-oiv7.pt) | 640 |
 34.9 | 596.9 | 2.43 | 44.1 | 167.4 | | [YOLOv8x](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-oiv7.pt) | 640 | 36.3 |
+ultralytics/assets/releases/download/v8.1.0/yolov8x-oiv7.pt) | 640 | 36.3 |
 860.6 | 3.56 | 68.7 | 260.6 | - **mAPval** values are for single-model single-
 scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-
 images-v7/) dataset.
 Reproduce by `yolo val detect data=open-images-v7.yaml device=0` - **Speed**
-averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/
-ec2/instance-types/p4/) instance.
+averaged over Open Image V7 val images using an [Amazon EC2 P4d](https://
+aws.amazon.com/ec2/instance-types/p4/) instance.
 Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
 Segmentation (COCO) See [Segmentation Docs](https://docs.ultralytics.com/tasks/
 segment/) for usage examples with these models trained on [COCO-Seg](https://
 docs.ultralytics.com/datasets/segment/coco/), which include 80 pre-trained
 classes. | Model | size
 (pixels) | mAPbox
 50-95 | mAPmask
@@ -180,25 +162,25 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
 --------------------- | --------------------- | -------------------- | --------
 ------------- | ------------------------------ | ------------------------------
 ----- | ------------------ | ----------------- | | [YOLOv8n-seg](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-seg.pt) | 640 |
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-seg.pt) | 640 |
 36.7 | 30.5 | 96.1 | 1.21 | 3.4 | 12.6 | | [YOLOv8s-seg](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-seg.pt) | 640 | 44.6 | 36.8
+ultralytics/assets/releases/download/v8.1.0/yolov8s-seg.pt) | 640 | 44.6 | 36.8
 | 155.7 | 1.47 | 11.8 | 42.6 | | [YOLOv8m-seg](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8m-seg.pt) | 640 | 49.9 | 40.8 | 317.0 |
+assets/releases/download/v8.1.0/yolov8m-seg.pt) | 640 | 49.9 | 40.8 | 317.0 |
 2.18 | 27.3 | 110.2 | | [YOLOv8l-seg](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8l-seg.pt) | 640 | 52.3 | 42.6 | 572.4 | 2.79 |
+releases/download/v8.1.0/yolov8l-seg.pt) | 640 | 52.3 | 42.6 | 572.4 | 2.79 |
 46.0 | 220.5 | | [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8x-seg.pt) | 640 | 53.4 | 43.4 | 712.1 | 4.02 | 71.8 |
+download/v8.1.0/yolov8x-seg.pt) | 640 | 53.4 | 43.4 | 712.1 | 4.02 | 71.8 |
 344.1 | - **mAPval** values are for single-model single-scale on [COCO val2017]
-(http://cocodataset.org) dataset.
+(https://cocodataset.org) dataset.
 Reproduce by `yolo val segment data=coco-seg.yaml device=0` - **Speed**
 averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/
 ec2/instance-types/p4/) instance.
 Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu` Pose
 (COCO) See [Pose Docs](https://docs.ultralytics.com/tasks/pose/) for usage
 examples with these models trained on [COCO-Pose](https://docs.ultralytics.com/
 datasets/pose/coco/), which include 1 pre-trained class, person. | Model | size
@@ -210,32 +192,63 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
 ----------------------------- | --------------------- | --------------------- |
 ------------------ | ------------------------------ | -------------------------
 ---------- | ------------------ | ----------------- | | [YOLOv8n-pose](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-pose.pt) | 640 |
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-pose.pt) | 640 |
 50.4 | 80.1 | 131.8 | 1.18 | 3.3 | 9.2 | | [YOLOv8s-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-pose.pt) | 640 | 60.0 |
+ultralytics/assets/releases/download/v8.1.0/yolov8s-pose.pt) | 640 | 60.0 |
 86.2 | 233.2 | 1.42 | 11.6 | 30.2 | | [YOLOv8m-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8m-pose.pt) | 640 | 65.0 |
+ultralytics/assets/releases/download/v8.1.0/yolov8m-pose.pt) | 640 | 65.0 |
 88.8 | 456.3 | 2.00 | 26.4 | 81.0 | | [YOLOv8l-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8l-pose.pt) | 640 | 67.6 |
+ultralytics/assets/releases/download/v8.1.0/yolov8l-pose.pt) | 640 | 67.6 |
 90.0 | 784.5 | 2.59 | 44.4 | 168.6 | | [YOLOv8x-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-pose.pt) | 640 | 69.2 |
+ultralytics/assets/releases/download/v8.1.0/yolov8x-pose.pt) | 640 | 69.2 |
 90.2 | 1607.1 | 3.73 | 69.4 | 263.2 | | [YOLOv8x-pose-p6](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-pose-p6.pt) | 1280 | 71.6 |
+ultralytics/assets/releases/download/v8.1.0/yolov8x-pose-p6.pt) | 1280 | 71.6 |
 91.2 | 4088.7 | 10.04 | 99.1 | 1066.4 | - **mAPval** values are for single-
-model single-scale on [COCO Keypoints val2017](http://cocodataset.org) dataset.
-
+model single-scale on [COCO Keypoints val2017](https://cocodataset.org)
+dataset.
 Reproduce by `yolo val pose data=coco-pose.yaml device=0` - **Speed** averaged
 over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/
 instance-types/p4/) instance.
-Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
+Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu` OBB
+(DOTAv1) See [OBB Docs](https://docs.ultralytics.com/tasks/obb/) for usage
+examples with these models trained on [DOTAv1](https://docs.ultralytics.com/
+datasets/obb/dota-v2/#dota-v10/), which include 15 pre-trained classes. | Model
+| size
+(pixels) | mAPtest
+50 | Speed
+CPU ONNX
+(ms) | Speed
+A100 TensorRT
+(ms) | params
+(M) | FLOPs
+(B) | | -----------------------------------------------------------------------
+--------------------- | --------------------- | ------------------ | ----------
+-------------------- | ----------------------------------- | -----------------
+- | ----------------- | | [YOLOv8n-obb](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8n-obb.pt) | 1024 | 78.0 | 204.77 | 3.57 | 3.1 |
+23.3 | | [YOLOv8s-obb](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8s-obb.pt) | 1024 | 79.5 | 424.88 | 4.07 | 11.4 | 76.3 | |
+[YOLOv8m-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/
+yolov8m-obb.pt) | 1024 | 80.5 | 763.48 | 7.61 | 26.4 | 208.6 | | [YOLOv8l-obb]
+(https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-obb.pt)
+| 1024 | 80.7 | 1278.42 | 11.83 | 44.5 | 433.8 | | [YOLOv8x-obb](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-obb.pt) | 1024 |
+81.36 | 1759.10 | 13.23 | 69.5 | 676.7 | - **mAPtest** values are for single-
+model multiscale on [DOTAv1](https://captain-whu.github.io/DOTA/index.html)
+dataset.
+Reproduce by `yolo val obb data=DOTAv1.yaml device=0 split=test` and submit
+merged results to [DOTA evaluation](https://captain-whu.github.io/DOTA/
+evaluation.html). - **Speed** averaged over DOTAv1 val images using an [Amazon
+EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
+Reproduce by `yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu`
 Classification (ImageNet) See [Classification Docs](https://
 docs.ultralytics.com/tasks/classify/) for usage examples with these models
 trained on [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/
 ), which include 1000 pretrained classes. | Model | size
 (pixels) | acc
 top1 | acc
 top5 | Speed
@@ -244,73 +257,70 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) at 640 | | ----------------------------------------------------------------
 ---------------------------- | --------------------- | ---------------- | -----
 ----------- | ------------------------------ | --------------------------------
 --- | ------------------ | ------------------------ | | [YOLOv8n-cls](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-cls.pt) | 224 |
-66.6 | 87.0 | 12.9 | 0.31 | 2.7 | 4.3 | | [YOLOv8s-cls](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-cls.pt) | 224 | 72.3 | 91.1
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-cls.pt) | 224 |
+69.0 | 88.3 | 12.9 | 0.31 | 2.7 | 4.3 | | [YOLOv8s-cls](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8s-cls.pt) | 224 | 73.8 | 91.7
 | 23.4 | 0.35 | 6.4 | 13.5 | | [YOLOv8m-cls](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8m-cls.pt) | 224 | 76.4 | 93.2 | 85.4 |
+assets/releases/download/v8.1.0/yolov8m-cls.pt) | 224 | 76.8 | 93.5 | 85.4 |
 0.62 | 17.0 | 42.7 | | [YOLOv8l-cls](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8l-cls.pt) | 224 | 78.0 | 94.1 | 163.0 | 0.87 |
+releases/download/v8.1.0/yolov8l-cls.pt) | 224 | 76.8 | 93.5 | 163.0 | 0.87 |
 37.5 | 99.7 | | [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8x-cls.pt) | 224 | 78.4 | 94.3 | 232.0 | 1.01 | 57.4 |
+download/v8.1.0/yolov8x-cls.pt) | 224 | 79.0 | 94.6 | 232.0 | 1.01 | 57.4 |
 154.8 | - **acc** values are model accuracies on the [ImageNet](https://
 www.image-net.org/) dataset validation set.
 Reproduce by `yolo val classify data=path/to/ImageNet device=0` - **Speed**
 averaged over ImageNet val images using an [Amazon EC2 P4d](https://
 aws.amazon.com/ec2/instance-types/p4/) instance.
 Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu` ##
                                  Integrations
 Our key integrations with leading AI platforms extend the functionality of
 Ultralytics' offerings, enhancing tasks like dataset labeling, training,
 visualization, and model management. Discover how Ultralytics, in collaboration
 with [Roboflow](https://roboflow.com/?ref=ultralytics), ClearML, [Comet](https:
 //bit.ly/yolov8-readme-comet), Neural Magic and [OpenVINO](https://
 docs.ultralytics.com/integrations/openvino), can optimize your AI workflow.
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_y_o_l_o_v_8_/_b_a_n_n_e_r_-_i_n_t_e_g_r_a_t_i_o_n_s_._p_n_g_]
+_[_U_l_t_r_a_l_y_t_i_c_s_ _a_c_t_i_v_e_ _l_e_a_r_n_i_n_g_ _i_n_t_e_g_r_a_t_i_o_n_s_]
 
-  _[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_r_o_b_o_f_l_o_w_._p_n_g_]
-  _[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_c_l_e_a_r_m_l_._p_n_g_]
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_c_o_m_e_t_._p_n_g_]_[_h_t_t_p_s_:
-    _/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_n_e_u_r_a_l_m_a_g_i_c_._p_n_g_]
+ _[_R_o_b_o_f_l_o_w_ _l_o_g_o_][space]_[_C_l_e_a_r_M_L_ _l_o_g_o_][space]_[_C_o_m_e_t_ _M_L_ _l_o_g_o_][space]_[_N_e_u_r_a_l_M_a_g_i_c
+                                     _l_o_g_o_]
 | Roboflow | ClearML  NEW | Comet  NEW | Neural Magic  NEW | | :------
 -------------------------------------------------------------------------------
 -------------------------------------: | :-------------------------------------
+------------------------------------------------------------------------: | :--
 -------------------------------------------------------------------------------
--------------: | :-------------------------------------------------------------
+----------------------------------------------------------------------: | :----
 -------------------------------------------------------------------------------
------------: | :---------------------------------------------------------------
--------------------------------------: | | Label and export your custom
-datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/
-?ref=ultralytics) | Automatically track, visualize and even remotely train
-YOLOv8 using [ClearML](https://cutt.ly/yolov5-readme-clearml) (open-source!) |
-Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8
-models, resume training, and interactively visualize and debug predictions |
-Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://
-bit.ly/yolov5-neuralmagic) | ##
+-----------------: | | Label and export your custom datasets directly to YOLOv8
+for training with [Roboflow](https://roboflow.com/?ref=ultralytics) |
+Automatically track, visualize and even remotely train YOLOv8 using [ClearML]
+(https://clear.ml/) (open-source!) | Free forever, [Comet](https://bit.ly/
+yolov8-readme-comet) lets you save YOLOv8 models, resume training, and
+interactively visualize and debug predictions | Run YOLOv8 inference up to 6x
+faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) | ##
                                 Ultralytics HUB
 Experience seamless AI with [Ultralytics HUB](https://bit.ly/ultralytics_hub)
 , the all-in-one solution for data visualization, YOLOv5 and YOLOv8 
 model training and deployment, without any coding. Transform images into
 actionable insights and bring your AI visions to life with ease using our
 cutting-edge platform and user-friendly [Ultralytics App](https://
 ultralytics.com/app_install). Start your journey for **Free** now! _[_U_l_t_r_a_l_y_t_i_c_s
 _H_U_B_ _p_r_e_v_i_e_w_ _i_m_a_g_e_]##
                                   Contribute
 We love your input! YOLOv5 and YOLOv8 would not be possible without help from
 our community. Please see our [Contributing Guide](https://
 docs.ultralytics.com/help/contributing) to get started, and fill out our
 [Survey](https://ultralytics.com/
 survey?utm_source=github&utm_medium=social&utm_campaign=Survey) to send us
-feedback on your experience. Thank you  to all our contributors! _[_h_t_t_p_s_:_/_/
-_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_i_m_/_i_m_a_g_e_-_c_o_n_t_r_i_b_u_t_o_r_s_._p_n_g_]##
+feedback on your experience. Thank you  to all our contributors!
+_[_U_l_t_r_a_l_y_t_i_c_s_ _o_p_e_n_-_s_o_u_r_c_e_ _c_o_n_t_r_i_b_u_t_o_r_s_]##
                                     License
 Ultralytics offers two licensing options to accommodate diverse use cases: -
 **AGPL-3.0 License**: This [OSI-approved](https://opensource.org/licenses/
 ) open-source license is ideal for students and enthusiasts, promoting open
 collaboration and knowledge sharing. See the [LICENSE](https://github.com/
 ultralytics/ultralytics/blob/main/LICENSE) file for more details. -
 **Enterprise License**: Designed for commercial use, this license permits
@@ -318,15 +328,10 @@
 goods and services, bypassing the open-source requirements of AGPL-3.0. If your
 scenario involves embedding our solutions into a commercial offering, reach out
 through [Ultralytics Licensing](https://ultralytics.com/license). ##
                                     Contact
 For Ultralytics bug reports and feature requests please visit [GitHub Issues]
 (https://github.com/ultralytics/ultralytics/issues), and join our [Discord]
 (https://ultralytics.com/discord) community for questions and discussions!
-  _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][https://github.com/ultralytics/assets/raw/main/social/
-  logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][https://github.com/ultralytics/
-  assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_][https://
-github.com/ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s
-     _Y_o_u_T_u_b_e_][https://github.com/ultralytics/assets/raw/main/social/logo-
-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][https://github.com/ultralytics/assets/raw/
- main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _I_n_s_t_a_g_r_a_m_][https://github.com/
- ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
+ _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_]
+  [space]_[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_T_u_b_e_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][space]_[_U_l_t_r_a_l_y_t_i_c_s
+                    _I_n_s_t_a_g_r_a_m_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
```

### Comparing `yolov8-pose-triton-8.1.0/README.md` & `yolov8_pose_triton-8.2.0/README.zh-CN.md`

 * *Files 26% similar despite different names*

```diff
@@ -1,276 +1,297 @@
 <div align="center">
   <p>
-    <a href="https://yolovision.ultralytics.com/" target="_blank">
-      <img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/im/banner-yolo-vision-2023.png"></a>
+    <a href="https://github.com/ultralytics/assets/releases/tag/v8.2.0" target="_blank">
+      <img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/banner-yolov8.png" alt="YOLO Vision banner"></a>
   </p>
 
-[](https://docs.ultralytics.com/zh/) | [](https://docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) | [](https://docs.ultralytics.com/ru/) | [Deutsch](https://docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) | [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/hi/) | [](https://docs.ultralytics.com/ar/)
-<br>
+[](https://docs.ultralytics.com/zh/) | [](https://docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) | [](https://docs.ultralytics.com/ru/) | [Deutsch](https://docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) | [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/hi/) | [](https://docs.ultralytics.com/ar/) <br>
 
 <div>
     <a href="https://github.com/ultralytics/ultralytics/actions/workflows/ci.yaml"><img src="https://github.com/ultralytics/ultralytics/actions/workflows/ci.yaml/badge.svg" alt="Ultralytics CI"></a>
     <a href="https://codecov.io/github/ultralytics/ultralytics"><img src="https://codecov.io/github/ultralytics/ultralytics/branch/main/graph/badge.svg?token=HHW7IIVFVY" alt="Ultralytics Code Coverage"></a>
     <a href="https://zenodo.org/badge/latestdoi/264818686"><img src="https://zenodo.org/badge/264818686.svg" alt="YOLOv8 Citation"></a>
     <a href="https://hub.docker.com/r/ultralytics/ultralytics"><img src="https://img.shields.io/docker/pulls/ultralytics/ultralytics?logo=docker" alt="Docker Pulls"></a>
+    <a href="https://ultralytics.com/discord"><img alt="Discord" src="https://img.shields.io/discord/1089800235347353640?logo=discord&logoColor=white&label=Discord&color=blue"></a>
     <br>
-    <a href="https://console.paperspace.com/github/ultralytics/ultralytics"><img src="https://assets.paperspace.io/img/gradient-badge.svg" alt="Run on Gradient"/></a>
+    <a href="https://console.paperspace.com/github/ultralytics/ultralytics"><img src="https://assets.paperspace.io/img/gradient-badge.svg" alt="Run on Gradient"></a>
     <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/tutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>
     <a href="https://www.kaggle.com/ultralytics/yolov8"><img src="https://kaggle.com/static/images/open-in-kaggle.svg" alt="Open In Kaggle"></a>
 </div>
 <br>
 
-[Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/ultralytics) is a cutting-edge, state-of-the-art (SOTA) model that builds upon the success of previous YOLO versions and introduces new features and improvements to further boost performance and flexibility. YOLOv8 is designed to be fast, accurate, and easy to use, making it an excellent choice for a wide range of object detection and tracking, instance segmentation, image classification and pose estimation tasks.
+[Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/ultralytics) SOTA YOLO YOLOv8 
 
-We hope that the resources here will help you get the most out of YOLOv8. Please browse the YOLOv8 <a href="https://docs.ultralytics.com/">Docs</a> for details, raise an issue on <a href="https://github.com/ultralytics/ultralytics/issues/new/choose">GitHub</a> for support, and join our <a href="https://ultralytics.com/discord">Discord</a> community for questions and discussions!
+ YOLOv8 YOLOv8 <a href="https://docs.ultralytics.com/"></a>  <a href="https://github.com/ultralytics/ultralytics/issues/new/choose">GitHub</a>  <a href="https://ultralytics.com/discord">Discord</a> 
 
-To request an Enterprise License please complete the form at [Ultralytics Licensing](https://ultralytics.com/license).
+ [Ultralytics Licensing](https://ultralytics.com/license) 
 
-<img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-plots.png"></a>
+<img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-plots.png" alt="YOLOv8 performance plots"></a>
 
 <div align="center">
   <a href="https://github.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-github.png" width="2%" alt="Ultralytics GitHub"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.linkedin.com/company/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-linkedin.png" width="2%" alt="Ultralytics LinkedIn"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://twitter.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-twitter.png" width="2%" alt="Ultralytics Twitter"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://youtube.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-youtube.png" width="2%" alt="Ultralytics YouTube"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.tiktok.com/@ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-tiktok.png" width="2%" alt="Ultralytics TikTok"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.instagram.com/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-instagram.png" width="2%" alt="Ultralytics Instagram"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://ultralytics.com/discord"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-discord.png" width="2%" alt="Ultralytics Discord"></a>
 </div>
 </div>
 
-## <div align="center">Documentation</div>
+
+
+## <div align="center"></div>
 
-See below for a quickstart installation and usage example, and see the [YOLOv8 Docs](https://docs.ultralytics.com) for full documentation on training, validation, prediction and deployment.
+ [YOLOv8 ](https://docs.ultralytics.com) 
 
 <details open>
-<summary>Install</summary>
+<summary></summary>
 
-Pip install the ultralytics package including all [requirements](https://github.com/ultralytics/ultralytics/blob/main/requirements.txt) in a [**Python>=3.8**](https://www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-started/locally/).
+Pip[**Python>=3.8**](https://www.python.org/)`ultralytics`[**PyTorch>=1.8**](https://pytorch.org/get-started/locally/)[](https://github.com/ultralytics/ultralytics/blob/main/pyproject.toml)
 
 [![PyPI version](https://badge.fury.io/py/ultralytics.svg)](https://badge.fury.io/py/ultralytics) [![Downloads](https://static.pepy.tech/badge/ultralytics)](https://pepy.tech/project/ultralytics)
 
 ```bash
 pip install ultralytics
 ```
 
-For alternative installation methods including [Conda](https://anaconda.org/conda-forge/ultralytics), [Docker](https://hub.docker.com/r/ultralytics/ultralytics), and Git, please refer to the [Quickstart Guide](https://docs.ultralytics.com/quickstart).
+[Conda](https://anaconda.org/conda-forge/ultralytics)[Docker](https://hub.docker.com/r/ultralytics/ultralytics)Git[](https://docs.ultralytics.com/quickstart)
 
 </details>
 
 <details open>
 <summary>Usage</summary>
 
-#### CLI
+### CLI
 
-YOLOv8 may be used directly in the Command Line Interface (CLI) with a `yolo` command:
+YOLOv8 CLI `yolo` 
 
 ```bash
 yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'
 ```
 
-`yolo` can be used for a variety of tasks and modes and accepts additional arguments, i.e. `imgsz=640`. See the YOLOv8 [CLI Docs](https://docs.ultralytics.com/usage/cli) for examples.
+`yolo`  `imgsz=640` YOLOv8 [CLI ](https://docs.ultralytics.com/usage/cli)
 
-#### Python
+### Python
 
-YOLOv8 may also be used directly in a Python environment, and accepts the same [arguments](https://docs.ultralytics.com/usage/cfg/) as in the CLI example above:
+YOLOv8  Python  CLI [](https://docs.ultralytics.com/usage/cfg/)
 
 ```python
 from ultralytics import YOLO
 
-# Load a model
-model = YOLO("yolov8n.yaml")  # build a new model from scratch
-model = YOLO("yolov8n.pt")  # load a pretrained model (recommended for training)
-
-# Use the model
-model.train(data="coco128.yaml", epochs=3)  # train the model
-metrics = model.val()  # evaluate model performance on the validation set
-results = model("https://ultralytics.com/images/bus.jpg")  # predict on an image
-path = model.export(format="onnx")  # export the model to ONNX format
+# 
+model = YOLO("yolov8n.yaml")  # 
+model = YOLO("yolov8n.pt")  # 
+
+# 
+model.train(data="coco128.yaml", epochs=3)  # 
+metrics = model.val()  # 
+results = model("https://ultralytics.com/images/bus.jpg")  # 
+success = model.export(format="onnx")  #  ONNX 
 ```
 
-See YOLOv8 [Python Docs](https://docs.ultralytics.com/usage/python) for more examples.
+ YOLOv8 [Python ](https://docs.ultralytics.com/usage/python)
 
 </details>
 
-## <div align="center">Models</div>
+### 
+
+Ultralytics  YOLOv8  [YouTube](https://youtube.com/ultralytics)  YOLOv8 
+
+|                                                                                                      |                                                                                                                                                                                                                       |                                                                                                     YouTube                                                                                                     |
+| ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
+| <a href="https://docs.ultralytics.com/modes/">YOLOv8 </a>                                 | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/tutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt=" Colab "></a>                  |  <a href="https://youtu.be/j8uQc0qB91s"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube "></center></a>   |
+| <a href="https://docs.ultralytics.com/hub/quickstart/">Ultralytics HUB </a>                        | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/hub.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt=" Colab "></a>                       |  <a href="https://youtu.be/lveF9iCMIzc"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube "></center></a>   |
+| <a href="https://docs.ultralytics.com/modes/track/">YOLOv8 </a>                               | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/object_tracking.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt=" Colab "></a>           |  <a href="https://youtu.be/hHyHmOtmEgs"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube "></center></a>   |
+| <a href="https://docs.ultralytics.com/guides/object-counting/">YOLOv8 </a>                     | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/object_counting.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt=" Colab "></a>           |  <a href="https://youtu.be/Ag2e-5_NpS0"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube "></center></a>   |
+| <a href="https://docs.ultralytics.com/guides/heatmaps/">YOLOv8 </a>                              | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/heatmaps.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt=" Colab "></a>                  |  <a href="https://youtu.be/4ezde5-nZZw"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube "></center></a>   |
+| <a href="https://docs.ultralytics.com/datasets/explorer/">Ultralytics  SQL  OpenAI  New</a> | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/docs/en/datasets/explorer/explorer.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt=" Colab "></a> | <a href="https://youtu.be/3VryynorQeo"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
 
-YOLOv8 [Detect](https://docs.ultralytics.com/tasks/detect), [Segment](https://docs.ultralytics.com/tasks/segment) and [Pose](https://docs.ultralytics.com/tasks/pose) models pretrained on the [COCO](https://docs.ultralytics.com/datasets/detect/coco) dataset are available here, as well as YOLOv8 [Classify](https://docs.ultralytics.com/tasks/classify) models pretrained on the [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet) dataset. [Track](https://docs.ultralytics.com/modes/track) mode is available for all Detect, Segment and Pose models.
+## <div align="center"></div>
+
+[COCO](https://docs.ultralytics.com/datasets/detect/coco)YOLOv8 [](https://docs.ultralytics.com/tasks/detect)[](https://docs.ultralytics.com/tasks/segment)[](https://docs.ultralytics.com/tasks/pose)[ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet)YOLOv8 [](https://docs.ultralytics.com/tasks/classify)[](https://docs.ultralytics.com/modes/track)
 
 <img width="1024" src="https://raw.githubusercontent.com/ultralytics/assets/main/im/banner-tasks.png" alt="Ultralytics YOLO supported tasks">
 
-All [Models](https://github.com/ultralytics/ultralytics/tree/main/ultralytics/cfg/models) download automatically from the latest Ultralytics [release](https://github.com/ultralytics/assets/releases) on first use.
+[](https://github.com/ultralytics/ultralytics/tree/main/ultralytics/cfg/models)Ultralytics [](https://github.com/ultralytics/assets/releases)
+
+<details open><summary> (COCO)</summary>
+
+[](https://docs.ultralytics.com/tasks/detect/)[COCO](https://docs.ultralytics.com/datasets/detect/coco/)80
+
+|                                                                                    | <br><sup>() | mAP<sup>val<br>50-95 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) |
+| ------------------------------------------------------------------------------------ | --------------- | -------------------- | --------------------------- | -------------------------------- | -------------- | ----------------- |
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n.pt) | 640             | 37.3                 | 80.4                        | 0.99                             | 3.2            | 8.7               |
+| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s.pt) | 640             | 44.9                 | 128.4                       | 1.20                             | 11.2           | 28.6              |
+| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m.pt) | 640             | 50.2                 | 234.7                       | 1.83                             | 25.9           | 78.9              |
+| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l.pt) | 640             | 52.9                 | 375.2                       | 2.39                             | 43.7           | 165.2             |
+| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x.pt) | 640             | 53.9                 | 479.1                       | 3.53                             | 68.2           | 257.8             |
 
-<details open><summary>Detection (COCO)</summary>
+- **mAP<sup>val</sup>**  [COCO val2017](https://cocodataset.org)  <br> `yolo val detect data=coco.yaml device=0` 
+- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO val  <br> `yolo val detect data=coco.yaml batch=1 device=0|cpu` 
 
-See [Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples with these models trained on [COCO](https://docs.ultralytics.com/datasets/detect/coco/), which include 80 pre-trained classes.
+</details>
+
+<details><summary>Open Image V7</summary>
+
+[](https://docs.ultralytics.com/tasks/detect/)[Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/)600
+
+|                                                                                         | <br><sup>() | mAP<sup><br>50-95 | <br><sup>CPU ONNX<br>() | <br><sup>A100 TensorRT<br>() | <br><sup>(M) | <br><sup>(B) |
+| ----------------------------------------------------------------------------------------- | --------------- | ------------------- | --------------------------- | -------------------------------- | -------------- | ---------------- |
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-oiv7.pt) | 640             | 18.4                | 142.4                       | 1.21                             | 3.5            | 10.5             |
+| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-oiv7.pt) | 640             | 27.7                | 183.1                       | 1.40                             | 11.4           | 29.7             |
+| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-oiv7.pt) | 640             | 33.6                | 408.5                       | 2.26                             | 26.2           | 80.6             |
+| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-oiv7.pt) | 640             | 34.9                | 596.9                       | 2.43                             | 44.1           | 167.4            |
+| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-oiv7.pt) | 640             | 36.3                | 860.6                       | 3.56                             | 68.7           | 260.6            |
 
-| Model                                                                                | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
-| ------------------------------------------------------------------------------------ | --------------------- | -------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt) | 640                   | 37.3                 | 80.4                           | 0.99                                | 3.2                | 8.7               |
-| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s.pt) | 640                   | 44.9                 | 128.4                          | 1.20                                | 11.2               | 28.6              |
-| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m.pt) | 640                   | 50.2                 | 234.7                          | 1.83                                | 25.9               | 78.9              |
-| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l.pt) | 640                   | 52.9                 | 375.2                          | 2.39                                | 43.7               | 165.2             |
-| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x.pt) | 640                   | 53.9                 | 479.1                          | 3.53                                | 68.2               | 257.8             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](http://cocodataset.org) dataset.
-  <br>Reproduce by `yolo val detect data=coco.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu`
+- **mAP<sup></sup>** [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/) <br> `yolo val detect data=open-images-v7.yaml device=0` 
+- **** [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)Open Image V7 <br> `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu` 
 
 </details>
 
-<details><summary>Detection (Open Image V7)</summary>
+<details><summary> (COCO)</summary>
 
-See [Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples with these models trained on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/), which include 600 pre-trained classes.
+[](https://docs.ultralytics.com/tasks/segment/)[COCO-Seg](https://docs.ultralytics.com/datasets/segment/coco/)80
 
-| Model                                                                                     | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
-| ----------------------------------------------------------------------------------------- | --------------------- | -------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-oiv7.pt) | 640                   | 18.4                 | 142.4                          | 1.21                                | 3.5                | 10.5              |
-| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-oiv7.pt) | 640                   | 27.7                 | 183.1                          | 1.40                                | 11.4               | 29.7              |
-| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-oiv7.pt) | 640                   | 33.6                 | 408.5                          | 2.26                                | 26.2               | 80.6              |
-| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-oiv7.pt) | 640                   | 34.9                 | 596.9                          | 2.43                                | 44.1               | 167.4             |
-| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-oiv7.pt) | 640                   | 36.3                 | 860.6                          | 3.56                                | 68.7               | 260.6             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/) dataset.
-  <br>Reproduce by `yolo val detect data=open-images-v7.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
+|                                                                                            | <br><sup>() | mAP<sup>box<br>50-95 | mAP<sup>mask<br>50-95 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) |
+| -------------------------------------------------------------------------------------------- | --------------- | -------------------- | --------------------- | --------------------------- | -------------------------------- | -------------- | ----------------- |
+| [YOLOv8n-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-seg.pt) | 640             | 36.7                 | 30.5                  | 96.1                        | 1.21                             | 3.4            | 12.6              |
+| [YOLOv8s-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-seg.pt) | 640             | 44.6                 | 36.8                  | 155.7                       | 1.47                             | 11.8           | 42.6              |
+| [YOLOv8m-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-seg.pt) | 640             | 49.9                 | 40.8                  | 317.0                       | 2.18                             | 27.3           | 110.2             |
+| [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-seg.pt) | 640             | 52.3                 | 42.6                  | 572.4                       | 2.79                             | 46.0           | 220.5             |
+| [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-seg.pt) | 640             | 53.4                 | 43.4                  | 712.1                       | 4.02                             | 71.8           | 344.1             |
+
+- **mAP<sup>val</sup>**  [COCO val2017](https://cocodataset.org)  <br> `yolo val segment data=coco-seg.yaml device=0` 
+- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO val  <br> `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu` 
 
 </details>
 
-<details><summary>Segmentation (COCO)</summary>
+<details><summary> (COCO)</summary>
+
+[](https://docs.ultralytics.com/tasks/pose/)[COCO-Pose](https://docs.ultralytics.com/datasets/pose/coco/)1
 
-See [Segmentation Docs](https://docs.ultralytics.com/tasks/segment/) for usage examples with these models trained on [COCO-Seg](https://docs.ultralytics.com/datasets/segment/coco/), which include 80 pre-trained classes.
+|                                                                                                    | <br><sup>() | mAP<sup>pose<br>50-95 | mAP<sup>pose<br>50 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) |
+| ---------------------------------------------------------------------------------------------------- | --------------- | --------------------- | ------------------ | --------------------------- | -------------------------------- | -------------- | ----------------- |
+| [YOLOv8n-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-pose.pt)       | 640             | 50.4                  | 80.1               | 131.8                       | 1.18                             | 3.3            | 9.2               |
+| [YOLOv8s-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-pose.pt)       | 640             | 60.0                  | 86.2               | 233.2                       | 1.42                             | 11.6           | 30.2              |
+| [YOLOv8m-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-pose.pt)       | 640             | 65.0                  | 88.8               | 456.3                       | 2.00                             | 26.4           | 81.0              |
+| [YOLOv8l-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-pose.pt)       | 640             | 67.6                  | 90.0               | 784.5                       | 2.59                             | 44.4           | 168.6             |
+| [YOLOv8x-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-pose.pt)       | 640             | 69.2                  | 90.2               | 1607.1                      | 3.73                             | 69.4           | 263.2             |
+| [YOLOv8x-pose-p6](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-pose-p6.pt) | 1280            | 71.6                  | 91.2               | 4088.7                      | 10.04                            | 99.1           | 1066.4            |
 
-| Model                                                                                        | size<br><sup>(pixels) | mAP<sup>box<br>50-95 | mAP<sup>mask<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
-| -------------------------------------------------------------------------------------------- | --------------------- | -------------------- | --------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-seg.pt) | 640                   | 36.7                 | 30.5                  | 96.1                           | 1.21                                | 3.4                | 12.6              |
-| [YOLOv8s-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-seg.pt) | 640                   | 44.6                 | 36.8                  | 155.7                          | 1.47                                | 11.8               | 42.6              |
-| [YOLOv8m-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-seg.pt) | 640                   | 49.9                 | 40.8                  | 317.0                          | 2.18                                | 27.3               | 110.2             |
-| [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-seg.pt) | 640                   | 52.3                 | 42.6                  | 572.4                          | 2.79                                | 46.0               | 220.5             |
-| [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-seg.pt) | 640                   | 53.4                 | 43.4                  | 712.1                          | 4.02                                | 71.8               | 344.1             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](http://cocodataset.org) dataset.
-  <br>Reproduce by `yolo val segment data=coco-seg.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu`
+- **mAP<sup>val</sup>**  [COCO Keypoints val2017](https://cocodataset.org)  <br> `yolo val pose data=coco-pose.yaml device=0` 
+- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO val  <br> `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu` 
 
 </details>
 
-<details><summary>Pose (COCO)</summary>
+<details><summary> (DOTAv1)</summary>
 
-See [Pose Docs](https://docs.ultralytics.com/tasks/pose/) for usage examples with these models trained on [COCO-Pose](https://docs.ultralytics.com/datasets/pose/coco/), which include 1 pre-trained class, person.
+[](https://docs.ultralytics.com/tasks/obb/)[DOTAv1](https://docs.ultralytics.com/datasets/obb/dota-v2/#dota-v10/)15
 
-| Model                                                                                                | size<br><sup>(pixels) | mAP<sup>pose<br>50-95 | mAP<sup>pose<br>50 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
-| ---------------------------------------------------------------------------------------------------- | --------------------- | --------------------- | ------------------ | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-pose.pt)       | 640                   | 50.4                  | 80.1               | 131.8                          | 1.18                                | 3.3                | 9.2               |
-| [YOLOv8s-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-pose.pt)       | 640                   | 60.0                  | 86.2               | 233.2                          | 1.42                                | 11.6               | 30.2              |
-| [YOLOv8m-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-pose.pt)       | 640                   | 65.0                  | 88.8               | 456.3                          | 2.00                                | 26.4               | 81.0              |
-| [YOLOv8l-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-pose.pt)       | 640                   | 67.6                  | 90.0               | 784.5                          | 2.59                                | 44.4               | 168.6             |
-| [YOLOv8x-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-pose.pt)       | 640                   | 69.2                  | 90.2               | 1607.1                         | 3.73                                | 69.4               | 263.2             |
-| [YOLOv8x-pose-p6](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-pose-p6.pt) | 1280                  | 71.6                  | 91.2               | 4088.7                         | 10.04                               | 99.1               | 1066.4            |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO Keypoints val2017](http://cocodataset.org)
-  dataset.
-  <br>Reproduce by `yolo val pose data=coco-pose.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
+|                                                                                            | <br><sup>() | mAP<sup>test<br>50 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) |
+| -------------------------------------------------------------------------------------------- | --------------- | ------------------ | --------------------------- | -------------------------------- | -------------- | ----------------- |
+| [YOLOv8n-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-obb.pt) | 1024            | 78.0               | 204.77                      | 3.57                             | 3.1            | 23.3              |
+| [YOLOv8s-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-obb.pt) | 1024            | 79.5               | 424.88                      | 4.07                             | 11.4           | 76.3              |
+| [YOLOv8m-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-obb.pt) | 1024            | 80.5               | 763.48                      | 7.61                             | 26.4           | 208.6             |
+| [YOLOv8l-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-obb.pt) | 1024            | 80.7               | 1278.42                     | 11.83                            | 44.5           | 433.8             |
+| [YOLOv8x-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-obb.pt) | 1024            | 81.36              | 1759.10                     | 13.23                            | 69.5           | 676.7             |
+
+- **mAP<sup>val</sup>**  [DOTAv1](https://captain-whu.github.io/DOTA/index.html)  <br> `yolo val obb data=DOTAv1.yaml device=0 split=test` 
+- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO val  <br> `yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu` 
 
 </details>
 
-<details><summary>Classification (ImageNet)</summary>
+<details><summary> (ImageNet)</summary>
+
+[](https://docs.ultralytics.com/tasks/classify/)[ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/)1000
 
-See [Classification Docs](https://docs.ultralytics.com/tasks/classify/) for usage examples with these models trained on [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/), which include 1000 pretrained classes.
+|                                                                                            | <br><sup>() | acc<br><sup>top1 | acc<br><sup>top5 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) at 640 |
+| -------------------------------------------------------------------------------------------- | --------------- | ---------------- | ---------------- | --------------------------- | -------------------------------- | -------------- | ------------------------ |
+| [YOLOv8n-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-cls.pt) | 224             | 69.0             | 88.3             | 12.9                        | 0.31                             | 2.7            | 4.3                      |
+| [YOLOv8s-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-cls.pt) | 224             | 73.8             | 91.7             | 23.4                        | 0.35                             | 6.4            | 13.5                     |
+| [YOLOv8m-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-cls.pt) | 224             | 76.8             | 93.5             | 85.4                        | 0.62                             | 17.0           | 42.7                     |
+| [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-cls.pt) | 224             | 76.8             | 93.5             | 163.0                       | 0.87                             | 37.5           | 99.7                     |
+| [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-cls.pt) | 224             | 79.0             | 94.6             | 232.0                       | 1.01                             | 57.4           | 154.8                    |
 
-| Model                                                                                        | size<br><sup>(pixels) | acc<br><sup>top1 | acc<br><sup>top5 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) at 640 |
-| -------------------------------------------------------------------------------------------- | --------------------- | ---------------- | ---------------- | ------------------------------ | ----------------------------------- | ------------------ | ------------------------ |
-| [YOLOv8n-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-cls.pt) | 224                   | 66.6             | 87.0             | 12.9                           | 0.31                                | 2.7                | 4.3                      |
-| [YOLOv8s-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-cls.pt) | 224                   | 72.3             | 91.1             | 23.4                           | 0.35                                | 6.4                | 13.5                     |
-| [YOLOv8m-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-cls.pt) | 224                   | 76.4             | 93.2             | 85.4                           | 0.62                                | 17.0               | 42.7                     |
-| [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-cls.pt) | 224                   | 78.0             | 94.1             | 163.0                          | 0.87                                | 37.5               | 99.7                     |
-| [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-cls.pt) | 224                   | 78.4             | 94.3             | 232.0                          | 1.01                                | 57.4               | 154.8                    |
-
-- **acc** values are model accuracies on the [ImageNet](https://www.image-net.org/) dataset validation set.
-  <br>Reproduce by `yolo val classify data=path/to/ImageNet device=0`
-- **Speed** averaged over ImageNet val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu`
+- **acc**  [ImageNet](https://www.image-net.org/)  <br> `yolo val classify data=path/to/ImageNet device=0` 
+- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  ImageNet val  <br> `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu` 
 
 </details>
 
-## <div align="center">Integrations</div>
+## <div align="center"></div>
 
-Our key integrations with leading AI platforms extend the functionality of Ultralytics' offerings, enhancing tasks like dataset labeling, training, visualization, and model management. Discover how Ultralytics, in collaboration with [Roboflow](https://roboflow.com/?ref=ultralytics), ClearML, [Comet](https://bit.ly/yolov8-readme-comet), Neural Magic and [OpenVINO](https://docs.ultralytics.com/integrations/openvino), can optimize your AI workflow.
+AIUltralyticsUltralytics[Roboflow](https://roboflow.com/?ref=ultralytics)ClearML[Comet](https://bit.ly/yolov8-readme-comet)Neural Magic[OpenVINO](https://docs.ultralytics.com/integrations/openvino)AI
 
 <br>
 <a href="https://bit.ly/ultralytics_hub" target="_blank">
-<img width="100%" src="https://github.com/ultralytics/assets/raw/main/yolov8/banner-integrations.png"></a>
+<img width="100%" src="https://github.com/ultralytics/assets/raw/main/yolov8/banner-integrations.png" alt="Ultralytics active learning integrations"></a>
 <br>
 <br>
 
 <div align="center">
   <a href="https://roboflow.com/?ref=ultralytics">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-roboflow.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
-  <a href="https://cutt.ly/yolov5-readme-clearml">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-clearml.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-roboflow.png" width="10%" alt="Roboflow logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
+  <a href="https://clear.ml/">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-clearml.png" width="10%" alt="ClearML logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
   <a href="https://bit.ly/yolov8-readme-comet">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-comet.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-comet.png" width="10%" alt="Comet ML logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
   <a href="https://bit.ly/yolov5-neuralmagic">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-neuralmagic.png" width="10%"></a>
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-neuralmagic.png" width="10%" alt="NeuralMagic logo"></a>
 </div>
 
-|                                                           Roboflow                                                           |                                                            ClearML  NEW                                                            |                                                                        Comet  NEW                                                                        |                                           Neural Magic  NEW                                           |
-| :--------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------: |
-| Label and export your custom datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/?ref=ultralytics) | Automatically track, visualize and even remotely train YOLOv8 using [ClearML](https://cutt.ly/yolov5-readme-clearml) (open-source!) | Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8 models, resume training, and interactively visualize and debug predictions | Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) |
+|                                      Roboflow                                      |                       ClearML  NEW                        |                                     Comet  NEW                                      |                                  Neural Magic  NEW                                   |
+| :--------------------------------------------------------------------------------: | :--------------------------------------------------------: | :----------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------------: |
+|  [Roboflow](https://roboflow.com/?ref=ultralytics)  YOLOv8  |  [ClearML](https://clear.ml/) YOLOv8 | [Comet](https://bit.ly/yolov8-readme-comet)  YOLOv8  |  [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic)  YOLOv8  6  |
 
 ## <div align="center">Ultralytics HUB</div>
 
-Experience seamless AI with [Ultralytics HUB](https://bit.ly/ultralytics_hub) , the all-in-one solution for data visualization, YOLOv5 and YOLOv8  model training and deployment, without any coding. Transform images into actionable insights and bring your AI visions to life with ease using our cutting-edge platform and user-friendly [Ultralytics App](https://ultralytics.com/app_install). Start your journey for **Free** now!
+ [Ultralytics HUB](https://bit.ly/ultralytics_hub)   AIYOLOv5  YOLOv8   [Ultralytics ](https://ultralytics.com/app_install) AI ****
 
 <a href="https://bit.ly/ultralytics_hub" target="_blank">
 <img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/ultralytics-hub.png" alt="Ultralytics HUB preview image"></a>
 
-## <div align="center">Contribute</div>
+## <div align="center"></div>
 
-We love your input! YOLOv5 and YOLOv8 would not be possible without help from our community. Please see our [Contributing Guide](https://docs.ultralytics.com/help/contributing) to get started, and fill out our [Survey](https://ultralytics.com/survey?utm_source=github&utm_medium=social&utm_campaign=Survey) to send us feedback on your experience. Thank you  to all our contributors!
+YOLOv5  YOLOv8 [](https://docs.ultralytics.com/help/contributing)[](https://ultralytics.com/survey?utm_source=github&utm_medium=social&utm_campaign=Survey)
 
 <!-- SVG image from https://opencollective.com/ultralytics/contributors.svg?width=990 -->
 
 <a href="https://github.com/ultralytics/yolov5/graphs/contributors">
-<img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/image-contributors.png"></a>
+<img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/image-contributors.png" alt="Ultralytics open-source contributors"></a>
 
-## <div align="center">License</div>
+## <div align="center"></div>
 
-Ultralytics offers two licensing options to accommodate diverse use cases:
+Ultralytics 
 
-- **AGPL-3.0 License**: This [OSI-approved](https://opensource.org/licenses/) open-source license is ideal for students and enthusiasts, promoting open collaboration and knowledge sharing. See the [LICENSE](https://github.com/ultralytics/ultralytics/blob/main/LICENSE) file for more details.
-- **Enterprise License**: Designed for commercial use, this license permits seamless integration of Ultralytics software and AI models into commercial goods and services, bypassing the open-source requirements of AGPL-3.0. If your scenario involves embedding our solutions into a commercial offering, reach out through [Ultralytics Licensing](https://ultralytics.com/license).
+- **AGPL-3.0 **[OSI ](https://opensource.org/licenses/)[LICENSE](https://github.com/ultralytics/ultralytics/blob/main/LICENSE) 
+- **** Ultralytics  AI  AGPL-3.0  [Ultralytics Licensing](https://ultralytics.com/license)
 
-## <div align="center">Contact</div>
+## <div align="center"></div>
 
-For Ultralytics bug reports and feature requests please visit [GitHub Issues](https://github.com/ultralytics/ultralytics/issues), and join our [Discord](https://ultralytics.com/discord) community for questions and discussions!
+ Ultralytics  [GitHub Issues](https://github.com/ultralytics/ultralytics/issues) [Discord](https://ultralytics.com/discord) 
 
 <br>
 <div align="center">
   <a href="https://github.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-github.png" width="3%" alt="Ultralytics GitHub"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.linkedin.com/company/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-linkedin.png" width="3%" alt="Ultralytics LinkedIn"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://twitter.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-twitter.png" width="3%" alt="Ultralytics Twitter"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://youtube.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-youtube.png" width="3%" alt="Ultralytics YouTube"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.tiktok.com/@ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-tiktok.png" width="3%" alt="Ultralytics TikTok"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.instagram.com/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-instagram.png" width="3%" alt="Ultralytics Instagram"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://ultralytics.com/discord"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-discord.png" width="3%" alt="Ultralytics Discord"></a>
 </div>
```

#### html2text {}

```diff
@@ -1,295 +1,339 @@
-  _[_h_t_t_p_s_:_/_/_r_a_w_._g_i_t_h_u_b_u_s_e_r_c_o_n_t_e_n_t_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_m_a_i_n_/_i_m_/_b_a_n_n_e_r_-_y_o_l_o_-
-                               _v_i_s_i_o_n_-_2_0_2_3_._p_n_g_]
+                             _[_Y_O_L_O_ _V_i_s_i_o_n_ _b_a_n_n_e_r_]
        [](https://docs.ultralytics.com/zh/) | [](https://
  docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) |
     [](https://docs.ultralytics.com/ru/) | [Deutsch](https://
  docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) |
      [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://
 docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/
            hi/) | [](https://docs.ultralytics.com/ar/)
   _[_U_l_t_r_a_l_y_t_i_c_s_ _C_I_]_[_U_l_t_r_a_l_y_t_i_c_s_ _C_o_d_e_ _C_o_v_e_r_a_g_e_]_[_Y_O_L_O_v_8_ _C_i_t_a_t_i_o_n_]_[_D_o_c_k_e_r_ _P_u_l_l_s_]
+                                   _[_D_i_s_c_o_r_d_]
                _[_R_u_n_ _o_n_ _G_r_a_d_i_e_n_t_]_[_O_p_e_n_ _I_n_ _C_o_l_a_b_]_[_O_p_e_n_ _I_n_ _K_a_g_g_l_e_]
 
 [Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/
-ultralytics) is a cutting-edge, state-of-the-art (SOTA) model that builds upon
-     the success of previous YOLO versions and introduces new features and
- improvements to further boost performance and flexibility. YOLOv8 is designed
-to be fast, accurate, and easy to use, making it an excellent choice for a wide
-     range of object detection and tracking, instance segmentation, image
-classification and pose estimation tasks. We hope that the resources here will
-help you get the most out of YOLOv8. Please browse the YOLOv8 _D_o_c_s for details,
-   raise an issue on _G_i_t_H_u_b for support, and join our _D_i_s_c_o_r_d community for
-questions and discussions! To request an Enterprise License please complete the
-  form at [Ultralytics Licensing](https://ultralytics.com/license).[https://
-   raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-
-                                  plots.png]
-  _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][https://github.com/ultralytics/assets/raw/main/social/
-  logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][https://github.com/ultralytics/
-  assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_][https://
-github.com/ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s
-     _Y_o_u_T_u_b_e_][https://github.com/ultralytics/assets/raw/main/social/logo-
-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][https://github.com/ultralytics/assets/raw/
- main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _I_n_s_t_a_g_r_a_m_][https://github.com/
- ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
-##
-                                 Documentation
-See below for a quickstart installation and usage example, and see the [YOLOv8
-Docs](https://docs.ultralytics.com) for full documentation on training,
-validation, prediction and deployment. Install Pip install the ultralytics
-package including all [requirements](https://github.com/ultralytics/
-ultralytics/blob/main/requirements.txt) in a [**Python>=3.8**](https://
-www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-
-started/locally/). [![PyPI version](https://badge.fury.io/py/ultralytics.svg)]
+ultralytics) SOTA YOLO
+YOLOv8
+
+  YOLOv8 YOLOv8
+                    ______  _G_i_t_H_u_b
+           _D_i_s_c_o_r_d
+   [Ultralytics
+Licensing](https://ultralytics.com/license) [YOLOv8 performance
+                                    plots]
+ _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_]
+  [space]_[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_T_u_b_e_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][space]_[_U_l_t_r_a_l_y_t_i_c_s
+                    _I_n_s_t_a_g_r_a_m_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
+ ##
+                                    
+ [YOLOv8 ](https://
+docs.ultralytics.com)
+ 
+Pip[**Python>=3.8**](https://www.python.org/
+)`ultralytics`[**PyTorch>=1.8**]
+(https://pytorch.org/get-started/locally/)
+[](https://github.com/ultralytics/ultralytics/blob/main/
+pyproject.toml) [![PyPI version](https://badge.fury.io/py/ultralytics.svg)]
 (https://badge.fury.io/py/ultralytics) [![Downloads](https://static.pepy.tech/
 badge/ultralytics)](https://pepy.tech/project/ultralytics) ```bash pip install
-ultralytics ``` For alternative installation methods including [Conda](https://
-anaconda.org/conda-forge/ultralytics), [Docker](https://hub.docker.com/r/
-ultralytics/ultralytics), and Git, please refer to the [Quickstart Guide]
-(https://docs.ultralytics.com/quickstart). Usage #### CLI YOLOv8 may be used
-directly in the Command Line Interface (CLI) with a `yolo` command: ```bash
-yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'
-``` `yolo` can be used for a variety of tasks and modes and accepts additional
-arguments, i.e. `imgsz=640`. See the YOLOv8 [CLI Docs](https://
-docs.ultralytics.com/usage/cli) for examples. #### Python YOLOv8 may also be
-used directly in a Python environment, and accepts the same [arguments](https:/
-/docs.ultralytics.com/usage/cfg/) as in the CLI example above: ```python from
-ultralytics import YOLO # Load a model model = YOLO("yolov8n.yaml") # build a
-new model from scratch model = YOLO("yolov8n.pt") # load a pretrained model
-(recommended for training) # Use the model model.train(data="coco128.yaml",
-epochs=3) # train the model metrics = model.val() # evaluate model performance
-on the validation set results = model("https://ultralytics.com/images/bus.jpg")
-# predict on an image path = model.export(format="onnx") # export the model to
-ONNX format ``` See YOLOv8 [Python Docs](https://docs.ultralytics.com/usage/
-python) for more examples. ##
-                                    Models
-YOLOv8 [Detect](https://docs.ultralytics.com/tasks/detect), [Segment](https://
-docs.ultralytics.com/tasks/segment) and [Pose](https://docs.ultralytics.com/
-tasks/pose) models pretrained on the [COCO](https://docs.ultralytics.com/
-datasets/detect/coco) dataset are available here, as well as YOLOv8 [Classify]
-(https://docs.ultralytics.com/tasks/classify) models pretrained on the
-[ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet) dataset.
-[Track](https://docs.ultralytics.com/modes/track) mode is available for all
-Detect, Segment and Pose models. [Ultralytics YOLO supported tasks]All [Models]
-(https://github.com/ultralytics/ultralytics/tree/main/ultralytics/cfg/models)
-download automatically from the latest Ultralytics [release](https://
-github.com/ultralytics/assets/releases) on first use. Detection (COCO) See
-[Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples
-with these models trained on [COCO](https://docs.ultralytics.com/datasets/
-detect/coco/), which include 80 pre-trained classes. | Model | size
-(pixels) | mAPval
-50-95 | Speed
+ultralytics ``` [Conda](https://anaconda.org/conda-forge/
+ultralytics)[Docker](https://hub.docker.com/r/ultralytics/
+ultralytics)Git[]
+(https://docs.ultralytics.com/quickstart) Usage ### CLI YOLOv8
+CLI `yolo`
+ ```bash yolo predict model=yolov8n.pt source='https://
+ultralytics.com/images/bus.jpg' ``` `yolo`
+
+`imgsz=640` YOLOv8 [CLI ](https://docs.ultralytics.com/usage/
+cli) ### Python YOLOv8  Python
+ CLI []
+(https://docs.ultralytics.com/usage/cfg/) ```python from ultralytics import
+YOLO #  model = YOLO("yolov8n.yaml") # 
+model = YOLO("yolov8n.pt") #  #
+ model.train(data="coco128.yaml", epochs=3) #  metrics
+= model.val() #  results = model("https://
+ultralytics.com/images/bus.jpg") #  success = model.export
+(format="onnx") #  ONNX  ```  YOLOv8 [Python
+](https://docs.ultralytics.com/usage/python) ###
+ Ultralytics  YOLOv8
+
+[YouTube](https://youtube.com/ultralytics) 
+YOLOv8  |  |  | YouTube | | ---------------
+-------------------------------------------------------------------------------
+-------- | --------------------------------------------------------------------
+-------------------------------------------------------------------------------
+--------------------------------------------------------------------- | :------
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+-----------------------------------------: | | _Y_O_L_O_v_8
+_______________________________________ | _[____ _C_o_l_a_b_ __________]|
+                         _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _______]
+| | _U_l_t_r_a_l_y_t_i_c_s_ _H_U_B_ ____________ | _[____ _C_o_l_a_b_ __________]|
+                         _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _______]
+| | _Y_O_L_O_v_8_ ___________________________ | _[____ _C_o_l_a_b_ __________]|
+                         _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _______]
+| | _Y_O_L_O_v_8_ ________________________ | _[____ _C_o_l_a_b_ __________]|
+                         _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _______]
+| | _Y_O_L_O_v_8_ __________________ | _[____ _C_o_l_a_b_ __________]|
+                         _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _______]
+| | _U_l_t_r_a_l_y_t_i_c_s_ ____________________________ _S_Q_L_ ____ _O_p_e_n_A_I_ _____ _N_e_w | _[___
+_C_o_l_a_b_ __________]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| ##
+                                    
+[COCO](https://docs.ultralytics.com/datasets/detect/
+coco)YOLOv8 [](https://docs.ultralytics.com/
+tasks/detect)[](https://docs.ultralytics.com/tasks/segment)[]
+(https://docs.ultralytics.com/tasks/
+pose)[ImageNet](https://
+docs.ultralytics.com/datasets/classify/imagenet)YOLOv8
+[](https://docs.ultralytics.com/tasks/
+classify)[]
+(https://docs.ultralytics.com/modes/track) [Ultralytics YOLO supported
+tasks][](https://github.com/ultralytics/ultralytics/tree/main/
+ultralytics/cfg/models)Ultralytics
+[](https://github.com/ultralytics/assets/releases) 
+(COCO) [](https://docs.ultralytics.com/tasks/detect/
+)[COCO](https://docs.ultralytics.com/datasets/detect/coco/
+)80 |
+ | 
+() | mAPval
+50-95 | 
 CPU ONNX
-(ms) | Speed
+(ms) | 
 A100 TensorRT
-(ms) | params
+(ms) | 
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
-------------- | --------------------- | -------------------- | ----------------
--------------- | ----------------------------------- | ------------------ | ---
--------------- | | [YOLOv8n](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8n.pt) | 640 | 37.3 | 80.4 | 0.99 | 3.2 | 8.7 | |
-[YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/
-yolov8s.pt) | 640 | 44.9 | 128.4 | 1.20 | 11.2 | 28.6 | | [YOLOv8m](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m.pt) | 640 | 50.2
-| 234.7 | 1.83 | 25.9 | 78.9 | | [YOLOv8l](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8l.pt) | 640 | 52.9 | 375.2 | 2.39 | 43.7
-| 165.2 | | [YOLOv8x](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8x.pt) | 640 | 53.9 | 479.1 | 3.53 | 68.2 | 257.8 | - **mAPval**
-values are for single-model single-scale on [COCO val2017](http://
-cocodataset.org) dataset.
-Reproduce by `yolo val detect data=coco.yaml device=0` - **Speed** averaged
-over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/
-instance-types/p4/) instance.
-Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu` Detection
-(Open Image V7) See [Detection Docs](https://docs.ultralytics.com/tasks/detect/
-) for usage examples with these models trained on [Open Image V7](https://
-docs.ultralytics.com/datasets/detect/open-images-v7/), which include 600 pre-
-trained classes. | Model | size
-(pixels) | mAPval
-50-95 | Speed
+------------- | --------------- | -------------------- | ----------------------
+----- | -------------------------------- | -------------- | ----------------- |
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/
+yolov8n.pt) | 640 | 37.3 | 80.4 | 0.99 | 3.2 | 8.7 | | [YOLOv8s](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s.pt) | 640 | 44.9
+| 128.4 | 1.20 | 11.2 | 28.6 | | [YOLOv8m](https://github.com/ultralytics/
+assets/releases/download/v8.1.0/yolov8m.pt) | 640 | 50.2 | 234.7 | 1.83 | 25.9
+| 78.9 | | [YOLOv8l](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8l.pt) | 640 | 52.9 | 375.2 | 2.39 | 43.7 | 165.2 | | [YOLOv8x]
+(https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x.pt) |
+640 | 53.9 | 479.1 | 3.53 | 68.2 | 257.8 | - **mAPval**
+ [COCO val2017](https://cocodataset.org)
+
+ `yolo val detect data=coco.yaml device=0`  - **** 
+[Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO
+val 
+ `yolo val detect data=coco.yaml batch=1 device=0|cpu` 
+Open Image V7 [](https://docs.ultralytics.com/
+tasks/detect/)[Open Image V7](https://docs.ultralytics.com/
+datasets/detect/open-images-v7/
+)600 |
+ | 
+() | mAP
+50-95 | 
 CPU ONNX
-(ms) | Speed
+() | 
 A100 TensorRT
-(ms) | params
-(M) | FLOPs
+() | 
+(M) | 
 (B) | | -----------------------------------------------------------------------
------------------- | --------------------- | -------------------- | -----------
-------------------- | ----------------------------------- | -----------------
-- | ----------------- | | [YOLOv8n](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8n-oiv7.pt) | 640 | 18.4 | 142.4 | 1.21 | 3.5 |
-10.5 | | [YOLOv8s](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8s-oiv7.pt) | 640 | 27.7 | 183.1 | 1.40 | 11.4 | 29.7 | | [YOLOv8m]
-(https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-
-oiv7.pt) | 640 | 33.6 | 408.5 | 2.26 | 26.2 | 80.6 | | [YOLOv8l](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-oiv7.pt) | 640 |
-34.9 | 596.9 | 2.43 | 44.1 | 167.4 | | [YOLOv8x](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-oiv7.pt) | 640 | 36.3 |
-860.6 | 3.56 | 68.7 | 260.6 | - **mAPval** values are for single-model single-
-scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-
-images-v7/) dataset.
-Reproduce by `yolo val detect data=open-images-v7.yaml device=0` - **Speed**
-averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/
-ec2/instance-types/p4/) instance.
-Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
-Segmentation (COCO) See [Segmentation Docs](https://docs.ultralytics.com/tasks/
-segment/) for usage examples with these models trained on [COCO-Seg](https://
-docs.ultralytics.com/datasets/segment/coco/), which include 80 pre-trained
-classes. | Model | size
-(pixels) | mAPbox
+------------------ | --------------- | ------------------- | ------------------
+--------- | -------------------------------- | -------------- | ---------------
+- | | [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/
+yolov8n-oiv7.pt) | 640 | 18.4 | 142.4 | 1.21 | 3.5 | 10.5 | | [YOLOv8s](https:/
+/github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-oiv7.pt) | 640
+| 27.7 | 183.1 | 1.40 | 11.4 | 29.7 | | [YOLOv8m](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8m-oiv7.pt) | 640 | 33.6 |
+408.5 | 2.26 | 26.2 | 80.6 | | [YOLOv8l](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8l-oiv7.pt) | 640 | 34.9 | 596.9 | 2.43 | 44.1 |
+167.4 | | [YOLOv8x](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8x-oiv7.pt) | 640 | 36.3 | 860.6 | 3.56 | 68.7 | 260.6 | -
+**mAP** [Open Image V7](https://docs.ultralytics.com/
+datasets/detect/open-images-v7/)
+ `yolo val detect data=open-images-v7.yaml device=0`  -
+**** [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/
+p4/)Open Image V7
+ `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
+  (COCO) [](https://docs.ultralytics.com/
+tasks/segment/)[COCO-Seg](https://docs.ultralytics.com/
+datasets/segment/coco/
+)80 |
+ | 
+() | mAPbox
 50-95 | mAPmask
-50-95 | Speed
+50-95 | 
 CPU ONNX
-(ms) | Speed
+(ms) | 
 A100 TensorRT
-(ms) | params
+(ms) | 
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
---------------------- | --------------------- | -------------------- | --------
-------------- | ------------------------------ | ------------------------------
------ | ------------------ | ----------------- | | [YOLOv8n-seg](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-seg.pt) | 640 |
-36.7 | 30.5 | 96.1 | 1.21 | 3.4 | 12.6 | | [YOLOv8s-seg](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-seg.pt) | 640 | 44.6 | 36.8
-| 155.7 | 1.47 | 11.8 | 42.6 | | [YOLOv8m-seg](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8m-seg.pt) | 640 | 49.9 | 40.8 | 317.0 |
-2.18 | 27.3 | 110.2 | | [YOLOv8l-seg](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8l-seg.pt) | 640 | 52.3 | 42.6 | 572.4 | 2.79 |
-46.0 | 220.5 | | [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8x-seg.pt) | 640 | 53.4 | 43.4 | 712.1 | 4.02 | 71.8 |
-344.1 | - **mAPval** values are for single-model single-scale on [COCO val2017]
-(http://cocodataset.org) dataset.
-Reproduce by `yolo val segment data=coco-seg.yaml device=0` - **Speed**
-averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/
-ec2/instance-types/p4/) instance.
-Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu` Pose
-(COCO) See [Pose Docs](https://docs.ultralytics.com/tasks/pose/) for usage
-examples with these models trained on [COCO-Pose](https://docs.ultralytics.com/
-datasets/pose/coco/), which include 1 pre-trained class, person. | Model | size
-(pixels) | mAPpose
+--------------------- | --------------- | -------------------- | --------------
+------- | --------------------------- | -------------------------------- | ----
+---------- | ----------------- | | [YOLOv8n-seg](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8n-seg.pt) | 640 | 36.7 | 30.5
+| 96.1 | 1.21 | 3.4 | 12.6 | | [YOLOv8s-seg](https://github.com/ultralytics/
+assets/releases/download/v8.1.0/yolov8s-seg.pt) | 640 | 44.6 | 36.8 | 155.7 |
+1.47 | 11.8 | 42.6 | | [YOLOv8m-seg](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8m-seg.pt) | 640 | 49.9 | 40.8 | 317.0 | 2.18 |
+27.3 | 110.2 | | [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/
+download/v8.1.0/yolov8l-seg.pt) | 640 | 52.3 | 42.6 | 572.4 | 2.79 | 46.0 |
+220.5 | | [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/
+download/v8.1.0/yolov8x-seg.pt) | 640 | 53.4 | 43.4 | 712.1 | 4.02 | 71.8 |
+344.1 | - **mAPval**  [COCO val2017](https://
+cocodataset.org) 
+ `yolo val segment data=coco-seg.yaml device=0`  - ****
+ [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/
+)  COCO val 
+ `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu`  
+(COCO) [](https://docs.ultralytics.com/tasks/pose/
+)[COCO-Pose](https://docs.ultralytics.com/datasets/pose/coco/
+)1
+|  | 
+() | mAPpose
 50-95 | mAPpose
-50 | Speed
+50 | 
 CPU ONNX
-(ms) | Speed
+(ms) | 
 A100 TensorRT
-(ms) | params
+(ms) | 
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
------------------------------ | --------------------- | --------------------- |
------------------- | ------------------------------ | -------------------------
----------- | ------------------ | ----------------- | | [YOLOv8n-pose](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-pose.pt) | 640 |
-50.4 | 80.1 | 131.8 | 1.18 | 3.3 | 9.2 | | [YOLOv8s-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-pose.pt) | 640 | 60.0 |
+----------------------------- | --------------- | --------------------- | -----
+------------- | --------------------------- | -------------------------------
+- | -------------- | ----------------- | | [YOLOv8n-pose](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8n-pose.pt) | 640 | 50.4 |
+80.1 | 131.8 | 1.18 | 3.3 | 9.2 | | [YOLOv8s-pose](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8s-pose.pt) | 640 | 60.0 |
 86.2 | 233.2 | 1.42 | 11.6 | 30.2 | | [YOLOv8m-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8m-pose.pt) | 640 | 65.0 |
+ultralytics/assets/releases/download/v8.1.0/yolov8m-pose.pt) | 640 | 65.0 |
 88.8 | 456.3 | 2.00 | 26.4 | 81.0 | | [YOLOv8l-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8l-pose.pt) | 640 | 67.6 |
+ultralytics/assets/releases/download/v8.1.0/yolov8l-pose.pt) | 640 | 67.6 |
 90.0 | 784.5 | 2.59 | 44.4 | 168.6 | | [YOLOv8x-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-pose.pt) | 640 | 69.2 |
+ultralytics/assets/releases/download/v8.1.0/yolov8x-pose.pt) | 640 | 69.2 |
 90.2 | 1607.1 | 3.73 | 69.4 | 263.2 | | [YOLOv8x-pose-p6](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-pose-p6.pt) | 1280 | 71.6 |
-91.2 | 4088.7 | 10.04 | 99.1 | 1066.4 | - **mAPval** values are for single-
-model single-scale on [COCO Keypoints val2017](http://cocodataset.org) dataset.
-
-Reproduce by `yolo val pose data=coco-pose.yaml device=0` - **Speed** averaged
-over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/
-instance-types/p4/) instance.
-Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
-Classification (ImageNet) See [Classification Docs](https://
-docs.ultralytics.com/tasks/classify/) for usage examples with these models
-trained on [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/
-), which include 1000 pretrained classes. | Model | size
-(pixels) | acc
+ultralytics/assets/releases/download/v8.1.0/yolov8x-pose-p6.pt) | 1280 | 71.6 |
+91.2 | 4088.7 | 10.04 | 99.1 | 1066.4 | - **mAPval**
+ [COCO Keypoints val2017](https://
+cocodataset.org) 
+ `yolo val pose data=coco-pose.yaml device=0`  - ****
+ [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/
+)  COCO val 
+ `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu` 
+ (DOTAv1) [](https://docs.ultralytics.com/
+tasks/obb/)[DOTAv1](https://docs.ultralytics.com/datasets/
+obb/dota-v2/#dota-v10/
+)15 |
+ | 
+() | mAPtest
+50 | 
+CPU ONNX
+(ms) | 
+A100 TensorRT
+(ms) | 
+(M) | FLOPs
+(B) | | -----------------------------------------------------------------------
+--------------------- | --------------- | ------------------ | ----------------
+----------- | -------------------------------- | -------------- | -------------
+---- | | [YOLOv8n-obb](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8n-obb.pt) | 1024 | 78.0 | 204.77 | 3.57 | 3.1 | 23.3 | | [YOLOv8s-
+obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-
+obb.pt) | 1024 | 79.5 | 424.88 | 4.07 | 11.4 | 76.3 | | [YOLOv8m-obb](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-obb.pt) | 1024 |
+80.5 | 763.48 | 7.61 | 26.4 | 208.6 | | [YOLOv8l-obb](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8l-obb.pt) | 1024 | 80.7 |
+1278.42 | 11.83 | 44.5 | 433.8 | | [YOLOv8x-obb](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8x-obb.pt) | 1024 | 81.36 |
+1759.10 | 13.23 | 69.5 | 676.7 | - **mAPval** 
+[DOTAv1](https://captain-whu.github.io/DOTA/index.html)
+
+ `yolo val obb data=DOTAv1.yaml device=0 split=test`  - ****
+ [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/
+)  COCO val 
+ `yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu`  
+(ImageNet) [](https://docs.ultralytics.com/tasks/classify/
+)[ImageNet](https://docs.ultralytics.com/datasets/classify/
+imagenet/
+)1000 |
+ | 
+() | acc
 top1 | acc
-top5 | Speed
+top5 | 
 CPU ONNX
-(ms) | Speed
+(ms) | 
 A100 TensorRT
-(ms) | params
+(ms) | 
 (M) | FLOPs
 (B) at 640 | | ----------------------------------------------------------------
----------------------------- | --------------------- | ---------------- | -----
------------ | ------------------------------ | --------------------------------
---- | ------------------ | ------------------------ | | [YOLOv8n-cls](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-cls.pt) | 224 |
-66.6 | 87.0 | 12.9 | 0.31 | 2.7 | 4.3 | | [YOLOv8s-cls](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-cls.pt) | 224 | 72.3 | 91.1
-| 23.4 | 0.35 | 6.4 | 13.5 | | [YOLOv8m-cls](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8m-cls.pt) | 224 | 76.4 | 93.2 | 85.4 |
-0.62 | 17.0 | 42.7 | | [YOLOv8l-cls](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8l-cls.pt) | 224 | 78.0 | 94.1 | 163.0 | 0.87 |
-37.5 | 99.7 | | [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8x-cls.pt) | 224 | 78.4 | 94.3 | 232.0 | 1.01 | 57.4 |
-154.8 | - **acc** values are model accuracies on the [ImageNet](https://
-www.image-net.org/) dataset validation set.
-Reproduce by `yolo val classify data=path/to/ImageNet device=0` - **Speed**
-averaged over ImageNet val images using an [Amazon EC2 P4d](https://
-aws.amazon.com/ec2/instance-types/p4/) instance.
-Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu` ##
-                                 Integrations
-Our key integrations with leading AI platforms extend the functionality of
-Ultralytics' offerings, enhancing tasks like dataset labeling, training,
-visualization, and model management. Discover how Ultralytics, in collaboration
-with [Roboflow](https://roboflow.com/?ref=ultralytics), ClearML, [Comet](https:
-//bit.ly/yolov8-readme-comet), Neural Magic and [OpenVINO](https://
-docs.ultralytics.com/integrations/openvino), can optimize your AI workflow.
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_y_o_l_o_v_8_/_b_a_n_n_e_r_-_i_n_t_e_g_r_a_t_i_o_n_s_._p_n_g_]
+---------------------------- | --------------- | ---------------- | -----------
+----- | --------------------------- | -------------------------------- | ------
+-------- | ------------------------ | | [YOLOv8n-cls](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8n-cls.pt) | 224 | 69.0 | 88.3
+| 12.9 | 0.31 | 2.7 | 4.3 | | [YOLOv8s-cls](https://github.com/ultralytics/
+assets/releases/download/v8.1.0/yolov8s-cls.pt) | 224 | 73.8 | 91.7 | 23.4 |
+0.35 | 6.4 | 13.5 | | [YOLOv8m-cls](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8m-cls.pt) | 224 | 76.8 | 93.5 | 85.4 | 0.62 |
+17.0 | 42.7 | | [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/
+download/v8.1.0/yolov8l-cls.pt) | 224 | 76.8 | 93.5 | 163.0 | 0.87 | 37.5 |
+99.7 | | [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8x-cls.pt) | 224 | 79.0 | 94.6 | 232.0 | 1.01 | 57.4 | 154.8 | -
+**acc**  [ImageNet](https://www.image-net.org/
+) 
+ `yolo val classify data=path/to/ImageNet device=0`  - ****
+ [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/
+)  ImageNet val 
+ `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu`  ##
+                                    
+AIUltralyticsUltralytics
+[Roboflow](https://roboflow.com/?ref=ultralytics)ClearML[Comet](https://
+bit.ly/yolov8-readme-comet)Neural Magic[OpenVINO](https://
+docs.ultralytics.com/integrations/
+openvino)AI
+_[_U_l_t_r_a_l_y_t_i_c_s_ _a_c_t_i_v_e_ _l_e_a_r_n_i_n_g_ _i_n_t_e_g_r_a_t_i_o_n_s_]
 
-  _[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_r_o_b_o_f_l_o_w_._p_n_g_]
-  _[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_c_l_e_a_r_m_l_._p_n_g_]
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_c_o_m_e_t_._p_n_g_]_[_h_t_t_p_s_:
-    _/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_n_e_u_r_a_l_m_a_g_i_c_._p_n_g_]
+ _[_R_o_b_o_f_l_o_w_ _l_o_g_o_][space]_[_C_l_e_a_r_M_L_ _l_o_g_o_][space]_[_C_o_m_e_t_ _M_L_ _l_o_g_o_][space]_[_N_e_u_r_a_l_M_a_g_i_c
+                                     _l_o_g_o_]
 | Roboflow | ClearML  NEW | Comet  NEW | Neural Magic  NEW | | :------
--------------------------------------------------------------------------------
--------------------------------------: | :-------------------------------------
--------------------------------------------------------------------------------
--------------: | :-------------------------------------------------------------
--------------------------------------------------------------------------------
------------: | :---------------------------------------------------------------
--------------------------------------: | | Label and export your custom
-datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/
-?ref=ultralytics) | Automatically track, visualize and even remotely train
-YOLOv8 using [ClearML](https://cutt.ly/yolov5-readme-clearml) (open-source!) |
-Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8
-models, resume training, and interactively visualize and debug predictions |
-Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://
-bit.ly/yolov5-neuralmagic) | ##
+--------------------------------------------------------------------------: | :
+--------------------------------------------------------: | :------------------
+----------------------------------------------------------------: | :----------
+-------------------------------------------------------------------------: | |
+ [Roboflow](https://roboflow.com/?ref=ultralytics)
+ YOLOv8  |
+ [ClearML](https://clear.ml/
+) YOLOv8 |
+[Comet](https://bit.ly/yolov8-readme-comet) 
+YOLOv8  |
+ [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic)  YOLOv8
+ 6  | ##
                                 Ultralytics HUB
-Experience seamless AI with [Ultralytics HUB](https://bit.ly/ultralytics_hub)
-, the all-in-one solution for data visualization, YOLOv5 and YOLOv8 
-model training and deployment, without any coding. Transform images into
-actionable insights and bring your AI visions to life with ease using our
-cutting-edge platform and user-friendly [Ultralytics App](https://
-ultralytics.com/app_install). Start your journey for **Free** now! _[_U_l_t_r_a_l_y_t_i_c_s
-_H_U_B_ _p_r_e_v_i_e_w_ _i_m_a_g_e_]##
-                                  Contribute
-We love your input! YOLOv5 and YOLOv8 would not be possible without help from
-our community. Please see our [Contributing Guide](https://
-docs.ultralytics.com/help/contributing) to get started, and fill out our
-[Survey](https://ultralytics.com/
-survey?utm_source=github&utm_medium=social&utm_campaign=Survey) to send us
-feedback on your experience. Thank you  to all our contributors! _[_h_t_t_p_s_:_/_/
-_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_i_m_/_i_m_a_g_e_-_c_o_n_t_r_i_b_u_t_o_r_s_._p_n_g_]##
-                                    License
-Ultralytics offers two licensing options to accommodate diverse use cases: -
-**AGPL-3.0 License**: This [OSI-approved](https://opensource.org/licenses/
-) open-source license is ideal for students and enthusiasts, promoting open
-collaboration and knowledge sharing. See the [LICENSE](https://github.com/
-ultralytics/ultralytics/blob/main/LICENSE) file for more details. -
-**Enterprise License**: Designed for commercial use, this license permits
-seamless integration of Ultralytics software and AI models into commercial
-goods and services, bypassing the open-source requirements of AGPL-3.0. If your
-scenario involves embedding our solutions into a commercial offering, reach out
-through [Ultralytics Licensing](https://ultralytics.com/license). ##
-                                    Contact
-For Ultralytics bug reports and feature requests please visit [GitHub Issues]
-(https://github.com/ultralytics/ultralytics/issues), and join our [Discord]
-(https://ultralytics.com/discord) community for questions and discussions!
-  _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][https://github.com/ultralytics/assets/raw/main/social/
-  logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][https://github.com/ultralytics/
-  assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_][https://
-github.com/ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s
-     _Y_o_u_T_u_b_e_][https://github.com/ultralytics/assets/raw/main/social/logo-
-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][https://github.com/ultralytics/assets/raw/
- main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _I_n_s_t_a_g_r_a_m_][https://github.com/
- ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
+ [Ultralytics HUB](https://bit.ly/ultralytics_hub)  
+AIYOLOv5
+ YOLOv8 
+
+[Ultralytics ](https://ultralytics.com/
+app_install) AI
+**** _[_U_l_t_r_a_l_y_t_i_c_s_ _H_U_B_ _p_r_e_v_i_e_w
+_i_m_a_g_e_]##
+                                    
+YOLOv5  YOLOv8
+[](https://
+docs.ultralytics.com/help/contributing)
+[](https://ultralytics.com/
+survey?utm_source=github&utm_medium=social&utm_campaign=Survey)
+_[_U_l_t_r_a_l_y_t_i_c_s_ _o_p_e_n_-_s_o_u_r_c_e_ _c_o_n_t_r_i_b_u_t_o_r_s_]##
+                                   
+Ultralytics  - **AGPL-
+3.0 **[OSI ](https://opensource.org/licenses/
+)
+[LICENSE](https://github.com/ultralytics/ultralytics/blob/main/LICENSE)
+ -
+****
+Ultralytics  AI
+ AGPL-3.0
+
+[Ultralytics Licensing](https://ultralytics.com/license) ##
+                                 
+ Ultralytics  [GitHub Issues]
+(https://github.com/ultralytics/ultralytics/issues)
+[Discord](https://ultralytics.com/discord) 
+ _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_]
+  [space]_[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_T_u_b_e_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][space]_[_U_l_t_r_a_l_y_t_i_c_s
+                    _I_n_s_t_a_g_r_a_m_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
```

### Comparing `yolov8-pose-triton-8.1.0/README.zh-CN.md` & `yolov8_pose_triton-8.2.0/PKG-INFO`

 * *Files 22% similar despite different names*

```diff
@@ -1,275 +1,375 @@
+Metadata-Version: 2.1
+Name: yolov8-pose-triton
+Version: 8.2.0
+Summary: Ultralytics YOLOv8 for SOTA object detection, multi-object tracking, instance segmentation, pose estimation and image classification.
+Author: Glenn Jocher, Ayush Chaurasia, Jing Qiu
+Maintainer: Glenn Jocher, Ayush Chaurasia, Jing Qiu
+License: AGPL-3.0
+Project-URL: Bug Reports, https://github.com/ultralytics/ultralytics/issues
+Project-URL: Funding, https://ultralytics.com
+Project-URL: Source, https://github.com/hmurari/ultralytics/
+Keywords: machine-learning,deep-learning,computer-vision,ML,DL,AI,YOLO,YOLOv3,YOLOv5,YOLOv8,HUB,Ultralytics
+Classifier: Development Status :: 4 - Beta
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Education
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Topic :: Software Development
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
+Classifier: Topic :: Scientific/Engineering :: Image Recognition
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: MacOS
+Classifier: Operating System :: Microsoft :: Windows
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+License-File: LICENSE
+Requires-Dist: matplotlib>=3.3.0
+Requires-Dist: opencv-python>=4.6.0
+Requires-Dist: pillow>=7.1.2
+Requires-Dist: pyyaml>=5.3.1
+Requires-Dist: requests>=2.23.0
+Requires-Dist: scipy>=1.4.1
+Requires-Dist: torch>=1.8.0
+Requires-Dist: torchvision>=0.9.0
+Requires-Dist: tqdm>=4.64.0
+Requires-Dist: psutil
+Requires-Dist: py-cpuinfo
+Requires-Dist: thop>=0.1.1
+Requires-Dist: pandas>=1.1.4
+Requires-Dist: seaborn>=0.11.0
+Provides-Extra: dev
+Requires-Dist: ipython; extra == "dev"
+Requires-Dist: check-manifest; extra == "dev"
+Requires-Dist: pre-commit; extra == "dev"
+Requires-Dist: pytest; extra == "dev"
+Requires-Dist: pytest-cov; extra == "dev"
+Requires-Dist: coverage[toml]; extra == "dev"
+Requires-Dist: mkdocs-material>=9.5.9; extra == "dev"
+Requires-Dist: mkdocstrings[python]; extra == "dev"
+Requires-Dist: mkdocs-jupyter; extra == "dev"
+Requires-Dist: mkdocs-redirects; extra == "dev"
+Requires-Dist: mkdocs-ultralytics-plugin>=0.0.44; extra == "dev"
+Provides-Extra: export
+Requires-Dist: onnx>=1.12.0; extra == "export"
+Requires-Dist: coremltools>=7.0; (platform_system != "Windows" and python_version <= "3.11") and extra == "export"
+Requires-Dist: openvino>=2024.0.0; extra == "export"
+Requires-Dist: tensorflow<=2.13.1; python_version <= "3.11" and extra == "export"
+Requires-Dist: tensorflowjs>=3.9.0; python_version <= "3.11" and extra == "export"
+Requires-Dist: numpy==1.23.5; platform_machine == "aarch64" and extra == "export"
+Requires-Dist: h5py!=3.11.0; platform_machine == "aarch64" and extra == "export"
+Provides-Extra: explorer
+Requires-Dist: lancedb; extra == "explorer"
+Requires-Dist: duckdb<=0.9.2; extra == "explorer"
+Requires-Dist: streamlit; extra == "explorer"
+Provides-Extra: logging
+Requires-Dist: comet; extra == "logging"
+Requires-Dist: tensorboard>=2.13.0; extra == "logging"
+Requires-Dist: dvclive>=2.12.0; extra == "logging"
+Provides-Extra: extra
+Requires-Dist: hub-sdk>=0.0.5; extra == "extra"
+Requires-Dist: ipython; extra == "extra"
+Requires-Dist: albumentations>=1.0.3; extra == "extra"
+Requires-Dist: pycocotools>=2.0.7; extra == "extra"
+
 <div align="center">
   <p>
-    <a href="https://yolovision.ultralytics.com/" target="_blank">
-      <img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/im/banner-yolo-vision-2023.png"></a>
+    <a href="https://github.com/ultralytics/assets/releases/tag/v8.2.0" target="_blank">
+      <img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/banner-yolov8.png" alt="YOLO Vision banner"></a>
   </p>
 
-[](https://docs.ultralytics.com/zh/) | [](https://docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) | [](https://docs.ultralytics.com/ru/) | [Deutsch](https://docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) | [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/hi/) | [](https://docs.ultralytics.com/ar/)
-<br>
+[](https://docs.ultralytics.com/zh/) | [](https://docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) | [](https://docs.ultralytics.com/ru/) | [Deutsch](https://docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) | [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/hi/) | [](https://docs.ultralytics.com/ar/) <br>
 
 <div>
     <a href="https://github.com/ultralytics/ultralytics/actions/workflows/ci.yaml"><img src="https://github.com/ultralytics/ultralytics/actions/workflows/ci.yaml/badge.svg" alt="Ultralytics CI"></a>
     <a href="https://codecov.io/github/ultralytics/ultralytics"><img src="https://codecov.io/github/ultralytics/ultralytics/branch/main/graph/badge.svg?token=HHW7IIVFVY" alt="Ultralytics Code Coverage"></a>
     <a href="https://zenodo.org/badge/latestdoi/264818686"><img src="https://zenodo.org/badge/264818686.svg" alt="YOLOv8 Citation"></a>
     <a href="https://hub.docker.com/r/ultralytics/ultralytics"><img src="https://img.shields.io/docker/pulls/ultralytics/ultralytics?logo=docker" alt="Docker Pulls"></a>
+    <a href="https://ultralytics.com/discord"><img alt="Discord" src="https://img.shields.io/discord/1089800235347353640?logo=discord&logoColor=white&label=Discord&color=blue"></a>
     <br>
-    <a href="https://console.paperspace.com/github/ultralytics/ultralytics"><img src="https://assets.paperspace.io/img/gradient-badge.svg" alt="Run on Gradient"/></a>
+    <a href="https://console.paperspace.com/github/ultralytics/ultralytics"><img src="https://assets.paperspace.io/img/gradient-badge.svg" alt="Run on Gradient"></a>
     <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/tutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>
     <a href="https://www.kaggle.com/ultralytics/yolov8"><img src="https://kaggle.com/static/images/open-in-kaggle.svg" alt="Open In Kaggle"></a>
 </div>
 <br>
 
-[Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/ultralytics) SOTA YOLO YOLOv8 
+[Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/ultralytics) is a cutting-edge, state-of-the-art (SOTA) model that builds upon the success of previous YOLO versions and introduces new features and improvements to further boost performance and flexibility. YOLOv8 is designed to be fast, accurate, and easy to use, making it an excellent choice for a wide range of object detection and tracking, instance segmentation, image classification and pose estimation tasks.
 
- YOLOv8 YOLOv8 <a href="https://docs.ultralytics.com/"></a>  <a href="https://github.com/ultralytics/ultralytics/issues/new/choose">GitHub</a>  <a href="https://ultralytics.com/discord">Discord</a> 
+We hope that the resources here will help you get the most out of YOLOv8. Please browse the YOLOv8 <a href="https://docs.ultralytics.com/">Docs</a> for details, raise an issue on <a href="https://github.com/ultralytics/ultralytics/issues/new/choose">GitHub</a> for support, and join our <a href="https://ultralytics.com/discord">Discord</a> community for questions and discussions!
 
- [Ultralytics Licensing](https://ultralytics.com/license) 
+To request an Enterprise License please complete the form at [Ultralytics Licensing](https://ultralytics.com/license).
 
-<img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-plots.png"></a>
+<img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-plots.png" alt="YOLOv8 performance plots"></a>
 
 <div align="center">
   <a href="https://github.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-github.png" width="2%" alt="Ultralytics GitHub"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.linkedin.com/company/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-linkedin.png" width="2%" alt="Ultralytics LinkedIn"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://twitter.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-twitter.png" width="2%" alt="Ultralytics Twitter"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://youtube.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-youtube.png" width="2%" alt="Ultralytics YouTube"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.tiktok.com/@ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-tiktok.png" width="2%" alt="Ultralytics TikTok"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.instagram.com/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-instagram.png" width="2%" alt="Ultralytics Instagram"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://ultralytics.com/discord"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-discord.png" width="2%" alt="Ultralytics Discord"></a>
 </div>
 </div>
 
-## <div align="center"></div>
+## <div align="center">Documentation</div>
 
- [YOLOv8 ](https://docs.ultralytics.com) 
+See below for a quickstart installation and usage example, and see the [YOLOv8 Docs](https://docs.ultralytics.com) for full documentation on training, validation, prediction and deployment.
 
 <details open>
-<summary></summary>
+<summary>Install</summary>
 
-Pip[**Python>=3.8**](https://www.python.org/)`ultralytics`[**PyTorch>=1.8**](https://pytorch.org/get-started/locally/)[](https://github.com/ultralytics/ultralytics/blob/main/requirements.txt)
+Pip install the ultralytics package including all [requirements](https://github.com/ultralytics/ultralytics/blob/main/pyproject.toml) in a [**Python>=3.8**](https://www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-started/locally/).
 
 [![PyPI version](https://badge.fury.io/py/ultralytics.svg)](https://badge.fury.io/py/ultralytics) [![Downloads](https://static.pepy.tech/badge/ultralytics)](https://pepy.tech/project/ultralytics)
 
 ```bash
 pip install ultralytics
 ```
 
-[Conda](https://anaconda.org/conda-forge/ultralytics)[Docker](https://hub.docker.com/r/ultralytics/ultralytics)Git[](https://docs.ultralytics.com/quickstart)
+For alternative installation methods including [Conda](https://anaconda.org/conda-forge/ultralytics), [Docker](https://hub.docker.com/r/ultralytics/ultralytics), and Git, please refer to the [Quickstart Guide](https://docs.ultralytics.com/quickstart).
 
 </details>
 
 <details open>
 <summary>Usage</summary>
 
-#### CLI
+### CLI
 
-YOLOv8 CLI `yolo` 
+YOLOv8 may be used directly in the Command Line Interface (CLI) with a `yolo` command:
 
 ```bash
 yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'
 ```
 
-`yolo`  `imgsz=640` YOLOv8 [CLI ](https://docs.ultralytics.com/usage/cli)
+`yolo` can be used for a variety of tasks and modes and accepts additional arguments, i.e. `imgsz=640`. See the YOLOv8 [CLI Docs](https://docs.ultralytics.com/usage/cli) for examples.
 
-#### Python
+### Python
 
-YOLOv8  Python  CLI [](https://docs.ultralytics.com/usage/cfg/)
+YOLOv8 may also be used directly in a Python environment, and accepts the same [arguments](https://docs.ultralytics.com/usage/cfg/) as in the CLI example above:
 
 ```python
 from ultralytics import YOLO
 
-# 
-model = YOLO("yolov8n.yaml")  # 
-model = YOLO("yolov8n.pt")  # 
-
-# 
-model.train(data="coco128.yaml", epochs=3)  # 
-metrics = model.val()  # 
-results = model("https://ultralytics.com/images/bus.jpg")  # 
-success = model.export(format="onnx")  #  ONNX 
+# Load a model
+model = YOLO("yolov8n.yaml")  # build a new model from scratch
+model = YOLO("yolov8n.pt")  # load a pretrained model (recommended for training)
+
+# Use the model
+model.train(data="coco128.yaml", epochs=3)  # train the model
+metrics = model.val()  # evaluate model performance on the validation set
+results = model("https://ultralytics.com/images/bus.jpg")  # predict on an image
+path = model.export(format="onnx")  # export the model to ONNX format
 ```
 
- YOLOv8 [Python ](https://docs.ultralytics.com/usage/python)
+See YOLOv8 [Python Docs](https://docs.ultralytics.com/usage/python) for more examples.
 
 </details>
 
-## <div align="center"></div>
+### Notebooks
+
+Ultralytics provides interactive notebooks for YOLOv8, covering training, validation, tracking, and more. Each notebook is paired with a [YouTube](https://youtube.com/ultralytics) tutorial, making it easy to learn and implement advanced YOLOv8 features.
+
+| Docs                                                                                                                              | Notebook                                                                                                                                                                                                                   |                                                                                                     YouTube                                                                                                     |
+| --------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
+| <a href="https://docs.ultralytics.com/modes/">YOLOv8 Train, Val, Predict and Export Modes</a>                                     | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/tutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                  | <a href="https://youtu.be/j8uQc0qB91s"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/hub/quickstart/">Ultralytics HUB QuickStart</a>                                             | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/hub.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                       | <a href="https://youtu.be/lveF9iCMIzc"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/modes/track/">YOLOv8 Multi-Object Tracking in Videos</a>                                    | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/object_tracking.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>           | <a href="https://youtu.be/hHyHmOtmEgs"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/guides/object-counting/">YOLOv8 Object Counting in Videos</a>                               | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/object_counting.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>           | <a href="https://youtu.be/Ag2e-5_NpS0"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/guides/heatmaps/">YOLOv8 Heatmaps in Videos</a>                                             | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/heatmaps.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                  | <a href="https://youtu.be/4ezde5-nZZw"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/datasets/explorer/">Ultralytics Datasets Explorer with SQL and OpenAI Integration  New</a> | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/docs/en/datasets/explorer/explorer.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a> | <a href="https://youtu.be/3VryynorQeo"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
 
-[COCO](https://docs.ultralytics.com/datasets/detect/coco)YOLOv8 [](https://docs.ultralytics.com/tasks/detect)[](https://docs.ultralytics.com/tasks/segment)[](https://docs.ultralytics.com/tasks/pose)[ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet)YOLOv8 [](https://docs.ultralytics.com/tasks/classify)[](https://docs.ultralytics.com/modes/track)
+## <div align="center">Models</div>
+
+YOLOv8 [Detect](https://docs.ultralytics.com/tasks/detect), [Segment](https://docs.ultralytics.com/tasks/segment) and [Pose](https://docs.ultralytics.com/tasks/pose) models pretrained on the [COCO](https://docs.ultralytics.com/datasets/detect/coco) dataset are available here, as well as YOLOv8 [Classify](https://docs.ultralytics.com/tasks/classify) models pretrained on the [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet) dataset. [Track](https://docs.ultralytics.com/modes/track) mode is available for all Detect, Segment and Pose models.
 
 <img width="1024" src="https://raw.githubusercontent.com/ultralytics/assets/main/im/banner-tasks.png" alt="Ultralytics YOLO supported tasks">
 
-[](https://github.com/ultralytics/ultralytics/tree/main/ultralytics/cfg/models)Ultralytics [](https://github.com/ultralytics/assets/releases)
+All [Models](https://github.com/ultralytics/ultralytics/tree/main/ultralytics/cfg/models) download automatically from the latest Ultralytics [release](https://github.com/ultralytics/assets/releases) on first use.
+
+<details open><summary>Detection (COCO)</summary>
+
+See [Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples with these models trained on [COCO](https://docs.ultralytics.com/datasets/detect/coco/), which include 80 pre-trained classes.
+
+| Model                                                                                | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
+| ------------------------------------------------------------------------------------ | --------------------- | -------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n.pt) | 640                   | 37.3                 | 80.4                           | 0.99                                | 3.2                | 8.7               |
+| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s.pt) | 640                   | 44.9                 | 128.4                          | 1.20                                | 11.2               | 28.6              |
+| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m.pt) | 640                   | 50.2                 | 234.7                          | 1.83                                | 25.9               | 78.9              |
+| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l.pt) | 640                   | 52.9                 | 375.2                          | 2.39                                | 43.7               | 165.2             |
+| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x.pt) | 640                   | 53.9                 | 479.1                          | 3.53                                | 68.2               | 257.8             |
 
-<details open><summary> (COCO)</summary>
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val detect data=coco.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu`
 
-[](https://docs.ultralytics.com/tasks/detect/)[COCO](https://docs.ultralytics.com/datasets/detect/coco/)80
+</details>
+
+<details><summary>Detection (Open Image V7)</summary>
+
+See [Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples with these models trained on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/), which include 600 pre-trained classes.
+
+| Model                                                                                     | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
+| ----------------------------------------------------------------------------------------- | --------------------- | -------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-oiv7.pt) | 640                   | 18.4                 | 142.4                          | 1.21                                | 3.5                | 10.5              |
+| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-oiv7.pt) | 640                   | 27.7                 | 183.1                          | 1.40                                | 11.4               | 29.7              |
+| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-oiv7.pt) | 640                   | 33.6                 | 408.5                          | 2.26                                | 26.2               | 80.6              |
+| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-oiv7.pt) | 640                   | 34.9                 | 596.9                          | 2.43                                | 44.1               | 167.4             |
+| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-oiv7.pt) | 640                   | 36.3                 | 860.6                          | 3.56                                | 68.7               | 260.6             |
 
-|                                                                                    | <br><sup>() | mAP<sup>val<br>50-95 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) |
-| ------------------------------------------------------------------------------------ | --------------- | -------------------- | --------------------------- | -------------------------------- | -------------- | ----------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt) | 640             | 37.3                 | 80.4                        | 0.99                             | 3.2            | 8.7               |
-| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s.pt) | 640             | 44.9                 | 128.4                       | 1.20                             | 11.2           | 28.6              |
-| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m.pt) | 640             | 50.2                 | 234.7                       | 1.83                             | 25.9           | 78.9              |
-| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l.pt) | 640             | 52.9                 | 375.2                       | 2.39                             | 43.7           | 165.2             |
-| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x.pt) | 640             | 53.9                 | 479.1                       | 3.53                             | 68.2           | 257.8             |
-
-- **mAP<sup>val</sup>**  [COCO val2017](http://cocodataset.org) 
-  <br> `yolo val detect data=coco.yaml device=0` 
-- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO val 
-  <br> `yolo val detect data=coco.yaml batch=1 device=0|cpu` 
+- **mAP<sup>val</sup>** values are for single-model single-scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/) dataset. <br>Reproduce by `yolo val detect data=open-images-v7.yaml device=0`
+- **Speed** averaged over Open Image V7 val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
 
 </details>
 
-<details><summary>Open Image V7</summary>
+<details><summary>Segmentation (COCO)</summary>
 
-[](https://docs.ultralytics.com/tasks/detect/)[Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/)600
+See [Segmentation Docs](https://docs.ultralytics.com/tasks/segment/) for usage examples with these models trained on [COCO-Seg](https://docs.ultralytics.com/datasets/segment/coco/), which include 80 pre-trained classes.
 
-|                                                                                         | <br><sup>() | mAP<sup><br>50-95 | <br><sup>CPU ONNX<br>() | <br><sup>A100 TensorRT<br>() | <br><sup>(M) | <br><sup>(B) |
-| ----------------------------------------------------------------------------------------- | --------------- | ------------------- | --------------------------- | -------------------------------- | -------------- | ---------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-oiv7.pt) | 640             | 18.4                | 142.4                       | 1.21                             | 3.5            | 10.5             |
-| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-oiv7.pt) | 640             | 27.7                | 183.1                       | 1.40                             | 11.4           | 29.7             |
-| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-oiv7.pt) | 640             | 33.6                | 408.5                       | 2.26                             | 26.2           | 80.6             |
-| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-oiv7.pt) | 640             | 34.9                | 596.9                       | 2.43                             | 44.1           | 167.4            |
-| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-oiv7.pt) | 640             | 36.3                | 860.6                       | 3.56                             | 68.7           | 260.6            |
-
-- **mAP<sup></sup>** [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/)
-  <br> `yolo val detect data=open-images-v7.yaml device=0` 
-- **** [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)COCO
-  <br> `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu` 
+| Model                                                                                        | size<br><sup>(pixels) | mAP<sup>box<br>50-95 | mAP<sup>mask<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
+| -------------------------------------------------------------------------------------------- | --------------------- | -------------------- | --------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
+| [YOLOv8n-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-seg.pt) | 640                   | 36.7                 | 30.5                  | 96.1                           | 1.21                                | 3.4                | 12.6              |
+| [YOLOv8s-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-seg.pt) | 640                   | 44.6                 | 36.8                  | 155.7                          | 1.47                                | 11.8               | 42.6              |
+| [YOLOv8m-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-seg.pt) | 640                   | 49.9                 | 40.8                  | 317.0                          | 2.18                                | 27.3               | 110.2             |
+| [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-seg.pt) | 640                   | 52.3                 | 42.6                  | 572.4                          | 2.79                                | 46.0               | 220.5             |
+| [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-seg.pt) | 640                   | 53.4                 | 43.4                  | 712.1                          | 4.02                                | 71.8               | 344.1             |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val segment data=coco-seg.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu`
 
 </details>
 
-<details><summary> (COCO)</summary>
+<details><summary>Pose (COCO)</summary>
+
+See [Pose Docs](https://docs.ultralytics.com/tasks/pose/) for usage examples with these models trained on [COCO-Pose](https://docs.ultralytics.com/datasets/pose/coco/), which include 1 pre-trained class, person.
 
-[](https://docs.ultralytics.com/tasks/segment/)[COCO-Seg](https://docs.ultralytics.com/datasets/segment/coco/)80
+| Model                                                                                                | size<br><sup>(pixels) | mAP<sup>pose<br>50-95 | mAP<sup>pose<br>50 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
+| ---------------------------------------------------------------------------------------------------- | --------------------- | --------------------- | ------------------ | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
+| [YOLOv8n-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-pose.pt)       | 640                   | 50.4                  | 80.1               | 131.8                          | 1.18                                | 3.3                | 9.2               |
+| [YOLOv8s-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-pose.pt)       | 640                   | 60.0                  | 86.2               | 233.2                          | 1.42                                | 11.6               | 30.2              |
+| [YOLOv8m-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-pose.pt)       | 640                   | 65.0                  | 88.8               | 456.3                          | 2.00                                | 26.4               | 81.0              |
+| [YOLOv8l-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-pose.pt)       | 640                   | 67.6                  | 90.0               | 784.5                          | 2.59                                | 44.4               | 168.6             |
+| [YOLOv8x-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-pose.pt)       | 640                   | 69.2                  | 90.2               | 1607.1                         | 3.73                                | 69.4               | 263.2             |
+| [YOLOv8x-pose-p6](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-pose-p6.pt) | 1280                  | 71.6                  | 91.2               | 4088.7                         | 10.04                               | 99.1               | 1066.4            |
 
-|                                                                                            | <br><sup>() | mAP<sup>box<br>50-95 | mAP<sup>mask<br>50-95 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) |
-| -------------------------------------------------------------------------------------------- | --------------- | -------------------- | --------------------- | --------------------------- | -------------------------------- | -------------- | ----------------- |
-| [YOLOv8n-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-seg.pt) | 640             | 36.7                 | 30.5                  | 96.1                        | 1.21                             | 3.4            | 12.6              |
-| [YOLOv8s-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-seg.pt) | 640             | 44.6                 | 36.8                  | 155.7                       | 1.47                             | 11.8           | 42.6              |
-| [YOLOv8m-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-seg.pt) | 640             | 49.9                 | 40.8                  | 317.0                       | 2.18                             | 27.3           | 110.2             |
-| [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-seg.pt) | 640             | 52.3                 | 42.6                  | 572.4                       | 2.79                             | 46.0           | 220.5             |
-| [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-seg.pt) | 640             | 53.4                 | 43.4                  | 712.1                       | 4.02                             | 71.8           | 344.1             |
-
-- **mAP<sup>val</sup>**  [COCO val2017](http://cocodataset.org) 
-  <br> `yolo val segment data=coco-seg.yaml device=0` 
-- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO val 
-  <br> `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu` 
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO Keypoints val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val pose data=coco-pose.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
 
 </details>
 
-<details><summary> (COCO)</summary>
+<details><summary>OBB (DOTAv1)</summary>
 
-[](https://docs.ultralytics.com/tasks/pose/)[COCO-Pose](https://docs.ultralytics.com/datasets/pose/coco/)1
+See [OBB Docs](https://docs.ultralytics.com/tasks/obb/) for usage examples with these models trained on [DOTAv1](https://docs.ultralytics.com/datasets/obb/dota-v2/#dota-v10/), which include 15 pre-trained classes.
 
-|                                                                                                    | <br><sup>() | mAP<sup>pose<br>50-95 | mAP<sup>pose<br>50 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) |
-| ---------------------------------------------------------------------------------------------------- | --------------- | --------------------- | ------------------ | --------------------------- | -------------------------------- | -------------- | ----------------- |
-| [YOLOv8n-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-pose.pt)       | 640             | 50.4                  | 80.1               | 131.8                       | 1.18                             | 3.3            | 9.2               |
-| [YOLOv8s-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-pose.pt)       | 640             | 60.0                  | 86.2               | 233.2                       | 1.42                             | 11.6           | 30.2              |
-| [YOLOv8m-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-pose.pt)       | 640             | 65.0                  | 88.8               | 456.3                       | 2.00                             | 26.4           | 81.0              |
-| [YOLOv8l-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-pose.pt)       | 640             | 67.6                  | 90.0               | 784.5                       | 2.59                             | 44.4           | 168.6             |
-| [YOLOv8x-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-pose.pt)       | 640             | 69.2                  | 90.2               | 1607.1                      | 3.73                             | 69.4           | 263.2             |
-| [YOLOv8x-pose-p6](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-pose-p6.pt) | 1280            | 71.6                  | 91.2               | 4088.7                      | 10.04                            | 99.1           | 1066.4            |
-
-- **mAP<sup>val</sup>**  [COCO Keypoints val2017](http://cocodataset.org) 
-  <br> `yolo val pose data=coco-pose.yaml device=0` 
-- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO val 
-  <br> `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu` 
+| Model                                                                                        | size<br><sup>(pixels) | mAP<sup>test<br>50 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
+| -------------------------------------------------------------------------------------------- | --------------------- | ------------------ | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
+| [YOLOv8n-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-obb.pt) | 1024                  | 78.0               | 204.77                         | 3.57                                | 3.1                | 23.3              |
+| [YOLOv8s-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-obb.pt) | 1024                  | 79.5               | 424.88                         | 4.07                                | 11.4               | 76.3              |
+| [YOLOv8m-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-obb.pt) | 1024                  | 80.5               | 763.48                         | 7.61                                | 26.4               | 208.6             |
+| [YOLOv8l-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-obb.pt) | 1024                  | 80.7               | 1278.42                        | 11.83                               | 44.5               | 433.8             |
+| [YOLOv8x-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-obb.pt) | 1024                  | 81.36              | 1759.10                        | 13.23                               | 69.5               | 676.7             |
+
+- **mAP<sup>test</sup>** values are for single-model multiscale on [DOTAv1](https://captain-whu.github.io/DOTA/index.html) dataset. <br>Reproduce by `yolo val obb data=DOTAv1.yaml device=0 split=test` and submit merged results to [DOTA evaluation](https://captain-whu.github.io/DOTA/evaluation.html).
+- **Speed** averaged over DOTAv1 val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu`
 
 </details>
 
-<details><summary> (ImageNet)</summary>
+<details><summary>Classification (ImageNet)</summary>
+
+See [Classification Docs](https://docs.ultralytics.com/tasks/classify/) for usage examples with these models trained on [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/), which include 1000 pretrained classes.
 
-[](https://docs.ultralytics.com/tasks/classify/)[ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/)1000
+| Model                                                                                        | size<br><sup>(pixels) | acc<br><sup>top1 | acc<br><sup>top5 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) at 640 |
+| -------------------------------------------------------------------------------------------- | --------------------- | ---------------- | ---------------- | ------------------------------ | ----------------------------------- | ------------------ | ------------------------ |
+| [YOLOv8n-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-cls.pt) | 224                   | 69.0             | 88.3             | 12.9                           | 0.31                                | 2.7                | 4.3                      |
+| [YOLOv8s-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-cls.pt) | 224                   | 73.8             | 91.7             | 23.4                           | 0.35                                | 6.4                | 13.5                     |
+| [YOLOv8m-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-cls.pt) | 224                   | 76.8             | 93.5             | 85.4                           | 0.62                                | 17.0               | 42.7                     |
+| [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-cls.pt) | 224                   | 76.8             | 93.5             | 163.0                          | 0.87                                | 37.5               | 99.7                     |
+| [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-cls.pt) | 224                   | 79.0             | 94.6             | 232.0                          | 1.01                                | 57.4               | 154.8                    |
 
-|                                                                                            | <br><sup>() | acc<br><sup>top1 | acc<br><sup>top5 | <br><sup>CPU ONNX<br>(ms) | <br><sup>A100 TensorRT<br>(ms) | <br><sup>(M) | FLOPs<br><sup>(B) at 640 |
-| -------------------------------------------------------------------------------------------- | --------------- | ---------------- | ---------------- | --------------------------- | -------------------------------- | -------------- | ------------------------ |
-| [YOLOv8n-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-cls.pt) | 224             | 66.6             | 87.0             | 12.9                        | 0.31                             | 2.7            | 4.3                      |
-| [YOLOv8s-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-cls.pt) | 224             | 72.3             | 91.1             | 23.4                        | 0.35                             | 6.4            | 13.5                     |
-| [YOLOv8m-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-cls.pt) | 224             | 76.4             | 93.2             | 85.4                        | 0.62                             | 17.0           | 42.7                     |
-| [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-cls.pt) | 224             | 78.0             | 94.1             | 163.0                       | 0.87                             | 37.5           | 99.7                     |
-| [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-cls.pt) | 224             | 78.4             | 94.3             | 232.0                       | 1.01                             | 57.4           | 154.8                    |
-
-- **acc**  [ImageNet](https://www.image-net.org/) 
-  <br> `yolo val classify data=path/to/ImageNet device=0` 
-- ****  [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  ImageNet val 
-  <br> `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu` 
+- **acc** values are model accuracies on the [ImageNet](https://www.image-net.org/) dataset validation set. <br>Reproduce by `yolo val classify data=path/to/ImageNet device=0`
+- **Speed** averaged over ImageNet val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu`
 
 </details>
 
-## <div align="center"></div>
+## <div align="center">Integrations</div>
 
-AIUltralyticsUltralytics[Roboflow](https://roboflow.com/?ref=ultralytics)ClearML[Comet](https://bit.ly/yolov8-readme-comet)Neural Magic[OpenVINO](https://docs.ultralytics.com/integrations/openvino)AI
+Our key integrations with leading AI platforms extend the functionality of Ultralytics' offerings, enhancing tasks like dataset labeling, training, visualization, and model management. Discover how Ultralytics, in collaboration with [Roboflow](https://roboflow.com/?ref=ultralytics), ClearML, [Comet](https://bit.ly/yolov8-readme-comet), Neural Magic and [OpenVINO](https://docs.ultralytics.com/integrations/openvino), can optimize your AI workflow.
 
 <br>
 <a href="https://bit.ly/ultralytics_hub" target="_blank">
-<img width="100%" src="https://github.com/ultralytics/assets/raw/main/yolov8/banner-integrations.png"></a>
+<img width="100%" src="https://github.com/ultralytics/assets/raw/main/yolov8/banner-integrations.png" alt="Ultralytics active learning integrations"></a>
 <br>
 <br>
 
 <div align="center">
   <a href="https://roboflow.com/?ref=ultralytics">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-roboflow.png" width="10%" /></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="" />
-  <a href="https://cutt.ly/yolov5-readme-clearml">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-clearml.png" width="10%" /></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="" />
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-roboflow.png" width="10%" alt="Roboflow logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
+  <a href="https://clear.ml/">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-clearml.png" width="10%" alt="ClearML logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
   <a href="https://bit.ly/yolov8-readme-comet">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-comet.png" width="10%" /></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="" />
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-comet.png" width="10%" alt="Comet ML logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
   <a href="https://bit.ly/yolov5-neuralmagic">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-neuralmagic.png" width="10%" /></a>
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-neuralmagic.png" width="10%" alt="NeuralMagic logo"></a>
 </div>
 
-|                                      Roboflow                                      |                                 ClearML  NEW                                  |                                     Comet  NEW                                      |                                  Neural Magic  NEW                                   |
-| :--------------------------------------------------------------------------------: | :----------------------------------------------------------------------------: | :----------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------------: |
-|  [Roboflow](https://roboflow.com/?ref=ultralytics)  YOLOv8  |  [ClearML](https://cutt.ly/yolov5-readme-clearml) YOLOv8 | [Comet](https://bit.ly/yolov8-readme-comet)  YOLOv8  |  [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic)  YOLOv8  6  |
+|                                                           Roboflow                                                           |                                                  ClearML  NEW                                                  |                                                                        Comet  NEW                                                                        |                                           Neural Magic  NEW                                           |
+| :--------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------: |
+| Label and export your custom datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/?ref=ultralytics) | Automatically track, visualize and even remotely train YOLOv8 using [ClearML](https://clear.ml/) (open-source!) | Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8 models, resume training, and interactively visualize and debug predictions | Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) |
 
 ## <div align="center">Ultralytics HUB</div>
 
- [Ultralytics HUB](https://bit.ly/ultralytics_hub)   AIYOLOv5  YOLOv8   [Ultralytics ](https://ultralytics.com/app_install) AI ****
+Experience seamless AI with [Ultralytics HUB](https://bit.ly/ultralytics_hub) , the all-in-one solution for data visualization, YOLOv5 and YOLOv8  model training and deployment, without any coding. Transform images into actionable insights and bring your AI visions to life with ease using our cutting-edge platform and user-friendly [Ultralytics App](https://ultralytics.com/app_install). Start your journey for **Free** now!
 
 <a href="https://bit.ly/ultralytics_hub" target="_blank">
 <img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/ultralytics-hub.png" alt="Ultralytics HUB preview image"></a>
 
-## <div align="center"></div>
+## <div align="center">Contribute</div>
 
-YOLOv5  YOLOv8 [](https://docs.ultralytics.com/help/contributing)[](https://ultralytics.com/survey?utm_source=github&utm_medium=social&utm_campaign=Survey)
+We love your input! YOLOv5 and YOLOv8 would not be possible without help from our community. Please see our [Contributing Guide](https://docs.ultralytics.com/help/contributing) to get started, and fill out our [Survey](https://ultralytics.com/survey?utm_source=github&utm_medium=social&utm_campaign=Survey) to send us feedback on your experience. Thank you  to all our contributors!
 
 <!-- SVG image from https://opencollective.com/ultralytics/contributors.svg?width=990 -->
 
 <a href="https://github.com/ultralytics/yolov5/graphs/contributors">
-<img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/image-contributors.png"></a>
+<img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/image-contributors.png" alt="Ultralytics open-source contributors"></a>
 
-## <div align="center"></div>
+## <div align="center">License</div>
 
-Ultralytics 
+Ultralytics offers two licensing options to accommodate diverse use cases:
 
-- **AGPL-3.0 **[OSI ](https://opensource.org/licenses/)[LICENSE](https://github.com/ultralytics/ultralytics/blob/main/LICENSE) 
-- **** Ultralytics  AI  AGPL-3.0  [Ultralytics Licensing](https://ultralytics.com/license)
+- **AGPL-3.0 License**: This [OSI-approved](https://opensource.org/licenses/) open-source license is ideal for students and enthusiasts, promoting open collaboration and knowledge sharing. See the [LICENSE](https://github.com/ultralytics/ultralytics/blob/main/LICENSE) file for more details.
+- **Enterprise License**: Designed for commercial use, this license permits seamless integration of Ultralytics software and AI models into commercial goods and services, bypassing the open-source requirements of AGPL-3.0. If your scenario involves embedding our solutions into a commercial offering, reach out through [Ultralytics Licensing](https://ultralytics.com/license).
 
-## <div align="center"></div>
+## <div align="center">Contact</div>
 
- Ultralytics  [GitHub Issues](https://github.com/ultralytics/ultralytics/issues) [Discord](https://ultralytics.com/discord) 
+For Ultralytics bug reports and feature requests please visit [GitHub Issues](https://github.com/ultralytics/ultralytics/issues), and join our [Discord](https://ultralytics.com/discord) community for questions and discussions!
 
 <br>
 <div align="center">
   <a href="https://github.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-github.png" width="3%" alt="Ultralytics GitHub"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.linkedin.com/company/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-linkedin.png" width="3%" alt="Ultralytics LinkedIn"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://twitter.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-twitter.png" width="3%" alt="Ultralytics Twitter"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://youtube.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-youtube.png" width="3%" alt="Ultralytics YouTube"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.tiktok.com/@ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-tiktok.png" width="3%" alt="Ultralytics TikTok"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.instagram.com/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-instagram.png" width="3%" alt="Ultralytics Instagram"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://ultralytics.com/discord"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-discord.png" width="3%" alt="Ultralytics Discord"></a>
 </div>
```

#### html2text {}

```diff
@@ -1,296 +1,387 @@
-  _[_h_t_t_p_s_:_/_/_r_a_w_._g_i_t_h_u_b_u_s_e_r_c_o_n_t_e_n_t_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_m_a_i_n_/_i_m_/_b_a_n_n_e_r_-_y_o_l_o_-
-                               _v_i_s_i_o_n_-_2_0_2_3_._p_n_g_]
+Metadata-Version: 2.1 Name: yolov8-pose-triton Version: 8.2.0 Summary:
+Ultralytics YOLOv8 for SOTA object detection, multi-object tracking, instance
+segmentation, pose estimation and image classification. Author: Glenn Jocher,
+Ayush Chaurasia, Jing Qiu Maintainer: Glenn Jocher, Ayush Chaurasia, Jing Qiu
+License: AGPL-3.0 Project-URL: Bug Reports, https://github.com/ultralytics/
+ultralytics/issues Project-URL: Funding, https://ultralytics.com Project-URL:
+Source, https://github.com/hmurari/ultralytics/ Keywords: machine-
+learning,deep-learning,computer-
+vision,ML,DL,AI,YOLO,YOLOv3,YOLOv5,YOLOv8,HUB,Ultralytics Classifier:
+Development Status :: 4 - Beta Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Education Classifier: Intended Audience ::
+Science/Research Classifier: License :: OSI Approved :: GNU Affero General
+Public License v3 or later (AGPLv3+) Classifier: Programming Language :: Python
+:: 3 Classifier: Programming Language :: Python :: 3.8 Classifier: Programming
+Language :: Python :: 3.9 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11 Classifier: Programming
+Language :: Python :: 3.12 Classifier: Topic :: Software Development
+Classifier: Topic :: Scientific/Engineering Classifier: Topic :: Scientific/
+Engineering :: Artificial Intelligence Classifier: Topic :: Scientific/
+Engineering :: Image Recognition Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: MacOS Classifier: Operating System :: Microsoft
+:: Windows Requires-Python: >=3.8 Description-Content-Type: text/markdown
+License-File: LICENSE Requires-Dist: matplotlib>=3.3.0 Requires-Dist: opencv-
+python>=4.6.0 Requires-Dist: pillow>=7.1.2 Requires-Dist: pyyaml>=5.3.1
+Requires-Dist: requests>=2.23.0 Requires-Dist: scipy>=1.4.1 Requires-Dist:
+torch>=1.8.0 Requires-Dist: torchvision>=0.9.0 Requires-Dist: tqdm>=4.64.0
+Requires-Dist: psutil Requires-Dist: py-cpuinfo Requires-Dist: thop>=0.1.1
+Requires-Dist: pandas>=1.1.4 Requires-Dist: seaborn>=0.11.0 Provides-Extra: dev
+Requires-Dist: ipython; extra == "dev" Requires-Dist: check-manifest; extra ==
+"dev" Requires-Dist: pre-commit; extra == "dev" Requires-Dist: pytest; extra ==
+"dev" Requires-Dist: pytest-cov; extra == "dev" Requires-Dist: coverage[toml];
+extra == "dev" Requires-Dist: mkdocs-material>=9.5.9; extra == "dev" Requires-
+Dist: mkdocstrings[python]; extra == "dev" Requires-Dist: mkdocs-jupyter; extra
+== "dev" Requires-Dist: mkdocs-redirects; extra == "dev" Requires-Dist: mkdocs-
+ultralytics-plugin>=0.0.44; extra == "dev" Provides-Extra: export Requires-
+Dist: onnx>=1.12.0; extra == "export" Requires-Dist: coremltools>=7.0;
+(platform_system != "Windows" and python_version <= "3.11") and extra ==
+"export" Requires-Dist: openvino>=2024.0.0; extra == "export" Requires-Dist:
+tensorflow<=2.13.1; python_version <= "3.11" and extra == "export" Requires-
+Dist: tensorflowjs>=3.9.0; python_version <= "3.11" and extra == "export"
+Requires-Dist: numpy==1.23.5; platform_machine == "aarch64" and extra ==
+"export" Requires-Dist: h5py!=3.11.0; platform_machine == "aarch64" and extra
+== "export" Provides-Extra: explorer Requires-Dist: lancedb; extra ==
+"explorer" Requires-Dist: duckdb<=0.9.2; extra == "explorer" Requires-Dist:
+streamlit; extra == "explorer" Provides-Extra: logging Requires-Dist: comet;
+extra == "logging" Requires-Dist: tensorboard>=2.13.0; extra == "logging"
+Requires-Dist: dvclive>=2.12.0; extra == "logging" Provides-Extra: extra
+Requires-Dist: hub-sdk>=0.0.5; extra == "extra" Requires-Dist: ipython; extra
+== "extra" Requires-Dist: albumentations>=1.0.3; extra == "extra" Requires-
+Dist: pycocotools>=2.0.7; extra == "extra"
+                             _[_Y_O_L_O_ _V_i_s_i_o_n_ _b_a_n_n_e_r_]
        [](https://docs.ultralytics.com/zh/) | [](https://
  docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) |
     [](https://docs.ultralytics.com/ru/) | [Deutsch](https://
  docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) |
      [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://
 docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/
            hi/) | [](https://docs.ultralytics.com/ar/)
   _[_U_l_t_r_a_l_y_t_i_c_s_ _C_I_]_[_U_l_t_r_a_l_y_t_i_c_s_ _C_o_d_e_ _C_o_v_e_r_a_g_e_]_[_Y_O_L_O_v_8_ _C_i_t_a_t_i_o_n_]_[_D_o_c_k_e_r_ _P_u_l_l_s_]
+                                   _[_D_i_s_c_o_r_d_]
                _[_R_u_n_ _o_n_ _G_r_a_d_i_e_n_t_]_[_O_p_e_n_ _I_n_ _C_o_l_a_b_]_[_O_p_e_n_ _I_n_ _K_a_g_g_l_e_]
 
 [Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/
-ultralytics) SOTA YOLO
-YOLOv8
-
-  YOLOv8 YOLOv8
-                    ______  _G_i_t_H_u_b
-           _D_i_s_c_o_r_d
-   [Ultralytics
-     Licensing](https://ultralytics.com/license) [https://
-   raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-
-                                  plots.png]
-  _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][https://github.com/ultralytics/assets/raw/main/social/
-  logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][https://github.com/ultralytics/
-  assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_][https://
-github.com/ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s
-     _Y_o_u_T_u_b_e_][https://github.com/ultralytics/assets/raw/main/social/logo-
-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][https://github.com/ultralytics/assets/raw/
- main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _I_n_s_t_a_g_r_a_m_][https://github.com/
- ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
+ultralytics) is a cutting-edge, state-of-the-art (SOTA) model that builds upon
+     the success of previous YOLO versions and introduces new features and
+ improvements to further boost performance and flexibility. YOLOv8 is designed
+to be fast, accurate, and easy to use, making it an excellent choice for a wide
+     range of object detection and tracking, instance segmentation, image
+classification and pose estimation tasks. We hope that the resources here will
+help you get the most out of YOLOv8. Please browse the YOLOv8 _D_o_c_s for details,
+   raise an issue on _G_i_t_H_u_b for support, and join our _D_i_s_c_o_r_d community for
+questions and discussions! To request an Enterprise License please complete the
+   form at [Ultralytics Licensing](https://ultralytics.com/license).[YOLOv8
+                              performance plots]
+ _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_]
+  [space]_[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_T_u_b_e_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][space]_[_U_l_t_r_a_l_y_t_i_c_s
+                    _I_n_s_t_a_g_r_a_m_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
 ##
-                                    
- [YOLOv8 ](https://
-docs.ultralytics.com)
- 
-Pip[**Python>=3.8**](https://www.python.org/
-)`ultralytics`[**PyTorch>=1.8**]
-(https://pytorch.org/get-started/locally/)
-[](https://github.com/ultralytics/ultralytics/blob/main/
-requirements.txt) [![PyPI version](https://badge.fury.io/py/
-ultralytics.svg)](https://badge.fury.io/py/ultralytics) [![Downloads](https://
-static.pepy.tech/badge/ultralytics)](https://pepy.tech/project/ultralytics)
-```bash pip install ultralytics ``` [Conda](https://
-anaconda.org/conda-forge/ultralytics)[Docker](https://hub.docker.com/r/
-ultralytics/ultralytics)Git
-[](https://docs.ultralytics.com/quickstart) Usage #### CLI
-YOLOv8 CLI `yolo`
- ```bash yolo predict model=yolov8n.pt source='https://
-ultralytics.com/images/bus.jpg' ``` `yolo`
-
-`imgsz=640` YOLOv8 [CLI ](https://docs.ultralytics.com/usage/
-cli) #### Python YOLOv8  Python
- CLI []
-(https://docs.ultralytics.com/usage/cfg/) ```python from ultralytics import
-YOLO #  model = YOLO("yolov8n.yaml") # 
-model = YOLO("yolov8n.pt") #  #
- model.train(data="coco128.yaml", epochs=3) #  metrics
-= model.val() #  results = model("https://
-ultralytics.com/images/bus.jpg") #  success = model.export
-(format="onnx") #  ONNX  ```  YOLOv8 [Python
-](https://docs.ultralytics.com/usage/python) ##
-                                    
-[COCO](https://docs.ultralytics.com/datasets/detect/
-coco)YOLOv8 [](https://docs.ultralytics.com/
-tasks/detect)[](https://docs.ultralytics.com/tasks/segment)[]
-(https://docs.ultralytics.com/tasks/
-pose)[ImageNet](https://
-docs.ultralytics.com/datasets/classify/imagenet)YOLOv8
-[](https://docs.ultralytics.com/tasks/
-classify)[]
-(https://docs.ultralytics.com/modes/track) [Ultralytics YOLO supported
-tasks][](https://github.com/ultralytics/ultralytics/tree/main/
-ultralytics/cfg/models)Ultralytics
-[](https://github.com/ultralytics/assets/releases) 
-(COCO) [](https://docs.ultralytics.com/tasks/detect/
-)[COCO](https://docs.ultralytics.com/datasets/detect/coco/
-)80 |
- | 
-() | mAPval
-50-95 | 
+                                 Documentation
+See below for a quickstart installation and usage example, and see the [YOLOv8
+Docs](https://docs.ultralytics.com) for full documentation on training,
+validation, prediction and deployment. Install Pip install the ultralytics
+package including all [requirements](https://github.com/ultralytics/
+ultralytics/blob/main/pyproject.toml) in a [**Python>=3.8**](https://
+www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-
+started/locally/). [![PyPI version](https://badge.fury.io/py/ultralytics.svg)]
+(https://badge.fury.io/py/ultralytics) [![Downloads](https://static.pepy.tech/
+badge/ultralytics)](https://pepy.tech/project/ultralytics) ```bash pip install
+ultralytics ``` For alternative installation methods including [Conda](https://
+anaconda.org/conda-forge/ultralytics), [Docker](https://hub.docker.com/r/
+ultralytics/ultralytics), and Git, please refer to the [Quickstart Guide]
+(https://docs.ultralytics.com/quickstart). Usage ### CLI YOLOv8 may be used
+directly in the Command Line Interface (CLI) with a `yolo` command: ```bash
+yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'
+``` `yolo` can be used for a variety of tasks and modes and accepts additional
+arguments, i.e. `imgsz=640`. See the YOLOv8 [CLI Docs](https://
+docs.ultralytics.com/usage/cli) for examples. ### Python YOLOv8 may also be
+used directly in a Python environment, and accepts the same [arguments](https:/
+/docs.ultralytics.com/usage/cfg/) as in the CLI example above: ```python from
+ultralytics import YOLO # Load a model model = YOLO("yolov8n.yaml") # build a
+new model from scratch model = YOLO("yolov8n.pt") # load a pretrained model
+(recommended for training) # Use the model model.train(data="coco128.yaml",
+epochs=3) # train the model metrics = model.val() # evaluate model performance
+on the validation set results = model("https://ultralytics.com/images/bus.jpg")
+# predict on an image path = model.export(format="onnx") # export the model to
+ONNX format ``` See YOLOv8 [Python Docs](https://docs.ultralytics.com/usage/
+python) for more examples. ### Notebooks Ultralytics provides interactive
+notebooks for YOLOv8, covering training, validation, tracking, and more. Each
+notebook is paired with a [YouTube](https://youtube.com/ultralytics) tutorial,
+making it easy to learn and implement advanced YOLOv8 features. | Docs |
+Notebook | YouTube | | --------------------------------------------------------
+------------------------------------------------------------------------- | ---
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+--------------------------------------------------------- | :------------------
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+-----------------------------: | | _Y_O_L_O_v_8_ _T_r_a_i_n_,_ _V_a_l_,_ _P_r_e_d_i_c_t_ _a_n_d_ _E_x_p_o_r_t_ _M_o_d_e_s
+| _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _U_l_t_r_a_l_y_t_i_c_s_ _H_U_B_ _Q_u_i_c_k_S_t_a_r_t | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _M_u_l_t_i_-_O_b_j_e_c_t_ _T_r_a_c_k_i_n_g_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _O_b_j_e_c_t_ _C_o_u_n_t_i_n_g_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _H_e_a_t_m_a_p_s_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _U_l_t_r_a_l_y_t_i_c_s_ _D_a_t_a_s_e_t_s_ _E_x_p_l_o_r_e_r_ _w_i_t_h_ _S_Q_L_ _a_n_d_ _O_p_e_n_A_I_ _I_n_t_e_g_r_a_t_i_o_n_ _____ _N_e_w |
+_[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| ##
+                                    Models
+YOLOv8 [Detect](https://docs.ultralytics.com/tasks/detect), [Segment](https://
+docs.ultralytics.com/tasks/segment) and [Pose](https://docs.ultralytics.com/
+tasks/pose) models pretrained on the [COCO](https://docs.ultralytics.com/
+datasets/detect/coco) dataset are available here, as well as YOLOv8 [Classify]
+(https://docs.ultralytics.com/tasks/classify) models pretrained on the
+[ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet) dataset.
+[Track](https://docs.ultralytics.com/modes/track) mode is available for all
+Detect, Segment and Pose models. [Ultralytics YOLO supported tasks]All [Models]
+(https://github.com/ultralytics/ultralytics/tree/main/ultralytics/cfg/models)
+download automatically from the latest Ultralytics [release](https://
+github.com/ultralytics/assets/releases) on first use. Detection (COCO) See
+[Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples
+with these models trained on [COCO](https://docs.ultralytics.com/datasets/
+detect/coco/), which include 80 pre-trained classes. | Model | size
+(pixels) | mAPval
+50-95 | Speed
 CPU ONNX
-(ms) | 
+(ms) | Speed
 A100 TensorRT
-(ms) | 
+(ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
-------------- | --------------- | -------------------- | ----------------------
------ | -------------------------------- | -------------- | ----------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/
-yolov8n.pt) | 640 | 37.3 | 80.4 | 0.99 | 3.2 | 8.7 | | [YOLOv8s](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s.pt) | 640 | 44.9
-| 128.4 | 1.20 | 11.2 | 28.6 | | [YOLOv8m](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8m.pt) | 640 | 50.2 | 234.7 | 1.83 | 25.9
-| 78.9 | | [YOLOv8l](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8l.pt) | 640 | 52.9 | 375.2 | 2.39 | 43.7 | 165.2 | | [YOLOv8x]
-(https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x.pt) |
-640 | 53.9 | 479.1 | 3.53 | 68.2 | 257.8 | - **mAPval**
- [COCO val2017](http://cocodataset.org)
-
- `yolo val detect data=coco.yaml device=0`  - **** 
-[Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/)  COCO
-val 
- `yolo val detect data=coco.yaml batch=1 device=0|cpu` 
-Open Image V7 [](https://docs.ultralytics.com/
-tasks/detect/)[Open Image V7](https://docs.ultralytics.com/
-datasets/detect/open-images-v7/
-)600 |
- | 
-() | mAP
-50-95 | 
+------------- | --------------------- | -------------------- | ----------------
+-------------- | ----------------------------------- | ------------------ | ---
+-------------- | | [YOLOv8n](https://github.com/ultralytics/assets/releases/
+download/v8.1.0/yolov8n.pt) | 640 | 37.3 | 80.4 | 0.99 | 3.2 | 8.7 | |
+[YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/
+yolov8s.pt) | 640 | 44.9 | 128.4 | 1.20 | 11.2 | 28.6 | | [YOLOv8m](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m.pt) | 640 | 50.2
+| 234.7 | 1.83 | 25.9 | 78.9 | | [YOLOv8l](https://github.com/ultralytics/
+assets/releases/download/v8.1.0/yolov8l.pt) | 640 | 52.9 | 375.2 | 2.39 | 43.7
+| 165.2 | | [YOLOv8x](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8x.pt) | 640 | 53.9 | 479.1 | 3.53 | 68.2 | 257.8 | - **mAPval**
+values are for single-model single-scale on [COCO val2017](https://
+cocodataset.org) dataset.
+Reproduce by `yolo val detect data=coco.yaml device=0` - **Speed** averaged
+over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/
+instance-types/p4/) instance.
+Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu` Detection
+(Open Image V7) See [Detection Docs](https://docs.ultralytics.com/tasks/detect/
+) for usage examples with these models trained on [Open Image V7](https://
+docs.ultralytics.com/datasets/detect/open-images-v7/), which include 600 pre-
+trained classes. | Model | size
+(pixels) | mAPval
+50-95 | Speed
 CPU ONNX
-() | 
+(ms) | Speed
 A100 TensorRT
-() | 
-(M) | 
+(ms) | params
+(M) | FLOPs
 (B) | | -----------------------------------------------------------------------
------------------- | --------------- | ------------------- | ------------------
---------- | -------------------------------- | -------------- | ---------------
-- | | [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/
-yolov8n-oiv7.pt) | 640 | 18.4 | 142.4 | 1.21 | 3.5 | 10.5 | | [YOLOv8s](https:/
-/github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-oiv7.pt) | 640
-| 27.7 | 183.1 | 1.40 | 11.4 | 29.7 | | [YOLOv8m](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8m-oiv7.pt) | 640 | 33.6 |
-408.5 | 2.26 | 26.2 | 80.6 | | [YOLOv8l](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8l-oiv7.pt) | 640 | 34.9 | 596.9 | 2.43 | 44.1 |
-167.4 | | [YOLOv8x](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8x-oiv7.pt) | 640 | 36.3 | 860.6 | 3.56 | 68.7 | 260.6 | -
-**mAP** [Open Image V7](https://docs.ultralytics.com/
-datasets/detect/open-images-v7/)
- `yolo val detect data=open-images-v7.yaml device=0`  -
-**** [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/
-p4/)COCO
- `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
-  (COCO) [](https://docs.ultralytics.com/
-tasks/segment/)[COCO-Seg](https://docs.ultralytics.com/
-datasets/segment/coco/
-)80 |
- | 
-() | mAPbox
+------------------ | --------------------- | -------------------- | -----------
+------------------- | ----------------------------------- | -----------------
+- | ----------------- | | [YOLOv8n](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8n-oiv7.pt) | 640 | 18.4 | 142.4 | 1.21 | 3.5 |
+10.5 | | [YOLOv8s](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8s-oiv7.pt) | 640 | 27.7 | 183.1 | 1.40 | 11.4 | 29.7 | | [YOLOv8m]
+(https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-
+oiv7.pt) | 640 | 33.6 | 408.5 | 2.26 | 26.2 | 80.6 | | [YOLOv8l](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-oiv7.pt) | 640 |
+34.9 | 596.9 | 2.43 | 44.1 | 167.4 | | [YOLOv8x](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8x-oiv7.pt) | 640 | 36.3 |
+860.6 | 3.56 | 68.7 | 260.6 | - **mAPval** values are for single-model single-
+scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-
+images-v7/) dataset.
+Reproduce by `yolo val detect data=open-images-v7.yaml device=0` - **Speed**
+averaged over Open Image V7 val images using an [Amazon EC2 P4d](https://
+aws.amazon.com/ec2/instance-types/p4/) instance.
+Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
+Segmentation (COCO) See [Segmentation Docs](https://docs.ultralytics.com/tasks/
+segment/) for usage examples with these models trained on [COCO-Seg](https://
+docs.ultralytics.com/datasets/segment/coco/), which include 80 pre-trained
+classes. | Model | size
+(pixels) | mAPbox
 50-95 | mAPmask
-50-95 | 
+50-95 | Speed
 CPU ONNX
-(ms) | 
+(ms) | Speed
 A100 TensorRT
-(ms) | 
+(ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
---------------------- | --------------- | -------------------- | --------------
-------- | --------------------------- | -------------------------------- | ----
----------- | ----------------- | | [YOLOv8n-seg](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8n-seg.pt) | 640 | 36.7 | 30.5
-| 96.1 | 1.21 | 3.4 | 12.6 | | [YOLOv8s-seg](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8s-seg.pt) | 640 | 44.6 | 36.8 | 155.7 |
-1.47 | 11.8 | 42.6 | | [YOLOv8m-seg](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8m-seg.pt) | 640 | 49.9 | 40.8 | 317.0 | 2.18 |
-27.3 | 110.2 | | [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8l-seg.pt) | 640 | 52.3 | 42.6 | 572.4 | 2.79 | 46.0 |
-220.5 | | [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8x-seg.pt) | 640 | 53.4 | 43.4 | 712.1 | 4.02 | 71.8 |
-344.1 | - **mAPval**  [COCO val2017](http://
-cocodataset.org) 
- `yolo val segment data=coco-seg.yaml device=0`  - ****
- [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/
-)  COCO val 
- `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu`  
-(COCO) [](https://docs.ultralytics.com/tasks/pose/
-)[COCO-Pose](https://docs.ultralytics.com/datasets/pose/coco/
-)1
-|  | 
-() | mAPpose
+--------------------- | --------------------- | -------------------- | --------
+------------- | ------------------------------ | ------------------------------
+----- | ------------------ | ----------------- | | [YOLOv8n-seg](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-seg.pt) | 640 |
+36.7 | 30.5 | 96.1 | 1.21 | 3.4 | 12.6 | | [YOLOv8s-seg](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8s-seg.pt) | 640 | 44.6 | 36.8
+| 155.7 | 1.47 | 11.8 | 42.6 | | [YOLOv8m-seg](https://github.com/ultralytics/
+assets/releases/download/v8.1.0/yolov8m-seg.pt) | 640 | 49.9 | 40.8 | 317.0 |
+2.18 | 27.3 | 110.2 | | [YOLOv8l-seg](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8l-seg.pt) | 640 | 52.3 | 42.6 | 572.4 | 2.79 |
+46.0 | 220.5 | | [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/
+download/v8.1.0/yolov8x-seg.pt) | 640 | 53.4 | 43.4 | 712.1 | 4.02 | 71.8 |
+344.1 | - **mAPval** values are for single-model single-scale on [COCO val2017]
+(https://cocodataset.org) dataset.
+Reproduce by `yolo val segment data=coco-seg.yaml device=0` - **Speed**
+averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/
+ec2/instance-types/p4/) instance.
+Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu` Pose
+(COCO) See [Pose Docs](https://docs.ultralytics.com/tasks/pose/) for usage
+examples with these models trained on [COCO-Pose](https://docs.ultralytics.com/
+datasets/pose/coco/), which include 1 pre-trained class, person. | Model | size
+(pixels) | mAPpose
 50-95 | mAPpose
-50 | 
+50 | Speed
 CPU ONNX
-(ms) | 
+(ms) | Speed
 A100 TensorRT
-(ms) | 
+(ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
------------------------------ | --------------- | --------------------- | -----
-------------- | --------------------------- | -------------------------------
-- | -------------- | ----------------- | | [YOLOv8n-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8n-pose.pt) | 640 | 50.4 |
-80.1 | 131.8 | 1.18 | 3.3 | 9.2 | | [YOLOv8s-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-pose.pt) | 640 | 60.0 |
+----------------------------- | --------------------- | --------------------- |
+------------------ | ------------------------------ | -------------------------
+---------- | ------------------ | ----------------- | | [YOLOv8n-pose](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-pose.pt) | 640 |
+50.4 | 80.1 | 131.8 | 1.18 | 3.3 | 9.2 | | [YOLOv8s-pose](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8s-pose.pt) | 640 | 60.0 |
 86.2 | 233.2 | 1.42 | 11.6 | 30.2 | | [YOLOv8m-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8m-pose.pt) | 640 | 65.0 |
+ultralytics/assets/releases/download/v8.1.0/yolov8m-pose.pt) | 640 | 65.0 |
 88.8 | 456.3 | 2.00 | 26.4 | 81.0 | | [YOLOv8l-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8l-pose.pt) | 640 | 67.6 |
+ultralytics/assets/releases/download/v8.1.0/yolov8l-pose.pt) | 640 | 67.6 |
 90.0 | 784.5 | 2.59 | 44.4 | 168.6 | | [YOLOv8x-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-pose.pt) | 640 | 69.2 |
+ultralytics/assets/releases/download/v8.1.0/yolov8x-pose.pt) | 640 | 69.2 |
 90.2 | 1607.1 | 3.73 | 69.4 | 263.2 | | [YOLOv8x-pose-p6](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-pose-p6.pt) | 1280 | 71.6 |
-91.2 | 4088.7 | 10.04 | 99.1 | 1066.4 | - **mAPval**
- [COCO Keypoints val2017](http://
-cocodataset.org) 
- `yolo val pose data=coco-pose.yaml device=0`  - ****
- [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/
-)  COCO val 
- `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`  
-(ImageNet) [](https://docs.ultralytics.com/tasks/classify/
-)[ImageNet](https://docs.ultralytics.com/datasets/classify/
-imagenet/
-)1000 |
- | 
-() | acc
+ultralytics/assets/releases/download/v8.1.0/yolov8x-pose-p6.pt) | 1280 | 71.6 |
+91.2 | 4088.7 | 10.04 | 99.1 | 1066.4 | - **mAPval** values are for single-
+model single-scale on [COCO Keypoints val2017](https://cocodataset.org)
+dataset.
+Reproduce by `yolo val pose data=coco-pose.yaml device=0` - **Speed** averaged
+over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/
+instance-types/p4/) instance.
+Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu` OBB
+(DOTAv1) See [OBB Docs](https://docs.ultralytics.com/tasks/obb/) for usage
+examples with these models trained on [DOTAv1](https://docs.ultralytics.com/
+datasets/obb/dota-v2/#dota-v10/), which include 15 pre-trained classes. | Model
+| size
+(pixels) | mAPtest
+50 | Speed
+CPU ONNX
+(ms) | Speed
+A100 TensorRT
+(ms) | params
+(M) | FLOPs
+(B) | | -----------------------------------------------------------------------
+--------------------- | --------------------- | ------------------ | ----------
+-------------------- | ----------------------------------- | -----------------
+- | ----------------- | | [YOLOv8n-obb](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8n-obb.pt) | 1024 | 78.0 | 204.77 | 3.57 | 3.1 |
+23.3 | | [YOLOv8s-obb](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8s-obb.pt) | 1024 | 79.5 | 424.88 | 4.07 | 11.4 | 76.3 | |
+[YOLOv8m-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/
+yolov8m-obb.pt) | 1024 | 80.5 | 763.48 | 7.61 | 26.4 | 208.6 | | [YOLOv8l-obb]
+(https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-obb.pt)
+| 1024 | 80.7 | 1278.42 | 11.83 | 44.5 | 433.8 | | [YOLOv8x-obb](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-obb.pt) | 1024 |
+81.36 | 1759.10 | 13.23 | 69.5 | 676.7 | - **mAPtest** values are for single-
+model multiscale on [DOTAv1](https://captain-whu.github.io/DOTA/index.html)
+dataset.
+Reproduce by `yolo val obb data=DOTAv1.yaml device=0 split=test` and submit
+merged results to [DOTA evaluation](https://captain-whu.github.io/DOTA/
+evaluation.html). - **Speed** averaged over DOTAv1 val images using an [Amazon
+EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
+Reproduce by `yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu`
+Classification (ImageNet) See [Classification Docs](https://
+docs.ultralytics.com/tasks/classify/) for usage examples with these models
+trained on [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/
+), which include 1000 pretrained classes. | Model | size
+(pixels) | acc
 top1 | acc
-top5 | 
+top5 | Speed
 CPU ONNX
-(ms) | 
+(ms) | Speed
 A100 TensorRT
-(ms) | 
+(ms) | params
 (M) | FLOPs
 (B) at 640 | | ----------------------------------------------------------------
----------------------------- | --------------- | ---------------- | -----------
------ | --------------------------- | -------------------------------- | ------
--------- | ------------------------ | | [YOLOv8n-cls](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8n-cls.pt) | 224 | 66.6 | 87.0
-| 12.9 | 0.31 | 2.7 | 4.3 | | [YOLOv8s-cls](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8s-cls.pt) | 224 | 72.3 | 91.1 | 23.4 |
-0.35 | 6.4 | 13.5 | | [YOLOv8m-cls](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8m-cls.pt) | 224 | 76.4 | 93.2 | 85.4 | 0.62 |
-17.0 | 42.7 | | [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8l-cls.pt) | 224 | 78.0 | 94.1 | 163.0 | 0.87 | 37.5 |
-99.7 | | [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8x-cls.pt) | 224 | 78.4 | 94.3 | 232.0 | 1.01 | 57.4 | 154.8 | -
-**acc**  [ImageNet](https://www.image-net.org/
-) 
- `yolo val classify data=path/to/ImageNet device=0`  - ****
- [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/
-)  ImageNet val 
- `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu`  ##
-                                    
-AIUltralyticsUltralytics
-[Roboflow](https://roboflow.com/?ref=ultralytics)ClearML[Comet](https://
-bit.ly/yolov8-readme-comet)Neural Magic[OpenVINO](https://
-docs.ultralytics.com/integrations/
-openvino)AI
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_y_o_l_o_v_8_/_b_a_n_n_e_r_-_i_n_t_e_g_r_a_t_i_o_n_s_._p_n_g_]
+---------------------------- | --------------------- | ---------------- | -----
+----------- | ------------------------------ | --------------------------------
+--- | ------------------ | ------------------------ | | [YOLOv8n-cls](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-cls.pt) | 224 |
+69.0 | 88.3 | 12.9 | 0.31 | 2.7 | 4.3 | | [YOLOv8s-cls](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8s-cls.pt) | 224 | 73.8 | 91.7
+| 23.4 | 0.35 | 6.4 | 13.5 | | [YOLOv8m-cls](https://github.com/ultralytics/
+assets/releases/download/v8.1.0/yolov8m-cls.pt) | 224 | 76.8 | 93.5 | 85.4 |
+0.62 | 17.0 | 42.7 | | [YOLOv8l-cls](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8l-cls.pt) | 224 | 76.8 | 93.5 | 163.0 | 0.87 |
+37.5 | 99.7 | | [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/
+download/v8.1.0/yolov8x-cls.pt) | 224 | 79.0 | 94.6 | 232.0 | 1.01 | 57.4 |
+154.8 | - **acc** values are model accuracies on the [ImageNet](https://
+www.image-net.org/) dataset validation set.
+Reproduce by `yolo val classify data=path/to/ImageNet device=0` - **Speed**
+averaged over ImageNet val images using an [Amazon EC2 P4d](https://
+aws.amazon.com/ec2/instance-types/p4/) instance.
+Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu` ##
+                                 Integrations
+Our key integrations with leading AI platforms extend the functionality of
+Ultralytics' offerings, enhancing tasks like dataset labeling, training,
+visualization, and model management. Discover how Ultralytics, in collaboration
+with [Roboflow](https://roboflow.com/?ref=ultralytics), ClearML, [Comet](https:
+//bit.ly/yolov8-readme-comet), Neural Magic and [OpenVINO](https://
+docs.ultralytics.com/integrations/openvino), can optimize your AI workflow.
+_[_U_l_t_r_a_l_y_t_i_c_s_ _a_c_t_i_v_e_ _l_e_a_r_n_i_n_g_ _i_n_t_e_g_r_a_t_i_o_n_s_]
 
-  _[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_r_o_b_o_f_l_o_w_._p_n_g_]
-  _[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_c_l_e_a_r_m_l_._p_n_g_]
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_c_o_m_e_t_._p_n_g_]_[_h_t_t_p_s_:
-    _/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_n_e_u_r_a_l_m_a_g_i_c_._p_n_g_]
+ _[_R_o_b_o_f_l_o_w_ _l_o_g_o_][space]_[_C_l_e_a_r_M_L_ _l_o_g_o_][space]_[_C_o_m_e_t_ _M_L_ _l_o_g_o_][space]_[_N_e_u_r_a_l_M_a_g_i_c
+                                     _l_o_g_o_]
 | Roboflow | ClearML  NEW | Comet  NEW | Neural Magic  NEW | | :------
---------------------------------------------------------------------------: | :
-----------------------------------------------------------------------------: |
-:------------------------------------------------------------------------------
-----: | :----------------------------------------------------------------------
--------------: | |  [Roboflow](https://roboflow.com/?ref=ultralytics)
- YOLOv8  |
- [ClearML](https://cutt.ly/yolov5-readme-
-clearml) YOLOv8 |
-[Comet](https://bit.ly/yolov8-readme-comet) 
-YOLOv8  |
- [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic)  YOLOv8
- 6  | ##
+-------------------------------------------------------------------------------
+-------------------------------------: | :-------------------------------------
+------------------------------------------------------------------------: | :--
+-------------------------------------------------------------------------------
+----------------------------------------------------------------------: | :----
+-------------------------------------------------------------------------------
+-----------------: | | Label and export your custom datasets directly to YOLOv8
+for training with [Roboflow](https://roboflow.com/?ref=ultralytics) |
+Automatically track, visualize and even remotely train YOLOv8 using [ClearML]
+(https://clear.ml/) (open-source!) | Free forever, [Comet](https://bit.ly/
+yolov8-readme-comet) lets you save YOLOv8 models, resume training, and
+interactively visualize and debug predictions | Run YOLOv8 inference up to 6x
+faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) | ##
                                 Ultralytics HUB
- [Ultralytics HUB](https://bit.ly/ultralytics_hub)  
-AIYOLOv5
- YOLOv8 
-
-[Ultralytics ](https://ultralytics.com/
-app_install) AI
-**** _[_U_l_t_r_a_l_y_t_i_c_s_ _H_U_B_ _p_r_e_v_i_e_w
-_i_m_a_g_e_]##
-                                    
-YOLOv5  YOLOv8
-[](https://
-docs.ultralytics.com/help/contributing)
-[](https://ultralytics.com/
-survey?utm_source=github&utm_medium=social&utm_campaign=Survey)
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_i_m_/_i_m_a_g_e_-_c_o_n_t_r_i_b_u_t_o_r_s_._p_n_g_]##
-                                   
-Ultralytics  - **AGPL-
-3.0 **[OSI ](https://opensource.org/licenses/
-)
-[LICENSE](https://github.com/ultralytics/ultralytics/blob/main/LICENSE)
- -
-****
-Ultralytics  AI
- AGPL-3.0
-
-[Ultralytics Licensing](https://ultralytics.com/license) ##
-                                 
- Ultralytics  [GitHub Issues]
-(https://github.com/ultralytics/ultralytics/issues)
-[Discord](https://ultralytics.com/discord) 
-  _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][https://github.com/ultralytics/assets/raw/main/social/
-  logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][https://github.com/ultralytics/
-  assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_][https://
-github.com/ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s
-     _Y_o_u_T_u_b_e_][https://github.com/ultralytics/assets/raw/main/social/logo-
-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][https://github.com/ultralytics/assets/raw/
- main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _I_n_s_t_a_g_r_a_m_][https://github.com/
- ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
+Experience seamless AI with [Ultralytics HUB](https://bit.ly/ultralytics_hub)
+, the all-in-one solution for data visualization, YOLOv5 and YOLOv8 
+model training and deployment, without any coding. Transform images into
+actionable insights and bring your AI visions to life with ease using our
+cutting-edge platform and user-friendly [Ultralytics App](https://
+ultralytics.com/app_install). Start your journey for **Free** now! _[_U_l_t_r_a_l_y_t_i_c_s
+_H_U_B_ _p_r_e_v_i_e_w_ _i_m_a_g_e_]##
+                                  Contribute
+We love your input! YOLOv5 and YOLOv8 would not be possible without help from
+our community. Please see our [Contributing Guide](https://
+docs.ultralytics.com/help/contributing) to get started, and fill out our
+[Survey](https://ultralytics.com/
+survey?utm_source=github&utm_medium=social&utm_campaign=Survey) to send us
+feedback on your experience. Thank you  to all our contributors!
+_[_U_l_t_r_a_l_y_t_i_c_s_ _o_p_e_n_-_s_o_u_r_c_e_ _c_o_n_t_r_i_b_u_t_o_r_s_]##
+                                    License
+Ultralytics offers two licensing options to accommodate diverse use cases: -
+**AGPL-3.0 License**: This [OSI-approved](https://opensource.org/licenses/
+) open-source license is ideal for students and enthusiasts, promoting open
+collaboration and knowledge sharing. See the [LICENSE](https://github.com/
+ultralytics/ultralytics/blob/main/LICENSE) file for more details. -
+**Enterprise License**: Designed for commercial use, this license permits
+seamless integration of Ultralytics software and AI models into commercial
+goods and services, bypassing the open-source requirements of AGPL-3.0. If your
+scenario involves embedding our solutions into a commercial offering, reach out
+through [Ultralytics Licensing](https://ultralytics.com/license). ##
+                                    Contact
+For Ultralytics bug reports and feature requests please visit [GitHub Issues]
+(https://github.com/ultralytics/ultralytics/issues), and join our [Discord]
+(https://ultralytics.com/discord) community for questions and discussions!
+ _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_]
+  [space]_[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_T_u_b_e_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][space]_[_U_l_t_r_a_l_y_t_i_c_s
+                    _I_n_s_t_a_g_r_a_m_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
```

### Comparing `yolov8-pose-triton-8.1.0/tests/conftest.py` & `yolov8_pose_triton-8.2.0/tests/conftest.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,59 +1,36 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import shutil
 from pathlib import Path
 
-import pytest
-
-TMP = Path(__file__).resolve().parent / 'tmp'  # temp directory for test files
+TMP = Path(__file__).resolve().parent / "tmp"  # temp directory for test files
 
 
 def pytest_addoption(parser):
     """
     Add custom command-line options to pytest.
 
     Args:
         parser (pytest.config.Parser): The pytest parser object.
     """
-    parser.addoption('--slow', action='store_true', default=False, help='Run slow tests')
-
-
-def pytest_configure(config):
-    """
-    Register custom markers to avoid pytest warnings.
-
-    Args:
-        config (pytest.config.Config): The pytest config object.
-    """
-    config.addinivalue_line('markers', 'slow: mark test as slow to run')
-
-
-def pytest_runtest_setup(item):
-    """
-    Setup hook to skip tests marked as slow if the --slow option is not provided.
-
-    Args:
-        item (pytest.Item): The test item object.
-    """
-    if 'slow' in item.keywords and not item.config.getoption('--slow'):
-        pytest.skip('skip slow tests unless --slow is set')
+    parser.addoption("--slow", action="store_true", default=False, help="Run slow tests")
 
 
 def pytest_collection_modifyitems(config, items):
     """
     Modify the list of test items to remove tests marked as slow if the --slow option is not provided.
 
     Args:
         config (pytest.config.Config): The pytest config object.
         items (list): List of test items to be executed.
     """
-    if not config.getoption('--slow'):
+    if not config.getoption("--slow"):
         # Remove the item entirely from the list of test items if it's marked as 'slow'
-        items[:] = [item for item in items if 'slow' not in item.keywords]
+        items[:] = [item for item in items if "slow" not in item.keywords]
 
 
 def pytest_sessionstart(session):
     """
     Initialize session configurations for pytest.
 
     This function is automatically called by pytest after the 'Session' object has been created but before performing
@@ -80,15 +57,15 @@
         terminalreporter (pytest.terminal.TerminalReporter): The terminal reporter object.
         exitstatus (int): The exit status of the test run.
         config (pytest.config.Config): The pytest config object.
     """
     from ultralytics.utils import WEIGHTS_DIR
 
     # Remove files
-    models = [path for x in ['*.onnx', '*.torchscript'] for path in WEIGHTS_DIR.rglob(x)]
-    for file in ['bus.jpg', 'yolov8n.onnx', 'yolov8n.torchscript'] + models:
+    models = [path for x in ["*.onnx", "*.torchscript"] for path in WEIGHTS_DIR.rglob(x)]
+    for file in ["bus.jpg", "yolov8n.onnx", "yolov8n.torchscript"] + models:
         Path(file).unlink(missing_ok=True)
 
     # Remove directories
-    models = [path for x in ['*.mlpackage', '*_openvino_model'] for path in WEIGHTS_DIR.rglob(x)]
-    for directory in [TMP.parents[1] / '.pytest_cache', TMP] + models:
+    models = [path for x in ["*.mlpackage", "*_openvino_model"] for path in WEIGHTS_DIR.rglob(x)]
+    for directory in [TMP.parents[1] / ".pytest_cache", TMP] + models:
         shutil.rmtree(directory, ignore_errors=True)
```

### Comparing `yolov8-pose-triton-8.1.0/tests/test_cli.py` & `yolov8_pose_triton-8.2.0/tests/test_cli.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,134 +1,138 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import subprocess
 
 import pytest
 
-from ultralytics.utils import ASSETS, WEIGHTS_DIR
-from ultralytics.utils.checks import cuda_device_count, cuda_is_available
+from ultralytics.utils import ASSETS, WEIGHTS_DIR, checks
 
-CUDA_IS_AVAILABLE = cuda_is_available()
-CUDA_DEVICE_COUNT = cuda_device_count()
+CUDA_IS_AVAILABLE = checks.cuda_is_available()
+CUDA_DEVICE_COUNT = checks.cuda_device_count()
 TASK_ARGS = [
-    ('detect', 'yolov8n', 'coco8.yaml'),
-    ('segment', 'yolov8n-seg', 'coco8-seg.yaml'),
-    ('classify', 'yolov8n-cls', 'imagenet10'),
-    ('pose', 'yolov8n-pose', 'coco8-pose.yaml'), ]  # (task, model, data)
+    ("detect", "yolov8n", "coco8.yaml"),
+    ("segment", "yolov8n-seg", "coco8-seg.yaml"),
+    ("classify", "yolov8n-cls", "imagenet10"),
+    ("pose", "yolov8n-pose", "coco8-pose.yaml"),
+    ("obb", "yolov8n-obb", "dota8.yaml"),
+]  # (task, model, data)
 EXPORT_ARGS = [
-    ('yolov8n', 'torchscript'),
-    ('yolov8n-seg', 'torchscript'),
-    ('yolov8n-cls', 'torchscript'),
-    ('yolov8n-pose', 'torchscript'), ]  # (model, format)
+    ("yolov8n", "torchscript"),
+    ("yolov8n-seg", "torchscript"),
+    ("yolov8n-cls", "torchscript"),
+    ("yolov8n-pose", "torchscript"),
+    ("yolov8n-obb", "torchscript"),
+]  # (model, format)
 
 
 def run(cmd):
     """Execute a shell command using subprocess."""
     subprocess.run(cmd.split(), check=True)
 
 
 def test_special_modes():
     """Test various special command modes of YOLO."""
-    run('yolo help')
-    run('yolo checks')
-    run('yolo version')
-    run('yolo settings reset')
-    run('yolo cfg')
+    run("yolo help")
+    run("yolo checks")
+    run("yolo version")
+    run("yolo settings reset")
+    run("yolo cfg")
 
 
-@pytest.mark.parametrize('task,model,data', TASK_ARGS)
+@pytest.mark.parametrize("task,model,data", TASK_ARGS)
 def test_train(task, model, data):
     """Test YOLO training for a given task, model, and data."""
-    run(f'yolo train {task} model={model}.yaml data={data} imgsz=32 epochs=1 cache=disk')
+    run(f"yolo train {task} model={model}.yaml data={data} imgsz=32 epochs=1 cache=disk")
 
 
-@pytest.mark.parametrize('task,model,data', TASK_ARGS)
+@pytest.mark.parametrize("task,model,data", TASK_ARGS)
 def test_val(task, model, data):
     """Test YOLO validation for a given task, model, and data."""
-    run(f'yolo val {task} model={WEIGHTS_DIR / model}.pt data={data} imgsz=32 save_txt save_json')
+    run(f"yolo val {task} model={WEIGHTS_DIR / model}.pt data={data} imgsz=32 save_txt save_json")
 
 
-@pytest.mark.parametrize('task,model,data', TASK_ARGS)
+@pytest.mark.parametrize("task,model,data", TASK_ARGS)
 def test_predict(task, model, data):
     """Test YOLO prediction on sample assets for a given task and model."""
-    run(f'yolo predict model={WEIGHTS_DIR / model}.pt source={ASSETS} imgsz=32 save save_crop save_txt')
+    run(f"yolo predict model={WEIGHTS_DIR / model}.pt source={ASSETS} imgsz=32 save save_crop save_txt")
 
 
-@pytest.mark.parametrize('model,format', EXPORT_ARGS)
+@pytest.mark.parametrize("model,format", EXPORT_ARGS)
 def test_export(model, format):
     """Test exporting a YOLO model to different formats."""
-    run(f'yolo export model={WEIGHTS_DIR / model}.pt format={format} imgsz=32')
+    run(f"yolo export model={WEIGHTS_DIR / model}.pt format={format} imgsz=32")
 
 
-def test_rtdetr(task='detect', model='yolov8n-rtdetr.yaml', data='coco8.yaml'):
+def test_rtdetr(task="detect", model="yolov8n-rtdetr.yaml", data="coco8.yaml"):
     """Test the RTDETR functionality with the Ultralytics framework."""
     # Warning: MUST use imgsz=640
-    run(f'yolo train {task} model={model} data={data} --imgsz= 640 epochs =1, cache = disk')  # add coma, spaces to args
-    run(f"yolo predict {task} model={model} source={ASSETS / 'bus.jpg'} imgsz=640 save save_crop save_txt")
+    run(f"yolo train {task} model={model} data={data} --imgsz= 160 epochs =1, cache = disk")  # add coma, spaces to args
+    run(f"yolo predict {task} model={model} source={ASSETS / 'bus.jpg'} imgsz=160 save save_crop save_txt")
 
 
-def test_fastsam(task='segment', model=WEIGHTS_DIR / 'FastSAM-s.pt', data='coco8-seg.yaml'):
+@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason="MobileSAM with CLIP is not supported in Python 3.12")
+def test_fastsam(task="segment", model=WEIGHTS_DIR / "FastSAM-s.pt", data="coco8-seg.yaml"):
     """Test FastSAM segmentation functionality within Ultralytics."""
-    source = ASSETS / 'bus.jpg'
+    source = ASSETS / "bus.jpg"
 
-    run(f'yolo segment val {task} model={model} data={data} imgsz=32')
-    run(f'yolo segment predict model={model} source={source} imgsz=32 save save_crop save_txt')
+    run(f"yolo segment val {task} model={model} data={data} imgsz=32")
+    run(f"yolo segment predict model={model} source={source} imgsz=32 save save_crop save_txt")
 
     from ultralytics import FastSAM
     from ultralytics.models.fastsam import FastSAMPrompt
     from ultralytics.models.sam import Predictor
 
     # Create a FastSAM model
     sam_model = FastSAM(model)  # or FastSAM-x.pt
 
     # Run inference on an image
-    everything_results = sam_model(source, device='cpu', retina_masks=True, imgsz=1024, conf=0.4, iou=0.9)
+    everything_results = sam_model(source, device="cpu", retina_masks=True, imgsz=1024, conf=0.4, iou=0.9)
 
     # Remove small regions
     new_masks, _ = Predictor.remove_small_regions(everything_results[0].masks.data, min_area=20)
 
     # Everything prompt
-    prompt_process = FastSAMPrompt(source, everything_results, device='cpu')
+    prompt_process = FastSAMPrompt(source, everything_results, device="cpu")
     ann = prompt_process.everything_prompt()
 
     # Bbox default shape [0,0,0,0] -> [x1,y1,x2,y2]
     ann = prompt_process.box_prompt(bbox=[200, 200, 300, 300])
 
     # Text prompt
-    ann = prompt_process.text_prompt(text='a photo of a dog')
+    ann = prompt_process.text_prompt(text="a photo of a dog")
 
     # Point prompt
     # Points default [[0,0]] [[x1,y1],[x2,y2]]
     # Point_label default [0] [1,0] 0:background, 1:foreground
     ann = prompt_process.point_prompt(points=[[200, 200]], pointlabel=[1])
-    prompt_process.plot(annotations=ann, output='./')
+    prompt_process.plot(annotations=ann, output="./")
 
 
 def test_mobilesam():
     """Test MobileSAM segmentation functionality using Ultralytics."""
     from ultralytics import SAM
 
     # Load the model
-    model = SAM(WEIGHTS_DIR / 'mobile_sam.pt')
+    model = SAM(WEIGHTS_DIR / "mobile_sam.pt")
 
     # Source
-    source = ASSETS / 'zidane.jpg'
+    source = ASSETS / "zidane.jpg"
 
     # Predict a segment based on a point prompt
     model.predict(source, points=[900, 370], labels=[1])
 
     # Predict a segment based on a box prompt
     model.predict(source, bboxes=[439, 437, 524, 709])
 
     # Predict all
     # model(source)
 
 
 # Slow Tests -----------------------------------------------------------------------------------------------------------
 @pytest.mark.slow
-@pytest.mark.parametrize('task,model,data', TASK_ARGS)
-@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason='CUDA is not available')
-@pytest.mark.skipif(CUDA_DEVICE_COUNT < 2, reason='DDP is not available')
+@pytest.mark.parametrize("task,model,data", TASK_ARGS)
+@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason="CUDA is not available")
+@pytest.mark.skipif(CUDA_DEVICE_COUNT < 2, reason="DDP is not available")
 def test_train_gpu(task, model, data):
     """Test YOLO training on GPU(s) for various tasks and models."""
-    run(f'yolo train {task} model={model}.yaml data={data} imgsz=32 epochs=1 device=0')  # single GPU
-    run(f'yolo train {task} model={model}.pt data={data} imgsz=32 epochs=1 device=0,1')  # multi GPU
+    run(f"yolo train {task} model={model}.yaml data={data} imgsz=32 epochs=1 device=0")  # single GPU
+    run(f"yolo train {task} model={model}.pt data={data} imgsz=32 epochs=1 device=0,1")  # multi GPU
```

### Comparing `yolov8-pose-triton-8.1.0/tests/test_cuda.py` & `yolov8_pose_triton-8.2.0/tests/test_cuda.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,101 +5,109 @@
 
 from ultralytics import YOLO
 from ultralytics.utils import ASSETS, WEIGHTS_DIR, checks
 
 CUDA_IS_AVAILABLE = checks.cuda_is_available()
 CUDA_DEVICE_COUNT = checks.cuda_device_count()
 
-MODEL = WEIGHTS_DIR / 'path with spaces' / 'yolov8n.pt'  # test spaces in path
-DATA = 'coco8.yaml'
-BUS = ASSETS / 'bus.jpg'
+MODEL = WEIGHTS_DIR / "path with spaces" / "yolov8n.pt"  # test spaces in path
+DATA = "coco8.yaml"
+BUS = ASSETS / "bus.jpg"
 
 
 def test_checks():
     """Validate CUDA settings against torch CUDA functions."""
     assert torch.cuda.is_available() == CUDA_IS_AVAILABLE
     assert torch.cuda.device_count() == CUDA_DEVICE_COUNT
 
+@pytest.mark.slow
+@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason="CUDA is not available")
+def test_export_engine():
+    """Test exporting the YOLO model to NVIDIA TensorRT format."""
+    f = YOLO(MODEL).export(format="engine", device=0)
+    YOLO(f)(BUS, device=0)
+
 
-@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason='CUDA is not available')
+@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason="CUDA is not available")
 def test_train():
     """Test model training on a minimal dataset."""
     device = 0 if CUDA_DEVICE_COUNT == 1 else [0, 1]
     YOLO(MODEL).train(data=DATA, imgsz=64, epochs=1, device=device)  # requires imgsz>=64
 
 
 @pytest.mark.slow
-@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason='CUDA is not available')
+@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason="CUDA is not available")
 def test_predict_multiple_devices():
     """Validate model prediction on multiple devices."""
-    model = YOLO('yolov8n.pt')
+    model = YOLO("yolov8n.pt")
     model = model.cpu()
-    assert str(model.device) == 'cpu'
+    assert str(model.device) == "cpu"
     _ = model(BUS)  # CPU inference
-    assert str(model.device) == 'cpu'
+    assert str(model.device) == "cpu"
 
-    model = model.to('cuda:0')
-    assert str(model.device) == 'cuda:0'
+    model = model.to("cuda:0")
+    assert str(model.device) == "cuda:0"
     _ = model(BUS)  # CUDA inference
-    assert str(model.device) == 'cuda:0'
+    assert str(model.device) == "cuda:0"
 
     model = model.cpu()
-    assert str(model.device) == 'cpu'
+    assert str(model.device) == "cpu"
     _ = model(BUS)  # CPU inference
-    assert str(model.device) == 'cpu'
+    assert str(model.device) == "cpu"
 
     model = model.cuda()
-    assert str(model.device) == 'cuda:0'
+    assert str(model.device) == "cuda:0"
     _ = model(BUS)  # CUDA inference
-    assert str(model.device) == 'cuda:0'
+    assert str(model.device) == "cuda:0"
 
 
-@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason='CUDA is not available')
+@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason="CUDA is not available")
 def test_autobatch():
     """Check batch size for YOLO model using autobatch."""
     from ultralytics.utils.autobatch import check_train_batch_size
 
     check_train_batch_size(YOLO(MODEL).model.cuda(), imgsz=128, amp=True)
 
 
-@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason='CUDA is not available')
+@pytest.mark.slow
+@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason="CUDA is not available")
 def test_utils_benchmarks():
     """Profile YOLO models for performance benchmarks."""
     from ultralytics.utils.benchmarks import ProfileModels
 
     # Pre-export a dynamic engine model to use dynamic inference
-    YOLO(MODEL).export(format='engine', imgsz=32, dynamic=True, batch=1)
+    YOLO(MODEL).export(format="engine", imgsz=32, dynamic=True, batch=1)
     ProfileModels([MODEL], imgsz=32, half=False, min_time=1, num_timed_runs=3, num_warmup_runs=1).profile()
 
 
-@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason='CUDA is not available')
+@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason="CUDA is not available")
 def test_predict_sam():
     """Test SAM model prediction with various prompts."""
     from ultralytics import SAM
     from ultralytics.models.sam import Predictor as SAMPredictor
 
     # Load a model
-    model = SAM(WEIGHTS_DIR / 'sam_b.pt')
+    model = SAM(WEIGHTS_DIR / "sam_b.pt")
 
     # Display model information (optional)
     model.info()
 
     # Run inference
     model(BUS, device=0)
 
     # Run inference with bboxes prompt
     model(BUS, bboxes=[439, 437, 524, 709], device=0)
 
     # Run inference with points prompt
-    model(ASSETS / 'zidane.jpg', points=[900, 370], labels=[1], device=0)
+    model(ASSETS / "zidane.jpg", points=[900, 370], labels=[1], device=0)
 
     # Create SAMPredictor
-    overrides = dict(conf=0.25, task='segment', mode='predict', imgsz=1024, model=WEIGHTS_DIR / 'mobile_sam.pt')
+    overrides = dict(conf=0.25, task="segment", mode="predict", imgsz=1024, model=WEIGHTS_DIR / "mobile_sam.pt")
     predictor = SAMPredictor(overrides=overrides)
 
     # Set image
-    predictor.set_image(ASSETS / 'zidane.jpg')  # set with image file
+    predictor.set_image(ASSETS / "zidane.jpg")  # set with image file
     # predictor(bboxes=[439, 437, 524, 709])
     # predictor(points=[900, 370], labels=[1])
 
     # Reset image
     predictor.reset_image()
```

### Comparing `yolov8-pose-triton-8.1.0/tests/test_engine.py` & `yolov8_pose_triton-8.2.0/tests/test_engine.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,128 +1,133 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
+import sys
+from unittest import mock
+
 from ultralytics import YOLO
 from ultralytics.cfg import get_cfg
 from ultralytics.engine.exporter import Exporter
 from ultralytics.models.yolo import classify, detect, segment
 from ultralytics.utils import ASSETS, DEFAULT_CFG, WEIGHTS_DIR
 
-CFG_DET = 'yolov8n.yaml'
-CFG_SEG = 'yolov8n-seg.yaml'
-CFG_CLS = 'yolov8n-cls.yaml'  # or 'squeezenet1_0'
+CFG_DET = "yolov8n.yaml"
+CFG_SEG = "yolov8n-seg.yaml"
+CFG_CLS = "yolov8n-cls.yaml"  # or 'squeezenet1_0'
 CFG = get_cfg(DEFAULT_CFG)
-MODEL = WEIGHTS_DIR / 'yolov8n'
+MODEL = WEIGHTS_DIR / "yolov8n"
 
 
 def test_func(*args):  # noqa
     """Test function callback."""
-    print('callback test passed')
+    print("callback test passed")
 
 
 def test_export():
     """Test model exporting functionality."""
     exporter = Exporter()
-    exporter.add_callback('on_export_start', test_func)
-    assert test_func in exporter.callbacks['on_export_start'], 'callback test failed'
+    exporter.add_callback("on_export_start", test_func)
+    assert test_func in exporter.callbacks["on_export_start"], "callback test failed"
     f = exporter(model=YOLO(CFG_DET).model)
     YOLO(f)(ASSETS)  # exported model inference
 
 
 def test_detect():
     """Test object detection functionality."""
-    overrides = {'data': 'coco8.yaml', 'model': CFG_DET, 'imgsz': 32, 'epochs': 1, 'save': False}
-    CFG.data = 'coco8.yaml'
+    overrides = {"data": "coco8.yaml", "model": CFG_DET, "imgsz": 32, "epochs": 1, "save": False}
+    CFG.data = "coco8.yaml"
     CFG.imgsz = 32
 
     # Trainer
     trainer = detect.DetectionTrainer(overrides=overrides)
-    trainer.add_callback('on_train_start', test_func)
-    assert test_func in trainer.callbacks['on_train_start'], 'callback test failed'
+    trainer.add_callback("on_train_start", test_func)
+    assert test_func in trainer.callbacks["on_train_start"], "callback test failed"
     trainer.train()
 
     # Validator
     val = detect.DetectionValidator(args=CFG)
-    val.add_callback('on_val_start', test_func)
-    assert test_func in val.callbacks['on_val_start'], 'callback test failed'
+    val.add_callback("on_val_start", test_func)
+    assert test_func in val.callbacks["on_val_start"], "callback test failed"
     val(model=trainer.best)  # validate best.pt
 
     # Predictor
-    pred = detect.DetectionPredictor(overrides={'imgsz': [64, 64]})
-    pred.add_callback('on_predict_start', test_func)
-    assert test_func in pred.callbacks['on_predict_start'], 'callback test failed'
-    result = pred(source=ASSETS, model=f'{MODEL}.pt')
-    assert len(result), 'predictor test failed'
+    pred = detect.DetectionPredictor(overrides={"imgsz": [64, 64]})
+    pred.add_callback("on_predict_start", test_func)
+    assert test_func in pred.callbacks["on_predict_start"], "callback test failed"
+    # Confirm there is no issue with sys.argv being empty.
+    with mock.patch.object(sys, "argv", []):
+        result = pred(source=ASSETS, model=f"{MODEL}.pt")
+        assert len(result), "predictor test failed"
 
-    overrides['resume'] = trainer.last
+    overrides["resume"] = trainer.last
     trainer = detect.DetectionTrainer(overrides=overrides)
     try:
         trainer.train()
     except Exception as e:
-        print(f'Expected exception caught: {e}')
+        print(f"Expected exception caught: {e}")
         return
 
-    Exception('Resume test failed!')
+    Exception("Resume test failed!")
 
 
 def test_segment():
     """Test image segmentation functionality."""
-    overrides = {'data': 'coco8-seg.yaml', 'model': CFG_SEG, 'imgsz': 32, 'epochs': 1, 'save': False}
-    CFG.data = 'coco8-seg.yaml'
+    overrides = {"data": "coco8-seg.yaml", "model": CFG_SEG, "imgsz": 32, "epochs": 1, "save": False}
+    CFG.data = "coco8-seg.yaml"
     CFG.imgsz = 32
     # YOLO(CFG_SEG).train(**overrides)  # works
 
     # Trainer
     trainer = segment.SegmentationTrainer(overrides=overrides)
-    trainer.add_callback('on_train_start', test_func)
-    assert test_func in trainer.callbacks['on_train_start'], 'callback test failed'
+    trainer.add_callback("on_train_start", test_func)
+    assert test_func in trainer.callbacks["on_train_start"], "callback test failed"
     trainer.train()
 
     # Validator
     val = segment.SegmentationValidator(args=CFG)
-    val.add_callback('on_val_start', test_func)
-    assert test_func in val.callbacks['on_val_start'], 'callback test failed'
+    val.add_callback("on_val_start", test_func)
+    assert test_func in val.callbacks["on_val_start"], "callback test failed"
     val(model=trainer.best)  # validate best.pt
 
     # Predictor
-    pred = segment.SegmentationPredictor(overrides={'imgsz': [64, 64]})
-    pred.add_callback('on_predict_start', test_func)
-    assert test_func in pred.callbacks['on_predict_start'], 'callback test failed'
-    result = pred(source=ASSETS, model=f'{MODEL}-seg.pt')
-    assert len(result), 'predictor test failed'
+    pred = segment.SegmentationPredictor(overrides={"imgsz": [64, 64]})
+    pred.add_callback("on_predict_start", test_func)
+    assert test_func in pred.callbacks["on_predict_start"], "callback test failed"
+    result = pred(source=ASSETS, model=f"{MODEL}-seg.pt")
+    assert len(result), "predictor test failed"
 
     # Test resume
-    overrides['resume'] = trainer.last
+    overrides["resume"] = trainer.last
     trainer = segment.SegmentationTrainer(overrides=overrides)
     try:
         trainer.train()
     except Exception as e:
-        print(f'Expected exception caught: {e}')
+        print(f"Expected exception caught: {e}")
         return
 
-    Exception('Resume test failed!')
+    Exception("Resume test failed!")
 
 
 def test_classify():
     """Test image classification functionality."""
-    overrides = {'data': 'imagenet10', 'model': CFG_CLS, 'imgsz': 32, 'epochs': 1, 'save': False}
-    CFG.data = 'imagenet10'
+    overrides = {"data": "imagenet10", "model": CFG_CLS, "imgsz": 32, "epochs": 1, "save": False}
+    CFG.data = "imagenet10"
     CFG.imgsz = 32
     # YOLO(CFG_SEG).train(**overrides)  # works
 
     # Trainer
     trainer = classify.ClassificationTrainer(overrides=overrides)
-    trainer.add_callback('on_train_start', test_func)
-    assert test_func in trainer.callbacks['on_train_start'], 'callback test failed'
+    trainer.add_callback("on_train_start", test_func)
+    assert test_func in trainer.callbacks["on_train_start"], "callback test failed"
     trainer.train()
 
     # Validator
     val = classify.ClassificationValidator(args=CFG)
-    val.add_callback('on_val_start', test_func)
-    assert test_func in val.callbacks['on_val_start'], 'callback test failed'
+    val.add_callback("on_val_start", test_func)
+    assert test_func in val.callbacks["on_val_start"], "callback test failed"
     val(model=trainer.best)
 
     # Predictor
-    pred = classify.ClassificationPredictor(overrides={'imgsz': [64, 64]})
-    pred.add_callback('on_predict_start', test_func)
-    assert test_func in pred.callbacks['on_predict_start'], 'callback test failed'
+    pred = classify.ClassificationPredictor(overrides={"imgsz": [64, 64]})
+    pred.add_callback("on_predict_start", test_func)
+    assert test_func in pred.callbacks["on_predict_start"], "callback test failed"
     result = pred(source=ASSETS, model=trainer.best)
-    assert len(result), 'predictor test failed'
+    assert len(result), "predictor test failed"
```

### Comparing `yolov8-pose-triton-8.1.0/tests/test_integrations.py` & `yolov8_pose_triton-8.2.0/tests/test_integrations.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,113 +5,146 @@
 
 import pytest
 
 from ultralytics import YOLO, download
 from ultralytics.utils import ASSETS, DATASETS_DIR, ROOT, SETTINGS, WEIGHTS_DIR
 from ultralytics.utils.checks import check_requirements
 
-MODEL = WEIGHTS_DIR / 'path with spaces' / 'yolov8n.pt'  # test spaces in path
-CFG = 'yolov8n.yaml'
-SOURCE = ASSETS / 'bus.jpg'
-TMP = (ROOT / '../tests/tmp').resolve()  # temp directory for test files
+MODEL = WEIGHTS_DIR / "path with spaces" / "yolov8n.pt"  # test spaces in path
+CFG = "yolov8n.yaml"
+SOURCE = ASSETS / "bus.jpg"
+TMP = (ROOT / "../tests/tmp").resolve()  # temp directory for test files
 
 
-@pytest.mark.skipif(not check_requirements('ray', install=False), reason='ray[tune] not installed')
+@pytest.mark.skipif(not check_requirements("ray", install=False), reason="ray[tune] not installed")
 def test_model_ray_tune():
     """Tune YOLO model with Ray optimization library."""
-    YOLO('yolov8n-cls.yaml').tune(use_ray=True,
-                                  data='imagenet10',
-                                  grace_period=1,
-                                  iterations=1,
-                                  imgsz=32,
-                                  epochs=1,
-                                  plots=False,
-                                  device='cpu')
+    YOLO("yolov8n-cls.yaml").tune(
+        use_ray=True, data="imagenet10", grace_period=1, iterations=1, imgsz=32, epochs=1, plots=False, device="cpu"
+    )
 
 
-@pytest.mark.skipif(not check_requirements('mlflow', install=False), reason='mlflow not installed')
+@pytest.mark.skipif(not check_requirements("mlflow", install=False), reason="mlflow not installed")
 def test_mlflow():
     """Test training with MLflow tracking enabled."""
-    SETTINGS['mlflow'] = True
-    YOLO('yolov8n-cls.yaml').train(data='imagenet10', imgsz=32, epochs=3, plots=False, device='cpu')
+    SETTINGS["mlflow"] = True
+    YOLO("yolov8n-cls.yaml").train(data="imagenet10", imgsz=32, epochs=3, plots=False, device="cpu")
 
 
-@pytest.mark.skipif(not check_requirements('tritonclient', install=False), reason='tritonclient[all] not installed')
+@pytest.mark.skipif(True, reason="Test failing in scheduled CI https://github.com/ultralytics/ultralytics/pull/8868")
+@pytest.mark.skipif(not check_requirements("mlflow", install=False), reason="mlflow not installed")
+def test_mlflow_keep_run_active():
+    import os
+
+    import mlflow
+
+    """Test training with MLflow tracking enabled."""
+    SETTINGS["mlflow"] = True
+    run_name = "Test Run"
+    os.environ["MLFLOW_RUN"] = run_name
+
+    # Test with MLFLOW_KEEP_RUN_ACTIVE=True
+    os.environ["MLFLOW_KEEP_RUN_ACTIVE"] = "True"
+    YOLO("yolov8n-cls.yaml").train(data="imagenet10", imgsz=32, epochs=1, plots=False, device="cpu")
+    status = mlflow.active_run().info.status
+    assert status == "RUNNING", "MLflow run should be active when MLFLOW_KEEP_RUN_ACTIVE=True"
+
+    run_id = mlflow.active_run().info.run_id
+
+    # Test with MLFLOW_KEEP_RUN_ACTIVE=False
+    os.environ["MLFLOW_KEEP_RUN_ACTIVE"] = "False"
+    YOLO("yolov8n-cls.yaml").train(data="imagenet10", imgsz=32, epochs=1, plots=False, device="cpu")
+    status = mlflow.get_run(run_id=run_id).info.status
+    assert status == "FINISHED", "MLflow run should be ended when MLFLOW_KEEP_RUN_ACTIVE=False"
+
+    # Test with MLFLOW_KEEP_RUN_ACTIVE not set
+    os.environ.pop("MLFLOW_KEEP_RUN_ACTIVE", None)
+    YOLO("yolov8n-cls.yaml").train(data="imagenet10", imgsz=32, epochs=1, plots=False, device="cpu")
+    status = mlflow.get_run(run_id=run_id).info.status
+    assert status == "FINISHED", "MLflow run should be ended by default when MLFLOW_KEEP_RUN_ACTIVE is not set"
+
+
+@pytest.mark.skipif(not check_requirements("tritonclient", install=False), reason="tritonclient[all] not installed")
 def test_triton():
     """Test NVIDIA Triton Server functionalities."""
-    check_requirements('tritonclient[all]')
+    check_requirements("tritonclient[all]")
     import subprocess
     import time
 
     from tritonclient.http import InferenceServerClient  # noqa
 
     # Create variables
-    model_name = 'yolo'
-    triton_repo_path = TMP / 'triton_repo'
-    triton_model_path = triton_repo_path / model_name
+    model_name = "yolo"
+    triton_repo = TMP / "triton_repo"  # Triton repo path
+    triton_model = triton_repo / model_name  # Triton model path
 
     # Export model to ONNX
-    f = YOLO(MODEL).export(format='onnx', dynamic=True)
+    f = YOLO(MODEL).export(format="onnx", dynamic=True)
 
     # Prepare Triton repo
-    (triton_model_path / '1').mkdir(parents=True, exist_ok=True)
-    Path(f).rename(triton_model_path / '1' / 'model.onnx')
-    (triton_model_path / 'config.pbtxt').touch()
+    (triton_model / "1").mkdir(parents=True, exist_ok=True)
+    Path(f).rename(triton_model / "1" / "model.onnx")
+    (triton_model / "config.pbtxt").touch()
 
     # Define image https://catalog.ngc.nvidia.com/orgs/nvidia/containers/tritonserver
-    tag = 'nvcr.io/nvidia/tritonserver:23.09-py3'  # 6.4 GB
+    tag = "nvcr.io/nvidia/tritonserver:23.09-py3"  # 6.4 GB
 
     # Pull the image
-    subprocess.call(f'docker pull {tag}', shell=True)
+    subprocess.call(f"docker pull {tag}", shell=True)
 
     # Run the Triton server and capture the container ID
-    container_id = subprocess.check_output(
-        f'docker run -d --rm -v {triton_repo_path}:/models -p 8000:8000 {tag} tritonserver --model-repository=/models',
-        shell=True).decode('utf-8').strip()
+    container_id = (
+        subprocess.check_output(
+            f"docker run -d --rm -v {triton_repo}:/models -p 8000:8000 {tag} tritonserver --model-repository=/models",
+            shell=True,
+        )
+        .decode("utf-8")
+        .strip()
+    )
 
     # Wait for the Triton server to start
-    triton_client = InferenceServerClient(url='localhost:8000', verbose=False, ssl=False)
+    triton_client = InferenceServerClient(url="localhost:8000", verbose=False, ssl=False)
 
     # Wait until model is ready
     for _ in range(10):
         with contextlib.suppress(Exception):
             assert triton_client.is_model_ready(model_name)
             break
         time.sleep(1)
 
     # Check Triton inference
-    YOLO(f'http://localhost:8000/{model_name}', 'detect')(SOURCE)  # exported model inference
+    YOLO(f"http://localhost:8000/{model_name}", "detect")(SOURCE)  # exported model inference
 
     # Kill and remove the container at the end of the test
-    subprocess.call(f'docker kill {container_id}', shell=True)
+    subprocess.call(f"docker kill {container_id}", shell=True)
 
 
-@pytest.mark.skipif(not check_requirements('pycocotools', install=False), reason='pycocotools not installed')
+@pytest.mark.skipif(not check_requirements("pycocotools", install=False), reason="pycocotools not installed")
 def test_pycocotools():
     """Validate model predictions using pycocotools."""
     from ultralytics.models.yolo.detect import DetectionValidator
     from ultralytics.models.yolo.pose import PoseValidator
     from ultralytics.models.yolo.segment import SegmentationValidator
 
     # Download annotations after each dataset downloads first
-    url = 'https://github.com/ultralytics/assets/releases/download/v0.0.0/'
+    url = "https://github.com/ultralytics/assets/releases/download/v8.1.0/"
 
-    args = {'model': 'yolov8n.pt', 'data': 'coco8.yaml', 'save_json': True, 'imgsz': 64}
+    args = {"model": "yolov8n.pt", "data": "coco8.yaml", "save_json": True, "imgsz": 64}
     validator = DetectionValidator(args=args)
     validator()
     validator.is_coco = True
-    download(f'{url}instances_val2017.json', dir=DATASETS_DIR / 'coco8/annotations')
+    download(f"{url}instances_val2017.json", dir=DATASETS_DIR / "coco8/annotations")
     _ = validator.eval_json(validator.stats)
 
-    args = {'model': 'yolov8n-seg.pt', 'data': 'coco8-seg.yaml', 'save_json': True, 'imgsz': 64}
+    args = {"model": "yolov8n-seg.pt", "data": "coco8-seg.yaml", "save_json": True, "imgsz": 64}
     validator = SegmentationValidator(args=args)
     validator()
     validator.is_coco = True
-    download(f'{url}instances_val2017.json', dir=DATASETS_DIR / 'coco8-seg/annotations')
+    download(f"{url}instances_val2017.json", dir=DATASETS_DIR / "coco8-seg/annotations")
     _ = validator.eval_json(validator.stats)
 
-    args = {'model': 'yolov8n-pose.pt', 'data': 'coco8-pose.yaml', 'save_json': True, 'imgsz': 64}
+    args = {"model": "yolov8n-pose.pt", "data": "coco8-pose.yaml", "save_json": True, "imgsz": 64}
     validator = PoseValidator(args=args)
     validator()
     validator.is_coco = True
-    download(f'{url}person_keypoints_val2017.json', dir=DATASETS_DIR / 'coco8-pose/annotations')
+    download(f"{url}person_keypoints_val2017.json", dir=DATASETS_DIR / "coco8-pose/annotations")
     _ = validator.eval_json(validator.stats)
```

### Comparing `yolov8-pose-triton-8.1.0/tests/test_python.py` & `yolov8_pose_triton-8.2.0/tests/test_python.py`

 * *Files 16% similar despite different names*

```diff
@@ -4,29 +4,42 @@
 from copy import copy
 from pathlib import Path
 
 import cv2
 import numpy as np
 import pytest
 import torch
+import yaml
 from PIL import Image
-from torchvision.transforms import ToTensor
 
 from ultralytics import RTDETR, YOLO
 from ultralytics.cfg import TASK2DATA
 from ultralytics.data.build import load_inference_source
-from ultralytics.utils import (ASSETS, DEFAULT_CFG, DEFAULT_CFG_PATH, LINUX, MACOS, ONLINE, ROOT, WEIGHTS_DIR, WINDOWS,
-                               checks, is_dir_writeable)
+from ultralytics.utils import (
+    ASSETS,
+    DEFAULT_CFG,
+    DEFAULT_CFG_PATH,
+    LINUX,
+    MACOS,
+    ONLINE,
+    ROOT,
+    WEIGHTS_DIR,
+    WINDOWS,
+    Retry,
+    checks,
+    is_dir_writeable,
+    IS_RASPBERRYPI,
+)
 from ultralytics.utils.downloads import download
-from ultralytics.utils.torch_utils import TORCH_1_9
+from ultralytics.utils.torch_utils import TORCH_1_9, TORCH_1_13
 
-MODEL = WEIGHTS_DIR / 'path with spaces' / 'yolov8n.pt'  # test spaces in path
-CFG = 'yolov8n.yaml'
-SOURCE = ASSETS / 'bus.jpg'
-TMP = (ROOT / '../tests/tmp').resolve()  # temp directory for test files
+MODEL = WEIGHTS_DIR / "path with spaces" / "yolov8n.pt"  # test spaces in path
+CFG = "yolov8n.yaml"
+SOURCE = ASSETS / "bus.jpg"
+TMP = (ROOT / "../tests/tmp").resolve()  # temp directory for test files
 IS_TMP_WRITEABLE = is_dir_writeable(TMP)
 
 
 def test_model_forward():
     """Test the forward pass of the YOLO model."""
     model = YOLO(CFG)
     model(source=None, imgsz=32, augment=True)  # also test no source and augment
@@ -36,17 +49,17 @@
     """Test various methods and properties of the YOLO model."""
     model = YOLO(MODEL)
 
     # Model methods
     model.info(verbose=True, detailed=True)
     model = model.reset_weights()
     model = model.load(MODEL)
-    model.to('cpu')
+    model.to("cpu")
     model.fuse()
-    model.clear_callback('on_train_start')
+    model.clear_callback("on_train_start")
     model.reset_callbacks()
 
     # Model properties
     _ = model.names
     _ = model.device
     _ = model.transforms
     _ = model.task_map
@@ -57,357 +70,386 @@
     from ultralytics.nn.tasks import DetectionModel
 
     model = DetectionModel()  # build model
     im = torch.randn(1, 3, 64, 64)  # requires min imgsz=64
     _ = model.predict(im, profile=True)
 
 
-@pytest.mark.skipif(not IS_TMP_WRITEABLE, reason='directory is not writeable')
+@pytest.mark.skipif(not IS_TMP_WRITEABLE, reason="directory is not writeable")
 def test_predict_txt():
     """Test YOLO predictions with sources (file, dir, glob, recursive glob) specified in a text file."""
-    txt_file = TMP / 'sources.txt'
-    with open(txt_file, 'w') as f:
-        for x in [ASSETS / 'bus.jpg', ASSETS, ASSETS / '*', ASSETS / '**/*.jpg']:
-            f.write(f'{x}\n')
+    txt_file = TMP / "sources.txt"
+    with open(txt_file, "w") as f:
+        for x in [ASSETS / "bus.jpg", ASSETS, ASSETS / "*", ASSETS / "**/*.jpg"]:
+            f.write(f"{x}\n")
     _ = YOLO(MODEL)(source=txt_file, imgsz=32)
 
 
 def test_predict_img():
     """Test YOLO prediction on various types of image sources."""
     model = YOLO(MODEL)
-    seg_model = YOLO(WEIGHTS_DIR / 'yolov8n-seg.pt')
-    cls_model = YOLO(WEIGHTS_DIR / 'yolov8n-cls.pt')
-    pose_model = YOLO(WEIGHTS_DIR / 'yolov8n-pose.pt')
+    seg_model = YOLO(WEIGHTS_DIR / "yolov8n-seg.pt")
+    cls_model = YOLO(WEIGHTS_DIR / "yolov8n-cls.pt")
+    pose_model = YOLO(WEIGHTS_DIR / "yolov8n-pose.pt")
+    obb_model = YOLO(WEIGHTS_DIR / "yolov8n-obb.pt")
     im = cv2.imread(str(SOURCE))
     assert len(model(source=Image.open(SOURCE), save=True, verbose=True, imgsz=32)) == 1  # PIL
     assert len(model(source=im, save=True, save_txt=True, imgsz=32)) == 1  # ndarray
     assert len(model(source=[im, im], save=True, save_txt=True, imgsz=32)) == 2  # batch
     assert len(list(model(source=[im, im], save=True, stream=True, imgsz=32))) == 2  # stream
     assert len(model(torch.zeros(320, 640, 3).numpy(), imgsz=32)) == 1  # tensor to numpy
     batch = [
         str(SOURCE),  # filename
         Path(SOURCE),  # Path
-        'https://ultralytics.com/images/zidane.jpg' if ONLINE else SOURCE,  # URI
+        "https://ultralytics.com/images/zidane.jpg" if ONLINE else SOURCE,  # URI
         cv2.imread(str(SOURCE)),  # OpenCV
         Image.open(SOURCE),  # PIL
-        np.zeros((320, 640, 3))]  # numpy
+        np.zeros((320, 640, 3)),
+    ]  # numpy
     assert len(model(batch, imgsz=32)) == len(batch)  # multiple sources in a batch
 
     # Test tensor inference
-    im = cv2.imread(str(SOURCE))  # OpenCV
-    t = cv2.resize(im, (32, 32))
-    t = ToTensor()(t)
-    t = torch.stack([t, t, t, t])
-    results = model(t, imgsz=32)
-    assert len(results) == t.shape[0]
-    results = seg_model(t, imgsz=32)
-    assert len(results) == t.shape[0]
-    results = cls_model(t, imgsz=32)
-    assert len(results) == t.shape[0]
-    results = pose_model(t, imgsz=32)
-    assert len(results) == t.shape[0]
+    im = torch.rand((4, 3, 32, 32))  # batch-size 4, FP32 0.0-1.0 RGB order
+    results = model(im, imgsz=32)
+    assert len(results) == im.shape[0]
+    results = seg_model(im, imgsz=32)
+    assert len(results) == im.shape[0]
+    results = cls_model(im, imgsz=32)
+    assert len(results) == im.shape[0]
+    results = pose_model(im, imgsz=32)
+    assert len(results) == im.shape[0]
+    results = obb_model(im, imgsz=32)
+    assert len(results) == im.shape[0]
 
 
 def test_predict_grey_and_4ch():
     """Test YOLO prediction on SOURCE converted to greyscale and 4-channel images."""
     im = Image.open(SOURCE)
-    directory = TMP / 'im4'
+    directory = TMP / "im4"
     directory.mkdir(parents=True, exist_ok=True)
 
-    source_greyscale = directory / 'greyscale.jpg'
-    source_rgba = directory / '4ch.png'
-    source_non_utf = directory / 'non_UTF__tst_image.jpg'
-    source_spaces = directory / 'image with spaces.jpg'
+    source_greyscale = directory / "greyscale.jpg"
+    source_rgba = directory / "4ch.png"
+    source_non_utf = directory / "non_UTF__tst_image.jpg"
+    source_spaces = directory / "image with spaces.jpg"
 
-    im.convert('L').save(source_greyscale)  # greyscale
-    im.convert('RGBA').save(source_rgba)  # 4-ch PNG with alpha
+    im.convert("L").save(source_greyscale)  # greyscale
+    im.convert("RGBA").save(source_rgba)  # 4-ch PNG with alpha
     im.save(source_non_utf)  # non-UTF characters in filename
     im.save(source_spaces)  # spaces in filename
 
     # Inference
     model = YOLO(MODEL)
     for f in source_rgba, source_greyscale, source_non_utf, source_spaces:
         for source in Image.open(f), cv2.imread(str(f)), f:
             results = model(source, save=True, verbose=True, imgsz=32)
             assert len(results) == 1  # verify that an image was run
         f.unlink()  # cleanup
 
 
 @pytest.mark.slow
-@pytest.mark.skipif(not ONLINE, reason='environment is offline')
+@pytest.mark.skipif(not ONLINE, reason="environment is offline")
+@Retry(times=3, delay=10)
 def test_youtube():
     """
     Test YouTube inference.
 
     Marked --slow to reduce YouTube API rate limits risk.
     """
     model = YOLO(MODEL)
-    model.predict('https://youtu.be/G17sBkb38XQ', imgsz=96, save=True)
+    model.predict("https://youtu.be/G17sBkb38XQ", imgsz=96, save=True)
 
 
-@pytest.mark.skipif(not ONLINE, reason='environment is offline')
-@pytest.mark.skipif(not IS_TMP_WRITEABLE, reason='directory is not writeable')
+@pytest.mark.skipif(not ONLINE, reason="environment is offline")
+@pytest.mark.skipif(not IS_TMP_WRITEABLE, reason="directory is not writeable")
 def test_track_stream():
     """
     Test streaming tracking (short 10 frame video) with non-default ByteTrack tracker.
 
     Note imgsz=160 required for tracking for higher confidence and better matches
     """
-    import yaml
-
+    video_url = "https://ultralytics.com/assets/decelera_portrait_min.mov"
     model = YOLO(MODEL)
-    model.track('https://ultralytics.com/assets/decelera_portrait_min.mov', imgsz=160, tracker='bytetrack.yaml')
-    model.track('https://ultralytics.com/assets/decelera_portrait_min.mov', imgsz=160, tracker='botsort.yaml')
+    model.track(video_url, imgsz=160, tracker="bytetrack.yaml")
+    model.track(video_url, imgsz=160, tracker="botsort.yaml", save_frames=True)  # test frame saving also
 
     # Test Global Motion Compensation (GMC) methods
-    for gmc in 'orb', 'sift', 'ecc':
-        with open(ROOT / 'cfg/trackers/botsort.yaml', encoding='utf-8') as f:
+    for gmc in "orb", "sift", "ecc":
+        with open(ROOT / "cfg/trackers/botsort.yaml", encoding="utf-8") as f:
             data = yaml.safe_load(f)
-        tracker = TMP / f'botsort-{gmc}.yaml'
-        data['gmc_method'] = gmc
-        with open(tracker, 'w', encoding='utf-8') as f:
+        tracker = TMP / f"botsort-{gmc}.yaml"
+        data["gmc_method"] = gmc
+        with open(tracker, "w", encoding="utf-8") as f:
             yaml.safe_dump(data, f)
-        model.track('https://ultralytics.com/assets/decelera_portrait_min.mov', imgsz=160, tracker=tracker)
+        model.track(video_url, imgsz=160, tracker=tracker)
 
 
 def test_val():
     """Test the validation mode of the YOLO model."""
-    YOLO(MODEL).val(data='coco8.yaml', imgsz=32, save_hybrid=True)
+    YOLO(MODEL).val(data="coco8.yaml", imgsz=32, save_hybrid=True)
 
 
 def test_train_scratch():
     """Test training the YOLO model from scratch."""
     model = YOLO(CFG)
-    model.train(data='coco8.yaml', epochs=2, imgsz=32, cache='disk', batch=-1, close_mosaic=1, name='model')
+    model.train(data="coco8.yaml", epochs=2, imgsz=32, cache="disk", batch=-1, close_mosaic=1, name="model")
     model(SOURCE)
 
 
 def test_train_pretrained():
     """Test training the YOLO model from a pre-trained state."""
-    model = YOLO(WEIGHTS_DIR / 'yolov8n-seg.pt')
-    model.train(data='coco8-seg.yaml', epochs=1, imgsz=32, cache='ram', copy_paste=0.5, mixup=0.5, name=0)
+    model = YOLO(WEIGHTS_DIR / "yolov8n-seg.pt")
+    model.train(data="coco8-seg.yaml", epochs=1, imgsz=32, cache="ram", copy_paste=0.5, mixup=0.5, name=0)
     model(SOURCE)
 
 
 def test_export_torchscript():
     """Test exporting the YOLO model to TorchScript format."""
-    f = YOLO(MODEL).export(format='torchscript', optimize=False)
+    f = YOLO(MODEL).export(format="torchscript", optimize=False)
     YOLO(f)(SOURCE)  # exported model inference
 
 
 def test_export_onnx():
     """Test exporting the YOLO model to ONNX format."""
-    f = YOLO(MODEL).export(format='onnx', dynamic=True)
+    f = YOLO(MODEL).export(format="onnx", dynamic=True)
     YOLO(f)(SOURCE)  # exported model inference
 
 
+@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason="OpenVINO not supported in Python 3.12")
+@pytest.mark.skipif(not TORCH_1_13, reason="OpenVINO requires torch>=1.13")
 def test_export_openvino():
     """Test exporting the YOLO model to OpenVINO format."""
-    f = YOLO(MODEL).export(format='openvino')
+    f = YOLO(MODEL).export(format="openvino")
     YOLO(f)(SOURCE)  # exported model inference
 
 
+@pytest.mark.skipif(WINDOWS, reason="CoreML not supported on Windows")  # RuntimeError: BlobWriter not loaded
+@pytest.mark.skipif(IS_RASPBERRYPI, reason="CoreML not supported on Raspberry Pi")
+@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason="CoreML not supported in Python 3.12")
 def test_export_coreml():
     """Test exporting the YOLO model to CoreML format."""
-    if not WINDOWS:  # RuntimeError: BlobWriter not loaded with coremltools 7.0 on windows
-        if MACOS:
-            f = YOLO(MODEL).export(format='coreml')
-            YOLO(f)(SOURCE)  # model prediction only supported on macOS for nms=False models
-        else:
-            YOLO(MODEL).export(format='coreml', nms=True)
+    if MACOS:
+        f = YOLO(MODEL).export(format="coreml")
+        YOLO(f)(SOURCE)  # model prediction only supported on macOS for nms=False models
+    else:
+        YOLO(MODEL).export(format="coreml", nms=True)
 
 
 def test_export_tflite(enabled=False):
     """
     Test exporting the YOLO model to TFLite format.
 
     Note TF suffers from install conflicts on Windows and macOS.
     """
     if enabled and LINUX:
         model = YOLO(MODEL)
-        f = model.export(format='tflite')
+        f = model.export(format="tflite")
         YOLO(f)(SOURCE)
 
 
 def test_export_pb(enabled=False):
     """
     Test exporting the YOLO model to *.pb format.
 
     Note TF suffers from install conflicts on Windows and macOS.
     """
     if enabled and LINUX:
         model = YOLO(MODEL)
-        f = model.export(format='pb')
+        f = model.export(format="pb")
         YOLO(f)(SOURCE)
 
 
 def test_export_paddle(enabled=False):
     """
     Test exporting the YOLO model to Paddle format.
 
     Note Paddle protobuf requirements conflicting with onnx protobuf requirements.
     """
     if enabled:
-        YOLO(MODEL).export(format='paddle')
+        YOLO(MODEL).export(format="paddle")
 
 
 @pytest.mark.slow
 def test_export_ncnn():
     """Test exporting the YOLO model to NCNN format."""
-    f = YOLO(MODEL).export(format='ncnn')
+    f = YOLO(MODEL).export(format="ncnn")
     YOLO(f)(SOURCE)  # exported model inference
 
 
 def test_all_model_yamls():
     """Test YOLO model creation for all available YAML configurations."""
-    for m in (ROOT / 'cfg' / 'models').rglob('*.yaml'):
-        if 'rtdetr' in m.name:
+    for m in (ROOT / "cfg" / "models").rglob("*.yaml"):
+        if "rtdetr" in m.name:
             if TORCH_1_9:  # torch<=1.8 issue - TypeError: __init__() got an unexpected keyword argument 'batch_first'
                 _ = RTDETR(m.name)(SOURCE, imgsz=640)  # must be 640
         else:
             YOLO(m.name)
 
 
 def test_workflow():
     """Test the complete workflow including training, validation, prediction, and exporting."""
     model = YOLO(MODEL)
-    model.train(data='coco8.yaml', epochs=1, imgsz=32, optimizer='SGD')
+    model.train(data="coco8.yaml", epochs=1, imgsz=32, optimizer="SGD")
     model.val(imgsz=32)
     model.predict(SOURCE, imgsz=32)
-    model.export(format='onnx')  # export a model to ONNX format
+    model.export(format="onnx")  # export a model to ONNX format
 
 
 def test_predict_callback_and_setup():
     """Test callback functionality during YOLO prediction."""
 
     def on_predict_batch_end(predictor):
         """Callback function that handles operations at the end of a prediction batch."""
-        path, im0s, _, _ = predictor.batch
+        path, im0s, _ = predictor.batch
         im0s = im0s if isinstance(im0s, list) else [im0s]
         bs = [predictor.dataset.bs for _ in range(len(path))]
         predictor.results = zip(predictor.results, im0s, bs)  # results is List[batch_size]
 
     model = YOLO(MODEL)
-    model.add_callback('on_predict_batch_end', on_predict_batch_end)
+    model.add_callback("on_predict_batch_end", on_predict_batch_end)
 
     dataset = load_inference_source(source=SOURCE)
     bs = dataset.bs  # noqa access predictor properties
     results = model.predict(dataset, stream=True, imgsz=160)  # source already setup
     for r, im0, bs in results:
-        print('test_callback', im0.shape)
-        print('test_callback', bs)
+        print("test_callback", im0.shape)
+        print("test_callback", bs)
         boxes = r.boxes  # Boxes object for bbox outputs
         print(boxes)
 
 
 def test_results():
     """Test various result formats for the YOLO model."""
-    for m in 'yolov8n-pose.pt', 'yolov8n-seg.pt', 'yolov8n.pt', 'yolov8n-cls.pt':
+    for m in "yolov8n-pose.pt", "yolov8n-seg.pt", "yolov8n.pt", "yolov8n-cls.pt":
         results = YOLO(WEIGHTS_DIR / m)([SOURCE, SOURCE], imgsz=160)
         for r in results:
             r = r.cpu().numpy()
-            r = r.to(device='cpu', dtype=torch.float32)
-            r.save_txt(txt_file=TMP / 'runs/tests/label.txt', save_conf=True)
-            r.save_crop(save_dir=TMP / 'runs/tests/crops/')
+            r = r.to(device="cpu", dtype=torch.float32)
+            r.save_txt(txt_file=TMP / "runs/tests/label.txt", save_conf=True)
+            r.save_crop(save_dir=TMP / "runs/tests/crops/")
             r.tojson(normalize=True)
             r.plot(pil=True)
             r.plot(conf=True, boxes=True)
             print(r, len(r), r.path)
 
 
-@pytest.mark.skipif(not ONLINE, reason='environment is offline')
+def test_labels_and_crops():
+    """Test output from prediction args for saving detection labels and crops."""
+    imgs = [SOURCE, ASSETS / "zidane.jpg"]
+    results = YOLO(WEIGHTS_DIR / "yolov8n.pt")(imgs, imgsz=160, save_txt=True, save_crop=True)
+    save_path = Path(results[0].save_dir)
+    for r in results:
+        im_name = Path(r.path).stem
+        cls_idxs = r.boxes.cls.int().tolist()
+        # Check label path
+        labels = save_path / f"labels/{im_name}.txt"
+        assert labels.exists()
+        # Check detections match label count
+        assert len(r.boxes.data) == len([l for l in labels.read_text().splitlines() if l])
+        # Check crops path and files
+        crop_dirs = [p for p in (save_path / "crops").iterdir()]
+        crop_files = [f for p in crop_dirs for f in p.glob("*")]
+        # Crop directories match detections
+        assert all([r.names.get(c) in {d.name for d in crop_dirs} for c in cls_idxs])
+        # Same number of crops as detections
+        assert len([f for f in crop_files if im_name in f.name]) == len(r.boxes.data)
+
+
+@pytest.mark.skipif(not ONLINE, reason="environment is offline")
 def test_data_utils():
     """Test utility functions in ultralytics/data/utils.py."""
     from ultralytics.data.utils import HUBDatasetStats, autosplit
     from ultralytics.utils.downloads import zip_directory
 
     # from ultralytics.utils.files import WorkingDirectory
     # with WorkingDirectory(ROOT.parent / 'tests'):
 
-    for task in 'detect', 'segment', 'pose', 'classify':
-        file = Path(TASK2DATA[task]).with_suffix('.zip')  # i.e. coco8.zip
-        download(f'https://github.com/ultralytics/hub/raw/main/example_datasets/{file}', unzip=False, dir=TMP)
+    for task in "detect", "segment", "pose", "classify":
+        file = Path(TASK2DATA[task]).with_suffix(".zip")  # i.e. coco8.zip
+        download(f"https://github.com/ultralytics/hub/raw/main/example_datasets/{file}", unzip=False, dir=TMP)
         stats = HUBDatasetStats(TMP / file, task=task)
         stats.get_json(save=True)
         stats.process_images()
 
-    autosplit(TMP / 'coco8')
-    zip_directory(TMP / 'coco8/images/val')  # zip
+    autosplit(TMP / "coco8")
+    zip_directory(TMP / "coco8/images/val")  # zip
 
 
-@pytest.mark.skipif(not ONLINE, reason='environment is offline')
+@pytest.mark.skipif(not ONLINE, reason="environment is offline")
 def test_data_converter():
     """Test dataset converters."""
     from ultralytics.data.converter import coco80_to_coco91_class, convert_coco
 
-    file = 'instances_val2017.json'
-    download(f'https://github.com/ultralytics/yolov5/releases/download/v1.0/{file}', dir=TMP)
-    convert_coco(labels_dir=TMP, save_dir=TMP / 'yolo_labels', use_segments=True, use_keypoints=False, cls91to80=True)
+    file = "instances_val2017.json"
+    download(f"https://github.com/ultralytics/yolov5/releases/download/v1.0/{file}", dir=TMP)
+    convert_coco(labels_dir=TMP, save_dir=TMP / "yolo_labels", use_segments=True, use_keypoints=False, cls91to80=True)
     coco80_to_coco91_class()
 
 
 def test_data_annotator():
     """Test automatic data annotation."""
     from ultralytics.data.annotator import auto_annotate
 
-    auto_annotate(ASSETS,
-                  det_model=WEIGHTS_DIR / 'yolov8n.pt',
-                  sam_model=WEIGHTS_DIR / 'mobile_sam.pt',
-                  output_dir=TMP / 'auto_annotate_labels')
+    auto_annotate(
+        ASSETS,
+        det_model=WEIGHTS_DIR / "yolov8n.pt",
+        sam_model=WEIGHTS_DIR / "mobile_sam.pt",
+        output_dir=TMP / "auto_annotate_labels",
+    )
 
 
 def test_events():
     """Test event sending functionality."""
     from ultralytics.hub.utils import Events
 
     events = Events()
     events.enabled = True
     cfg = copy(DEFAULT_CFG)  # does not require deepcopy
-    cfg.mode = 'test'
+    cfg.mode = "test"
     events(cfg)
 
 
 def test_cfg_init():
     """Test configuration initialization utilities."""
     from ultralytics.cfg import check_dict_alignment, copy_default_cfg, smart_value
 
     with contextlib.suppress(SyntaxError):
-        check_dict_alignment({'a': 1}, {'b': 2})
+        check_dict_alignment({"a": 1}, {"b": 2})
     copy_default_cfg()
-    (Path.cwd() / DEFAULT_CFG_PATH.name.replace('.yaml', '_copy.yaml')).unlink(missing_ok=False)
-    [smart_value(x) for x in ['none', 'true', 'false']]
+    (Path.cwd() / DEFAULT_CFG_PATH.name.replace(".yaml", "_copy.yaml")).unlink(missing_ok=False)
+    [smart_value(x) for x in ["none", "true", "false"]]
 
 
 def test_utils_init():
     """Test initialization utilities."""
     from ultralytics.utils import get_git_branch, get_git_origin_url, get_ubuntu_version, is_github_action_running
 
     get_ubuntu_version()
     is_github_action_running()
     get_git_origin_url()
     get_git_branch()
 
 
 def test_utils_checks():
     """Test various utility checks."""
-    checks.check_yolov5u_filename('yolov5n.pt')
+    checks.check_yolov5u_filename("yolov5n.pt")
     checks.git_describe(ROOT)
     checks.check_requirements()  # check requirements.txt
     checks.check_imgsz([600, 600], max_dim=1)
     checks.check_imshow()
-    checks.check_version('ultralytics', '8.0.0')
+    checks.check_version("ultralytics", "8.0.0")
     checks.print_args()
     # checks.check_imshow(warn=True)
 
 
 def test_utils_benchmarks():
     """Test model benchmarking."""
     from ultralytics.utils.benchmarks import ProfileModels
 
-    ProfileModels(['yolov8n.yaml'], imgsz=32, min_time=1, num_timed_runs=3, num_warmup_runs=1).profile()
+    ProfileModels(["yolov8n.yaml"], imgsz=32, min_time=1, num_timed_runs=3, num_warmup_runs=1).profile()
 
 
 def test_utils_torchutils():
     """Test Torch utility functions."""
     from ultralytics.nn.modules.conv import Conv
     from ultralytics.utils.torch_utils import get_flops_with_torch_profiler, profile, time_sync
 
@@ -415,26 +457,38 @@
     m = Conv(64, 64, k=1, s=2)
 
     profile(x, [m], n=3)
     get_flops_with_torch_profiler(m)
     time_sync()
 
 
-@pytest.mark.skipif(not ONLINE, reason='environment is offline')
+@pytest.mark.slow
+@pytest.mark.skipif(not ONLINE, reason="environment is offline")
 def test_utils_downloads():
     """Test file download utilities."""
     from ultralytics.utils.downloads import get_google_drive_file_info
 
-    get_google_drive_file_info('https://drive.google.com/file/d/1cqT-cJgANNrhIHCrEufUYhQ4RqiWG_lJ/view?usp=drive_link')
+    get_google_drive_file_info("https://drive.google.com/file/d/1cqT-cJgANNrhIHCrEufUYhQ4RqiWG_lJ/view?usp=drive_link")
 
 
 def test_utils_ops():
     """Test various operations utilities."""
-    from ultralytics.utils.ops import (ltwh2xywh, ltwh2xyxy, make_divisible, xywh2ltwh, xywh2xyxy, xywhn2xyxy,
-                                       xywhr2xyxyxyxy, xyxy2ltwh, xyxy2xywh, xyxy2xywhn, xyxyxyxy2xywhr)
+    from ultralytics.utils.ops import (
+        ltwh2xywh,
+        ltwh2xyxy,
+        make_divisible,
+        xywh2ltwh,
+        xywh2xyxy,
+        xywhn2xyxy,
+        xywhr2xyxyxyxy,
+        xyxy2ltwh,
+        xyxy2xywh,
+        xyxy2xywhn,
+        xyxyxyxy2xywhr,
+    )
 
     make_divisible(17, torch.tensor([8]))
 
     boxes = torch.rand(10, 4)  # xywh
     torch.allclose(boxes, xyxy2xywh(xywh2xyxy(boxes)))
     torch.allclose(boxes, xyxy2xywhn(xywhn2xyxy(boxes)))
     torch.allclose(boxes, ltwh2xywh(xywh2ltwh(boxes)))
@@ -447,22 +501,38 @@
 
 def test_utils_files():
     """Test file handling utilities."""
     from ultralytics.utils.files import file_age, file_date, get_latest_run, spaces_in_path
 
     file_age(SOURCE)
     file_date(SOURCE)
-    get_latest_run(ROOT / 'runs')
+    get_latest_run(ROOT / "runs")
 
-    path = TMP / 'path/with spaces'
+    path = TMP / "path/with spaces"
     path.mkdir(parents=True, exist_ok=True)
     with spaces_in_path(path) as new_path:
         print(new_path)
 
 
+@pytest.mark.slow
+def test_utils_patches_torch_save():
+    """Test torch_save backoff when _torch_save throws RuntimeError."""
+    from unittest.mock import MagicMock, patch
+
+    from ultralytics.utils.patches import torch_save
+
+    mock = MagicMock(side_effect=RuntimeError)
+
+    with patch("ultralytics.utils.patches._torch_save", new=mock):
+        with pytest.raises(RuntimeError):
+            torch_save(torch.zeros(1), TMP / "test.pt")
+
+    assert mock.call_count == 4, "torch_save was not attempted the expected number of times"
+
+
 def test_nn_modules_conv():
     """Test Convolutional Neural Network modules."""
     from ultralytics.nn.modules.conv import CBAM, Conv2, ConvTranspose, DWConvTranspose2d, Focus
 
     c1, c2 = 8, 16  # input and output channels
     x = torch.zeros(4, c1, 10, 10)  # BCHW
 
@@ -489,24 +559,108 @@
     C1(c1, c2)(x)
     C3x(c1, c2)(x)
     C3TR(c1, c2)(x)
     C3Ghost(c1, c2)(x)
     BottleneckCSP(c1, c2)(x)
 
 
-@pytest.mark.skipif(not ONLINE, reason='environment is offline')
+@pytest.mark.skipif(not ONLINE, reason="environment is offline")
 def test_hub():
     """Test Ultralytics HUB functionalities."""
     from ultralytics.hub import export_fmts_hub, logout
     from ultralytics.hub.utils import smart_request
 
     export_fmts_hub()
     logout()
-    smart_request('GET', 'http://github.com', progress=True)
+    smart_request("GET", "https://github.com", progress=True)
+
+
+@pytest.fixture
+def image():
+    """Loads an image from a predefined source using OpenCV."""
+    return cv2.imread(str(SOURCE))
+
+
+@pytest.mark.parametrize(
+    "auto_augment, erasing, force_color_jitter",
+    [
+        (None, 0.0, False),
+        ("randaugment", 0.5, True),
+        ("augmix", 0.2, False),
+        ("autoaugment", 0.0, True),
+    ],
+)
+def test_classify_transforms_train(image, auto_augment, erasing, force_color_jitter):
+    """Tests classification transforms during training with various augmentation settings."""
+    from ultralytics.data.augment import classify_augmentations
+
+    transform = classify_augmentations(
+        size=224,
+        mean=(0.5, 0.5, 0.5),
+        std=(0.5, 0.5, 0.5),
+        scale=(0.08, 1.0),
+        ratio=(3.0 / 4.0, 4.0 / 3.0),
+        hflip=0.5,
+        vflip=0.5,
+        auto_augment=auto_augment,
+        hsv_h=0.015,
+        hsv_s=0.4,
+        hsv_v=0.4,
+        force_color_jitter=force_color_jitter,
+        erasing=erasing,
+    )
+
+    transformed_image = transform(Image.fromarray(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)))
+
+    assert transformed_image.shape == (3, 224, 224)
+    assert torch.is_tensor(transformed_image)
+    assert transformed_image.dtype == torch.float32
 
 
 @pytest.mark.slow
-@pytest.mark.skipif(not ONLINE, reason='environment is offline')
+@pytest.mark.skipif(not ONLINE, reason="environment is offline")
 def test_model_tune():
     """Tune YOLO model for performance."""
-    YOLO('yolov8n-pose.pt').tune(data='coco8-pose.yaml', plots=False, imgsz=32, epochs=1, iterations=2, device='cpu')
-    YOLO('yolov8n-cls.pt').tune(data='imagenet10', plots=False, imgsz=32, epochs=1, iterations=2, device='cpu')
+    YOLO("yolov8n-pose.pt").tune(data="coco8-pose.yaml", plots=False, imgsz=32, epochs=1, iterations=2, device="cpu")
+    YOLO("yolov8n-cls.pt").tune(data="imagenet10", plots=False, imgsz=32, epochs=1, iterations=2, device="cpu")
+
+
+def test_model_embeddings():
+    """Test YOLO model embeddings."""
+    model_detect = YOLO(MODEL)
+    model_segment = YOLO(WEIGHTS_DIR / "yolov8n-seg.pt")
+
+    for batch in [SOURCE], [SOURCE, SOURCE]:  # test batch size 1 and 2
+        assert len(model_detect.embed(source=batch, imgsz=32)) == len(batch)
+        assert len(model_segment.embed(source=batch, imgsz=32)) == len(batch)
+
+
+@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason="YOLOWorld with CLIP is not supported in Python 3.12")
+def test_yolo_world():
+    model = YOLO("yolov8s-world.pt")  # no YOLOv8n-world model yet
+    model.set_classes(["tree", "window"])
+    model(ASSETS / "bus.jpg", conf=0.01)
+
+    # Training from yaml
+    model = YOLO("yolov8s-worldv2.yaml")  # no YOLOv8n-world model yet
+    model.train(data="coco8.yaml", epochs=2, imgsz=32, cache="disk", batch=-1, close_mosaic=1, name="yolo-world")
+
+    model = YOLO("yolov8s-worldv2.pt")  # no YOLOv8n-world model yet
+    # val
+    model.val(data="coco8.yaml", imgsz=32, save_txt=True, save_json=True)
+    # Training from pretrain
+    model.train(data="coco8.yaml", epochs=2, imgsz=32, cache="disk", batch=-1, close_mosaic=1, name="yolo-world")
+
+    # test WorWorldTrainerFromScratch
+    from ultralytics.models.yolo.world.train_world import WorldTrainerFromScratch
+
+    model = YOLO("yolov8s-worldv2.yaml")  # no YOLOv8n-world model yet
+    model.train(
+        data={"train": {"yolo_data": ["coco8.yaml"]}, "val": {"yolo_data": ["coco8.yaml"]}},
+        epochs=2,
+        imgsz=32,
+        cache="disk",
+        batch=-1,
+        close_mosaic=1,
+        name="yolo-world",
+        trainer=WorldTrainerFromScratch,
+    )
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/assets/bus.jpg` & `yolov8_pose_triton-8.2.0/ultralytics/assets/bus.jpg`

 * *Files identical despite different names*

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/assets/zidane.jpg` & `yolov8_pose_triton-8.2.0/ultralytics/assets/zidane.jpg`

 * *Files identical despite different names*

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/__init__.py` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,38 +1,66 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import contextlib
 import shutil
+import subprocess
 import sys
 from pathlib import Path
 from types import SimpleNamespace
 from typing import Dict, List, Union
 
-from ultralytics.utils import (ASSETS, DEFAULT_CFG, DEFAULT_CFG_DICT, DEFAULT_CFG_PATH, LOGGER, RANK, ROOT, RUNS_DIR,
-                               SETTINGS, SETTINGS_YAML, TESTS_RUNNING, IterableSimpleNamespace, __version__, checks,
-                               colorstr, deprecation_warn, yaml_load, yaml_print)
+from ultralytics.utils import (
+    ASSETS,
+    DEFAULT_CFG,
+    DEFAULT_CFG_DICT,
+    DEFAULT_CFG_PATH,
+    LOGGER,
+    RANK,
+    ROOT,
+    RUNS_DIR,
+    SETTINGS,
+    SETTINGS_YAML,
+    TESTS_RUNNING,
+    IterableSimpleNamespace,
+    __version__,
+    checks,
+    colorstr,
+    deprecation_warn,
+    yaml_load,
+    yaml_print,
+)
 
 # Define valid tasks and modes
-MODES = 'train', 'val', 'predict', 'export', 'track', 'benchmark'
-TASKS = 'detect', 'segment', 'classify', 'pose'
-TASK2DATA = {'detect': 'coco8.yaml', 'segment': 'coco8-seg.yaml', 'classify': 'imagenet10', 'pose': 'coco8-pose.yaml'}
+MODES = {"train", "val", "predict", "export", "track", "benchmark"}
+TASKS = {"detect", "segment", "classify", "pose", "obb"}
+TASK2DATA = {
+    "detect": "coco8.yaml",
+    "segment": "coco8-seg.yaml",
+    "classify": "imagenet10",
+    "pose": "coco8-pose.yaml",
+    "obb": "dota8.yaml",
+}
 TASK2MODEL = {
-    'detect': 'yolov8n.pt',
-    'segment': 'yolov8n-seg.pt',
-    'classify': 'yolov8n-cls.pt',
-    'pose': 'yolov8n-pose.pt'}
+    "detect": "yolov8n.pt",
+    "segment": "yolov8n-seg.pt",
+    "classify": "yolov8n-cls.pt",
+    "pose": "yolov8n-pose.pt",
+    "obb": "yolov8n-obb.pt",
+}
 TASK2METRIC = {
-    'detect': 'metrics/mAP50-95(B)',
-    'segment': 'metrics/mAP50-95(M)',
-    'classify': 'metrics/accuracy_top1',
-    'pose': 'metrics/mAP50-95(P)'}
-
-CLI_HELP_MSG = \
-    f"""
-    Arguments received: {str(['yolo'] + sys.argv[1:])}. Ultralytics 'yolo' commands use the following syntax:
+    "detect": "metrics/mAP50-95(B)",
+    "segment": "metrics/mAP50-95(M)",
+    "classify": "metrics/accuracy_top1",
+    "pose": "metrics/mAP50-95(P)",
+    "obb": "metrics/mAP50-95(B)",
+}
+
+ARGV = sys.argv or ["", ""]  # sometimes sys.argv = []
+CLI_HELP_MSG = f"""
+    Arguments received: {str(['yolo'] + ARGV[1:])}. Ultralytics 'yolo' commands use the following syntax:
 
         yolo TASK MODE ARGS
 
         Where   TASK (optional) is one of {TASKS}
                 MODE (required) is one of {MODES}
                 ARGS (optional) are any number of custom 'arg=value' pairs like 'imgsz=320' that override defaults.
                     See all ARGS at https://docs.ultralytics.com/usage/cfg or with 'yolo cfg'
@@ -45,38 +73,108 @@
 
     3. Val a pretrained detection model at batch-size 1 and image size 640:
         yolo val model=yolov8n.pt data=coco128.yaml batch=1 imgsz=640
 
     4. Export a YOLOv8n classification model to ONNX format at image size 224 by 128 (no TASK required)
         yolo export model=yolov8n-cls.pt format=onnx imgsz=224,128
 
+    6. Explore your datasets using semantic search and SQL with a simple GUI powered by Ultralytics Explorer API
+        yolo explorer
+
     5. Run special commands:
         yolo help
         yolo checks
         yolo version
         yolo settings
         yolo copy-cfg
         yolo cfg
 
     Docs: https://docs.ultralytics.com
     Community: https://community.ultralytics.com
     GitHub: https://github.com/ultralytics/ultralytics
     """
 
 # Define keys for arg type checks
-CFG_FLOAT_KEYS = 'warmup_epochs', 'box', 'cls', 'dfl', 'degrees', 'shear'
-CFG_FRACTION_KEYS = ('dropout', 'iou', 'lr0', 'lrf', 'momentum', 'weight_decay', 'warmup_momentum', 'warmup_bias_lr',
-                     'label_smoothing', 'hsv_h', 'hsv_s', 'hsv_v', 'translate', 'scale', 'perspective', 'flipud',
-                     'fliplr', 'mosaic', 'mixup', 'copy_paste', 'conf', 'iou', 'fraction')  # fraction floats 0.0 - 1.0
-CFG_INT_KEYS = ('epochs', 'patience', 'batch', 'workers', 'seed', 'close_mosaic', 'mask_ratio', 'max_det', 'vid_stride',
-                'line_width', 'workspace', 'nbs', 'save_period')
-CFG_BOOL_KEYS = ('save', 'exist_ok', 'verbose', 'deterministic', 'single_cls', 'rect', 'cos_lr', 'overlap_mask', 'val',
-                 'save_json', 'save_hybrid', 'half', 'dnn', 'plots', 'show', 'save_txt', 'save_conf', 'save_crop',
-                 'show_labels', 'show_conf', 'visualize', 'augment', 'agnostic_nms', 'retina_masks', 'show_boxes',
-                 'keras', 'optimize', 'int8', 'dynamic', 'simplify', 'nms', 'profile')
+CFG_FLOAT_KEYS = {"warmup_epochs", "box", "cls", "dfl", "degrees", "shear", "time", "workspace"}
+CFG_FRACTION_KEYS = {
+    "dropout",
+    "iou",
+    "lr0",
+    "lrf",
+    "momentum",
+    "weight_decay",
+    "warmup_momentum",
+    "warmup_bias_lr",
+    "label_smoothing",
+    "hsv_h",
+    "hsv_s",
+    "hsv_v",
+    "translate",
+    "scale",
+    "perspective",
+    "flipud",
+    "fliplr",
+    "bgr",
+    "mosaic",
+    "mixup",
+    "copy_paste",
+    "conf",
+    "iou",
+    "fraction",
+}  # fraction floats 0.0 - 1.0
+CFG_INT_KEYS = {
+    "epochs",
+    "patience",
+    "batch",
+    "workers",
+    "seed",
+    "close_mosaic",
+    "mask_ratio",
+    "max_det",
+    "vid_stride",
+    "line_width",
+    "nbs",
+    "save_period",
+}
+CFG_BOOL_KEYS = {
+    "save",
+    "exist_ok",
+    "verbose",
+    "deterministic",
+    "single_cls",
+    "rect",
+    "cos_lr",
+    "overlap_mask",
+    "val",
+    "save_json",
+    "save_hybrid",
+    "half",
+    "dnn",
+    "plots",
+    "show",
+    "save_txt",
+    "save_conf",
+    "save_crop",
+    "save_frames",
+    "show_labels",
+    "show_conf",
+    "visualize",
+    "augment",
+    "agnostic_nms",
+    "retina_masks",
+    "show_boxes",
+    "keras",
+    "optimize",
+    "int8",
+    "dynamic",
+    "simplify",
+    "nms",
+    "profile",
+    "multi_scale",
+}
 
 
 def cfg2dict(cfg):
     """
     Convert a configuration object to a dictionary, whether it is a file path, a string, or a SimpleNamespace object.
 
     Args:
@@ -104,82 +202,101 @@
         (SimpleNamespace): Training arguments namespace.
     """
     cfg = cfg2dict(cfg)
 
     # Merge overrides
     if overrides:
         overrides = cfg2dict(overrides)
-        if 'save_dir' not in cfg:
-            overrides.pop('save_dir', None)  # special override keys to ignore
+        if "save_dir" not in cfg:
+            overrides.pop("save_dir", None)  # special override keys to ignore
         check_dict_alignment(cfg, overrides)
         cfg = {**cfg, **overrides}  # merge cfg and overrides dicts (prefer overrides)
 
     # Special handling for numeric project/name
-    for k in 'project', 'name':
+    for k in "project", "name":
         if k in cfg and isinstance(cfg[k], (int, float)):
             cfg[k] = str(cfg[k])
-    if cfg.get('name') == 'model':  # assign model to 'name' arg
-        cfg['name'] = cfg.get('model', '').split('.')[0]
+    if cfg.get("name") == "model":  # assign model to 'name' arg
+        cfg["name"] = cfg.get("model", "").split(".")[0]
         LOGGER.warning(f"WARNING  'name=model' automatically updated to 'name={cfg['name']}'.")
 
     # Type and Value checks
+    check_cfg(cfg)
+
+    # Return instance
+    return IterableSimpleNamespace(**cfg)
+
+
+def check_cfg(cfg, hard=True):
+    """Check Ultralytics configuration argument types and values."""
     for k, v in cfg.items():
         if v is not None:  # None values may be from optional args
             if k in CFG_FLOAT_KEYS and not isinstance(v, (int, float)):
-                raise TypeError(f"'{k}={v}' is of invalid type {type(v).__name__}. "
-                                f"Valid '{k}' types are int (i.e. '{k}=0') or float (i.e. '{k}=0.5')")
+                if hard:
+                    raise TypeError(
+                        f"'{k}={v}' is of invalid type {type(v).__name__}. "
+                        f"Valid '{k}' types are int (i.e. '{k}=0') or float (i.e. '{k}=0.5')"
+                    )
+                cfg[k] = float(v)
             elif k in CFG_FRACTION_KEYS:
                 if not isinstance(v, (int, float)):
-                    raise TypeError(f"'{k}={v}' is of invalid type {type(v).__name__}. "
-                                    f"Valid '{k}' types are int (i.e. '{k}=0') or float (i.e. '{k}=0.5')")
+                    if hard:
+                        raise TypeError(
+                            f"'{k}={v}' is of invalid type {type(v).__name__}. "
+                            f"Valid '{k}' types are int (i.e. '{k}=0') or float (i.e. '{k}=0.5')"
+                        )
+                    cfg[k] = v = float(v)
                 if not (0.0 <= v <= 1.0):
-                    raise ValueError(f"'{k}={v}' is an invalid value. "
-                                     f"Valid '{k}' values are between 0.0 and 1.0.")
+                    raise ValueError(f"'{k}={v}' is an invalid value. " f"Valid '{k}' values are between 0.0 and 1.0.")
             elif k in CFG_INT_KEYS and not isinstance(v, int):
-                raise TypeError(f"'{k}={v}' is of invalid type {type(v).__name__}. "
-                                f"'{k}' must be an int (i.e. '{k}=8')")
+                if hard:
+                    raise TypeError(
+                        f"'{k}={v}' is of invalid type {type(v).__name__}. " f"'{k}' must be an int (i.e. '{k}=8')"
+                    )
+                cfg[k] = int(v)
             elif k in CFG_BOOL_KEYS and not isinstance(v, bool):
-                raise TypeError(f"'{k}={v}' is of invalid type {type(v).__name__}. "
-                                f"'{k}' must be a bool (i.e. '{k}=True' or '{k}=False')")
-
-    # Return instance
-    return IterableSimpleNamespace(**cfg)
+                if hard:
+                    raise TypeError(
+                        f"'{k}={v}' is of invalid type {type(v).__name__}. "
+                        f"'{k}' must be a bool (i.e. '{k}=True' or '{k}=False')"
+                    )
+                cfg[k] = bool(v)
 
 
 def get_save_dir(args, name=None):
     """Return save_dir as created from train/val/predict arguments."""
 
-    if getattr(args, 'save_dir', None):
+    if getattr(args, "save_dir", None):
         save_dir = args.save_dir
     else:
         from ultralytics.utils.files import increment_path
 
-        project = args.project or (ROOT.parent / 'tests/tmp/runs' if TESTS_RUNNING else RUNS_DIR) / args.task
-        name = name or args.name or f'{args.mode}'
-        save_dir = increment_path(Path(project) / name, exist_ok=args.exist_ok if RANK in (-1, 0) else True)
+        project = args.project or (ROOT.parent / "tests/tmp/runs" if TESTS_RUNNING else RUNS_DIR) / args.task
+        name = name or args.name or f"{args.mode}"
+        save_dir = increment_path(Path(project) / name, exist_ok=args.exist_ok if RANK in {-1, 0} else True)
 
     return Path(save_dir)
 
 
 def _handle_deprecation(custom):
     """Hardcoded function to handle deprecated config keys."""
 
     for key in custom.copy().keys():
-        if key == 'boxes':
-            deprecation_warn(key, 'show_boxes')
-            custom['show_boxes'] = custom.pop('boxes')
-        if key == 'hide_labels':
-            deprecation_warn(key, 'show_labels')
-            custom['show_labels'] = custom.pop('hide_labels') == 'False'
-        if key == 'hide_conf':
-            deprecation_warn(key, 'show_conf')
-            custom['show_conf'] = custom.pop('hide_conf') == 'False'
-        if key == 'line_thickness':
-            deprecation_warn(key, 'line_width')
-            custom['line_width'] = custom.pop('line_thickness')
+        if key == "boxes":
+            deprecation_warn(key, "show_boxes")
+            custom["show_boxes"] = custom.pop("boxes")
+        if key == "hide_labels":
+            deprecation_warn(key, "show_labels")
+            custom["show_labels"] = custom.pop("hide_labels") == "False"
+        if key == "hide_conf":
+            deprecation_warn(key, "show_conf")
+            custom["show_conf"] = custom.pop("hide_conf") == "False"
+        if key == "line_thickness":
+            deprecation_warn(key, "line_width")
+            custom["line_width"] = custom.pop("line_thickness")
 
     return custom
 
 
 def check_dict_alignment(base: Dict, custom: Dict, e=None):
     """
     This function checks for any mismatched keys between a custom configuration list and a base configuration list. If
@@ -192,43 +309,43 @@
     """
     custom = _handle_deprecation(custom)
     base_keys, custom_keys = (set(x.keys()) for x in (base, custom))
     mismatched = [k for k in custom_keys if k not in base_keys]
     if mismatched:
         from difflib import get_close_matches
 
-        string = ''
+        string = ""
         for x in mismatched:
             matches = get_close_matches(x, base_keys)  # key list
-            matches = [f'{k}={base[k]}' if base.get(k) is not None else k for k in matches]
-            match_str = f'Similar arguments are i.e. {matches}.' if matches else ''
+            matches = [f"{k}={base[k]}" if base.get(k) is not None else k for k in matches]
+            match_str = f"Similar arguments are i.e. {matches}." if matches else ""
             string += f"'{colorstr('red', 'bold', x)}' is not a valid YOLO argument. {match_str}\n"
         raise SyntaxError(string + CLI_HELP_MSG) from e
 
 
 def merge_equals_args(args: List[str]) -> List[str]:
     """
     Merges arguments around isolated '=' args in a list of strings. The function considers cases where the first
     argument ends with '=' or the second starts with '=', as well as when the middle one is an equals sign.
 
     Args:
         args (List[str]): A list of strings where each element is an argument.
 
     Returns:
-        List[str]: A list of strings where the arguments around isolated '=' are merged.
+        (List[str]): A list of strings where the arguments around isolated '=' are merged.
     """
     new_args = []
     for i, arg in enumerate(args):
-        if arg == '=' and 0 < i < len(args) - 1:  # merge ['arg', '=', 'val']
-            new_args[-1] += f'={args[i + 1]}'
+        if arg == "=" and 0 < i < len(args) - 1:  # merge ['arg', '=', 'val']
+            new_args[-1] += f"={args[i + 1]}"
             del args[i + 1]
-        elif arg.endswith('=') and i < len(args) - 1 and '=' not in args[i + 1]:  # merge ['arg=', 'val']
-            new_args.append(f'{arg}{args[i + 1]}')
+        elif arg.endswith("=") and i < len(args) - 1 and "=" not in args[i + 1]:  # merge ['arg=', 'val']
+            new_args.append(f"{arg}{args[i + 1]}")
             del args[i + 1]
-        elif arg.startswith('=') and i > 0:  # merge ['arg', '=val']
+        elif arg.startswith("=") and i > 0:  # merge ['arg', '=val']
             new_args[-1] += arg
         else:
             new_args.append(arg)
     return new_args
 
 
 def handle_yolo_hub(args: List[str]) -> None:
@@ -244,19 +361,19 @@
     Example:
         ```bash
         python my_script.py hub login your_api_key
         ```
     """
     from ultralytics import hub
 
-    if args[0] == 'login':
-        key = args[1] if len(args) > 1 else ''
+    if args[0] == "login":
+        key = args[1] if len(args) > 1 else ""
         # Log in to Ultralytics HUB using the provided API key
         hub.login(key)
-    elif args[0] == 'logout':
+    elif args[0] == "logout":
         # Log out from Ultralytics HUB
         hub.logout()
 
 
 def handle_yolo_settings(args: List[str]) -> None:
     """
     Handle YOLO settings command-line interface (CLI) commands.
@@ -268,198 +385,217 @@
         args (List[str]): A list of command line arguments for YOLO settings management.
 
     Example:
         ```bash
         python my_script.py yolo settings reset
         ```
     """
-    url = 'https://docs.ultralytics.com/quickstart/#ultralytics-settings'  # help URL
+    url = "https://docs.ultralytics.com/quickstart/#ultralytics-settings"  # help URL
     try:
         if any(args):
-            if args[0] == 'reset':
+            if args[0] == "reset":
                 SETTINGS_YAML.unlink()  # delete the settings file
                 SETTINGS.reset()  # create new settings
-                LOGGER.info('Settings reset successfully')  # inform the user that settings have been reset
+                LOGGER.info("Settings reset successfully")  # inform the user that settings have been reset
             else:  # save a new setting
                 new = dict(parse_key_value_pair(a) for a in args)
                 check_dict_alignment(SETTINGS, new)
                 SETTINGS.update(new)
 
-        LOGGER.info(f' Learn about settings at {url}')
+        LOGGER.info(f" Learn about settings at {url}")
         yaml_print(SETTINGS_YAML)  # print the current settings
     except Exception as e:
         LOGGER.warning(f"WARNING  settings error: '{e}'. Please see {url} for help.")
 
 
+def handle_explorer():
+    """Open the Ultralytics Explorer GUI."""
+    checks.check_requirements("streamlit")
+    LOGGER.info(" Loading Explorer dashboard...")
+    subprocess.run(["streamlit", "run", ROOT / "data/explorer/gui/dash.py", "--server.maxMessageSize", "2048"])
+
+
 def parse_key_value_pair(pair):
     """Parse one 'key=value' pair and return key and value."""
-    k, v = pair.split('=', 1)  # split on first '=' sign
+    k, v = pair.split("=", 1)  # split on first '=' sign
     k, v = k.strip(), v.strip()  # remove spaces
     assert v, f"missing '{k}' value"
     return k, smart_value(v)
 
 
 def smart_value(v):
     """Convert a string to an underlying type such as int, float, bool, etc."""
     v_lower = v.lower()
-    if v_lower == 'none':
+    if v_lower == "none":
         return None
-    elif v_lower == 'true':
+    elif v_lower == "true":
         return True
-    elif v_lower == 'false':
+    elif v_lower == "false":
         return False
     else:
         with contextlib.suppress(Exception):
             return eval(v)
         return v
 
 
-def entrypoint(debug=''):
+def entrypoint(debug=""):
     """
     This function is the ultralytics package entrypoint, it's responsible for parsing the command line arguments passed
     to the package.
 
     This function allows for:
     - passing mandatory YOLO args as a list of strings
     - specifying the task to be performed, either 'detect', 'segment' or 'classify'
     - specifying the mode, either 'train', 'val', 'test', or 'predict'
     - running special modes like 'checks'
     - passing overrides to the package's configuration
 
     It uses the package's default cfg and initializes it using the passed overrides.
     Then it calls the CLI function with the composed cfg
     """
-    args = (debug.split(' ') if debug else sys.argv)[1:]
+    args = (debug.split(" ") if debug else ARGV)[1:]
     if not args:  # no arguments passed
         LOGGER.info(CLI_HELP_MSG)
         return
 
     special = {
-        'help': lambda: LOGGER.info(CLI_HELP_MSG),
-        'checks': checks.collect_system_info,
-        'version': lambda: LOGGER.info(__version__),
-        'settings': lambda: handle_yolo_settings(args[1:]),
-        'cfg': lambda: yaml_print(DEFAULT_CFG_PATH),
-        'hub': lambda: handle_yolo_hub(args[1:]),
-        'login': lambda: handle_yolo_hub(args),
-        'copy-cfg': copy_default_cfg}
+        "help": lambda: LOGGER.info(CLI_HELP_MSG),
+        "checks": checks.collect_system_info,
+        "version": lambda: LOGGER.info(__version__),
+        "settings": lambda: handle_yolo_settings(args[1:]),
+        "cfg": lambda: yaml_print(DEFAULT_CFG_PATH),
+        "hub": lambda: handle_yolo_hub(args[1:]),
+        "login": lambda: handle_yolo_hub(args),
+        "copy-cfg": copy_default_cfg,
+        "explorer": lambda: handle_explorer(),
+    }
     full_args_dict = {**DEFAULT_CFG_DICT, **{k: None for k in TASKS}, **{k: None for k in MODES}, **special}
 
     # Define common misuses of special commands, i.e. -h, -help, --help
     special.update({k[0]: v for k, v in special.items()})  # singular
-    special.update({k[:-1]: v for k, v in special.items() if len(k) > 1 and k.endswith('s')})  # singular
-    special = {**special, **{f'-{k}': v for k, v in special.items()}, **{f'--{k}': v for k, v in special.items()}}
+    special.update({k[:-1]: v for k, v in special.items() if len(k) > 1 and k.endswith("s")})  # singular
+    special = {**special, **{f"-{k}": v for k, v in special.items()}, **{f"--{k}": v for k, v in special.items()}}
 
     overrides = {}  # basic overrides, i.e. imgsz=320
     for a in merge_equals_args(args):  # merge spaces around '=' sign
-        if a.startswith('--'):
-            LOGGER.warning(f"WARNING  '{a}' does not require leading dashes '--', updating to '{a[2:]}'.")
+        if a.startswith("--"):
+            LOGGER.warning(f"WARNING  argument '{a}' does not require leading dashes '--', updating to '{a[2:]}'.")
             a = a[2:]
-        if a.endswith(','):
-            LOGGER.warning(f"WARNING  '{a}' does not require trailing comma ',', updating to '{a[:-1]}'.")
+        if a.endswith(","):
+            LOGGER.warning(f"WARNING  argument '{a}' does not require trailing comma ',', updating to '{a[:-1]}'.")
             a = a[:-1]
-        if '=' in a:
+        if "=" in a:
             try:
                 k, v = parse_key_value_pair(a)
-                if k == 'cfg' and v is not None:  # custom.yaml passed
-                    LOGGER.info(f'Overriding {DEFAULT_CFG_PATH} with {v}')
-                    overrides = {k: val for k, val in yaml_load(checks.check_yaml(v)).items() if k != 'cfg'}
+                if k == "cfg" and v is not None:  # custom.yaml passed
+                    LOGGER.info(f"Overriding {DEFAULT_CFG_PATH} with {v}")
+                    overrides = {k: val for k, val in yaml_load(checks.check_yaml(v)).items() if k != "cfg"}
                 else:
                     overrides[k] = v
             except (NameError, SyntaxError, ValueError, AssertionError) as e:
-                check_dict_alignment(full_args_dict, {a: ''}, e)
+                check_dict_alignment(full_args_dict, {a: ""}, e)
 
         elif a in TASKS:
-            overrides['task'] = a
+            overrides["task"] = a
         elif a in MODES:
-            overrides['mode'] = a
+            overrides["mode"] = a
         elif a.lower() in special:
             special[a.lower()]()
             return
         elif a in DEFAULT_CFG_DICT and isinstance(DEFAULT_CFG_DICT[a], bool):
             overrides[a] = True  # auto-True for default bool args, i.e. 'yolo show' sets show=True
         elif a in DEFAULT_CFG_DICT:
-            raise SyntaxError(f"'{colorstr('red', 'bold', a)}' is a valid YOLO argument but is missing an '=' sign "
-                              f"to set its value, i.e. try '{a}={DEFAULT_CFG_DICT[a]}'\n{CLI_HELP_MSG}")
+            raise SyntaxError(
+                f"'{colorstr('red', 'bold', a)}' is a valid YOLO argument but is missing an '=' sign "
+                f"to set its value, i.e. try '{a}={DEFAULT_CFG_DICT[a]}'\n{CLI_HELP_MSG}"
+            )
         else:
-            check_dict_alignment(full_args_dict, {a: ''})
+            check_dict_alignment(full_args_dict, {a: ""})
 
     # Check keys
     check_dict_alignment(full_args_dict, overrides)
 
     # Mode
-    mode = overrides.get('mode')
+    mode = overrides.get("mode")
     if mode is None:
-        mode = DEFAULT_CFG.mode or 'predict'
-        LOGGER.warning(f"WARNING  'mode' is missing. Valid modes are {MODES}. Using default 'mode={mode}'.")
+        mode = DEFAULT_CFG.mode or "predict"
+        LOGGER.warning(f"WARNING  'mode' argument is missing. Valid modes are {MODES}. Using default 'mode={mode}'.")
     elif mode not in MODES:
         raise ValueError(f"Invalid 'mode={mode}'. Valid modes are {MODES}.\n{CLI_HELP_MSG}")
 
     # Task
-    task = overrides.pop('task', None)
+    task = overrides.pop("task", None)
     if task:
         if task not in TASKS:
             raise ValueError(f"Invalid 'task={task}'. Valid tasks are {TASKS}.\n{CLI_HELP_MSG}")
-        if 'model' not in overrides:
-            overrides['model'] = TASK2MODEL[task]
+        if "model" not in overrides:
+            overrides["model"] = TASK2MODEL[task]
 
     # Model
-    model = overrides.pop('model', DEFAULT_CFG.model)
+    model = overrides.pop("model", DEFAULT_CFG.model)
     if model is None:
-        model = 'yolov8n.pt'
-        LOGGER.warning(f"WARNING  'model' is missing. Using default 'model={model}'.")
-    overrides['model'] = model
+        model = "yolov8n.pt"
+        LOGGER.warning(f"WARNING  'model' argument is missing. Using default 'model={model}'.")
+    overrides["model"] = model
     stem = Path(model).stem.lower()
-    if 'rtdetr' in stem:  # guess architecture
+    if "rtdetr" in stem:  # guess architecture
         from ultralytics import RTDETR
+
         model = RTDETR(model)  # no task argument
-    elif 'fastsam' in stem:
+    elif "fastsam" in stem:
         from ultralytics import FastSAM
+
         model = FastSAM(model)
-    elif 'sam' in stem:
+    elif "sam" in stem:
         from ultralytics import SAM
+
         model = SAM(model)
     else:
         from ultralytics import YOLO
+
         model = YOLO(model, task=task)
-    if isinstance(overrides.get('pretrained'), str):
-        model.load(overrides['pretrained'])
+    if isinstance(overrides.get("pretrained"), str):
+        model.load(overrides["pretrained"])
 
     # Task Update
     if task != model.task:
         if task:
-            LOGGER.warning(f"WARNING  conflicting 'task={task}' passed with 'task={model.task}' model. "
-                           f"Ignoring 'task={task}' and updating to 'task={model.task}' to match model.")
+            LOGGER.warning(
+                f"WARNING  conflicting 'task={task}' passed with 'task={model.task}' model. "
+                f"Ignoring 'task={task}' and updating to 'task={model.task}' to match model."
+            )
         task = model.task
 
     # Mode
-    if mode in ('predict', 'track') and 'source' not in overrides:
-        overrides['source'] = DEFAULT_CFG.source or ASSETS
-        LOGGER.warning(f"WARNING  'source' is missing. Using default 'source={overrides['source']}'.")
-    elif mode in ('train', 'val'):
-        if 'data' not in overrides and 'resume' not in overrides:
-            overrides['data'] = TASK2DATA.get(task or DEFAULT_CFG.task, DEFAULT_CFG.data)
-            LOGGER.warning(f"WARNING  'data' is missing. Using default 'data={overrides['data']}'.")
-    elif mode == 'export':
-        if 'format' not in overrides:
-            overrides['format'] = DEFAULT_CFG.format or 'torchscript'
-            LOGGER.warning(f"WARNING  'format' is missing. Using default 'format={overrides['format']}'.")
+    if mode in {"predict", "track"} and "source" not in overrides:
+        overrides["source"] = DEFAULT_CFG.source or ASSETS
+        LOGGER.warning(f"WARNING  'source' argument is missing. Using default 'source={overrides['source']}'.")
+    elif mode in {"train", "val"}:
+        if "data" not in overrides and "resume" not in overrides:
+            overrides["data"] = DEFAULT_CFG.data or TASK2DATA.get(task or DEFAULT_CFG.task, DEFAULT_CFG.data)
+            LOGGER.warning(f"WARNING  'data' argument is missing. Using default 'data={overrides['data']}'.")
+    elif mode == "export":
+        if "format" not in overrides:
+            overrides["format"] = DEFAULT_CFG.format or "torchscript"
+            LOGGER.warning(f"WARNING  'format' argument is missing. Using default 'format={overrides['format']}'.")
 
     # Run command in python
     getattr(model, mode)(**overrides)  # default args from model
 
     # Show help
-    LOGGER.info(f' Learn more at https://docs.ultralytics.com/modes/{mode}')
+    LOGGER.info(f" Learn more at https://docs.ultralytics.com/modes/{mode}")
 
 
 # Special modes --------------------------------------------------------------------------------------------------------
 def copy_default_cfg():
     """Copy and create a new default configuration file with '_copy' appended to its name."""
-    new_file = Path.cwd() / DEFAULT_CFG_PATH.name.replace('.yaml', '_copy.yaml')
+    new_file = Path.cwd() / DEFAULT_CFG_PATH.name.replace(".yaml", "_copy.yaml")
     shutil.copy2(DEFAULT_CFG_PATH, new_file)
-    LOGGER.info(f'{DEFAULT_CFG_PATH} copied to {new_file}\n'
-                f"Example YOLO command with this new custom cfg:\n    yolo cfg='{new_file}' imgsz=320 batch=8")
+    LOGGER.info(
+        f"{DEFAULT_CFG_PATH} copied to {new_file}\n"
+        f"Example YOLO command with this new custom cfg:\n    yolo cfg='{new_file}' imgsz=320 batch=8"
+    )
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     # Example: entrypoint(debug='yolo predict model=yolov8n.pt')
-    entrypoint(debug='')
+    entrypoint(debug="")
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/Argoverse.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/Argoverse.yaml`

 * *Files 18% similar despite different names*

```diff
@@ -1,34 +1,33 @@
 # Ultralytics YOLO , AGPL-3.0 license
-# Argoverse-HD dataset (ring-front-center camera) http://www.cs.cmu.edu/~mengtial/proj/streaming/ by Argo AI
+# Argoverse-HD dataset (ring-front-center camera) https://www.cs.cmu.edu/~mengtial/proj/streaming/ by Argo AI
+# Documentation: https://docs.ultralytics.com/datasets/detect/argoverse/
 # Example usage: yolo train data=Argoverse.yaml
 # parent
 #  ultralytics
 #  datasets
 #      Argoverse   downloads here (31.5 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/Argoverse  # dataset root dir
-train: Argoverse-1.1/images/train/  # train images (relative to 'path') 39384 images
-val: Argoverse-1.1/images/val/  # val images (relative to 'path') 15062 images
-test: Argoverse-1.1/images/test/  # test images (optional) https://eval.ai/web/challenges/challenge-page/800/overview
+path: ../datasets/Argoverse # dataset root dir
+train: Argoverse-1.1/images/train/ # train images (relative to 'path') 39384 images
+val: Argoverse-1.1/images/val/ # val images (relative to 'path') 15062 images
+test: Argoverse-1.1/images/test/ # test images (optional) https://eval.ai/web/challenges/challenge-page/800/overview
 
 # Classes
 names:
   0: person
   1: bicycle
   2: car
   3: motorcycle
   4: bus
   5: truck
   6: traffic_light
   7: stop_sign
 
-
 # Download script/URL (optional) ---------------------------------------------------------------------------------------
 download: |
   import json
   from tqdm import tqdm
   from ultralytics.utils.downloads import download
   from pathlib import Path
 
@@ -60,14 +59,16 @@
           with open(k, "w") as f:
               f.writelines(labels[k])
 
 
   # Download 'https://argoverse-hd.s3.us-east-2.amazonaws.com/Argoverse-HD-Full.zip' (deprecated S3 link)
   dir = Path(yaml['path'])  # dataset root dir
   urls = ['https://drive.google.com/file/d/1st9qW3BeIwQsnR0t8mRpvbsSWIo16ACi/view?usp=drive_link']
-  download(urls, dir=dir)
+  print("\n\nWARNING: Argoverse dataset MUST be downloaded manually, autodownload will NOT work.")
+  print(f"WARNING: Manually download Argoverse dataset '{urls[0]}' to '{dir}' and re-run your command.\n\n")
+  # download(urls, dir=dir)
 
   # Convert
   annotations_dir = 'Argoverse-HD/annotations/'
   (dir / 'Argoverse-1.1' / 'tracking').rename(dir / 'Argoverse-1.1' / 'images')  # rename 'tracking' to 'images'
   for d in "train.json", "val.json":
       argoverse2yolo(dir / annotations_dir / d)  # convert Argoverse annotations to YOLO labels
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/DOTAv2.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/DOTAv1.yaml`

 * *Files 11% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 # Ultralytics YOLO , AGPL-3.0 license
-# DOTA 2.0 dataset https://captain-whu.github.io/DOTA/index.html for object detection in aerial images by Wuhan University
-# Example usage: yolo train model=yolov8n-obb.pt data=DOTAv2.yaml
+# DOTA 1.0 dataset https://captain-whu.github.io/DOTA/index.html for object detection in aerial images by Wuhan University
+# Documentation: https://docs.ultralytics.com/datasets/obb/dota-v2/
+# Example usage: yolo train model=yolov8n-obb.pt data=DOTAv1.yaml
 # parent
 #  ultralytics
 #  datasets
-#      dota2   downloads here (2GB)
+#      dota1   downloads here (2GB)
 
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/DOTAv2  # dataset root dir
-train: images/train  # train images (relative to 'path') 1411 images
-val: images/val  # val images (relative to 'path') 458 images
-test: images/test  # test images (optional) 937 images
+path: ../datasets/DOTAv1 # dataset root dir
+train: images/train # train images (relative to 'path') 1411 images
+val: images/val # val images (relative to 'path') 458 images
+test: images/test # test images (optional) 937 images
 
-# Classes for DOTA 2.0
+# Classes for DOTA 1.0
 names:
   0: plane
   1: ship
   2: storage tank
   3: baseball diamond
   4: tennis court
   5: basketball court
@@ -25,13 +26,10 @@
   8: bridge
   9: large vehicle
   10: small vehicle
   11: helicopter
   12: roundabout
   13: soccer ball field
   14: swimming pool
-  15: container crane
-  16: airport
-  17: helipad
 
 # Download script/URL (optional)
-download: https://github.com/ultralytics/yolov5/releases/download/v1.0/DOTAv2.zip
+download: https://github.com/ultralytics/yolov5/releases/download/v1.0/DOTAv1.zip
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/GlobalWheat2020.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/GlobalWheat2020.yaml`

 * *Files 5% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 # Ultralytics YOLO , AGPL-3.0 license
-# Global Wheat 2020 dataset http://www.global-wheat.com/ by University of Saskatchewan
+# Global Wheat 2020 dataset https://www.global-wheat.com/ by University of Saskatchewan
+# Documentation: https://docs.ultralytics.com/datasets/detect/globalwheat2020/
 # Example usage: yolo train data=GlobalWheat2020.yaml
 # parent
 #  ultralytics
 #  datasets
 #      GlobalWheat2020   downloads here (7.0 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/GlobalWheat2020  # dataset root dir
+path: ../datasets/GlobalWheat2020 # dataset root dir
 train: # train images (relative to 'path') 3422 images
   - images/arvalis_1
   - images/arvalis_2
   - images/arvalis_3
   - images/ethz_1
   - images/rres_1
   - images/inrae_1
@@ -25,15 +25,14 @@
   - images/nau_1
   - images/uq_1
 
 # Classes
 names:
   0: wheat_head
 
-
 # Download script/URL (optional) ---------------------------------------------------------------------------------------
 download: |
   from ultralytics.utils.downloads import download
   from pathlib import Path
 
   # Download
   dir = Path(yaml['path'])  # dataset root dir
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/ImageNet.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/ImageNet.yaml`

 * *Files 0% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # ImageNet-1k dataset https://www.image-net.org/index.php by Stanford University
 # Simplified class names from https://github.com/anishathalye/imagenet-simple-labels
+# Documentation: https://docs.ultralytics.com/datasets/classify/imagenet/
 # Example usage: yolo train task=classify data=imagenet
 # parent
 #  ultralytics
 #  datasets
 #      imagenet   downloads here (144 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/imagenet  # dataset root dir
-train: train  # train images (relative to 'path') 1281167 images
-val: val  # val images (relative to 'path') 50000 images
-test:  # test images (optional)
+path: ../datasets/imagenet # dataset root dir
+train: train # train images (relative to 'path') 1281167 images
+val: val # val images (relative to 'path') 50000 images
+test: # test images (optional)
 
 # Classes
 names:
   0: tench
   1: goldfish
   2: great white shark
   3: tiger shark
@@ -2016,10 +2016,9 @@
   n13040303: stinkhorn
   n13044778: earthstar
   n13052670: hen-of-the-woods
   n13054560: bolete
   n13133613: ear
   n15075141: toilet_tissue
 
-
 # Download script/URL (optional)
 download: yolo/data/scripts/get_imagenet.sh
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/Objects365.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/Objects365.yaml`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # Objects365 dataset https://www.objects365.org/ by Megvii
+# Documentation: https://docs.ultralytics.com/datasets/detect/objects365/
 # Example usage: yolo train data=Objects365.yaml
 # parent
 #  ultralytics
 #  datasets
 #      Objects365   downloads here (712 GB = 367G data + 345G zips)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/Objects365  # dataset root dir
-train: images/train  # train images (relative to 'path') 1742289 images
+path: ../datasets/Objects365 # dataset root dir
+train: images/train # train images (relative to 'path') 1742289 images
 val: images/val # val images (relative to 'path') 80000 images
-test:  # test images (optional)
+test: # test images (optional)
 
 # Classes
 names:
   0: Person
   1: Sneakers
   2: Chair
   3: Other Shoes
@@ -377,15 +377,14 @@
   359: Durian
   360: Okra
   361: Lipstick
   362: Cosmetics Mirror
   363: Curling
   364: Table Tennis
 
-
 # Download script/URL (optional) ---------------------------------------------------------------------------------------
 download: |
   from tqdm import tqdm
 
   from ultralytics.utils.checks import check_requirements
   from ultralytics.utils.downloads import download
   from ultralytics.utils.ops import xyxy2xywhn
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/SKU-110K.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/SKU-110K.yaml`

 * *Files 8% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # SKU-110K retail items dataset https://github.com/eg4000/SKU110K_CVPR19 by Trax Retail
+# Documentation: https://docs.ultralytics.com/datasets/detect/sku-110k/
 # Example usage: yolo train data=SKU-110K.yaml
 # parent
 #  ultralytics
 #  datasets
 #      SKU-110K   downloads here (13.6 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/SKU-110K  # dataset root dir
-train: train.txt  # train images (relative to 'path')  8219 images
-val: val.txt  # val images (relative to 'path')  588 images
-test: test.txt  # test images (optional)  2936 images
+path: ../datasets/SKU-110K # dataset root dir
+train: train.txt # train images (relative to 'path')  8219 images
+val: val.txt # val images (relative to 'path')  588 images
+test: test.txt # test images (optional)  2936 images
 
 # Classes
 names:
   0: object
 
-
 # Download script/URL (optional) ---------------------------------------------------------------------------------------
 download: |
   import shutil
   from pathlib import Path
 
   import numpy as np
   import pandas as pd
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/VOC.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/VOC.yaml`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # PASCAL VOC dataset http://host.robots.ox.ac.uk/pascal/VOC by University of Oxford
+# Documentation: # Documentation: https://docs.ultralytics.com/datasets/detect/voc/
 # Example usage: yolo train data=VOC.yaml
 # parent
 #  ultralytics
 #  datasets
 #      VOC   downloads here (2.8 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
 path: ../datasets/VOC
 train: # train images (relative to 'path')  16551 images
   - images/train2012
   - images/train2007
   - images/val2012
   - images/val2007
@@ -38,15 +38,14 @@
   14: person
   15: pottedplant
   16: sheep
   17: sofa
   18: train
   19: tvmonitor
 
-
 # Download script/URL (optional) ---------------------------------------------------------------------------------------
 download: |
   import xml.etree.ElementTree as ET
 
   from tqdm import tqdm
   from ultralytics.utils.downloads import download
   from pathlib import Path
@@ -77,15 +76,15 @@
 
   # Download
   dir = Path(yaml['path'])  # dataset root dir
   url = 'https://github.com/ultralytics/yolov5/releases/download/v1.0/'
   urls = [f'{url}VOCtrainval_06-Nov-2007.zip',  # 446MB, 5012 images
           f'{url}VOCtest_06-Nov-2007.zip',  # 438MB, 4953 images
           f'{url}VOCtrainval_11-May-2012.zip']  # 1.95GB, 17126 images
-  download(urls, dir=dir / 'images', curl=True, threads=3)
+  download(urls, dir=dir / 'images', curl=True, threads=3, exist_ok=True)  # download and unzip over existing paths (required)
 
   # Convert
   path = dir / 'images/VOCdevkit'
   for year, image_set in ('2012', 'train'), ('2012', 'val'), ('2007', 'train'), ('2007', 'val'), ('2007', 'test'):
       imgs_path = dir / 'images' / f'{image_set}{year}'
       lbs_path = dir / 'labels' / f'{image_set}{year}'
       imgs_path.mkdir(exist_ok=True, parents=True)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/VisDrone.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/VisDrone.yaml`

 * *Files 2% similar despite different names*

```diff
@@ -1,36 +1,35 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # VisDrone2019-DET dataset https://github.com/VisDrone/VisDrone-Dataset by Tianjin University
+# Documentation: https://docs.ultralytics.com/datasets/detect/visdrone/
 # Example usage: yolo train data=VisDrone.yaml
 # parent
 #  ultralytics
 #  datasets
 #      VisDrone   downloads here (2.3 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/VisDrone  # dataset root dir
-train: VisDrone2019-DET-train/images  # train images (relative to 'path')  6471 images
-val: VisDrone2019-DET-val/images  # val images (relative to 'path')  548 images
-test: VisDrone2019-DET-test-dev/images  # test images (optional)  1610 images
+path: ../datasets/VisDrone # dataset root dir
+train: VisDrone2019-DET-train/images # train images (relative to 'path')  6471 images
+val: VisDrone2019-DET-val/images # val images (relative to 'path')  548 images
+test: VisDrone2019-DET-test-dev/images # test images (optional)  1610 images
 
 # Classes
 names:
   0: pedestrian
   1: people
   2: bicycle
   3: car
   4: van
   5: truck
   6: tricycle
   7: awning-tricycle
   8: bus
   9: motor
 
-
 # Download script/URL (optional) ---------------------------------------------------------------------------------------
 download: |
   import os
   from pathlib import Path
 
   from ultralytics.utils.downloads import download
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco-pose.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco-pose.yaml`

 * *Files 4% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 # Ultralytics YOLO , AGPL-3.0 license
-# COCO 2017 dataset http://cocodataset.org by Microsoft
+# COCO 2017 dataset https://cocodataset.org by Microsoft
+# Documentation: https://docs.ultralytics.com/datasets/pose/coco/
 # Example usage: yolo train data=coco-pose.yaml
 # parent
 #  ultralytics
 #  datasets
 #      coco-pose   downloads here (20.1 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/coco-pose  # dataset root dir
-train: train2017.txt  # train images (relative to 'path') 118287 images
-val: val2017.txt  # val images (relative to 'path') 5000 images
-test: test-dev2017.txt  # 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794
+path: ../datasets/coco-pose # dataset root dir
+train: train2017.txt # train images (relative to 'path') 118287 images
+val: val2017.txt # val images (relative to 'path') 5000 images
+test: test-dev2017.txt # 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794
 
 # Keypoints
-kpt_shape: [17, 3]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
+kpt_shape: [17, 3] # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
 flip_idx: [0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]
 
 # Classes
 names:
   0: person
 
 # Download script/URL (optional)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco.yaml`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # Ultralytics YOLO , AGPL-3.0 license
-# COCO 2017 dataset http://cocodataset.org by Microsoft
+# COCO 2017 dataset https://cocodataset.org by Microsoft
+# Documentation: https://docs.ultralytics.com/datasets/detect/coco/
 # Example usage: yolo train data=coco.yaml
 # parent
 #  ultralytics
 #  datasets
 #      coco   downloads here (20.1 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/coco  # dataset root dir
-train: train2017.txt  # train images (relative to 'path') 118287 images
-val: val2017.txt  # val images (relative to 'path') 5000 images
-test: test-dev2017.txt  # 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794
+path: ../datasets/coco # dataset root dir
+train: train2017.txt # train images (relative to 'path') 118287 images
+val: val2017.txt # val images (relative to 'path') 5000 images
+test: test-dev2017.txt # 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794
 
 # Classes
 names:
   0: person
   1: bicycle
   2: car
   3: motorcycle
@@ -92,15 +92,14 @@
   74: clock
   75: vase
   76: scissors
   77: teddy bear
   78: hair drier
   79: toothbrush
 
-
 # Download script/URL (optional)
 download: |
   from ultralytics.utils.downloads import download
   from pathlib import Path
 
   # Download labels
   segments = True  # segment or box labels
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco128-seg.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco128-seg.yaml`

 * *Files 3% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # COCO128-seg dataset https://www.kaggle.com/ultralytics/coco128 (first 128 images from COCO train2017) by Ultralytics
+# Documentation: https://docs.ultralytics.com/datasets/segment/coco/
 # Example usage: yolo train data=coco128.yaml
 # parent
 #  ultralytics
 #  datasets
 #      coco128-seg   downloads here (7 MB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/coco128-seg  # dataset root dir
-train: images/train2017  # train images (relative to 'path') 128 images
-val: images/train2017  # val images (relative to 'path') 128 images
-test:  # test images (optional)
+path: ../datasets/coco128-seg # dataset root dir
+train: images/train2017 # train images (relative to 'path') 128 images
+val: images/train2017 # val images (relative to 'path') 128 images
+test: # test images (optional)
 
 # Classes
 names:
   0: person
   1: bicycle
   2: car
   3: motorcycle
@@ -92,10 +92,9 @@
   74: clock
   75: vase
   76: scissors
   77: teddy bear
   78: hair drier
   79: toothbrush
 
-
 # Download script/URL (optional)
 download: https://ultralytics.com/assets/coco128-seg.zip
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco128.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco128.yaml`

 * *Files 3% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # COCO128 dataset https://www.kaggle.com/ultralytics/coco128 (first 128 images from COCO train2017) by Ultralytics
+# Documentation: https://docs.ultralytics.com/datasets/detect/coco/
 # Example usage: yolo train data=coco128.yaml
 # parent
 #  ultralytics
 #  datasets
 #      coco128   downloads here (7 MB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/coco128  # dataset root dir
-train: images/train2017  # train images (relative to 'path') 128 images
-val: images/train2017  # val images (relative to 'path') 128 images
-test:  # test images (optional)
+path: ../datasets/coco128 # dataset root dir
+train: images/train2017 # train images (relative to 'path') 128 images
+val: images/train2017 # val images (relative to 'path') 128 images
+test: # test images (optional)
 
 # Classes
 names:
   0: person
   1: bicycle
   2: car
   3: motorcycle
@@ -92,10 +92,9 @@
   74: clock
   75: vase
   76: scissors
   77: teddy bear
   78: hair drier
   79: toothbrush
 
-
 # Download script/URL (optional)
 download: https://ultralytics.com/assets/coco128.zip
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco8-pose.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco8-pose.yaml`

 * *Files 15% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # COCO8-pose dataset (first 8 images from COCO train2017) by Ultralytics
+# Documentation: https://docs.ultralytics.com/datasets/pose/coco8-pose/
 # Example usage: yolo train data=coco8-pose.yaml
 # parent
 #  ultralytics
 #  datasets
 #      coco8-pose   downloads here (1 MB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/coco8-pose  # dataset root dir
-train: images/train  # train images (relative to 'path') 4 images
-val: images/val  # val images (relative to 'path') 4 images
-test:  # test images (optional)
+path: ../datasets/coco8-pose # dataset root dir
+train: images/train # train images (relative to 'path') 4 images
+val: images/val # val images (relative to 'path') 4 images
+test: # test images (optional)
 
 # Keypoints
-kpt_shape: [17, 3]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
+kpt_shape: [17, 3] # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
 flip_idx: [0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]
 
 # Classes
 names:
   0: person
 
 # Download script/URL (optional)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco8-seg.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco8-seg.yaml`

 * *Files 11% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # COCO8-seg dataset (first 8 images from COCO train2017) by Ultralytics
+# Documentation: https://docs.ultralytics.com/datasets/segment/coco8-seg/
 # Example usage: yolo train data=coco8-seg.yaml
 # parent
 #  ultralytics
 #  datasets
 #      coco8-seg   downloads here (1 MB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/coco8-seg  # dataset root dir
-train: images/train  # train images (relative to 'path') 4 images
-val: images/val  # val images (relative to 'path') 4 images
-test:  # test images (optional)
+path: ../datasets/coco8-seg # dataset root dir
+train: images/train # train images (relative to 'path') 4 images
+val: images/val # val images (relative to 'path') 4 images
+test: # test images (optional)
 
 # Classes
 names:
   0: person
   1: bicycle
   2: car
   3: motorcycle
@@ -92,10 +92,9 @@
   74: clock
   75: vase
   76: scissors
   77: teddy bear
   78: hair drier
   79: toothbrush
 
-
 # Download script/URL (optional)
 download: https://ultralytics.com/assets/coco8-seg.zip
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/coco8.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/coco8.yaml`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # COCO8 dataset (first 8 images from COCO train2017) by Ultralytics
+# Documentation: https://docs.ultralytics.com/datasets/detect/coco8/
 # Example usage: yolo train data=coco8.yaml
 # parent
 #  ultralytics
 #  datasets
 #      coco8   downloads here (1 MB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/coco8  # dataset root dir
-train: images/train  # train images (relative to 'path') 4 images
-val: images/val  # val images (relative to 'path') 4 images
-test:  # test images (optional)
+path: ../datasets/coco8 # dataset root dir
+train: images/train # train images (relative to 'path') 4 images
+val: images/val # val images (relative to 'path') 4 images
+test: # test images (optional)
 
 # Classes
 names:
   0: person
   1: bicycle
   2: car
   3: motorcycle
@@ -92,10 +92,9 @@
   74: clock
   75: vase
   76: scissors
   77: teddy bear
   78: hair drier
   79: toothbrush
 
-
 # Download script/URL (optional)
 download: https://ultralytics.com/assets/coco8.zip
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/open-images-v7.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/open-images-v7.yaml`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # Open Images v7 dataset https://storage.googleapis.com/openimages/web/index.html by Google
+# Documentation: https://docs.ultralytics.com/datasets/detect/open-images-v7/
 # Example usage: yolo train data=open-images-v7.yaml
 # parent
 #  ultralytics
 #  datasets
 #      open-images-v7   downloads here (561 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/open-images-v7  # dataset root dir
-train: images/train  # train images (relative to 'path') 1743042 images
-val: images/val  # val images (relative to 'path') 41620 images
-test:  # test images (optional)
+path: ../datasets/open-images-v7 # dataset root dir
+train: images/train # train images (relative to 'path') 1743042 images
+val: images/val # val images (relative to 'path') 41620 images
+test: # test images (optional)
 
 # Classes
 names:
   0: Accordion
   1: Adhesive tape
   2: Aircraft
   3: Airplane
@@ -613,15 +613,14 @@
   595: Wood-burning stove
   596: Woodpecker
   597: Worm
   598: Wrench
   599: Zebra
   600: Zucchini
 
-
 # Download script/URL (optional) ---------------------------------------------------------------------------------------
 download: |
   from ultralytics.utils import LOGGER, SETTINGS, Path, is_ubuntu, get_ubuntu_version
   from ultralytics.utils.checks import check_requirements, check_version
 
   check_requirements('fiftyone')
   if is_ubuntu() and check_version(get_ubuntu_version(), '>=22.04'):
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/tiger-pose.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/tiger-pose.yaml`

 * *Files 15% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # Tiger Pose dataset by Ultralytics
+# Documentation: https://docs.ultralytics.com/datasets/pose/tiger-pose/
 # Example usage: yolo train data=tiger-pose.yaml
 # parent
 #  ultralytics
 #  datasets
 #      tiger-pose   downloads here (75.3 MB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/tiger-pose  # dataset root dir
-train: train  # train images (relative to 'path') 210 images
-val: val  # val images (relative to 'path') 53 images
+path: ../datasets/tiger-pose # dataset root dir
+train: train # train images (relative to 'path') 210 images
+val: val # val images (relative to 'path') 53 images
 
 # Keypoints
-kpt_shape: [12, 2]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
+kpt_shape: [12, 2] # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
 flip_idx: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
 
 # Classes
 names:
   0: tiger
 
 # Download script/URL (optional)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/datasets/xView.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/datasets/xView.yaml`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # DIUx xView 2018 Challenge https://challenge.xviewdataset.org by U.S. National Geospatial-Intelligence Agency (NGA)
 # --------  DOWNLOAD DATA MANUALLY and jar xf val_images.zip to 'datasets/xView' before running train command!  --------
+# Documentation: https://docs.ultralytics.com/datasets/detect/xview/
 # Example usage: yolo train data=xView.yaml
 # parent
 #  ultralytics
 #  datasets
 #      xView   downloads here (20.7 GB)
 
-
 # Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]
-path: ../datasets/xView  # dataset root dir
-train: images/autosplit_train.txt  # train images (relative to 'path') 90% of 847 train images
-val: images/autosplit_val.txt  # train images (relative to 'path') 10% of 847 train images
+path: ../datasets/xView # dataset root dir
+train: images/autosplit_train.txt # train images (relative to 'path') 90% of 847 train images
+val: images/autosplit_val.txt # train images (relative to 'path') 10% of 847 train images
 
 # Classes
 names:
   0: Fixed-wing Aircraft
   1: Small Aircraft
   2: Cargo Plane
   3: Helicopter
@@ -72,15 +72,14 @@
   54: Helipad
   55: Storage Tank
   56: Shipping container lot
   57: Shipping Container
   58: Pylon
   59: Tower
 
-
 # Download script/URL (optional) ---------------------------------------------------------------------------------------
 download: |
   import json
   import os
   from pathlib import Path
 
   import numpy as np
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/default.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/default.yaml`

 * *Files 27% similar despite different names*

```diff
@@ -1,118 +1,126 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # Default training settings and hyperparameters for medium-augmentation COCO training
 
-task: detect  # (str) YOLO task, i.e. detect, segment, classify, pose
-mode: train  # (str) YOLO mode, i.e. train, val, predict, export, track, benchmark
+task: detect # (str) YOLO task, i.e. detect, segment, classify, pose
+mode: train # (str) YOLO mode, i.e. train, val, predict, export, track, benchmark
 
 # Train settings -------------------------------------------------------------------------------------------------------
-model:  # (str, optional) path to model file, i.e. yolov8n.pt, yolov8n.yaml
-data:  # (str, optional) path to data file, i.e. coco128.yaml
-epochs: 100  # (int) number of epochs to train for
-patience: 50  # (int) epochs to wait for no observable improvement for early stopping of training
-batch: 16  # (int) number of images per batch (-1 for AutoBatch)
-imgsz: 640  # (int | list) input images size as int for train and val modes, or list[w,h] for predict and export modes
-save: True  # (bool) save train checkpoints and predict results
+model: # (str, optional) path to model file, i.e. yolov8n.pt, yolov8n.yaml
+data: # (str, optional) path to data file, i.e. coco128.yaml
+epochs: 100 # (int) number of epochs to train for
+time: # (float, optional) number of hours to train for, overrides epochs if supplied
+patience: 100 # (int) epochs to wait for no observable improvement for early stopping of training
+batch: 16 # (int) number of images per batch (-1 for AutoBatch)
+imgsz: 640 # (int | list) input images size as int for train and val modes, or list[w,h] for predict and export modes
+save: True # (bool) save train checkpoints and predict results
 save_period: -1 # (int) Save checkpoint every x epochs (disabled if < 1)
-cache: False  # (bool) True/ram, disk or False. Use cache for data loading
-device:  # (int | str | list, optional) device to run on, i.e. cuda device=0 or device=0,1,2,3 or device=cpu
-workers: 8  # (int) number of worker threads for data loading (per RANK if DDP)
-project:  # (str, optional) project name
-name:  # (str, optional) experiment name, results saved to 'project/name' directory
-exist_ok: False  # (bool) whether to overwrite existing experiment
-pretrained: True  # (bool | str) whether to use a pretrained model (bool) or a model to load weights from (str)
-optimizer: auto  # (str) optimizer to use, choices=[SGD, Adam, Adamax, AdamW, NAdam, RAdam, RMSProp, auto]
-verbose: True  # (bool) whether to print verbose output
-seed: 0  # (int) random seed for reproducibility
-deterministic: True  # (bool) whether to enable deterministic mode
-single_cls: False  # (bool) train multi-class data as single-class
-rect: False  # (bool) rectangular training if mode='train' or rectangular validation if mode='val'
-cos_lr: False  # (bool) use cosine learning rate scheduler
-close_mosaic: 10  # (int) disable mosaic augmentation for final epochs (0 to disable)
-resume: False  # (bool) resume training from last checkpoint
-amp: True  # (bool) Automatic Mixed Precision (AMP) training, choices=[True, False], True runs AMP check
-fraction: 1.0  # (float) dataset fraction to train on (default is 1.0, all images in train set)
-profile: False  # (bool) profile ONNX and TensorRT speeds during training for loggers
-freeze: None  # (int | list, optional) freeze first n layers, or freeze list of layer indices during training
+cache: False # (bool) True/ram, disk or False. Use cache for data loading
+device: # (int | str | list, optional) device to run on, i.e. cuda device=0 or device=0,1,2,3 or device=cpu
+workers: 8 # (int) number of worker threads for data loading (per RANK if DDP)
+project: # (str, optional) project name
+name: # (str, optional) experiment name, results saved to 'project/name' directory
+exist_ok: False # (bool) whether to overwrite existing experiment
+pretrained: True # (bool | str) whether to use a pretrained model (bool) or a model to load weights from (str)
+optimizer: auto # (str) optimizer to use, choices=[SGD, Adam, Adamax, AdamW, NAdam, RAdam, RMSProp, auto]
+verbose: True # (bool) whether to print verbose output
+seed: 0 # (int) random seed for reproducibility
+deterministic: True # (bool) whether to enable deterministic mode
+single_cls: False # (bool) train multi-class data as single-class
+rect: False # (bool) rectangular training if mode='train' or rectangular validation if mode='val'
+cos_lr: False # (bool) use cosine learning rate scheduler
+close_mosaic: 10 # (int) disable mosaic augmentation for final epochs (0 to disable)
+resume: False # (bool) resume training from last checkpoint
+amp: True # (bool) Automatic Mixed Precision (AMP) training, choices=[True, False], True runs AMP check
+fraction: 1.0 # (float) dataset fraction to train on (default is 1.0, all images in train set)
+profile: False # (bool) profile ONNX and TensorRT speeds during training for loggers
+freeze: None # (int | list, optional) freeze first n layers, or freeze list of layer indices during training
+multi_scale: False # (bool) Whether to use multiscale during training
 # Segmentation
-overlap_mask: True  # (bool) masks should overlap during training (segment train only)
-mask_ratio: 4  # (int) mask downsample ratio (segment train only)
+overlap_mask: True # (bool) masks should overlap during training (segment train only)
+mask_ratio: 4 # (int) mask downsample ratio (segment train only)
 # Classification
-dropout: 0.0  # (float) use dropout regularization (classify train only)
+dropout: 0.0 # (float) use dropout regularization (classify train only)
 
 # Val/Test settings ----------------------------------------------------------------------------------------------------
-val: True  # (bool) validate/test during training
-split: val  # (str) dataset split to use for validation, i.e. 'val', 'test' or 'train'
-save_json: False  # (bool) save results to JSON file
-save_hybrid: False  # (bool) save hybrid version of labels (labels + additional predictions)
-conf:  # (float, optional) object confidence threshold for detection (default 0.25 predict, 0.001 val)
-iou: 0.7  # (float) intersection over union (IoU) threshold for NMS
-max_det: 300  # (int) maximum number of detections per image
-half: False  # (bool) use half precision (FP16)
-dnn: False  # (bool) use OpenCV DNN for ONNX inference
-plots: True  # (bool) save plots and images during train/val
+val: True # (bool) validate/test during training
+split: val # (str) dataset split to use for validation, i.e. 'val', 'test' or 'train'
+save_json: False # (bool) save results to JSON file
+save_hybrid: False # (bool) save hybrid version of labels (labels + additional predictions)
+conf: # (float, optional) object confidence threshold for detection (default 0.25 predict, 0.001 val)
+iou: 0.7 # (float) intersection over union (IoU) threshold for NMS
+max_det: 300 # (int) maximum number of detections per image
+half: False # (bool) use half precision (FP16)
+dnn: False # (bool) use OpenCV DNN for ONNX inference
+plots: True # (bool) save plots and images during train/val
 
 # Predict settings -----------------------------------------------------------------------------------------------------
-source:  # (str, optional) source directory for images or videos
-vid_stride: 1  # (int) video frame-rate stride
-stream_buffer: False  # (bool) buffer all streaming frames (True) or return the most recent frame (False)
-visualize: False  # (bool) visualize model features
-augment: False  # (bool) apply image augmentation to prediction sources
-agnostic_nms: False  # (bool) class-agnostic NMS
-classes:  # (int | list[int], optional) filter results by class, i.e. classes=0, or classes=[0,2,3]
-retina_masks: False  # (bool) use high-resolution segmentation masks
+source: # (str, optional) source directory for images or videos
+vid_stride: 1 # (int) video frame-rate stride
+stream_buffer: False # (bool) buffer all streaming frames (True) or return the most recent frame (False)
+visualize: False # (bool) visualize model features
+augment: False # (bool) apply image augmentation to prediction sources
+agnostic_nms: False # (bool) class-agnostic NMS
+classes: # (int | list[int], optional) filter results by class, i.e. classes=0, or classes=[0,2,3]
+retina_masks: False # (bool) use high-resolution segmentation masks
+embed: # (list[int], optional) return feature vectors/embeddings from given layers
 
 # Visualize settings ---------------------------------------------------------------------------------------------------
-show: False  # (bool) show predicted images and videos if environment allows
-save_txt: False  # (bool) save results as .txt file
-save_conf: False  # (bool) save results with confidence scores
-save_crop: False  # (bool) save cropped images with results
-show_labels: True  # (bool) show prediction labels, i.e. 'person'
-show_conf: True  # (bool) show prediction confidence, i.e. '0.99'
-show_boxes: True  # (bool) show prediction boxes
-line_width:   # (int, optional) line width of the bounding boxes. Scaled to image size if None.
+show: False # (bool) show predicted images and videos if environment allows
+save_frames: False # (bool) save predicted individual video frames
+save_txt: False # (bool) save results as .txt file
+save_conf: False # (bool) save results with confidence scores
+save_crop: False # (bool) save cropped images with results
+show_labels: True # (bool) show prediction labels, i.e. 'person'
+show_conf: True # (bool) show prediction confidence, i.e. '0.99'
+show_boxes: True # (bool) show prediction boxes
+line_width: # (int, optional) line width of the bounding boxes. Scaled to image size if None.
 
 # Export settings ------------------------------------------------------------------------------------------------------
-format: torchscript  # (str) format to export to, choices at https://docs.ultralytics.com/modes/export/#export-formats
-keras: False  # (bool) use Kera=s
-optimize: False  # (bool) TorchScript: optimize for mobile
-int8: False  # (bool) CoreML/TF INT8 quantization
-dynamic: False  # (bool) ONNX/TF/TensorRT: dynamic axes
-simplify: False  # (bool) ONNX: simplify model
-opset:  # (int, optional) ONNX: opset version
-workspace: 4  # (int) TensorRT: workspace size (GB)
-nms: False  # (bool) CoreML: add NMS
+format: torchscript # (str) format to export to, choices at https://docs.ultralytics.com/modes/export/#export-formats
+keras: False # (bool) use Kera=s
+optimize: False # (bool) TorchScript: optimize for mobile
+int8: False # (bool) CoreML/TF INT8 quantization
+dynamic: False # (bool) ONNX/TF/TensorRT: dynamic axes
+simplify: False # (bool) ONNX: simplify model
+opset: # (int, optional) ONNX: opset version
+workspace: 4 # (int) TensorRT: workspace size (GB)
+nms: False # (bool) CoreML: add NMS
 
 # Hyperparameters ------------------------------------------------------------------------------------------------------
-lr0: 0.01  # (float) initial learning rate (i.e. SGD=1E-2, Adam=1E-3)
-lrf: 0.01  # (float) final learning rate (lr0 * lrf)
-momentum: 0.937  # (float) SGD momentum/Adam beta1
-weight_decay: 0.0005  # (float) optimizer weight decay 5e-4
-warmup_epochs: 3.0  # (float) warmup epochs (fractions ok)
-warmup_momentum: 0.8  # (float) warmup initial momentum
-warmup_bias_lr: 0.1  # (float) warmup initial bias lr
-box: 7.5  # (float) box loss gain
-cls: 0.5  # (float) cls loss gain (scale with pixels)
-dfl: 1.5  # (float) dfl loss gain
-pose: 12.0  # (float) pose loss gain
-kobj: 1.0  # (float) keypoint obj loss gain
-label_smoothing: 0.0  # (float) label smoothing (fraction)
-nbs: 64  # (int) nominal batch size
-hsv_h: 0.015  # (float) image HSV-Hue augmentation (fraction)
-hsv_s: 0.7  # (float) image HSV-Saturation augmentation (fraction)
-hsv_v: 0.4  # (float) image HSV-Value augmentation (fraction)
-degrees: 0.0  # (float) image rotation (+/- deg)
-translate: 0.1  # (float) image translation (+/- fraction)
-scale: 0.5  # (float) image scale (+/- gain)
-shear: 0.0  # (float) image shear (+/- deg)
-perspective: 0.0  # (float) image perspective (+/- fraction), range 0-0.001
-flipud: 0.0  # (float) image flip up-down (probability)
-fliplr: 0.5  # (float) image flip left-right (probability)
-mosaic: 1.0  # (float) image mosaic (probability)
-mixup: 0.0  # (float) image mixup (probability)
-copy_paste: 0.0  # (float) segment copy-paste (probability)
+lr0: 0.01 # (float) initial learning rate (i.e. SGD=1E-2, Adam=1E-3)
+lrf: 0.01 # (float) final learning rate (lr0 * lrf)
+momentum: 0.937 # (float) SGD momentum/Adam beta1
+weight_decay: 0.0005 # (float) optimizer weight decay 5e-4
+warmup_epochs: 3.0 # (float) warmup epochs (fractions ok)
+warmup_momentum: 0.8 # (float) warmup initial momentum
+warmup_bias_lr: 0.1 # (float) warmup initial bias lr
+box: 7.5 # (float) box loss gain
+cls: 0.5 # (float) cls loss gain (scale with pixels)
+dfl: 1.5 # (float) dfl loss gain
+pose: 12.0 # (float) pose loss gain
+kobj: 1.0 # (float) keypoint obj loss gain
+label_smoothing: 0.0 # (float) label smoothing (fraction)
+nbs: 64 # (int) nominal batch size
+hsv_h: 0.015 # (float) image HSV-Hue augmentation (fraction)
+hsv_s: 0.7 # (float) image HSV-Saturation augmentation (fraction)
+hsv_v: 0.4 # (float) image HSV-Value augmentation (fraction)
+degrees: 0.0 # (float) image rotation (+/- deg)
+translate: 0.1 # (float) image translation (+/- fraction)
+scale: 0.5 # (float) image scale (+/- gain)
+shear: 0.0 # (float) image shear (+/- deg)
+perspective: 0.0 # (float) image perspective (+/- fraction), range 0-0.001
+flipud: 0.0 # (float) image flip up-down (probability)
+fliplr: 0.5 # (float) image flip left-right (probability)
+bgr: 0.0 # (float) image channel BGR (probability)
+mosaic: 1.0 # (float) image mosaic (probability)
+mixup: 0.0 # (float) image mixup (probability)
+copy_paste: 0.0 # (float) segment copy-paste (probability)
+auto_augment: randaugment # (str) auto augmentation policy for classification (randaugment, autoaugment, augmix)
+erasing: 0.4 # (float) probability of random erasing during classification training (0-0.9), 0 means no erasing, must be less than 1.0.
+crop_fraction: 1.0 # (float) image crop fraction for classification (0.1-1), 1.0 means no crop, must be greater than 0.
 
 # Custom config.yaml ---------------------------------------------------------------------------------------------------
-cfg:  # (str, optional) for overriding defaults.yaml
+cfg: # (str, optional) for overriding defaults.yaml
 
 # Tracker settings ------------------------------------------------------------------------------------------------------
-tracker: botsort.yaml  # (str) tracker type, choices=[botsort.yaml, bytetrack.yaml]
+tracker: botsort.yaml # (str) tracker type, choices=[botsort.yaml, bytetrack.yaml]
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/rt-detr/rtdetr-l.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/rt-detr/rtdetr-l.yaml`

 * *Files 6% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # RT-DETR-l object detection model with P3-P5 outputs. For details see https://docs.ultralytics.com/models/rtdetr
 
 # Parameters
-nc: 80  # number of classes
+nc: 80 # number of classes
 scales: # model compound scaling constants, i.e. 'model=yolov8n-cls.yaml' will call yolov8-cls.yaml with scale 'n'
   # [depth, width, max_channels]
   l: [1.00, 1.00, 1024]
 
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, HGStem, [32, 48]]  # 0-P2/4
-  - [-1, 6, HGBlock, [48, 128, 3]]  # stage 1
+  - [-1, 1, HGStem, [32, 48]] # 0-P2/4
+  - [-1, 6, HGBlock, [48, 128, 3]] # stage 1
 
-  - [-1, 1, DWConv, [128, 3, 2, 1, False]]  # 2-P3/8
-  - [-1, 6, HGBlock, [96, 512, 3]]   # stage 2
+  - [-1, 1, DWConv, [128, 3, 2, 1, False]] # 2-P3/8
+  - [-1, 6, HGBlock, [96, 512, 3]] # stage 2
 
-  - [-1, 1, DWConv, [512, 3, 2, 1, False]]  # 4-P3/16
-  - [-1, 6, HGBlock, [192, 1024, 5, True, False]]  # cm, c2, k, light, shortcut
+  - [-1, 1, DWConv, [512, 3, 2, 1, False]] # 4-P3/16
+  - [-1, 6, HGBlock, [192, 1024, 5, True, False]] # cm, c2, k, light, shortcut
   - [-1, 6, HGBlock, [192, 1024, 5, True, True]]
-  - [-1, 6, HGBlock, [192, 1024, 5, True, True]]  # stage 3
+  - [-1, 6, HGBlock, [192, 1024, 5, True, True]] # stage 3
 
-  - [-1, 1, DWConv, [1024, 3, 2, 1, False]]  # 8-P4/32
-  - [-1, 6, HGBlock, [384, 2048, 5, True, False]]  # stage 4
+  - [-1, 1, DWConv, [1024, 3, 2, 1, False]] # 8-P4/32
+  - [-1, 6, HGBlock, [384, 2048, 5, True, False]] # stage 4
 
 head:
-  - [-1, 1, Conv, [256, 1, 1, None, 1, 1, False]]  # 10 input_proj.2
+  - [-1, 1, Conv, [256, 1, 1, None, 1, 1, False]] # 10 input_proj.2
   - [-1, 1, AIFI, [1024, 8]]
-  - [-1, 1, Conv, [256, 1, 1]]   # 12, Y5, lateral_convs.0
+  - [-1, 1, Conv, [256, 1, 1]] # 12, Y5, lateral_convs.0
 
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [7, 1, Conv, [256, 1, 1, None, 1, 1, False]]  # 14 input_proj.1
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [7, 1, Conv, [256, 1, 1, None, 1, 1, False]] # 14 input_proj.1
   - [[-2, -1], 1, Concat, [1]]
-  - [-1, 3, RepC3, [256]]  # 16, fpn_blocks.0
-  - [-1, 1, Conv, [256, 1, 1]]   # 17, Y4, lateral_convs.1
+  - [-1, 3, RepC3, [256]] # 16, fpn_blocks.0
+  - [-1, 1, Conv, [256, 1, 1]] # 17, Y4, lateral_convs.1
 
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [3, 1, Conv, [256, 1, 1, None, 1, 1, False]]  # 19 input_proj.0
-  - [[-2, -1], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, RepC3, [256]]    # X3 (21), fpn_blocks.1
-
-  - [-1, 1, Conv, [256, 3, 2]]   # 22, downsample_convs.0
-  - [[-1, 17], 1, Concat, [1]]  # cat Y4
-  - [-1, 3, RepC3, [256]]    # F4 (24), pan_blocks.0
-
-  - [-1, 1, Conv, [256, 3, 2]]   # 25, downsample_convs.1
-  - [[-1, 12], 1, Concat, [1]]  # cat Y5
-  - [-1, 3, RepC3, [256]]    # F5 (27), pan_blocks.1
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [3, 1, Conv, [256, 1, 1, None, 1, 1, False]] # 19 input_proj.0
+  - [[-2, -1], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, RepC3, [256]] # X3 (21), fpn_blocks.1
+
+  - [-1, 1, Conv, [256, 3, 2]] # 22, downsample_convs.0
+  - [[-1, 17], 1, Concat, [1]] # cat Y4
+  - [-1, 3, RepC3, [256]] # F4 (24), pan_blocks.0
+
+  - [-1, 1, Conv, [256, 3, 2]] # 25, downsample_convs.1
+  - [[-1, 12], 1, Concat, [1]] # cat Y5
+  - [-1, 3, RepC3, [256]] # F5 (27), pan_blocks.1
 
-  - [[21, 24, 27], 1, RTDETRDecoder, [nc]]  # Detect(P3, P4, P5)
+  - [[21, 24, 27], 1, RTDETRDecoder, [nc]] # Detect(P3, P4, P5)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/rt-detr/rtdetr-x.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/rt-detr/rtdetr-x.yaml`

 * *Files 6% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # RT-DETR-x object detection model with P3-P5 outputs. For details see https://docs.ultralytics.com/models/rtdetr
 
 # Parameters
-nc: 80  # number of classes
+nc: 80 # number of classes
 scales: # model compound scaling constants, i.e. 'model=yolov8n-cls.yaml' will call yolov8-cls.yaml with scale 'n'
   # [depth, width, max_channels]
   x: [1.00, 1.00, 2048]
 
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, HGStem, [32, 64]]  # 0-P2/4
-  - [-1, 6, HGBlock, [64, 128, 3]]  # stage 1
+  - [-1, 1, HGStem, [32, 64]] # 0-P2/4
+  - [-1, 6, HGBlock, [64, 128, 3]] # stage 1
 
-  - [-1, 1, DWConv, [128, 3, 2, 1, False]]  # 2-P3/8
+  - [-1, 1, DWConv, [128, 3, 2, 1, False]] # 2-P3/8
   - [-1, 6, HGBlock, [128, 512, 3]]
-  - [-1, 6, HGBlock, [128, 512, 3, False, True]]   # 4-stage 2
+  - [-1, 6, HGBlock, [128, 512, 3, False, True]] # 4-stage 2
 
-  - [-1, 1, DWConv, [512, 3, 2, 1, False]]  # 5-P3/16
-  - [-1, 6, HGBlock, [256, 1024, 5, True, False]]  # cm, c2, k, light, shortcut
+  - [-1, 1, DWConv, [512, 3, 2, 1, False]] # 5-P3/16
+  - [-1, 6, HGBlock, [256, 1024, 5, True, False]] # cm, c2, k, light, shortcut
   - [-1, 6, HGBlock, [256, 1024, 5, True, True]]
   - [-1, 6, HGBlock, [256, 1024, 5, True, True]]
   - [-1, 6, HGBlock, [256, 1024, 5, True, True]]
-  - [-1, 6, HGBlock, [256, 1024, 5, True, True]]  # 10-stage 3
+  - [-1, 6, HGBlock, [256, 1024, 5, True, True]] # 10-stage 3
 
-  - [-1, 1, DWConv, [1024, 3, 2, 1, False]]  # 11-P4/32
+  - [-1, 1, DWConv, [1024, 3, 2, 1, False]] # 11-P4/32
   - [-1, 6, HGBlock, [512, 2048, 5, True, False]]
-  - [-1, 6, HGBlock, [512, 2048, 5, True, True]]  # 13-stage 4
+  - [-1, 6, HGBlock, [512, 2048, 5, True, True]] # 13-stage 4
 
 head:
-  - [-1, 1, Conv, [384, 1, 1, None, 1, 1, False]]  # 14 input_proj.2
+  - [-1, 1, Conv, [384, 1, 1, None, 1, 1, False]] # 14 input_proj.2
   - [-1, 1, AIFI, [2048, 8]]
-  - [-1, 1, Conv, [384, 1, 1]]   # 16, Y5, lateral_convs.0
+  - [-1, 1, Conv, [384, 1, 1]] # 16, Y5, lateral_convs.0
 
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [10, 1, Conv, [384, 1, 1, None, 1, 1, False]]  # 18 input_proj.1
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [10, 1, Conv, [384, 1, 1, None, 1, 1, False]] # 18 input_proj.1
   - [[-2, -1], 1, Concat, [1]]
-  - [-1, 3, RepC3, [384]]  # 20, fpn_blocks.0
-  - [-1, 1, Conv, [384, 1, 1]]   # 21, Y4, lateral_convs.1
+  - [-1, 3, RepC3, [384]] # 20, fpn_blocks.0
+  - [-1, 1, Conv, [384, 1, 1]] # 21, Y4, lateral_convs.1
 
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [4, 1, Conv, [384, 1, 1, None, 1, 1, False]]  # 23 input_proj.0
-  - [[-2, -1], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, RepC3, [384]]    # X3 (25), fpn_blocks.1
-
-  - [-1, 1, Conv, [384, 3, 2]]   # 26, downsample_convs.0
-  - [[-1, 21], 1, Concat, [1]]  # cat Y4
-  - [-1, 3, RepC3, [384]]    # F4 (28), pan_blocks.0
-
-  - [-1, 1, Conv, [384, 3, 2]]   # 29, downsample_convs.1
-  - [[-1, 16], 1, Concat, [1]]  # cat Y5
-  - [-1, 3, RepC3, [384]]    # F5 (31), pan_blocks.1
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [4, 1, Conv, [384, 1, 1, None, 1, 1, False]] # 23 input_proj.0
+  - [[-2, -1], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, RepC3, [384]] # X3 (25), fpn_blocks.1
+
+  - [-1, 1, Conv, [384, 3, 2]] # 26, downsample_convs.0
+  - [[-1, 21], 1, Concat, [1]] # cat Y4
+  - [-1, 3, RepC3, [384]] # F4 (28), pan_blocks.0
+
+  - [-1, 1, Conv, [384, 3, 2]] # 29, downsample_convs.1
+  - [[-1, 16], 1, Concat, [1]] # cat Y5
+  - [-1, 3, RepC3, [384]] # F5 (31), pan_blocks.1
 
-  - [[25, 28, 31], 1, RTDETRDecoder, [nc]]  # Detect(P3, P4, P5)
+  - [[25, 28, 31], 1, RTDETRDecoder, [nc]] # Detect(P3, P4, P5)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v6/yolov6.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v6/yolov6.yaml`

 * *Files 10% similar despite different names*

```diff
@@ -1,53 +1,53 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # YOLOv6 object detection model with P3-P5 outputs. For Usage examples see https://docs.ultralytics.com/models/yolov6
 
 # Parameters
-nc: 80  # number of classes
-activation: nn.ReLU()  # (optional) model default activation function
+nc: 80 # number of classes
+activation: nn.ReLU() # (optional) model default activation function
 scales: # model compound scaling constants, i.e. 'model=yolov6n.yaml' will call yolov8.yaml with scale 'n'
   # [depth, width, max_channels]
   n: [0.33, 0.25, 1024]
   s: [0.33, 0.50, 1024]
   m: [0.67, 0.75, 768]
   l: [1.00, 1.00, 512]
   x: [1.00, 1.25, 512]
 
 # YOLOv6-3.0s backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 6, Conv, [128, 3, 1]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 12, Conv, [256, 3, 1]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 18, Conv, [512, 3, 1]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32
   - [-1, 6, Conv, [1024, 3, 1]]
-  - [-1, 1, SPPF, [1024, 5]]  # 9
+  - [-1, 1, SPPF, [1024, 5]] # 9
 
 # YOLOv6-3.0s head
 head:
   - [-1, 1, Conv, [256, 1, 1]]
   - [-1, 1, nn.ConvTranspose2d, [256, 2, 2, 0]]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
   - [-1, 1, Conv, [256, 3, 1]]
-  - [-1, 9, Conv, [256, 3, 1]]  # 14
+  - [-1, 9, Conv, [256, 3, 1]] # 14
 
   - [-1, 1, Conv, [128, 1, 1]]
   - [-1, 1, nn.ConvTranspose2d, [128, 2, 2, 0]]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
   - [-1, 1, Conv, [128, 3, 1]]
-  - [-1, 9, Conv, [128, 3, 1]]  # 19
+  - [-1, 9, Conv, [128, 3, 1]] # 19
 
   - [-1, 1, Conv, [128, 3, 2]]
-  - [[-1, 15], 1, Concat, [1]]  # cat head P4
+  - [[-1, 15], 1, Concat, [1]] # cat head P4
   - [-1, 1, Conv, [256, 3, 1]]
-  - [-1, 9, Conv, [256, 3, 1]]  # 23
+  - [-1, 9, Conv, [256, 3, 1]] # 23
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 10], 1, Concat, [1]]  # cat head P5
+  - [[-1, 10], 1, Concat, [1]] # cat head P5
   - [-1, 1, Conv, [512, 3, 1]]
-  - [-1, 9, Conv, [512, 3, 1]]  # 27
+  - [-1, 9, Conv, [512, 3, 1]] # 27
 
-  - [[19, 23, 27], 1, Detect, [nc]]  # Detect(P3, P4, P5)
+  - [[19, 23, 27], 1, Detect, [nc]] # Detect(P3, P4, P5)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-cls.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-cls.yaml`

 * *Files 3% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # YOLOv8-cls image classification model. For Usage examples see https://docs.ultralytics.com/tasks/classify
 
 # Parameters
-nc: 1000  # number of classes
+nc: 1000 # number of classes
 scales: # model compound scaling constants, i.e. 'model=yolov8n-cls.yaml' will call yolov8-cls.yaml with scale 'n'
   # [depth, width, max_channels]
   n: [0.33, 0.25, 1024]
   s: [0.33, 0.50, 1024]
   m: [0.67, 0.75, 1024]
   l: [1.00, 1.00, 1024]
   x: [1.00, 1.25, 1024]
 
 # YOLOv8.0n backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32
   - [-1, 3, C2f, [1024, True]]
 
 # YOLOv8.0n head
 head:
-  - [-1, 1, Classify, [nc]]  # Classify
+  - [-1, 1, Classify, [nc]] # Classify
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-p2.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-p2.yaml`

 * *Files 6% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # YOLOv8 object detection model with P2-P5 outputs. For Usage examples see https://docs.ultralytics.com/tasks/detect
 
 # Parameters
-nc: 80  # number of classes
+nc: 80 # number of classes
 scales: # model compound scaling constants, i.e. 'model=yolov8n.yaml' will call yolov8.yaml with scale 'n'
   # [depth, width, max_channels]
   n: [0.33, 0.25, 1024]
   s: [0.33, 0.50, 1024]
   m: [0.67, 0.75, 768]
   l: [1.00, 1.00, 512]
   x: [1.00, 1.25, 512]
 
 # YOLOv8.0 backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32
   - [-1, 3, C2f, [1024, True]]
-  - [-1, 1, SPPF, [1024, 5]]  # 9
+  - [-1, 1, SPPF, [1024, 5]] # 9
 
 # YOLOv8.0-p2 head
 head:
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, C2f, [512]]  # 12
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
-  - [-1, 3, C2f, [256]]  # 15 (P3/8-small)
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 2], 1, Concat, [1]]  # cat backbone P2
-  - [-1, 3, C2f, [128]]  # 18 (P2/4-xsmall)
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, C2f, [512]] # 12
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
+  - [-1, 3, C2f, [256]] # 15 (P3/8-small)
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 2], 1, Concat, [1]] # cat backbone P2
+  - [-1, 3, C2f, [128]] # 18 (P2/4-xsmall)
 
   - [-1, 1, Conv, [128, 3, 2]]
-  - [[-1, 15], 1, Concat, [1]]  # cat head P3
-  - [-1, 3, C2f, [256]]  # 21 (P3/8-small)
+  - [[-1, 15], 1, Concat, [1]] # cat head P3
+  - [-1, 3, C2f, [256]] # 21 (P3/8-small)
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 12], 1, Concat, [1]]  # cat head P4
-  - [-1, 3, C2f, [512]]  # 24 (P4/16-medium)
+  - [[-1, 12], 1, Concat, [1]] # cat head P4
+  - [-1, 3, C2f, [512]] # 24 (P4/16-medium)
 
   - [-1, 1, Conv, [512, 3, 2]]
-  - [[-1, 9], 1, Concat, [1]]  # cat head P5
-  - [-1, 3, C2f, [1024]]  # 27 (P5/32-large)
+  - [[-1, 9], 1, Concat, [1]] # cat head P5
+  - [-1, 3, C2f, [1024]] # 27 (P5/32-large)
 
-  - [[18, 21, 24, 27], 1, Detect, [nc]]  # Detect(P2, P3, P4, P5)
+  - [[18, 21, 24, 27], 1, Detect, [nc]] # Detect(P2, P3, P4, P5)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-p6.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-p6.yaml`

 * *Files 14% similar despite different names*

```diff
@@ -1,56 +1,56 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # YOLOv8 object detection model with P3-P6 outputs. For Usage examples see https://docs.ultralytics.com/tasks/detect
 
 # Parameters
-nc: 80  # number of classes
+nc: 80 # number of classes
 scales: # model compound scaling constants, i.e. 'model=yolov8n-p6.yaml' will call yolov8-p6.yaml with scale 'n'
   # [depth, width, max_channels]
   n: [0.33, 0.25, 1024]
   s: [0.33, 0.50, 1024]
   m: [0.67, 0.75, 768]
   l: [1.00, 1.00, 512]
   x: [1.00, 1.25, 512]
 
 # YOLOv8.0x6 backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [768, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [768, 3, 2]] # 7-P5/32
   - [-1, 3, C2f, [768, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 9-P6/64
+  - [-1, 1, Conv, [1024, 3, 2]] # 9-P6/64
   - [-1, 3, C2f, [1024, True]]
-  - [-1, 1, SPPF, [1024, 5]]  # 11
+  - [-1, 1, SPPF, [1024, 5]] # 11
 
 # YOLOv8.0x6 head
 head:
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 8], 1, Concat, [1]]  # cat backbone P5
-  - [-1, 3, C2, [768, False]]  # 14
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, C2, [512, False]]  # 17
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
-  - [-1, 3, C2, [256, False]]  # 20 (P3/8-small)
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 8], 1, Concat, [1]] # cat backbone P5
+  - [-1, 3, C2, [768, False]] # 14
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, C2, [512, False]] # 17
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
+  - [-1, 3, C2, [256, False]] # 20 (P3/8-small)
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 17], 1, Concat, [1]]  # cat head P4
-  - [-1, 3, C2, [512, False]]  # 23 (P4/16-medium)
+  - [[-1, 17], 1, Concat, [1]] # cat head P4
+  - [-1, 3, C2, [512, False]] # 23 (P4/16-medium)
 
   - [-1, 1, Conv, [512, 3, 2]]
-  - [[-1, 14], 1, Concat, [1]]  # cat head P5
-  - [-1, 3, C2, [768, False]]  # 26 (P5/32-large)
+  - [[-1, 14], 1, Concat, [1]] # cat head P5
+  - [-1, 3, C2, [768, False]] # 26 (P5/32-large)
 
   - [-1, 1, Conv, [768, 3, 2]]
-  - [[-1, 11], 1, Concat, [1]]  # cat head P6
-  - [-1, 3, C2, [1024, False]]  # 29 (P6/64-xlarge)
+  - [[-1, 11], 1, Concat, [1]] # cat head P6
+  - [-1, 3, C2, [1024, False]] # 29 (P6/64-xlarge)
 
-  - [[20, 23, 26, 29], 1, Detect, [nc]]  # Detect(P3, P4, P5, P6)
+  - [[20, 23, 26, 29], 1, Detect, [nc]] # Detect(P3, P4, P5, P6)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-pose-p6.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-pose-p6.yaml`

 * *Files 7% similar despite different names*

```diff
@@ -1,57 +1,57 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # YOLOv8-pose-p6 keypoints/pose estimation model. For Usage examples see https://docs.ultralytics.com/tasks/pose
 
 # Parameters
-nc: 1  # number of classes
-kpt_shape: [17, 3]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
+nc: 1 # number of classes
+kpt_shape: [17, 3] # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
 scales: # model compound scaling constants, i.e. 'model=yolov8n-p6.yaml' will call yolov8-p6.yaml with scale 'n'
   # [depth, width, max_channels]
   n: [0.33, 0.25, 1024]
   s: [0.33, 0.50, 1024]
   m: [0.67, 0.75, 768]
   l: [1.00, 1.00, 512]
   x: [1.00, 1.25, 512]
 
 # YOLOv8.0x6 backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [768, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [768, 3, 2]] # 7-P5/32
   - [-1, 3, C2f, [768, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 9-P6/64
+  - [-1, 1, Conv, [1024, 3, 2]] # 9-P6/64
   - [-1, 3, C2f, [1024, True]]
-  - [-1, 1, SPPF, [1024, 5]]  # 11
+  - [-1, 1, SPPF, [1024, 5]] # 11
 
 # YOLOv8.0x6 head
 head:
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 8], 1, Concat, [1]]  # cat backbone P5
-  - [-1, 3, C2, [768, False]]  # 14
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, C2, [512, False]]  # 17
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
-  - [-1, 3, C2, [256, False]]  # 20 (P3/8-small)
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 8], 1, Concat, [1]] # cat backbone P5
+  - [-1, 3, C2, [768, False]] # 14
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, C2, [512, False]] # 17
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
+  - [-1, 3, C2, [256, False]] # 20 (P3/8-small)
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 17], 1, Concat, [1]]  # cat head P4
-  - [-1, 3, C2, [512, False]]  # 23 (P4/16-medium)
+  - [[-1, 17], 1, Concat, [1]] # cat head P4
+  - [-1, 3, C2, [512, False]] # 23 (P4/16-medium)
 
   - [-1, 1, Conv, [512, 3, 2]]
-  - [[-1, 14], 1, Concat, [1]]  # cat head P5
-  - [-1, 3, C2, [768, False]]  # 26 (P5/32-large)
+  - [[-1, 14], 1, Concat, [1]] # cat head P5
+  - [-1, 3, C2, [768, False]] # 26 (P5/32-large)
 
   - [-1, 1, Conv, [768, 3, 2]]
-  - [[-1, 11], 1, Concat, [1]]  # cat head P6
-  - [-1, 3, C2, [1024, False]]  # 29 (P6/64-xlarge)
+  - [[-1, 11], 1, Concat, [1]] # cat head P6
+  - [-1, 3, C2, [1024, False]] # 29 (P6/64-xlarge)
 
-  - [[20, 23, 26, 29], 1, Pose, [nc, kpt_shape]]  # Pose(P3, P4, P5, P6)
+  - [[20, 23, 26, 29], 1, Pose, [nc, kpt_shape]] # Pose(P3, P4, P5, P6)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-pose.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-pose.yaml`

 * *Files 4% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # YOLOv8-pose keypoints/pose estimation model. For Usage examples see https://docs.ultralytics.com/tasks/pose
 
 # Parameters
-nc: 1  # number of classes
-kpt_shape: [17, 3]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
+nc: 1 # number of classes
+kpt_shape: [17, 3] # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
 scales: # model compound scaling constants, i.e. 'model=yolov8n-pose.yaml' will call yolov8-pose.yaml with scale 'n'
   # [depth, width, max_channels]
   n: [0.33, 0.25, 1024]
   s: [0.33, 0.50, 1024]
   m: [0.67, 0.75, 768]
   l: [1.00, 1.00, 512]
   x: [1.00, 1.25, 512]
 
 # YOLOv8.0n backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32
   - [-1, 3, C2f, [1024, True]]
-  - [-1, 1, SPPF, [1024, 5]]  # 9
+  - [-1, 1, SPPF, [1024, 5]] # 9
 
 # YOLOv8.0n head
 head:
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, C2f, [512]]  # 12
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
-  - [-1, 3, C2f, [256]]  # 15 (P3/8-small)
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, C2f, [512]] # 12
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
+  - [-1, 3, C2f, [256]] # 15 (P3/8-small)
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 12], 1, Concat, [1]]  # cat head P4
-  - [-1, 3, C2f, [512]]  # 18 (P4/16-medium)
+  - [[-1, 12], 1, Concat, [1]] # cat head P4
+  - [-1, 3, C2f, [512]] # 18 (P4/16-medium)
 
   - [-1, 1, Conv, [512, 3, 2]]
-  - [[-1, 9], 1, Concat, [1]]  # cat head P5
-  - [-1, 3, C2f, [1024]]  # 21 (P5/32-large)
+  - [[-1, 9], 1, Concat, [1]] # cat head P5
+  - [-1, 3, C2f, [1024]] # 21 (P5/32-large)
 
-  - [[15, 18, 21], 1, Pose, [nc, kpt_shape]]  # Pose(P3, P4, P5)
+  - [[15, 18, 21], 1, Pose, [nc, kpt_shape]] # Pose(P3, P4, P5)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-rtdetr.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-obb.yaml`

 * *Files 9% similar despite different names*

```diff
@@ -1,46 +1,46 @@
 # Ultralytics YOLO , AGPL-3.0 license
-# YOLOv8 object detection model with P3-P5 outputs. For Usage examples see https://docs.ultralytics.com/tasks/detect
+# YOLOv8 Oriented Bounding Boxes (OBB) model with P3-P5 outputs. For Usage examples see https://docs.ultralytics.com/tasks/detect
 
 # Parameters
-nc: 80  # number of classes
+nc: 80 # number of classes
 scales: # model compound scaling constants, i.e. 'model=yolov8n.yaml' will call yolov8.yaml with scale 'n'
   # [depth, width, max_channels]
-  n: [0.33, 0.25, 1024]  # YOLOv8n summary: 225 layers,  3157200 parameters,  3157184 gradients,   8.9 GFLOPs
-  s: [0.33, 0.50, 1024]  # YOLOv8s summary: 225 layers, 11166560 parameters, 11166544 gradients,  28.8 GFLOPs
-  m: [0.67, 0.75, 768]   # YOLOv8m summary: 295 layers, 25902640 parameters, 25902624 gradients,  79.3 GFLOPs
-  l: [1.00, 1.00, 512]   # YOLOv8l summary: 365 layers, 43691520 parameters, 43691504 gradients, 165.7 GFLOPs
-  x: [1.00, 1.25, 512]   # YOLOv8x summary: 365 layers, 68229648 parameters, 68229632 gradients, 258.5 GFLOPs
+  n: [0.33, 0.25, 1024] # YOLOv8n summary: 225 layers,  3157200 parameters,  3157184 gradients,   8.9 GFLOPs
+  s: [0.33, 0.50, 1024] # YOLOv8s summary: 225 layers, 11166560 parameters, 11166544 gradients,  28.8 GFLOPs
+  m: [0.67, 0.75, 768] # YOLOv8m summary: 295 layers, 25902640 parameters, 25902624 gradients,  79.3 GFLOPs
+  l: [1.00, 1.00, 512] # YOLOv8l summary: 365 layers, 43691520 parameters, 43691504 gradients, 165.7 GFLOPs
+  x: [1.00, 1.25, 512] # YOLOv8x summary: 365 layers, 68229648 parameters, 68229632 gradients, 258.5 GFLOPs
 
 # YOLOv8.0n backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32
   - [-1, 3, C2f, [1024, True]]
-  - [-1, 1, SPPF, [1024, 5]]  # 9
+  - [-1, 1, SPPF, [1024, 5]] # 9
 
 # YOLOv8.0n head
 head:
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, C2f, [512]]  # 12
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
-  - [-1, 3, C2f, [256]]  # 15 (P3/8-small)
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, C2f, [512]] # 12
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
+  - [-1, 3, C2f, [256]] # 15 (P3/8-small)
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 12], 1, Concat, [1]]  # cat head P4
-  - [-1, 3, C2f, [512]]  # 18 (P4/16-medium)
+  - [[-1, 12], 1, Concat, [1]] # cat head P4
+  - [-1, 3, C2f, [512]] # 18 (P4/16-medium)
 
   - [-1, 1, Conv, [512, 3, 2]]
-  - [[-1, 9], 1, Concat, [1]]  # cat head P5
-  - [-1, 3, C2f, [1024]]  # 21 (P5/32-large)
+  - [[-1, 9], 1, Concat, [1]] # cat head P5
+  - [-1, 3, C2f, [1024]] # 21 (P5/32-large)
 
-  - [[15, 18, 21], 1, RTDETRDecoder, [nc]]  # Detect(P3, P4, P5)
+  - [[15, 18, 21], 1, OBB, [nc, 1]] # OBB(P3, P4, P5)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-seg-p6.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8-seg-p6.yaml`

 * *Files 8% similar despite different names*

```diff
@@ -1,56 +1,56 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # YOLOv8-seg-p6 instance segmentation model. For Usage examples see https://docs.ultralytics.com/tasks/segment
 
 # Parameters
-nc: 80  # number of classes
+nc: 80 # number of classes
 scales: # model compound scaling constants, i.e. 'model=yolov8n-seg-p6.yaml' will call yolov8-seg-p6.yaml with scale 'n'
   # [depth, width, max_channels]
   n: [0.33, 0.25, 1024]
   s: [0.33, 0.50, 1024]
   m: [0.67, 0.75, 768]
   l: [1.00, 1.00, 512]
   x: [1.00, 1.25, 512]
 
 # YOLOv8.0x6 backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [768, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [768, 3, 2]] # 7-P5/32
   - [-1, 3, C2f, [768, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 9-P6/64
+  - [-1, 1, Conv, [1024, 3, 2]] # 9-P6/64
   - [-1, 3, C2f, [1024, True]]
-  - [-1, 1, SPPF, [1024, 5]]  # 11
+  - [-1, 1, SPPF, [1024, 5]] # 11
 
 # YOLOv8.0x6 head
 head:
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 8], 1, Concat, [1]]  # cat backbone P5
-  - [-1, 3, C2, [768, False]]  # 14
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, C2, [512, False]]  # 17
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
-  - [-1, 3, C2, [256, False]]  # 20 (P3/8-small)
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 8], 1, Concat, [1]] # cat backbone P5
+  - [-1, 3, C2, [768, False]] # 14
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, C2, [512, False]] # 17
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
+  - [-1, 3, C2, [256, False]] # 20 (P3/8-small)
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 17], 1, Concat, [1]]  # cat head P4
-  - [-1, 3, C2, [512, False]]  # 23 (P4/16-medium)
+  - [[-1, 17], 1, Concat, [1]] # cat head P4
+  - [-1, 3, C2, [512, False]] # 23 (P4/16-medium)
 
   - [-1, 1, Conv, [512, 3, 2]]
-  - [[-1, 14], 1, Concat, [1]]  # cat head P5
-  - [-1, 3, C2, [768, False]]  # 26 (P5/32-large)
+  - [[-1, 14], 1, Concat, [1]] # cat head P5
+  - [-1, 3, C2, [768, False]] # 26 (P5/32-large)
 
   - [-1, 1, Conv, [768, 3, 2]]
-  - [[-1, 11], 1, Concat, [1]]  # cat head P6
-  - [-1, 3, C2, [1024, False]]  # 29 (P6/64-xlarge)
+  - [[-1, 11], 1, Concat, [1]] # cat head P6
+  - [-1, 3, C2, [1024, False]] # 29 (P6/64-xlarge)
 
-  - [[20, 23, 26, 29], 1, Segment, [nc, 32, 256]]  # Pose(P3, P4, P5, P6)
+  - [[20, 23, 26, 29], 1, Segment, [nc, 32, 256]] # Pose(P3, P4, P5, P6)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8-seg.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v5/yolov5-p6.yaml`

 * *Files 16% similar despite different names*

```diff
@@ -1,46 +1,59 @@
 # Ultralytics YOLO , AGPL-3.0 license
-# YOLOv8-seg instance segmentation model. For Usage examples see https://docs.ultralytics.com/tasks/segment
+# YOLOv5 object detection model with P3-P6 outputs. For details see https://docs.ultralytics.com/models/yolov5
 
 # Parameters
-nc: 80  # number of classes
-scales: # model compound scaling constants, i.e. 'model=yolov8n-seg.yaml' will call yolov8-seg.yaml with scale 'n'
+nc: 80 # number of classes
+scales: # model compound scaling constants, i.e. 'model=yolov5n-p6.yaml' will call yolov5-p6.yaml with scale 'n'
   # [depth, width, max_channels]
   n: [0.33, 0.25, 1024]
   s: [0.33, 0.50, 1024]
-  m: [0.67, 0.75, 768]
-  l: [1.00, 1.00, 512]
-  x: [1.00, 1.25, 512]
+  m: [0.67, 0.75, 1024]
+  l: [1.00, 1.00, 1024]
+  x: [1.33, 1.25, 1024]
 
-# YOLOv8.0n backbone
+# YOLOv5 v6.0 backbone
 backbone:
-  # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
-  - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
-  - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
-  - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 7-P5/32
-  - [-1, 3, C2f, [1024, True]]
-  - [-1, 1, SPPF, [1024, 5]]  # 9
+  # [from, number, module, args]
+  - [-1, 1, Conv, [64, 6, 2, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
+  - [-1, 3, C3, [128]]
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
+  - [-1, 6, C3, [256]]
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
+  - [-1, 9, C3, [512]]
+  - [-1, 1, Conv, [768, 3, 2]] # 7-P5/32
+  - [-1, 3, C3, [768]]
+  - [-1, 1, Conv, [1024, 3, 2]] # 9-P6/64
+  - [-1, 3, C3, [1024]]
+  - [-1, 1, SPPF, [1024, 5]] # 11
 
-# YOLOv8.0n head
+# YOLOv5 v6.0 head
 head:
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, C2f, [512]]  # 12
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
-  - [-1, 3, C2f, [256]]  # 15 (P3/8-small)
+  - [-1, 1, Conv, [768, 1, 1]]
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 8], 1, Concat, [1]] # cat backbone P5
+  - [-1, 3, C3, [768, False]] # 15
+
+  - [-1, 1, Conv, [512, 1, 1]]
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, C3, [512, False]] # 19
+
+  - [-1, 1, Conv, [256, 1, 1]]
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
+  - [-1, 3, C3, [256, False]] # 23 (P3/8-small)
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 12], 1, Concat, [1]]  # cat head P4
-  - [-1, 3, C2f, [512]]  # 18 (P4/16-medium)
+  - [[-1, 20], 1, Concat, [1]] # cat head P4
+  - [-1, 3, C3, [512, False]] # 26 (P4/16-medium)
 
   - [-1, 1, Conv, [512, 3, 2]]
-  - [[-1, 9], 1, Concat, [1]]  # cat head P5
-  - [-1, 3, C2f, [1024]]  # 21 (P5/32-large)
+  - [[-1, 16], 1, Concat, [1]] # cat head P5
+  - [-1, 3, C3, [768, False]] # 29 (P5/32-large)
 
-  - [[15, 18, 21], 1, Segment, [nc, 32, 256]]  # Segment(P3, P4, P5)
+  - [-1, 1, Conv, [768, 3, 2]]
+  - [[-1, 12], 1, Concat, [1]] # cat head P6
+  - [-1, 3, C3, [1024, False]] # 32 (P6/64-xlarge)
+
+  - [[23, 26, 29, 32], 1, Detect, [nc]] # Detect(P3, P4, P5, P6)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/models/v8/yolov8.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/models/v8/yolov8.yaml`

 * *Files 9% similar despite different names*

```diff
@@ -1,46 +1,46 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # YOLOv8 object detection model with P3-P5 outputs. For Usage examples see https://docs.ultralytics.com/tasks/detect
 
 # Parameters
-nc: 80  # number of classes
+nc: 80 # number of classes
 scales: # model compound scaling constants, i.e. 'model=yolov8n.yaml' will call yolov8.yaml with scale 'n'
   # [depth, width, max_channels]
-  n: [0.33, 0.25, 1024]  # YOLOv8n summary: 225 layers,  3157200 parameters,  3157184 gradients,   8.9 GFLOPs
-  s: [0.33, 0.50, 1024]  # YOLOv8s summary: 225 layers, 11166560 parameters, 11166544 gradients,  28.8 GFLOPs
-  m: [0.67, 0.75, 768]   # YOLOv8m summary: 295 layers, 25902640 parameters, 25902624 gradients,  79.3 GFLOPs
-  l: [1.00, 1.00, 512]   # YOLOv8l summary: 365 layers, 43691520 parameters, 43691504 gradients, 165.7 GFLOPs
-  x: [1.00, 1.25, 512]   # YOLOv8x summary: 365 layers, 68229648 parameters, 68229632 gradients, 258.5 GFLOPs
+  n: [0.33, 0.25, 1024] # YOLOv8n summary: 225 layers,  3157200 parameters,  3157184 gradients,   8.9 GFLOPs
+  s: [0.33, 0.50, 1024] # YOLOv8s summary: 225 layers, 11166560 parameters, 11166544 gradients,  28.8 GFLOPs
+  m: [0.67, 0.75, 768] # YOLOv8m summary: 295 layers, 25902640 parameters, 25902624 gradients,  79.3 GFLOPs
+  l: [1.00, 1.00, 512] # YOLOv8l summary: 365 layers, 43691520 parameters, 43691504 gradients, 165.7 GFLOPs
+  x: [1.00, 1.25, 512] # YOLOv8x summary: 365 layers, 68229648 parameters, 68229632 gradients, 258.5 GFLOPs
 
 # YOLOv8.0n backbone
 backbone:
   # [from, repeats, module, args]
-  - [-1, 1, Conv, [64, 3, 2]]  # 0-P1/2
-  - [-1, 1, Conv, [128, 3, 2]]  # 1-P2/4
+  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
+  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
   - [-1, 3, C2f, [128, True]]
-  - [-1, 1, Conv, [256, 3, 2]]  # 3-P3/8
+  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
   - [-1, 6, C2f, [256, True]]
-  - [-1, 1, Conv, [512, 3, 2]]  # 5-P4/16
+  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
   - [-1, 6, C2f, [512, True]]
-  - [-1, 1, Conv, [1024, 3, 2]]  # 7-P5/32
+  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32
   - [-1, 3, C2f, [1024, True]]
-  - [-1, 1, SPPF, [1024, 5]]  # 9
+  - [-1, 1, SPPF, [1024, 5]] # 9
 
 # YOLOv8.0n head
 head:
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 6], 1, Concat, [1]]  # cat backbone P4
-  - [-1, 3, C2f, [512]]  # 12
-
-  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]
-  - [[-1, 4], 1, Concat, [1]]  # cat backbone P3
-  - [-1, 3, C2f, [256]]  # 15 (P3/8-small)
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
+  - [-1, 3, C2f, [512]] # 12
+
+  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
+  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
+  - [-1, 3, C2f, [256]] # 15 (P3/8-small)
 
   - [-1, 1, Conv, [256, 3, 2]]
-  - [[-1, 12], 1, Concat, [1]]  # cat head P4
-  - [-1, 3, C2f, [512]]  # 18 (P4/16-medium)
+  - [[-1, 12], 1, Concat, [1]] # cat head P4
+  - [-1, 3, C2f, [512]] # 18 (P4/16-medium)
 
   - [-1, 1, Conv, [512, 3, 2]]
-  - [[-1, 9], 1, Concat, [1]]  # cat head P5
-  - [-1, 3, C2f, [1024]]  # 21 (P5/32-large)
+  - [[-1, 9], 1, Concat, [1]] # cat head P5
+  - [-1, 3, C2f, [1024]] # 21 (P5/32-large)
 
-  - [[15, 18, 21], 1, Detect, [nc]]  # Detect(P3, P4, P5)
+  - [[15, 18, 21], 1, Detect, [nc]] # Detect(P3, P4, P5)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/trackers/botsort.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/trackers/botsort.yaml`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # Default YOLO tracker settings for BoT-SORT tracker https://github.com/NirAharon/BoT-SORT
 
-tracker_type: botsort  # tracker type, ['botsort', 'bytetrack']
-track_high_thresh: 0.5  # threshold for the first association
-track_low_thresh: 0.1  # threshold for the second association
-new_track_thresh: 0.6  # threshold for init new track if the detection does not match any tracks
-track_buffer: 30  # buffer to calculate the time when to remove tracks
-match_thresh: 0.8  # threshold for matching tracks
+tracker_type: botsort # tracker type, ['botsort', 'bytetrack']
+track_high_thresh: 0.5 # threshold for the first association
+track_low_thresh: 0.1 # threshold for the second association
+new_track_thresh: 0.6 # threshold for init new track if the detection does not match any tracks
+track_buffer: 30 # buffer to calculate the time when to remove tracks
+match_thresh: 0.8 # threshold for matching tracks
 # min_box_area: 10  # threshold for min box areas(for tracker evaluation, not used for now)
 # mot20: False  # for tracker evaluation(not used for now)
 
 # BoT-SORT settings
-gmc_method: sparseOptFlow  # method of global motion compensation
+gmc_method: sparseOptFlow # method of global motion compensation
 # ReID model related thresh (not supported yet)
 proximity_thresh: 0.5
 appearance_thresh: 0.25
 with_reid: False
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/cfg/trackers/bytetrack.yaml` & `yolov8_pose_triton-8.2.0/ultralytics/cfg/trackers/bytetrack.yaml`

 * *Files 15% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 # Ultralytics YOLO , AGPL-3.0 license
 # Default YOLO tracker settings for ByteTrack tracker https://github.com/ifzhang/ByteTrack
 
-tracker_type: bytetrack  # tracker type, ['botsort', 'bytetrack']
-track_high_thresh: 0.5  # threshold for the first association
-track_low_thresh: 0.1  # threshold for the second association
-new_track_thresh: 0.6  # threshold for init new track if the detection does not match any tracks
-track_buffer: 30  # buffer to calculate the time when to remove tracks
-match_thresh: 0.8  # threshold for matching tracks
+tracker_type: bytetrack # tracker type, ['botsort', 'bytetrack']
+track_high_thresh: 0.5 # threshold for the first association
+track_low_thresh: 0.1 # threshold for the second association
+new_track_thresh: 0.6 # threshold for init new track if the detection does not match any tracks
+track_buffer: 30 # buffer to calculate the time when to remove tracks
+match_thresh: 0.8 # threshold for matching tracks
 # min_box_area: 10  # threshold for min box areas(for tracker evaluation, not used for now)
 # mot20: False  # for tracker evaluation(not used for now)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/data/annotator.py` & `yolov8_pose_triton-8.2.0/ultralytics/data/annotator.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 from pathlib import Path
 
 from ultralytics import SAM, YOLO
 
 
-def auto_annotate(data, det_model='yolov8x.pt', sam_model='sam_b.pt', device='', output_dir=None):
+def auto_annotate(data, det_model="yolov8x.pt", sam_model="sam_b.pt", device="", output_dir=None):
     """
     Automatically annotates images using a YOLO object detection model and a SAM segmentation model.
 
     Args:
         data (str): Path to a folder containing images to be annotated.
         det_model (str, optional): Pre-trained YOLO detection model. Defaults to 'yolov8x.pt'.
         sam_model (str, optional): Pre-trained SAM segmentation model. Defaults to 'sam_b.pt'.
@@ -25,26 +25,26 @@
         ```
     """
     det_model = YOLO(det_model)
     sam_model = SAM(sam_model)
 
     data = Path(data)
     if not output_dir:
-        output_dir = data.parent / f'{data.stem}_auto_annotate_labels'
+        output_dir = data.parent / f"{data.stem}_auto_annotate_labels"
     Path(output_dir).mkdir(exist_ok=True, parents=True)
 
     det_results = det_model(data, stream=True, device=device)
 
     for result in det_results:
         class_ids = result.boxes.cls.int().tolist()  # noqa
         if len(class_ids):
             boxes = result.boxes.xyxy  # Boxes object for bbox outputs
             sam_results = sam_model(result.orig_img, bboxes=boxes, verbose=False, save=False, device=device)
             segments = sam_results[0].masks.xyn  # noqa
 
-            with open(f'{str(Path(output_dir) / Path(result.path).stem)}.txt', 'w') as f:
+            with open(f"{Path(output_dir) / Path(result.path).stem}.txt", "w") as f:
                 for i in range(len(segments)):
                     s = segments[i]
                     if len(s) == 0:
                         continue
                     segment = map(str, segments[i].reshape(-1).tolist())
-                    f.write(f'{class_ids[i]} ' + ' '.join(segment) + '\n')
+                    f.write(f"{class_ids[i]} " + " ".join(segment) + "\n")
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/data/augment.py` & `yolov8_pose_triton-8.2.0/ultralytics/data/augment.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,26 +1,32 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import math
 import random
 from copy import deepcopy
+from typing import Tuple, Union
 
 import cv2
 import numpy as np
 import torch
-import torchvision.transforms as T
+from PIL import Image
 
 from ultralytics.utils import LOGGER, colorstr
 from ultralytics.utils.checks import check_version
 from ultralytics.utils.instance import Instances
 from ultralytics.utils.metrics import bbox_ioa
-from ultralytics.utils.ops import segment2box
+from ultralytics.utils.ops import segment2box, xyxyxyxy2xywhr
+from ultralytics.utils.torch_utils import TORCHVISION_0_10, TORCHVISION_0_11, TORCHVISION_0_13
 
 from .utils import polygons2masks, polygons2masks_overlap
 
+DEFAULT_MEAN = (0.0, 0.0, 0.0)
+DEFAULT_STD = (1.0, 1.0, 1.0)
+DEFAULT_CROP_FRACTION = 1.0
+
 
 # TODO: we might need a BaseTransform to make all these augments be compatible with both classification and semantic
 class BaseTransform:
     """
     Base class for image transformations.
 
     This is a generic transformation class that can be extended for specific image processing needs.
@@ -58,26 +64,49 @@
 
 
 class Compose:
     """Class for composing multiple image transformations."""
 
     def __init__(self, transforms):
         """Initializes the Compose object with a list of transforms."""
-        self.transforms = transforms
+        self.transforms = transforms if isinstance(transforms, list) else [transforms]
 
     def __call__(self, data):
         """Applies a series of transformations to input data."""
         for t in self.transforms:
             data = t(data)
         return data
 
     def append(self, transform):
         """Appends a new transform to the existing list of transforms."""
         self.transforms.append(transform)
 
+    def insert(self, index, transform):
+        """Inserts a new transform to the existing list of transforms."""
+        self.transforms.insert(index, transform)
+
+    def __getitem__(self, index: Union[list, int]) -> "Compose":
+        """Retrieve a specific transform or a set of transforms using indexing."""
+        assert isinstance(index, (int, list)), f"The indices should be either list or int type but got {type(index)}"
+        index = [index] if isinstance(index, int) else index
+        return Compose([self.transforms[i] for i in index])
+
+    def __setitem__(self, index: Union[list, int], value: Union[list, int]) -> None:
+        """Retrieve a specific transform or a set of transforms using indexing."""
+        assert isinstance(index, (int, list)), f"The indices should be either list or int type but got {type(index)}"
+        if isinstance(index, list):
+            assert isinstance(
+                value, list
+            ), f"The indices should be the same type as values, but got {type(index)} and {type(value)}"
+        if isinstance(index, int):
+            index, value = [index], [value]
+        for i, v in zip(index, value):
+            assert i < len(self.transforms), f"list index {i} out of range {len(self.transforms)}."
+            self.transforms[i] = v
+
     def tolist(self):
         """Converts the list of transforms to a standard Python list."""
         return self.transforms
 
     def __repr__(self):
         """Returns a string representation of the object."""
         return f"{self.__class__.__name__}({', '.join([f'{t}' for t in self.transforms])})"
@@ -108,29 +137,47 @@
 
         # Get images information will be used for Mosaic or MixUp
         mix_labels = [self.dataset.get_image_and_label(i) for i in indexes]
 
         if self.pre_transform is not None:
             for i, data in enumerate(mix_labels):
                 mix_labels[i] = self.pre_transform(data)
-        labels['mix_labels'] = mix_labels
+        labels["mix_labels"] = mix_labels
 
+        # Update cls and texts
+        labels = self._update_label_text(labels)
         # Mosaic or MixUp
         labels = self._mix_transform(labels)
-        labels.pop('mix_labels', None)
+        labels.pop("mix_labels", None)
         return labels
 
     def _mix_transform(self, labels):
         """Applies MixUp or Mosaic augmentation to the label dictionary."""
         raise NotImplementedError
 
     def get_indexes(self):
         """Gets a list of shuffled indexes for mosaic augmentation."""
         raise NotImplementedError
 
+    def _update_label_text(self, labels):
+        """Update label text."""
+        if "texts" not in labels:
+            return labels
+
+        mix_texts = sum([labels["texts"]] + [x["texts"] for x in labels["mix_labels"]], [])
+        mix_texts = list({tuple(x) for x in mix_texts})
+        text2id = {text: i for i, text in enumerate(mix_texts)}
+
+        for label in [labels] + labels["mix_labels"]:
+            for i, cls in enumerate(label["cls"].squeeze(-1).tolist()):
+                text = label["texts"][int(cls)]
+                label["cls"][i] = text2id[tuple(text)]
+            label["texts"] = mix_texts
+        return labels
+
 
 class Mosaic(BaseMixTransform):
     """
     Mosaic augmentation.
 
     This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image.
     The augmentation is applied to a dataset with a given probability.
@@ -140,16 +187,16 @@
         imgsz (int, optional): Image size (height and width) after mosaic pipeline of a single image. Default to 640.
         p (float, optional): Probability of applying the mosaic augmentation. Must be in the range 0-1. Default to 1.0.
         n (int, optional): The grid size, either 4 (for 2x2) or 9 (for 3x3).
     """
 
     def __init__(self, dataset, imgsz=640, p=1.0, n=4):
         """Initializes the object with a dataset, image size, probability, and border."""
-        assert 0 <= p <= 1.0, f'The probability should be in range [0, 1], but got {p}.'
-        assert n in (4, 9), 'grid must be equal to 4 or 9.'
+        assert 0 <= p <= 1.0, f"The probability should be in range [0, 1], but got {p}."
+        assert n in {4, 9}, "grid must be equal to 4 or 9."
         super().__init__(dataset=dataset, p=p)
         self.dataset = dataset
         self.imgsz = imgsz
         self.border = (-imgsz // 2, -imgsz // 2)  # width, height
         self.n = n
 
     def get_indexes(self, buffer=True):
@@ -157,28 +204,64 @@
         if buffer:  # select images from buffer
             return random.choices(list(self.dataset.buffer), k=self.n - 1)
         else:  # select any images
             return [random.randint(0, len(self.dataset) - 1) for _ in range(self.n - 1)]
 
     def _mix_transform(self, labels):
         """Apply mixup transformation to the input image and labels."""
-        assert labels.get('rect_shape', None) is None, 'rect and mosaic are mutually exclusive.'
-        assert len(labels.get('mix_labels', [])), 'There are no other images for mosaic augment.'
-        return self._mosaic4(labels) if self.n == 4 else self._mosaic9(labels)
+        assert labels.get("rect_shape", None) is None, "rect and mosaic are mutually exclusive."
+        assert len(labels.get("mix_labels", [])), "There are no other images for mosaic augment."
+        return (
+            self._mosaic3(labels) if self.n == 3 else self._mosaic4(labels) if self.n == 4 else self._mosaic9(labels)
+        )  # This code is modified for mosaic3 method.
+
+    def _mosaic3(self, labels):
+        """Create a 1x3 image mosaic."""
+        mosaic_labels = []
+        s = self.imgsz
+        for i in range(3):
+            labels_patch = labels if i == 0 else labels["mix_labels"][i - 1]
+            # Load image
+            img = labels_patch["img"]
+            h, w = labels_patch.pop("resized_shape")
+
+            # Place img in img3
+            if i == 0:  # center
+                img3 = np.full((s * 3, s * 3, img.shape[2]), 114, dtype=np.uint8)  # base image with 3 tiles
+                h0, w0 = h, w
+                c = s, s, s + w, s + h  # xmin, ymin, xmax, ymax (base) coordinates
+            elif i == 1:  # right
+                c = s + w0, s, s + w0 + w, s + h
+            elif i == 2:  # left
+                c = s - w, s + h0 - h, s, s + h0
+
+            padw, padh = c[:2]
+            x1, y1, x2, y2 = (max(x, 0) for x in c)  # allocate coords
+
+            img3[y1:y2, x1:x2] = img[y1 - padh :, x1 - padw :]  # img3[ymin:ymax, xmin:xmax]
+            # hp, wp = h, w  # height, width previous for next iteration
+
+            # Labels assuming imgsz*2 mosaic size
+            labels_patch = self._update_labels(labels_patch, padw + self.border[0], padh + self.border[1])
+            mosaic_labels.append(labels_patch)
+        final_labels = self._cat_labels(mosaic_labels)
+
+        final_labels["img"] = img3[-self.border[0] : self.border[0], -self.border[1] : self.border[1]]
+        return final_labels
 
     def _mosaic4(self, labels):
         """Create a 2x2 image mosaic."""
         mosaic_labels = []
         s = self.imgsz
         yc, xc = (int(random.uniform(-x, 2 * s + x)) for x in self.border)  # mosaic center x, y
         for i in range(4):
-            labels_patch = labels if i == 0 else labels['mix_labels'][i - 1]
+            labels_patch = labels if i == 0 else labels["mix_labels"][i - 1]
             # Load image
-            img = labels_patch['img']
-            h, w = labels_patch.pop('resized_shape')
+            img = labels_patch["img"]
+            h, w = labels_patch.pop("resized_shape")
 
             # Place img in img4
             if i == 0:  # top left
                 img4 = np.full((s * 2, s * 2, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles
                 x1a, y1a, x2a, y2a = max(xc - w, 0), max(yc - h, 0), xc, yc  # xmin, ymin, xmax, ymax (large image)
                 x1b, y1b, x2b, y2b = w - (x2a - x1a), h - (y2a - y1a), w, h  # xmin, ymin, xmax, ymax (small image)
             elif i == 1:  # top right
@@ -194,27 +277,27 @@
             img4[y1a:y2a, x1a:x2a] = img[y1b:y2b, x1b:x2b]  # img4[ymin:ymax, xmin:xmax]
             padw = x1a - x1b
             padh = y1a - y1b
 
             labels_patch = self._update_labels(labels_patch, padw, padh)
             mosaic_labels.append(labels_patch)
         final_labels = self._cat_labels(mosaic_labels)
-        final_labels['img'] = img4
+        final_labels["img"] = img4
         return final_labels
 
     def _mosaic9(self, labels):
         """Create a 3x3 image mosaic."""
         mosaic_labels = []
         s = self.imgsz
         hp, wp = -1, -1  # height, width previous
         for i in range(9):
-            labels_patch = labels if i == 0 else labels['mix_labels'][i - 1]
+            labels_patch = labels if i == 0 else labels["mix_labels"][i - 1]
             # Load image
-            img = labels_patch['img']
-            h, w = labels_patch.pop('resized_shape')
+            img = labels_patch["img"]
+            h, w = labels_patch.pop("resized_shape")
 
             # Place img in img9
             if i == 0:  # center
                 img9 = np.full((s * 3, s * 3, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles
                 h0, w0 = h, w
                 c = s, s, s + w, s + h  # xmin, ymin, xmax, ymax (base) coordinates
             elif i == 1:  # top
@@ -234,54 +317,58 @@
             elif i == 8:  # top left
                 c = s - w, s + h0 - hp - h, s, s + h0 - hp
 
             padw, padh = c[:2]
             x1, y1, x2, y2 = (max(x, 0) for x in c)  # allocate coords
 
             # Image
-            img9[y1:y2, x1:x2] = img[y1 - padh:, x1 - padw:]  # img9[ymin:ymax, xmin:xmax]
+            img9[y1:y2, x1:x2] = img[y1 - padh :, x1 - padw :]  # img9[ymin:ymax, xmin:xmax]
             hp, wp = h, w  # height, width previous for next iteration
 
             # Labels assuming imgsz*2 mosaic size
             labels_patch = self._update_labels(labels_patch, padw + self.border[0], padh + self.border[1])
             mosaic_labels.append(labels_patch)
         final_labels = self._cat_labels(mosaic_labels)
 
-        final_labels['img'] = img9[-self.border[0]:self.border[0], -self.border[1]:self.border[1]]
+        final_labels["img"] = img9[-self.border[0] : self.border[0], -self.border[1] : self.border[1]]
         return final_labels
 
     @staticmethod
     def _update_labels(labels, padw, padh):
         """Update labels."""
-        nh, nw = labels['img'].shape[:2]
-        labels['instances'].convert_bbox(format='xyxy')
-        labels['instances'].denormalize(nw, nh)
-        labels['instances'].add_padding(padw, padh)
+        nh, nw = labels["img"].shape[:2]
+        labels["instances"].convert_bbox(format="xyxy")
+        labels["instances"].denormalize(nw, nh)
+        labels["instances"].add_padding(padw, padh)
         return labels
 
     def _cat_labels(self, mosaic_labels):
         """Return labels with mosaic border instances clipped."""
         if len(mosaic_labels) == 0:
             return {}
         cls = []
         instances = []
         imgsz = self.imgsz * 2  # mosaic imgsz
         for labels in mosaic_labels:
-            cls.append(labels['cls'])
-            instances.append(labels['instances'])
+            cls.append(labels["cls"])
+            instances.append(labels["instances"])
+        # Final labels
         final_labels = {
-            'im_file': mosaic_labels[0]['im_file'],
-            'ori_shape': mosaic_labels[0]['ori_shape'],
-            'resized_shape': (imgsz, imgsz),
-            'cls': np.concatenate(cls, 0),
-            'instances': Instances.concatenate(instances, axis=0),
-            'mosaic_border': self.border}  # final_labels
-        final_labels['instances'].clip(imgsz, imgsz)
-        good = final_labels['instances'].remove_zero_area_boxes()
-        final_labels['cls'] = final_labels['cls'][good]
+            "im_file": mosaic_labels[0]["im_file"],
+            "ori_shape": mosaic_labels[0]["ori_shape"],
+            "resized_shape": (imgsz, imgsz),
+            "cls": np.concatenate(cls, 0),
+            "instances": Instances.concatenate(instances, axis=0),
+            "mosaic_border": self.border,
+        }
+        final_labels["instances"].clip(imgsz, imgsz)
+        good = final_labels["instances"].remove_zero_area_boxes()
+        final_labels["cls"] = final_labels["cls"][good]
+        if "texts" in mosaic_labels[0]:
+            final_labels["texts"] = mosaic_labels[0]["texts"]
         return final_labels
 
 
 class MixUp(BaseMixTransform):
     """Class for applying MixUp augmentation to the dataset."""
 
     def __init__(self, dataset, pre_transform=None, p=0.0) -> None:
@@ -291,18 +378,18 @@
     def get_indexes(self):
         """Get a random index from the dataset."""
         return random.randint(0, len(self.dataset) - 1)
 
     def _mix_transform(self, labels):
         """Applies MixUp augmentation as per https://arxiv.org/pdf/1710.09412.pdf."""
         r = np.random.beta(32.0, 32.0)  # mixup ratio, alpha=beta=32.0
-        labels2 = labels['mix_labels'][0]
-        labels['img'] = (labels['img'] * r + labels2['img'] * (1 - r)).astype(np.uint8)
-        labels['instances'] = Instances.concatenate([labels['instances'], labels2['instances']], axis=0)
-        labels['cls'] = np.concatenate([labels['cls'], labels2['cls']], 0)
+        labels2 = labels["mix_labels"][0]
+        labels["img"] = (labels["img"] * r + labels2["img"] * (1 - r)).astype(np.uint8)
+        labels["instances"] = Instances.concatenate([labels["instances"], labels2["instances"]], axis=0)
+        labels["cls"] = np.concatenate([labels["cls"], labels2["cls"]], 0)
         return labels
 
 
 class RandomPerspective:
     """
     Implements random perspective and affine transformations on images and corresponding bounding boxes, segments, and
     keypoints. These transformations include rotation, translation, scaling, and shearing. The class also offers the
@@ -322,22 +409,17 @@
         apply_bboxes(bboxes, M): Transforms bounding boxes using the calculated affine matrix.
         apply_segments(segments, M): Transforms segments and generates new bounding boxes.
         apply_keypoints(keypoints, M): Transforms keypoints.
         __call__(labels): Main method to apply transformations to both images and their corresponding annotations.
         box_candidates(box1, box2): Filters out bounding boxes that don't meet certain criteria post-transformation.
     """
 
-    def __init__(self,
-                 degrees=0.0,
-                 translate=0.1,
-                 scale=0.5,
-                 shear=0.0,
-                 perspective=0.0,
-                 border=(0, 0),
-                 pre_transform=None):
+    def __init__(
+        self, degrees=0.0, translate=0.1, scale=0.5, shear=0.0, perspective=0.0, border=(0, 0), pre_transform=None
+    ):
         """Initializes RandomPerspective object with transformation parameters."""
 
         self.degrees = degrees
         self.translate = translate
         self.scale = scale
         self.shear = shear
         self.perspective = perspective
@@ -441,14 +523,16 @@
         xy = np.ones((n * num, 3), dtype=segments.dtype)
         segments = segments.reshape(-1, 2)
         xy[:, :2] = segments
         xy = xy @ M.T  # transform
         xy = xy[:, :2] / xy[:, 2:3]
         segments = xy.reshape(n, -1, 2)
         bboxes = np.stack([segment2box(xy, self.size[0], self.size[1]) for xy in segments], 0)
+        segments[..., 0] = segments[..., 0].clip(bboxes[:, 0:1], bboxes[:, 2:3])
+        segments[..., 1] = segments[..., 1].clip(bboxes[:, 1:2], bboxes[:, 3:4])
         return bboxes, segments
 
     def apply_keypoints(self, keypoints, M):
         """
         Apply affine to keypoints.
 
         Args:
@@ -473,26 +557,26 @@
     def __call__(self, labels):
         """
         Affine images and targets.
 
         Args:
             labels (dict): a dict of `bboxes`, `segments`, `keypoints`.
         """
-        if self.pre_transform and 'mosaic_border' not in labels:
+        if self.pre_transform and "mosaic_border" not in labels:
             labels = self.pre_transform(labels)
-        labels.pop('ratio_pad', None)  # do not need ratio pad
+        labels.pop("ratio_pad", None)  # do not need ratio pad
 
-        img = labels['img']
-        cls = labels['cls']
-        instances = labels.pop('instances')
+        img = labels["img"]
+        cls = labels["cls"]
+        instances = labels.pop("instances")
         # Make sure the coord formats are right
-        instances.convert_bbox(format='xyxy')
+        instances.convert_bbox(format="xyxy")
         instances.denormalize(*img.shape[:2][::-1])
 
-        border = labels.pop('mosaic_border', self.border)
+        border = labels.pop("mosaic_border", self.border)
         self.size = img.shape[1] + border[1] * 2, img.shape[0] + border[0] * 2  # w, h
         # M is affine matrix
         # Scale for func:`box_candidates`
         img, M, scale = self.affine_transform(img, border)
 
         bboxes = self.apply_bboxes(instances.bboxes, M)
 
@@ -500,28 +584,28 @@
         keypoints = instances.keypoints
         # Update bboxes if there are segments.
         if len(segments):
             bboxes, segments = self.apply_segments(segments, M)
 
         if keypoints is not None:
             keypoints = self.apply_keypoints(keypoints, M)
-        new_instances = Instances(bboxes, segments, keypoints, bbox_format='xyxy', normalized=False)
+        new_instances = Instances(bboxes, segments, keypoints, bbox_format="xyxy", normalized=False)
         # Clip
         new_instances.clip(*self.size)
 
         # Filter instances
         instances.scale(scale_w=scale, scale_h=scale, bbox_only=True)
         # Make the bboxes have the same scale with new_bboxes
-        i = self.box_candidates(box1=instances.bboxes.T,
-                                box2=new_instances.bboxes.T,
-                                area_thr=0.01 if len(segments) else 0.10)
-        labels['instances'] = new_instances[i]
-        labels['cls'] = cls[i]
-        labels['img'] = img
-        labels['resized_shape'] = img.shape[:2]
+        i = self.box_candidates(
+            box1=instances.bboxes.T, box2=new_instances.bboxes.T, area_thr=0.01 if len(segments) else 0.10
+        )
+        labels["instances"] = new_instances[i]
+        labels["cls"] = cls[i]
+        labels["img"] = img
+        labels["resized_shape"] = img.shape[:2]
         return labels
 
     def box_candidates(self, box1, box2, wh_thr=2, ar_thr=100, area_thr=0.1, eps=1e-16):
         """
         Compute box candidates based on a set of thresholds. This method compares the characteristics of the boxes
         before and after augmentation to decide whether a box is a candidate for further processing.
 
@@ -565,15 +649,15 @@
 
     def __call__(self, labels):
         """
         Applies random HSV augmentation to an image within the predefined limits.
 
         The modified image replaces the original image in the input 'labels' dict.
         """
-        img = labels['img']
+        img = labels["img"]
         if self.hgain or self.sgain or self.vgain:
             r = np.random.uniform(-1, 1, 3) * [self.hgain, self.sgain, self.vgain] + 1  # random gains
             hue, sat, val = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2HSV))
             dtype = img.dtype  # uint8
 
             x = np.arange(0, 256, dtype=r.dtype)
             lut_hue = ((x * r[0]) % 180).astype(dtype)
@@ -588,25 +672,25 @@
 class RandomFlip:
     """
     Applies a random horizontal or vertical flip to an image with a given probability.
 
     Also updates any instances (bounding boxes, keypoints, etc.) accordingly.
     """
 
-    def __init__(self, p=0.5, direction='horizontal', flip_idx=None) -> None:
+    def __init__(self, p=0.5, direction="horizontal", flip_idx=None) -> None:
         """
         Initializes the RandomFlip class with probability and direction.
 
         Args:
             p (float, optional): The probability of applying the flip. Must be between 0 and 1. Default is 0.5.
             direction (str, optional): The direction to apply the flip. Must be 'horizontal' or 'vertical'.
                 Default is 'horizontal'.
             flip_idx (array-like, optional): Index mapping for flipping keypoints, if any.
         """
-        assert direction in ['horizontal', 'vertical'], f'Support direction `horizontal` or `vertical`, got {direction}'
+        assert direction in {"horizontal", "vertical"}, f"Support direction `horizontal` or `vertical`, got {direction}"
         assert 0 <= p <= 1.0
 
         self.p = p
         self.direction = direction
         self.flip_idx = flip_idx
 
     def __call__(self, labels):
@@ -616,33 +700,33 @@
         Args:
             labels (dict): A dictionary containing the keys 'img' and 'instances'. 'img' is the image to be flipped.
                            'instances' is an object containing bounding boxes and optionally keypoints.
 
         Returns:
             (dict): The same dict with the flipped image and updated instances under the 'img' and 'instances' keys.
         """
-        img = labels['img']
-        instances = labels.pop('instances')
-        instances.convert_bbox(format='xywh')
+        img = labels["img"]
+        instances = labels.pop("instances")
+        instances.convert_bbox(format="xywh")
         h, w = img.shape[:2]
         h = 1 if instances.normalized else h
         w = 1 if instances.normalized else w
 
         # Flip up-down
-        if self.direction == 'vertical' and random.random() < self.p:
+        if self.direction == "vertical" and random.random() < self.p:
             img = np.flipud(img)
             instances.flipud(h)
-        if self.direction == 'horizontal' and random.random() < self.p:
+        if self.direction == "horizontal" and random.random() < self.p:
             img = np.fliplr(img)
             instances.fliplr(w)
             # For keypoints
             if self.flip_idx is not None and instances.keypoints is not None:
                 instances.keypoints = np.ascontiguousarray(instances.keypoints[:, self.flip_idx, :])
-        labels['img'] = np.ascontiguousarray(img)
-        labels['instances'] = instances
+        labels["img"] = np.ascontiguousarray(img)
+        labels["instances"] = instances
         return labels
 
 
 class LetterBox:
     """Resize image and padding for detection, instance segmentation, pose."""
 
     def __init__(self, new_shape=(640, 640), auto=False, scaleFill=False, scaleup=True, center=True, stride=32):
@@ -654,17 +738,17 @@
         self.stride = stride
         self.center = center  # Put the image in the middle or top-left
 
     def __call__(self, labels=None, image=None):
         """Return updated labels and image with added border."""
         if labels is None:
             labels = {}
-        img = labels.get('img') if image is None else image
+        img = labels.get("img") if image is None else image
         shape = img.shape[:2]  # current shape [height, width]
-        new_shape = labels.pop('rect_shape', self.new_shape)
+        new_shape = labels.pop("rect_shape", self.new_shape)
         if isinstance(new_shape, int):
             new_shape = (new_shape, new_shape)
 
         # Scale ratio (new / old)
         r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])
         if not self.scaleup:  # only scale down, do not scale up (for better val mAP)
             r = min(r, 1.0)
@@ -684,33 +768,34 @@
             dw /= 2  # divide padding into 2 sides
             dh /= 2
 
         if shape[::-1] != new_unpad:  # resize
             img = cv2.resize(img, new_unpad, interpolation=cv2.INTER_LINEAR)
         top, bottom = int(round(dh - 0.1)) if self.center else 0, int(round(dh + 0.1))
         left, right = int(round(dw - 0.1)) if self.center else 0, int(round(dw + 0.1))
-        img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT,
-                                 value=(114, 114, 114))  # add border
-        if labels.get('ratio_pad'):
-            labels['ratio_pad'] = (labels['ratio_pad'], (left, top))  # for evaluation
+        img = cv2.copyMakeBorder(
+            img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=(114, 114, 114)
+        )  # add border
+        if labels.get("ratio_pad"):
+            labels["ratio_pad"] = (labels["ratio_pad"], (left, top))  # for evaluation
 
         if len(labels):
             labels = self._update_labels(labels, ratio, dw, dh)
-            labels['img'] = img
-            labels['resized_shape'] = new_shape
+            labels["img"] = img
+            labels["resized_shape"] = new_shape
             return labels
         else:
             return img
 
     def _update_labels(self, labels, ratio, padw, padh):
         """Update labels."""
-        labels['instances'].convert_bbox(format='xyxy')
-        labels['instances'].denormalize(*labels['img'].shape[:2][::-1])
-        labels['instances'].scale(*ratio)
-        labels['instances'].add_padding(padw, padh)
+        labels["instances"].convert_bbox(format="xyxy")
+        labels["instances"].denormalize(*labels["img"].shape[:2][::-1])
+        labels["instances"].scale(*ratio)
+        labels["instances"].add_padding(padw, padh)
         return labels
 
 
 class CopyPaste:
     """
     Implements the Copy-Paste augmentation as described in the paper https://arxiv.org/abs/2012.07177. This class is
     responsible for applying the Copy-Paste augmentation on images and their corresponding instances.
@@ -739,19 +824,19 @@
         Returns:
             (dict): Dict with augmented image and updated instances under the 'img', 'cls', and 'instances' keys.
 
         Notes:
             1. Instances are expected to have 'segments' as one of their attributes for this augmentation to work.
             2. This method modifies the input dictionary 'labels' in place.
         """
-        im = labels['img']
-        cls = labels['cls']
+        im = labels["img"]
+        cls = labels["cls"]
         h, w = im.shape[:2]
-        instances = labels.pop('instances')
-        instances.convert_bbox(format='xyxy')
+        instances = labels.pop("instances")
+        instances.convert_bbox(format="xyxy")
         instances.denormalize(w, h)
         if self.p and len(instances.segments):
             n = len(instances)
             _, w, _ = im.shape  # height, width, channels
             im_new = np.zeros(im.shape, np.uint8)
 
             # Calculate ioa first then select indexes randomly
@@ -766,17 +851,17 @@
                 instances = Instances.concatenate((instances, ins_flip[[j]]), axis=0)
                 cv2.drawContours(im_new, instances.segments[[j]].astype(np.int32), -1, (1, 1, 1), cv2.FILLED)
 
             result = cv2.flip(im, 1)  # augment segments (flip left-right)
             i = cv2.flip(im_new, 1).astype(bool)
             im[i] = result[i]
 
-        labels['img'] = im
-        labels['cls'] = cls
-        labels['instances'] = instances
+        labels["img"] = im
+        labels["cls"] = cls
+        labels["instances"] = instances
         return labels
 
 
 class Albumentations:
     """
     Albumentations transformations.
 
@@ -785,52 +870,54 @@
     compression.
     """
 
     def __init__(self, p=1.0):
         """Initialize the transform object for YOLO bbox formatted params."""
         self.p = p
         self.transform = None
-        prefix = colorstr('albumentations: ')
+        prefix = colorstr("albumentations: ")
         try:
             import albumentations as A
 
-            check_version(A.__version__, '1.0.3', hard=True)  # version requirement
+            check_version(A.__version__, "1.0.3", hard=True)  # version requirement
 
+            # Transforms
             T = [
                 A.Blur(p=0.01),
                 A.MedianBlur(p=0.01),
                 A.ToGray(p=0.01),
                 A.CLAHE(p=0.01),
                 A.RandomBrightnessContrast(p=0.0),
                 A.RandomGamma(p=0.0),
-                A.ImageCompression(quality_lower=75, p=0.0)]  # transforms
-            self.transform = A.Compose(T, bbox_params=A.BboxParams(format='yolo', label_fields=['class_labels']))
+                A.ImageCompression(quality_lower=75, p=0.0),
+            ]
+            self.transform = A.Compose(T, bbox_params=A.BboxParams(format="yolo", label_fields=["class_labels"]))
 
-            LOGGER.info(prefix + ', '.join(f'{x}'.replace('always_apply=False, ', '') for x in T if x.p))
+            LOGGER.info(prefix + ", ".join(f"{x}".replace("always_apply=False, ", "") for x in T if x.p))
         except ImportError:  # package not installed, skip
             pass
         except Exception as e:
-            LOGGER.info(f'{prefix}{e}')
+            LOGGER.info(f"{prefix}{e}")
 
     def __call__(self, labels):
         """Generates object detections and returns a dictionary with detection results."""
-        im = labels['img']
-        cls = labels['cls']
+        im = labels["img"]
+        cls = labels["cls"]
         if len(cls):
-            labels['instances'].convert_bbox('xywh')
-            labels['instances'].normalize(*im.shape[:2][::-1])
-            bboxes = labels['instances'].bboxes
+            labels["instances"].convert_bbox("xywh")
+            labels["instances"].normalize(*im.shape[:2][::-1])
+            bboxes = labels["instances"].bboxes
             # TODO: add supports of segments and keypoints
             if self.transform and random.random() < self.p:
                 new = self.transform(image=im, bboxes=bboxes, class_labels=cls)  # transformed
-                if len(new['class_labels']) > 0:  # skip update if no bbox in new im
-                    labels['img'] = new['image']
-                    labels['cls'] = np.array(new['class_labels'])
-                    bboxes = np.array(new['bboxes'], dtype=np.float32)
-            labels['instances'].update(bboxes=bboxes)
+                if len(new["class_labels"]) > 0:  # skip update if no bbox in new im
+                    labels["img"] = new["image"]
+                    labels["cls"] = np.array(new["class_labels"])
+                    bboxes = np.array(new["bboxes"], dtype=np.float32)
+            labels["instances"].update(bboxes=bboxes)
         return labels
 
 
 # TODO: technically this is not an augmentation, maybe we should put this to another files
 class Format:
     """
     Formats image annotations for object detection, instance segmentation, and pose estimation tasks. The class
@@ -840,68 +927,86 @@
         bbox_format (str): Format for bounding boxes. Default is 'xywh'.
         normalize (bool): Whether to normalize bounding boxes. Default is True.
         return_mask (bool): Return instance masks for segmentation. Default is False.
         return_keypoint (bool): Return keypoints for pose estimation. Default is False.
         mask_ratio (int): Downsample ratio for masks. Default is 4.
         mask_overlap (bool): Whether to overlap masks. Default is True.
         batch_idx (bool): Keep batch indexes. Default is True.
+        bgr (float): The probability to return BGR images. Default is 0.0.
     """
 
-    def __init__(self,
-                 bbox_format='xywh',
-                 normalize=True,
-                 return_mask=False,
-                 return_keypoint=False,
-                 mask_ratio=4,
-                 mask_overlap=True,
-                 batch_idx=True):
+    def __init__(
+        self,
+        bbox_format="xywh",
+        normalize=True,
+        return_mask=False,
+        return_keypoint=False,
+        return_obb=False,
+        mask_ratio=4,
+        mask_overlap=True,
+        batch_idx=True,
+        bgr=0.0,
+    ):
         """Initializes the Format class with given parameters."""
         self.bbox_format = bbox_format
         self.normalize = normalize
         self.return_mask = return_mask  # set False when training detection only
         self.return_keypoint = return_keypoint
+        self.return_obb = return_obb
         self.mask_ratio = mask_ratio
         self.mask_overlap = mask_overlap
         self.batch_idx = batch_idx  # keep the batch indexes
+        self.bgr = bgr
 
     def __call__(self, labels):
         """Return formatted image, classes, bounding boxes & keypoints to be used by 'collate_fn'."""
-        img = labels.pop('img')
+        img = labels.pop("img")
         h, w = img.shape[:2]
-        cls = labels.pop('cls')
-        instances = labels.pop('instances')
+        cls = labels.pop("cls")
+        instances = labels.pop("instances")
         instances.convert_bbox(format=self.bbox_format)
         instances.denormalize(w, h)
         nl = len(instances)
 
         if self.return_mask:
             if nl:
                 masks, instances, cls = self._format_segments(instances, cls, w, h)
                 masks = torch.from_numpy(masks)
             else:
-                masks = torch.zeros(1 if self.mask_overlap else nl, img.shape[0] // self.mask_ratio,
-                                    img.shape[1] // self.mask_ratio)
-            labels['masks'] = masks
-        if self.normalize:
-            instances.normalize(w, h)
-        labels['img'] = self._format_img(img)
-        labels['cls'] = torch.from_numpy(cls) if nl else torch.zeros(nl)
-        labels['bboxes'] = torch.from_numpy(instances.bboxes) if nl else torch.zeros((nl, 4))
+                masks = torch.zeros(
+                    1 if self.mask_overlap else nl, img.shape[0] // self.mask_ratio, img.shape[1] // self.mask_ratio
+                )
+            labels["masks"] = masks
+        labels["img"] = self._format_img(img)
+        labels["cls"] = torch.from_numpy(cls) if nl else torch.zeros(nl)
+        labels["bboxes"] = torch.from_numpy(instances.bboxes) if nl else torch.zeros((nl, 4))
         if self.return_keypoint:
-            labels['keypoints'] = torch.from_numpy(instances.keypoints)
+            labels["keypoints"] = torch.from_numpy(instances.keypoints)
+            if self.normalize:
+                labels["keypoints"][..., 0] /= w
+                labels["keypoints"][..., 1] /= h
+        if self.return_obb:
+            labels["bboxes"] = (
+                xyxyxyxy2xywhr(torch.from_numpy(instances.segments)) if len(instances.segments) else torch.zeros((0, 5))
+            )
+        # NOTE: need to normalize obb in xywhr format for width-height consistency
+        if self.normalize:
+            labels["bboxes"][:, [0, 2]] /= w
+            labels["bboxes"][:, [1, 3]] /= h
         # Then we can use collate_fn
         if self.batch_idx:
-            labels['batch_idx'] = torch.zeros(nl)
+            labels["batch_idx"] = torch.zeros(nl)
         return labels
 
     def _format_img(self, img):
         """Format the image for YOLO from Numpy array to PyTorch tensor."""
         if len(img.shape) < 3:
             img = np.expand_dims(img, -1)
-        img = np.ascontiguousarray(img.transpose(2, 0, 1)[::-1])
+        img = img.transpose(2, 0, 1)
+        img = np.ascontiguousarray(img[::-1] if random.uniform(0, 1) > self.bgr else img)
         img = torch.from_numpy(img)
         return img
 
     def _format_segments(self, instances, cls, w, h):
         """Convert polygon points to bitmap."""
         segments = instances.segments
         if self.mask_overlap:
@@ -911,105 +1016,275 @@
             cls = cls[sorted_idx]
         else:
             masks = polygons2masks((h, w), segments, color=1, downsample_ratio=self.mask_ratio)
 
         return masks, instances, cls
 
 
+class RandomLoadText:
+    """
+    Randomly sample positive texts and negative texts and update the class indices accordingly to the number of samples.
+
+    Attributes:
+        prompt_format (str): Format for prompt. Default is '{}'.
+        neg_samples (tuple[int]): A ranger to randomly sample negative texts, Default is (80, 80).
+        max_samples (int): The max number of different text samples in one image, Default is 80.
+        padding (bool): Whether to pad texts to max_samples. Default is False.
+        padding_value (str): The padding text. Default is "".
+    """
+
+    def __init__(
+        self,
+        prompt_format: str = "{}",
+        neg_samples: Tuple[int, int] = (80, 80),
+        max_samples: int = 80,
+        padding: bool = False,
+        padding_value: str = "",
+    ) -> None:
+        """Initializes the RandomLoadText class with given parameters."""
+        self.prompt_format = prompt_format
+        self.neg_samples = neg_samples
+        self.max_samples = max_samples
+        self.padding = padding
+        self.padding_value = padding_value
+
+    def __call__(self, labels: dict) -> dict:
+        """Return updated classes and texts."""
+        assert "texts" in labels, "No texts found in labels."
+        class_texts = labels["texts"]
+        num_classes = len(class_texts)
+        cls = np.asarray(labels.pop("cls"), dtype=int)
+        pos_labels = np.unique(cls).tolist()
+
+        if len(pos_labels) > self.max_samples:
+            pos_labels = set(random.sample(pos_labels, k=self.max_samples))
+
+        neg_samples = min(min(num_classes, self.max_samples) - len(pos_labels), random.randint(*self.neg_samples))
+        neg_labels = []
+        for i in range(num_classes):
+            if i not in pos_labels:
+                neg_labels.append(i)
+        neg_labels = random.sample(neg_labels, k=neg_samples)
+
+        sampled_labels = pos_labels + neg_labels
+        random.shuffle(sampled_labels)
+
+        label2ids = {label: i for i, label in enumerate(sampled_labels)}
+        valid_idx = np.zeros(len(labels["instances"]), dtype=bool)
+        new_cls = []
+        for i, label in enumerate(cls.squeeze(-1).tolist()):
+            if label not in label2ids:
+                continue
+            valid_idx[i] = True
+            new_cls.append([label2ids[label]])
+        labels["instances"] = labels["instances"][valid_idx]
+        labels["cls"] = np.array(new_cls)
+
+        # Randomly select one prompt when there's more than one prompts
+        texts = []
+        for label in sampled_labels:
+            prompts = class_texts[label]
+            assert len(prompts) > 0
+            prompt = self.prompt_format.format(prompts[random.randrange(len(prompts))])
+            texts.append(prompt)
+
+        if self.padding:
+            valid_labels = len(pos_labels) + len(neg_labels)
+            num_padding = self.max_samples - valid_labels
+            if num_padding > 0:
+                texts += [self.padding_value] * num_padding
+
+        labels["texts"] = texts
+        return labels
+
+
 def v8_transforms(dataset, imgsz, hyp, stretch=False):
     """Convert images to a size suitable for YOLOv8 training."""
-    pre_transform = Compose([
-        Mosaic(dataset, imgsz=imgsz, p=hyp.mosaic),
-        CopyPaste(p=hyp.copy_paste),
-        RandomPerspective(
-            degrees=hyp.degrees,
-            translate=hyp.translate,
-            scale=hyp.scale,
-            shear=hyp.shear,
-            perspective=hyp.perspective,
-            pre_transform=None if stretch else LetterBox(new_shape=(imgsz, imgsz)),
-        )])
-    flip_idx = dataset.data.get('flip_idx', [])  # for keypoints augmentation
+    pre_transform = Compose(
+        [
+            Mosaic(dataset, imgsz=imgsz, p=hyp.mosaic),
+            CopyPaste(p=hyp.copy_paste),
+            RandomPerspective(
+                degrees=hyp.degrees,
+                translate=hyp.translate,
+                scale=hyp.scale,
+                shear=hyp.shear,
+                perspective=hyp.perspective,
+                pre_transform=None if stretch else LetterBox(new_shape=(imgsz, imgsz)),
+            ),
+        ]
+    )
+    flip_idx = dataset.data.get("flip_idx", [])  # for keypoints augmentation
     if dataset.use_keypoints:
-        kpt_shape = dataset.data.get('kpt_shape', None)
+        kpt_shape = dataset.data.get("kpt_shape", None)
         if len(flip_idx) == 0 and hyp.fliplr > 0.0:
             hyp.fliplr = 0.0
             LOGGER.warning("WARNING  No 'flip_idx' array defined in data.yaml, setting augmentation 'fliplr=0.0'")
         elif flip_idx and (len(flip_idx) != kpt_shape[0]):
-            raise ValueError(f'data.yaml flip_idx={flip_idx} length must be equal to kpt_shape[0]={kpt_shape[0]}')
+            raise ValueError(f"data.yaml flip_idx={flip_idx} length must be equal to kpt_shape[0]={kpt_shape[0]}")
 
-    return Compose([
-        pre_transform,
-        MixUp(dataset, pre_transform=pre_transform, p=hyp.mixup),
-        Albumentations(p=1.0),
-        RandomHSV(hgain=hyp.hsv_h, sgain=hyp.hsv_s, vgain=hyp.hsv_v),
-        RandomFlip(direction='vertical', p=hyp.flipud),
-        RandomFlip(direction='horizontal', p=hyp.fliplr, flip_idx=flip_idx)])  # transforms
+    return Compose(
+        [
+            pre_transform,
+            MixUp(dataset, pre_transform=pre_transform, p=hyp.mixup),
+            Albumentations(p=1.0),
+            RandomHSV(hgain=hyp.hsv_h, sgain=hyp.hsv_s, vgain=hyp.hsv_v),
+            RandomFlip(direction="vertical", p=hyp.flipud),
+            RandomFlip(direction="horizontal", p=hyp.fliplr, flip_idx=flip_idx),
+        ]
+    )  # transforms
 
 
 # Classification augmentations -----------------------------------------------------------------------------------------
-def classify_transforms(size=224, rect=False, mean=(0.0, 0.0, 0.0), std=(1.0, 1.0, 1.0)):  # IMAGENET_MEAN, IMAGENET_STD
-    """Transforms to apply if albumentations not installed."""
-    if not isinstance(size, int):
-        raise TypeError(f'classify_transforms() size {size} must be integer, not (list, tuple)')
-    transforms = [ClassifyLetterBox(size, auto=True) if rect else CenterCrop(size), ToTensor()]
-    if any(mean) or any(std):
-        transforms.append(T.Normalize(mean, std, inplace=True))
-    return T.Compose(transforms)
-
-
-def hsv2colorjitter(h, s, v):
-    """Map HSV (hue, saturation, value) jitter into ColorJitter values (brightness, contrast, saturation, hue)"""
-    return v, v, s, h
-
-
-def classify_albumentations(
-        augment=True,
-        size=224,
-        scale=(0.08, 1.0),
-        hflip=0.5,
-        vflip=0.0,
-        hsv_h=0.015,  # image HSV-Hue augmentation (fraction)
-        hsv_s=0.7,  # image HSV-Saturation augmentation (fraction)
-        hsv_v=0.4,  # image HSV-Value augmentation (fraction)
-        mean=(0.0, 0.0, 0.0),  # IMAGENET_MEAN
-        std=(1.0, 1.0, 1.0),  # IMAGENET_STD
-        auto_aug=False,
+def classify_transforms(
+    size=224,
+    mean=DEFAULT_MEAN,
+    std=DEFAULT_STD,
+    interpolation=Image.BILINEAR,
+    crop_fraction: float = DEFAULT_CROP_FRACTION,
 ):
-    """YOLOv8 classification Albumentations (optional, only used if package is installed)."""
-    prefix = colorstr('albumentations: ')
-    try:
-        import albumentations as A
-        from albumentations.pytorch import ToTensorV2
-
-        check_version(A.__version__, '1.0.3', hard=True)  # version requirement
-        if augment:  # Resize and crop
-            T = [A.RandomResizedCrop(height=size, width=size, scale=scale)]
-            if auto_aug:
-                # TODO: implement AugMix, AutoAug & RandAug in albumentations
-                LOGGER.info(f'{prefix}auto augmentations are currently not supported')
+    """
+    Classification transforms for evaluation/inference. Inspired by timm/data/transforms_factory.py.
+
+    Args:
+        size (int): image size
+        mean (tuple): mean values of RGB channels
+        std (tuple): std values of RGB channels
+        interpolation (T.InterpolationMode): interpolation mode. default is T.InterpolationMode.BILINEAR.
+        crop_fraction (float): fraction of image to crop. default is 1.0.
+
+    Returns:
+        (T.Compose): torchvision transforms
+    """
+    import torchvision.transforms as T  # scope for faster 'import ultralytics'
+
+    if isinstance(size, (tuple, list)):
+        assert len(size) == 2
+        scale_size = tuple(math.floor(x / crop_fraction) for x in size)
+    else:
+        scale_size = math.floor(size / crop_fraction)
+        scale_size = (scale_size, scale_size)
+
+    # Aspect ratio is preserved, crops center within image, no borders are added, image is lost
+    if scale_size[0] == scale_size[1]:
+        # Simple case, use torchvision built-in Resize with the shortest edge mode (scalar size arg)
+        tfl = [T.Resize(scale_size[0], interpolation=interpolation)]
+    else:
+        # Resize the shortest edge to matching target dim for non-square target
+        tfl = [T.Resize(scale_size)]
+    tfl += [T.CenterCrop(size)]
+
+    tfl += [
+        T.ToTensor(),
+        T.Normalize(
+            mean=torch.tensor(mean),
+            std=torch.tensor(std),
+        ),
+    ]
+
+    return T.Compose(tfl)
+
+
+# Classification training augmentations --------------------------------------------------------------------------------
+def classify_augmentations(
+    size=224,
+    mean=DEFAULT_MEAN,
+    std=DEFAULT_STD,
+    scale=None,
+    ratio=None,
+    hflip=0.5,
+    vflip=0.0,
+    auto_augment=None,
+    hsv_h=0.015,  # image HSV-Hue augmentation (fraction)
+    hsv_s=0.4,  # image HSV-Saturation augmentation (fraction)
+    hsv_v=0.4,  # image HSV-Value augmentation (fraction)
+    force_color_jitter=False,
+    erasing=0.0,
+    interpolation=Image.BILINEAR,
+):
+    """
+    Classification transforms with augmentation for training. Inspired by timm/data/transforms_factory.py.
+
+    Args:
+        size (int): image size
+        scale (tuple): scale range of the image. default is (0.08, 1.0)
+        ratio (tuple): aspect ratio range of the image. default is (3./4., 4./3.)
+        mean (tuple): mean values of RGB channels
+        std (tuple): std values of RGB channels
+        hflip (float): probability of horizontal flip
+        vflip (float): probability of vertical flip
+        auto_augment (str): auto augmentation policy. can be 'randaugment', 'augmix', 'autoaugment' or None.
+        hsv_h (float): image HSV-Hue augmentation (fraction)
+        hsv_s (float): image HSV-Saturation augmentation (fraction)
+        hsv_v (float): image HSV-Value augmentation (fraction)
+        force_color_jitter (bool): force to apply color jitter even if auto augment is enabled
+        erasing (float): probability of random erasing
+        interpolation (T.InterpolationMode): interpolation mode. default is T.InterpolationMode.BILINEAR.
+
+    Returns:
+        (T.Compose): torchvision transforms
+    """
+    # Transforms to apply if Albumentations not installed
+    import torchvision.transforms as T  # scope for faster 'import ultralytics'
+
+    if not isinstance(size, int):
+        raise TypeError(f"classify_transforms() size {size} must be integer, not (list, tuple)")
+    scale = tuple(scale or (0.08, 1.0))  # default imagenet scale range
+    ratio = tuple(ratio or (3.0 / 4.0, 4.0 / 3.0))  # default imagenet ratio range
+    primary_tfl = [T.RandomResizedCrop(size, scale=scale, ratio=ratio, interpolation=interpolation)]
+    if hflip > 0.0:
+        primary_tfl += [T.RandomHorizontalFlip(p=hflip)]
+    if vflip > 0.0:
+        primary_tfl += [T.RandomVerticalFlip(p=vflip)]
+
+    secondary_tfl = []
+    disable_color_jitter = False
+    if auto_augment:
+        assert isinstance(auto_augment, str)
+        # color jitter is typically disabled if AA/RA on,
+        # this allows override without breaking old hparm cfgs
+        disable_color_jitter = not force_color_jitter
+
+        if auto_augment == "randaugment":
+            if TORCHVISION_0_11:
+                secondary_tfl += [T.RandAugment(interpolation=interpolation)]
             else:
-                if hflip > 0:
-                    T += [A.HorizontalFlip(p=hflip)]
-                if vflip > 0:
-                    T += [A.VerticalFlip(p=vflip)]
-                if any((hsv_h, hsv_s, hsv_v)):
-                    T += [A.ColorJitter(*hsv2colorjitter(hsv_h, hsv_s, hsv_v))]  # brightness, contrast, saturation, hue
-        else:  # Use fixed crop for eval set (reproducibility)
-            T = [A.SmallestMaxSize(max_size=size), A.CenterCrop(height=size, width=size)]
-        T += [A.Normalize(mean=mean, std=std), ToTensorV2()]  # Normalize and convert to Tensor
-        LOGGER.info(prefix + ', '.join(f'{x}'.replace('always_apply=False, ', '') for x in T if x.p))
-        return A.Compose(T)
+                LOGGER.warning('"auto_augment=randaugment" requires torchvision >= 0.11.0. Disabling it.')
 
-    except ImportError:  # package not installed, skip
-        pass
-    except Exception as e:
-        LOGGER.info(f'{prefix}{e}')
+        elif auto_augment == "augmix":
+            if TORCHVISION_0_13:
+                secondary_tfl += [T.AugMix(interpolation=interpolation)]
+            else:
+                LOGGER.warning('"auto_augment=augmix" requires torchvision >= 0.13.0. Disabling it.')
+
+        elif auto_augment == "autoaugment":
+            if TORCHVISION_0_10:
+                secondary_tfl += [T.AutoAugment(interpolation=interpolation)]
+            else:
+                LOGGER.warning('"auto_augment=autoaugment" requires torchvision >= 0.10.0. Disabling it.')
+
+        else:
+            raise ValueError(
+                f'Invalid auto_augment policy: {auto_augment}. Should be one of "randaugment", '
+                f'"augmix", "autoaugment" or None'
+            )
+
+    if not disable_color_jitter:
+        secondary_tfl += [T.ColorJitter(brightness=hsv_v, contrast=hsv_v, saturation=hsv_s, hue=hsv_h)]
+
+    final_tfl = [
+        T.ToTensor(),
+        T.Normalize(mean=torch.tensor(mean), std=torch.tensor(std)),
+        T.RandomErasing(p=erasing, inplace=True),
+    ]
+
+    return T.Compose(primary_tfl + secondary_tfl + final_tfl)
 
 
+# NOTE: keep this class for backward compatibility
 class ClassifyLetterBox:
     """
     YOLOv8 LetterBox class for image preprocessing, designed to be part of a transformation pipeline, e.g.,
     T.Compose([LetterBox(size), ToTensor()]).
 
     Attributes:
         h (int): Target height of the image.
@@ -1048,18 +1323,19 @@
 
         # Calculate padding dimensions
         hs, ws = (math.ceil(x / self.stride) * self.stride for x in (h, w)) if self.auto else (self.h, self.w)
         top, left = round((hs - h) / 2 - 0.1), round((ws - w) / 2 - 0.1)
 
         # Create padded image
         im_out = np.full((hs, ws, 3), 114, dtype=im.dtype)
-        im_out[top:top + h, left:left + w] = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)
+        im_out[top : top + h, left : left + w] = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)
         return im_out
 
 
+# NOTE: keep this class for backward compatibility
 class CenterCrop:
     """YOLOv8 CenterCrop class for image preprocessing, designed to be part of a transformation pipeline, e.g.,
     T.Compose([CenterCrop(size), ToTensor()]).
     """
 
     def __init__(self, size=640):
         """Converts an image from numpy array to PyTorch tensor."""
@@ -1075,17 +1351,18 @@
 
         Returns:
             (numpy.ndarray): The center-cropped and resized image as a numpy array.
         """
         imh, imw = im.shape[:2]
         m = min(imh, imw)  # min dimension
         top, left = (imh - m) // 2, (imw - m) // 2
-        return cv2.resize(im[top:top + m, left:left + m], (self.w, self.h), interpolation=cv2.INTER_LINEAR)
+        return cv2.resize(im[top : top + m, left : left + m], (self.w, self.h), interpolation=cv2.INTER_LINEAR)
 
 
+# NOTE: keep this class for backward compatibility
 class ToTensor:
     """YOLOv8 ToTensor class for image preprocessing, i.e., T.Compose([LetterBox(size), ToTensor()])."""
 
     def __init__(self, half=False):
         """Initialize YOLOv8 ToTensor object with optional half-precision support."""
         super().__init__()
         self.half = half
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/data/base.py` & `yolov8_pose_triton-8.2.0/ultralytics/data/base.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 import cv2
 import numpy as np
 import psutil
 from torch.utils.data import Dataset
 
 from ultralytics.utils import DEFAULT_CFG, LOCAL_RANK, LOGGER, NUM_THREADS, TQDM
 
-from .utils import HELP_URL, IMG_FORMATS
+from .utils import FORMATS_HELP_MSG, HELP_URL, IMG_FORMATS
 
 
 class BaseDataset(Dataset):
     """
     Base dataset class for loading and processing image data.
 
     Args:
@@ -43,28 +43,30 @@
         labels (list): List of label data dictionaries.
         ni (int): Number of images in the dataset.
         ims (list): List of loaded images.
         npy_files (list): List of numpy file paths.
         transforms (callable): Image transformation function.
     """
 
-    def __init__(self,
-                 img_path,
-                 imgsz=640,
-                 cache=False,
-                 augment=True,
-                 hyp=DEFAULT_CFG,
-                 prefix='',
-                 rect=False,
-                 batch_size=16,
-                 stride=32,
-                 pad=0.5,
-                 single_cls=False,
-                 classes=None,
-                 fraction=1.0):
+    def __init__(
+        self,
+        img_path,
+        imgsz=640,
+        cache=False,
+        augment=True,
+        hyp=DEFAULT_CFG,
+        prefix="",
+        rect=False,
+        batch_size=16,
+        stride=32,
+        pad=0.5,
+        single_cls=False,
+        classes=None,
+        fraction=1.0,
+    ):
         """Initialize BaseDataset with given configuration and options."""
         super().__init__()
         self.img_path = img_path
         self.imgsz = imgsz
         self.augment = augment
         self.single_cls = single_cls
         self.prefix = prefix
@@ -81,85 +83,84 @@
             assert self.batch_size is not None
             self.set_rectangle()
 
         # Buffer thread for mosaic images
         self.buffer = []  # buffer size = batch size
         self.max_buffer_length = min((self.ni, self.batch_size * 8, 1000)) if self.augment else 0
 
-        # Cache images
-        if cache == 'ram' and not self.check_cache_ram():
-            cache = False
+        # Cache images (options are cache = True, False, None, "ram", "disk")
         self.ims, self.im_hw0, self.im_hw = [None] * self.ni, [None] * self.ni, [None] * self.ni
-        self.npy_files = [Path(f).with_suffix('.npy') for f in self.im_files]
-        if cache:
-            self.cache_images(cache)
+        self.npy_files = [Path(f).with_suffix(".npy") for f in self.im_files]
+        self.cache = cache.lower() if isinstance(cache, str) else "ram" if cache is True else None
+        if (self.cache == "ram" and self.check_cache_ram()) or self.cache == "disk":
+            self.cache_images()
 
         # Transforms
         self.transforms = self.build_transforms(hyp=hyp)
 
     def get_img_files(self, img_path):
         """Read image files."""
         try:
             f = []  # image files
             for p in img_path if isinstance(img_path, list) else [img_path]:
                 p = Path(p)  # os-agnostic
                 if p.is_dir():  # dir
-                    f += glob.glob(str(p / '**' / '*.*'), recursive=True)
+                    f += glob.glob(str(p / "**" / "*.*"), recursive=True)
                     # F = list(p.rglob('*.*'))  # pathlib
                 elif p.is_file():  # file
                     with open(p) as t:
                         t = t.read().strip().splitlines()
                         parent = str(p.parent) + os.sep
-                        f += [x.replace('./', parent) if x.startswith('./') else x for x in t]  # local to global path
+                        f += [x.replace("./", parent) if x.startswith("./") else x for x in t]  # local to global path
                         # F += [p.parent / x.lstrip(os.sep) for x in t]  # local to global path (pathlib)
                 else:
-                    raise FileNotFoundError(f'{self.prefix}{p} does not exist')
-            im_files = sorted(x.replace('/', os.sep) for x in f if x.split('.')[-1].lower() in IMG_FORMATS)
+                    raise FileNotFoundError(f"{self.prefix}{p} does not exist")
+            im_files = sorted(x.replace("/", os.sep) for x in f if x.split(".")[-1].lower() in IMG_FORMATS)
             # self.img_files = sorted([x for x in f if x.suffix[1:].lower() in IMG_FORMATS])  # pathlib
-            assert im_files, f'{self.prefix}No images found in {img_path}'
+            assert im_files, f"{self.prefix}No images found in {img_path}. {FORMATS_HELP_MSG}"
         except Exception as e:
-            raise FileNotFoundError(f'{self.prefix}Error loading data from {img_path}\n{HELP_URL}') from e
+            raise FileNotFoundError(f"{self.prefix}Error loading data from {img_path}\n{HELP_URL}") from e
         if self.fraction < 1:
-            im_files = im_files[:round(len(im_files) * self.fraction)]
+            im_files = im_files[: round(len(im_files) * self.fraction)]  # retain a fraction of the dataset
         return im_files
 
     def update_labels(self, include_class: Optional[list]):
         """Update labels to include only these classes (optional)."""
         include_class_array = np.array(include_class).reshape(1, -1)
         for i in range(len(self.labels)):
             if include_class is not None:
-                cls = self.labels[i]['cls']
-                bboxes = self.labels[i]['bboxes']
-                segments = self.labels[i]['segments']
-                keypoints = self.labels[i]['keypoints']
+                cls = self.labels[i]["cls"]
+                bboxes = self.labels[i]["bboxes"]
+                segments = self.labels[i]["segments"]
+                keypoints = self.labels[i]["keypoints"]
                 j = (cls == include_class_array).any(1)
-                self.labels[i]['cls'] = cls[j]
-                self.labels[i]['bboxes'] = bboxes[j]
+                self.labels[i]["cls"] = cls[j]
+                self.labels[i]["bboxes"] = bboxes[j]
                 if segments:
-                    self.labels[i]['segments'] = [segments[si] for si, idx in enumerate(j) if idx]
+                    self.labels[i]["segments"] = [segments[si] for si, idx in enumerate(j) if idx]
                 if keypoints is not None:
-                    self.labels[i]['keypoints'] = keypoints[j]
+                    self.labels[i]["keypoints"] = keypoints[j]
             if self.single_cls:
-                self.labels[i]['cls'][:, 0] = 0
+                self.labels[i]["cls"][:, 0] = 0
 
     def load_image(self, i, rect_mode=True):
         """Loads 1 image from dataset index 'i', returns (im, resized hw)."""
         im, f, fn = self.ims[i], self.im_files[i], self.npy_files[i]
         if im is None:  # not cached in RAM
             if fn.exists():  # load npy
                 try:
                     im = np.load(fn)
                 except Exception as e:
-                    LOGGER.warning(f'{self.prefix}WARNING  Removing corrupt *.npy image file {fn} due to: {e}')
+                    LOGGER.warning(f"{self.prefix}WARNING  Removing corrupt *.npy image file {fn} due to: {e}")
                     Path(fn).unlink(missing_ok=True)
                     im = cv2.imread(f)  # BGR
             else:  # read image
                 im = cv2.imread(f)  # BGR
             if im is None:
-                raise FileNotFoundError(f'Image Not Found {f}')
+                raise FileNotFoundError(f"Image Not Found {f}")
 
             h0, w0 = im.shape[:2]  # orig hw
             if rect_mode:  # resize long side to imgsz while maintaining aspect ratio
                 r = self.imgsz / max(h0, w0)  # ratio
                 if r != 1:  # if sizes are not equal
                     w, h = (min(math.ceil(w0 * r), self.imgsz), min(math.ceil(h0 * r), self.imgsz))
                     im = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)
@@ -168,34 +169,35 @@
 
             # Add to buffer if training with augmentations
             if self.augment:
                 self.ims[i], self.im_hw0[i], self.im_hw[i] = im, (h0, w0), im.shape[:2]  # im, hw_original, hw_resized
                 self.buffer.append(i)
                 if len(self.buffer) >= self.max_buffer_length:
                     j = self.buffer.pop(0)
-                    self.ims[j], self.im_hw0[j], self.im_hw[j] = None, None, None
+                    if self.cache != "ram":
+                        self.ims[j], self.im_hw0[j], self.im_hw[j] = None, None, None
 
             return im, (h0, w0), im.shape[:2]
 
         return self.ims[i], self.im_hw0[i], self.im_hw[i]
 
-    def cache_images(self, cache):
+    def cache_images(self):
         """Cache images to memory or disk."""
         b, gb = 0, 1 << 30  # bytes of cached images, bytes per gigabytes
-        fcn = self.cache_images_to_disk if cache == 'disk' else self.load_image
+        fcn, storage = (self.cache_images_to_disk, "Disk") if self.cache == "disk" else (self.load_image, "RAM")
         with ThreadPool(NUM_THREADS) as pool:
             results = pool.imap(fcn, range(self.ni))
             pbar = TQDM(enumerate(results), total=self.ni, disable=LOCAL_RANK > 0)
             for i, x in pbar:
-                if cache == 'disk':
+                if self.cache == "disk":
                     b += self.npy_files[i].stat().st_size
                 else:  # 'ram'
                     self.ims[i], self.im_hw0[i], self.im_hw[i] = x  # im, hw_orig, hw_resized = load_image(self, i)
                     b += self.ims[i].nbytes
-                pbar.desc = f'{self.prefix}Caching images ({b / gb:.1f}GB {cache})'
+                pbar.desc = f"{self.prefix}Caching images ({b / gb:.1f}GB {storage})"
             pbar.close()
 
     def cache_images_to_disk(self, i):
         """Saves an image as an *.npy file for faster loading."""
         f = self.npy_files[i]
         if not f.exists():
             np.save(f.as_posix(), cv2.imread(self.im_files[i]), allow_pickle=False)
@@ -203,31 +205,33 @@
     def check_cache_ram(self, safety_margin=0.5):
         """Check image caching requirements vs available memory."""
         b, gb = 0, 1 << 30  # bytes of cached images, bytes per gigabytes
         n = min(self.ni, 30)  # extrapolate from 30 random images
         for _ in range(n):
             im = cv2.imread(random.choice(self.im_files))  # sample image
             ratio = self.imgsz / max(im.shape[0], im.shape[1])  # max(h, w)  # ratio
-            b += im.nbytes * ratio ** 2
+            b += im.nbytes * ratio**2
         mem_required = b * self.ni / n * (1 + safety_margin)  # GB required to cache dataset into RAM
         mem = psutil.virtual_memory()
-        cache = mem_required < mem.available  # to cache or not to cache, that is the question
-        if not cache:
-            LOGGER.info(f'{self.prefix}{mem_required / gb:.1f}GB RAM required to cache images '
-                        f'with {int(safety_margin * 100)}% safety margin but only '
-                        f'{mem.available / gb:.1f}/{mem.total / gb:.1f}GB available, '
-                        f"{'caching images ' if cache else 'not caching images '}")
-        return cache
+        success = mem_required < mem.available  # to cache or not to cache, that is the question
+        if not success:
+            self.cache = None
+            LOGGER.info(
+                f"{self.prefix}{mem_required / gb:.1f}GB RAM required to cache images "
+                f"with {int(safety_margin * 100)}% safety margin but only "
+                f"{mem.available / gb:.1f}/{mem.total / gb:.1f}GB available, not caching images "
+            )
+        return success
 
     def set_rectangle(self):
         """Sets the shape of bounding boxes for YOLO detections as rectangles."""
         bi = np.floor(np.arange(self.ni) / self.batch_size).astype(int)  # batch index
         nb = bi[-1] + 1  # number of batches
 
-        s = np.array([x.pop('shape') for x in self.labels])  # hw
+        s = np.array([x.pop("shape") for x in self.labels])  # hw
         ar = s[:, 0] / s[:, 1]  # aspect ratio
         irect = ar.argsort()
         self.im_files = [self.im_files[i] for i in irect]
         self.labels = [self.labels[i] for i in irect]
         ar = ar[irect]
 
         # Set training image shapes
@@ -246,20 +250,22 @@
     def __getitem__(self, index):
         """Returns transformed label information for given index."""
         return self.transforms(self.get_image_and_label(index))
 
     def get_image_and_label(self, index):
         """Get and return label information from the dataset."""
         label = deepcopy(self.labels[index])  # requires deepcopy() https://github.com/ultralytics/ultralytics/pull/1948
-        label.pop('shape', None)  # shape is for rect, remove it
-        label['img'], label['ori_shape'], label['resized_shape'] = self.load_image(index)
-        label['ratio_pad'] = (label['resized_shape'][0] / label['ori_shape'][0],
-                              label['resized_shape'][1] / label['ori_shape'][1])  # for evaluation
+        label.pop("shape", None)  # shape is for rect, remove it
+        label["img"], label["ori_shape"], label["resized_shape"] = self.load_image(index)
+        label["ratio_pad"] = (
+            label["resized_shape"][0] / label["ori_shape"][0],
+            label["resized_shape"][1] / label["ori_shape"][1],
+        )  # for evaluation
         if self.rect:
-            label['rect_shape'] = self.batch_shapes[self.batch[index]]
+            label["rect_shape"] = self.batch_shapes[self.batch[index]]
         return self.update_labels_info(label)
 
     def __len__(self):
         """Returns the length of the labels list for the dataset."""
         return len(self.labels)
 
     def update_labels_info(self, label):
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/data/build.py` & `yolov8_pose_triton-8.2.0/ultralytics/data/build.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,35 +5,43 @@
 from pathlib import Path
 
 import numpy as np
 import torch
 from PIL import Image
 from torch.utils.data import dataloader, distributed
 
-from ultralytics.data.loaders import (LOADERS, LoadImages, LoadPilAndNumpy, LoadScreenshots, LoadStreams, LoadTensor,
-                                      SourceTypes, autocast_list)
+from ultralytics.data.loaders import (
+    LOADERS,
+    LoadImagesAndVideos,
+    LoadPilAndNumpy,
+    LoadScreenshots,
+    LoadStreams,
+    LoadTensor,
+    SourceTypes,
+    autocast_list,
+)
 from ultralytics.data.utils import IMG_FORMATS, VID_FORMATS
 from ultralytics.utils import RANK, colorstr
 from ultralytics.utils.checks import check_file
 
-from .dataset import YOLODataset
+from .dataset import GroundingDataset, YOLODataset, YOLOMultiModalDataset
 from .utils import PIN_MEMORY
 
 
 class InfiniteDataLoader(dataloader.DataLoader):
     """
     Dataloader that reuses workers.
 
     Uses same syntax as vanilla DataLoader.
     """
 
     def __init__(self, *args, **kwargs):
         """Dataloader that infinitely recycles workers, inherits from DataLoader."""
         super().__init__(*args, **kwargs)
-        object.__setattr__(self, 'batch_sampler', _RepeatSampler(self.batch_sampler))
+        object.__setattr__(self, "batch_sampler", _RepeatSampler(self.batch_sampler))
         self.iterator = super().__iter__()
 
     def __len__(self):
         """Returns the length of the batch sampler's sampler."""
         return len(self.batch_sampler.sampler)
 
     def __iter__(self):
@@ -66,112 +74,136 @@
         """Iterates over the 'sampler' and yields its contents."""
         while True:
             yield from iter(self.sampler)
 
 
 def seed_worker(worker_id):  # noqa
     """Set dataloader worker seed https://pytorch.org/docs/stable/notes/randomness.html#dataloader."""
-    worker_seed = torch.initial_seed() % 2 ** 32
+    worker_seed = torch.initial_seed() % 2**32
     np.random.seed(worker_seed)
     random.seed(worker_seed)
 
 
-def build_yolo_dataset(cfg, img_path, batch, data, mode='train', rect=False, stride=32):
+def build_yolo_dataset(cfg, img_path, batch, data, mode="train", rect=False, stride=32, multi_modal=False):
     """Build YOLO Dataset."""
-    return YOLODataset(
+    dataset = YOLOMultiModalDataset if multi_modal else YOLODataset
+    return dataset(
         img_path=img_path,
         imgsz=cfg.imgsz,
         batch_size=batch,
-        augment=mode == 'train',  # augmentation
+        augment=mode == "train",  # augmentation
         hyp=cfg,  # TODO: probably add a get_hyps_from_cfg function
         rect=cfg.rect or rect,  # rectangular batches
         cache=cfg.cache or None,
         single_cls=cfg.single_cls or False,
         stride=int(stride),
-        pad=0.0 if mode == 'train' else 0.5,
-        prefix=colorstr(f'{mode}: '),
-        use_segments=cfg.task == 'segment',
-        use_keypoints=cfg.task == 'pose',
+        pad=0.0 if mode == "train" else 0.5,
+        prefix=colorstr(f"{mode}: "),
+        task=cfg.task,
         classes=cfg.classes,
         data=data,
-        fraction=cfg.fraction if mode == 'train' else 1.0)
+        fraction=cfg.fraction if mode == "train" else 1.0,
+    )
+
+
+def build_grounding(cfg, img_path, json_file, batch, mode="train", rect=False, stride=32):
+    """Build YOLO Dataset."""
+    return GroundingDataset(
+        img_path=img_path,
+        json_file=json_file,
+        imgsz=cfg.imgsz,
+        batch_size=batch,
+        augment=mode == "train",  # augmentation
+        hyp=cfg,  # TODO: probably add a get_hyps_from_cfg function
+        rect=cfg.rect or rect,  # rectangular batches
+        cache=cfg.cache or None,
+        single_cls=cfg.single_cls or False,
+        stride=int(stride),
+        pad=0.0 if mode == "train" else 0.5,
+        prefix=colorstr(f"{mode}: "),
+        task=cfg.task,
+        classes=cfg.classes,
+        fraction=cfg.fraction if mode == "train" else 1.0,
+    )
 
 
 def build_dataloader(dataset, batch, workers, shuffle=True, rank=-1):
     """Return an InfiniteDataLoader or DataLoader for training or validation set."""
     batch = min(batch, len(dataset))
     nd = torch.cuda.device_count()  # number of CUDA devices
-    nw = min([os.cpu_count() // max(nd, 1), batch if batch > 1 else 0, workers])  # number of workers
+    nw = min([os.cpu_count() // max(nd, 1), workers])  # number of workers
     sampler = None if rank == -1 else distributed.DistributedSampler(dataset, shuffle=shuffle)
     generator = torch.Generator()
     generator.manual_seed(6148914691236517205 + RANK)
-    return InfiniteDataLoader(dataset=dataset,
-                              batch_size=batch,
-                              shuffle=shuffle and sampler is None,
-                              num_workers=nw,
-                              sampler=sampler,
-                              pin_memory=PIN_MEMORY,
-                              collate_fn=getattr(dataset, 'collate_fn', None),
-                              worker_init_fn=seed_worker,
-                              generator=generator)
+    return InfiniteDataLoader(
+        dataset=dataset,
+        batch_size=batch,
+        shuffle=shuffle and sampler is None,
+        num_workers=nw,
+        sampler=sampler,
+        pin_memory=PIN_MEMORY,
+        collate_fn=getattr(dataset, "collate_fn", None),
+        worker_init_fn=seed_worker,
+        generator=generator,
+    )
 
 
 def check_source(source):
     """Check source type and return corresponding flag values."""
     webcam, screenshot, from_img, in_memory, tensor = False, False, False, False, False
     if isinstance(source, (str, int, Path)):  # int for local usb camera
         source = str(source)
-        is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)
-        is_url = source.lower().startswith(('https://', 'http://', 'rtsp://', 'rtmp://', 'tcp://'))
-        webcam = source.isnumeric() or source.endswith('.streams') or (is_url and not is_file)
-        screenshot = source.lower() == 'screen'
+        is_file = Path(source).suffix[1:] in (IMG_FORMATS | VID_FORMATS)
+        is_url = source.lower().startswith(("https://", "http://", "rtsp://", "rtmp://", "tcp://"))
+        webcam = source.isnumeric() or source.endswith(".streams") or (is_url and not is_file)
+        screenshot = source.lower() == "screen"
         if is_url and is_file:
             source = check_file(source)  # download
     elif isinstance(source, LOADERS):
         in_memory = True
     elif isinstance(source, (list, tuple)):
         source = autocast_list(source)  # convert all list elements to PIL or np arrays
         from_img = True
     elif isinstance(source, (Image.Image, np.ndarray)):
         from_img = True
     elif isinstance(source, torch.Tensor):
         tensor = True
     else:
-        raise TypeError('Unsupported image type. For supported types see https://docs.ultralytics.com/modes/predict')
+        raise TypeError("Unsupported image type. For supported types see https://docs.ultralytics.com/modes/predict")
 
     return source, webcam, screenshot, from_img, in_memory, tensor
 
 
-def load_inference_source(source=None, imgsz=640, vid_stride=1, buffer=False):
+def load_inference_source(source=None, batch=1, vid_stride=1, buffer=False):
     """
     Loads an inference source for object detection and applies necessary transformations.
 
     Args:
         source (str, Path, Tensor, PIL.Image, np.ndarray): The input source for inference.
-        imgsz (int, optional): The size of the image for inference. Default is 640.
+        batch (int, optional): Batch size for dataloaders. Default is 1.
         vid_stride (int, optional): The frame interval for video sources. Default is 1.
         buffer (bool, optional): Determined whether stream frames will be buffered. Default is False.
 
     Returns:
         dataset (Dataset): A dataset object for the specified input source.
     """
-    source, webcam, screenshot, from_img, in_memory, tensor = check_source(source)
-    source_type = source.source_type if in_memory else SourceTypes(webcam, screenshot, from_img, tensor)
+    source, stream, screenshot, from_img, in_memory, tensor = check_source(source)
+    source_type = source.source_type if in_memory else SourceTypes(stream, screenshot, from_img, tensor)
 
     # Dataloader
     if tensor:
         dataset = LoadTensor(source)
     elif in_memory:
         dataset = source
-    elif webcam:
-        dataset = LoadStreams(source, imgsz=imgsz, vid_stride=vid_stride, buffer=buffer)
+    elif stream:
+        dataset = LoadStreams(source, vid_stride=vid_stride, buffer=buffer)
     elif screenshot:
-        dataset = LoadScreenshots(source, imgsz=imgsz)
+        dataset = LoadScreenshots(source)
     elif from_img:
-        dataset = LoadPilAndNumpy(source, imgsz=imgsz)
+        dataset = LoadPilAndNumpy(source)
     else:
-        dataset = LoadImages(source, imgsz=imgsz, vid_stride=vid_stride)
+        dataset = LoadImagesAndVideos(source, batch=batch, vid_stride=vid_stride)
 
     # Attach source types to the dataset
-    setattr(dataset, 'source_type', source_type)
+    setattr(dataset, "source_type", source_type)
 
     return dataset
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/data/converter.py` & `yolov8_pose_triton-8.2.0/ultralytics/data/converter.py`

 * *Files 27% similar despite different names*

```diff
@@ -16,18 +16,106 @@
     Converts 91-index COCO class IDs to 80-index COCO class IDs.
 
     Returns:
         (list): A list of 91 class IDs where the index represents the 80-index class ID and the value is the
             corresponding 91-index class ID.
     """
     return [
-        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, None, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, None, 24, 25, None,
-        None, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, None, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
-        51, 52, 53, 54, 55, 56, 57, 58, 59, None, 60, None, None, 61, None, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
-        None, 73, 74, 75, 76, 77, 78, 79, None]
+        0,
+        1,
+        2,
+        3,
+        4,
+        5,
+        6,
+        7,
+        8,
+        9,
+        10,
+        None,
+        11,
+        12,
+        13,
+        14,
+        15,
+        16,
+        17,
+        18,
+        19,
+        20,
+        21,
+        22,
+        23,
+        None,
+        24,
+        25,
+        None,
+        None,
+        26,
+        27,
+        28,
+        29,
+        30,
+        31,
+        32,
+        33,
+        34,
+        35,
+        36,
+        37,
+        38,
+        39,
+        None,
+        40,
+        41,
+        42,
+        43,
+        44,
+        45,
+        46,
+        47,
+        48,
+        49,
+        50,
+        51,
+        52,
+        53,
+        54,
+        55,
+        56,
+        57,
+        58,
+        59,
+        None,
+        60,
+        None,
+        None,
+        61,
+        None,
+        62,
+        63,
+        64,
+        65,
+        66,
+        67,
+        68,
+        69,
+        70,
+        71,
+        72,
+        None,
+        73,
+        74,
+        75,
+        76,
+        77,
+        78,
+        79,
+        None,
+    ]
 
 
 def coco80_to_coco91_class():
     """
     Converts 80-index (val2014) to 91-index (paper).
     For details see https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/.
 
@@ -38,118 +126,217 @@
         a = np.loadtxt('data/coco.names', dtype='str', delimiter='\n')
         b = np.loadtxt('data/coco_paper.names', dtype='str', delimiter='\n')
         x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco
         x2 = [list(b[i] == a).index(True) if any(b[i] == a) else None for i in range(91)]  # coco to darknet
         ```
     """
     return [
-        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 31, 32, 33, 34,
-        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
-        64, 65, 67, 70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 84, 85, 86, 87, 88, 89, 90]
-
-
-def convert_coco(labels_dir='../coco/annotations/',
-                 save_dir='coco_converted/',
-                 use_segments=False,
-                 use_keypoints=False,
-                 cls91to80=True):
+        1,
+        2,
+        3,
+        4,
+        5,
+        6,
+        7,
+        8,
+        9,
+        10,
+        11,
+        13,
+        14,
+        15,
+        16,
+        17,
+        18,
+        19,
+        20,
+        21,
+        22,
+        23,
+        24,
+        25,
+        27,
+        28,
+        31,
+        32,
+        33,
+        34,
+        35,
+        36,
+        37,
+        38,
+        39,
+        40,
+        41,
+        42,
+        43,
+        44,
+        46,
+        47,
+        48,
+        49,
+        50,
+        51,
+        52,
+        53,
+        54,
+        55,
+        56,
+        57,
+        58,
+        59,
+        60,
+        61,
+        62,
+        63,
+        64,
+        65,
+        67,
+        70,
+        72,
+        73,
+        74,
+        75,
+        76,
+        77,
+        78,
+        79,
+        80,
+        81,
+        82,
+        84,
+        85,
+        86,
+        87,
+        88,
+        89,
+        90,
+    ]
+
+
+def convert_coco(
+    labels_dir="../coco/annotations/",
+    save_dir="coco_converted/",
+    use_segments=False,
+    use_keypoints=False,
+    cls91to80=True,
+    lvis=False,
+):
     """
     Converts COCO dataset annotations to a YOLO annotation format  suitable for training YOLO models.
 
     Args:
         labels_dir (str, optional): Path to directory containing COCO dataset annotation files.
         save_dir (str, optional): Path to directory to save results to.
         use_segments (bool, optional): Whether to include segmentation masks in the output.
         use_keypoints (bool, optional): Whether to include keypoint annotations in the output.
         cls91to80 (bool, optional): Whether to map 91 COCO class IDs to the corresponding 80 COCO class IDs.
+        lvis (bool, optional): Whether to convert data in lvis dataset way.
 
     Example:
         ```python
         from ultralytics.data.converter import convert_coco
 
         convert_coco('../datasets/coco/annotations/', use_segments=True, use_keypoints=False, cls91to80=True)
+        convert_coco('../datasets/lvis/annotations/', use_segments=True, use_keypoints=False, cls91to80=False, lvis=True)
         ```
 
     Output:
         Generates output files in the specified output directory.
     """
 
     # Create dataset directory
     save_dir = increment_path(save_dir)  # increment if save directory already exists
-    for p in save_dir / 'labels', save_dir / 'images':
+    for p in save_dir / "labels", save_dir / "images":
         p.mkdir(parents=True, exist_ok=True)  # make dir
 
     # Convert classes
     coco80 = coco91_to_coco80_class()
 
     # Import json
-    for json_file in sorted(Path(labels_dir).resolve().glob('*.json')):
-        fn = Path(save_dir) / 'labels' / json_file.stem.replace('instances_', '')  # folder name
+    for json_file in sorted(Path(labels_dir).resolve().glob("*.json")):
+        lname = "" if lvis else json_file.stem.replace("instances_", "")
+        fn = Path(save_dir) / "labels" / lname  # folder name
         fn.mkdir(parents=True, exist_ok=True)
+        if lvis:
+            # NOTE: create folders for both train and val in advance,
+            # since LVIS val set contains images from COCO 2017 train in addition to the COCO 2017 val split.
+            (fn / "train2017").mkdir(parents=True, exist_ok=True)
+            (fn / "val2017").mkdir(parents=True, exist_ok=True)
         with open(json_file) as f:
             data = json.load(f)
 
         # Create image dict
-        images = {f'{x["id"]:d}': x for x in data['images']}
+        images = {f'{x["id"]:d}': x for x in data["images"]}
         # Create image-annotations dict
         imgToAnns = defaultdict(list)
-        for ann in data['annotations']:
-            imgToAnns[ann['image_id']].append(ann)
+        for ann in data["annotations"]:
+            imgToAnns[ann["image_id"]].append(ann)
 
+        image_txt = []
         # Write labels file
-        for img_id, anns in TQDM(imgToAnns.items(), desc=f'Annotations {json_file}'):
-            img = images[f'{img_id:d}']
-            h, w, f = img['height'], img['width'], img['file_name']
+        for img_id, anns in TQDM(imgToAnns.items(), desc=f"Annotations {json_file}"):
+            img = images[f"{img_id:d}"]
+            h, w = img["height"], img["width"]
+            f = str(Path(img["coco_url"]).relative_to("http://images.cocodataset.org")) if lvis else img["file_name"]
+            if lvis:
+                image_txt.append(str(Path("./images") / f))
 
             bboxes = []
             segments = []
             keypoints = []
             for ann in anns:
-                if ann['iscrowd']:
+                if ann.get("iscrowd", False):
                     continue
                 # The COCO box format is [top left x, top left y, width, height]
-                box = np.array(ann['bbox'], dtype=np.float64)
+                box = np.array(ann["bbox"], dtype=np.float64)
                 box[:2] += box[2:] / 2  # xy top-left corner to center
                 box[[0, 2]] /= w  # normalize x
                 box[[1, 3]] /= h  # normalize y
                 if box[2] <= 0 or box[3] <= 0:  # if w <= 0 and h <= 0
                     continue
 
-                cls = coco80[ann['category_id'] - 1] if cls91to80 else ann['category_id'] - 1  # class
+                cls = coco80[ann["category_id"] - 1] if cls91to80 else ann["category_id"] - 1  # class
                 box = [cls] + box.tolist()
                 if box not in bboxes:
                     bboxes.append(box)
-                if use_segments and ann.get('segmentation') is not None:
-                    if len(ann['segmentation']) == 0:
-                        segments.append([])
-                        continue
-                    elif len(ann['segmentation']) > 1:
-                        s = merge_multi_segment(ann['segmentation'])
-                        s = (np.concatenate(s, axis=0) / np.array([w, h])).reshape(-1).tolist()
-                    else:
-                        s = [j for i in ann['segmentation'] for j in i]  # all segments concatenated
-                        s = (np.array(s).reshape(-1, 2) / np.array([w, h])).reshape(-1).tolist()
-                    s = [cls] + s
-                    if s not in segments:
+                    if use_segments and ann.get("segmentation") is not None:
+                        if len(ann["segmentation"]) == 0:
+                            segments.append([])
+                            continue
+                        elif len(ann["segmentation"]) > 1:
+                            s = merge_multi_segment(ann["segmentation"])
+                            s = (np.concatenate(s, axis=0) / np.array([w, h])).reshape(-1).tolist()
+                        else:
+                            s = [j for i in ann["segmentation"] for j in i]  # all segments concatenated
+                            s = (np.array(s).reshape(-1, 2) / np.array([w, h])).reshape(-1).tolist()
+                        s = [cls] + s
                         segments.append(s)
-                if use_keypoints and ann.get('keypoints') is not None:
-                    keypoints.append(box + (np.array(ann['keypoints']).reshape(-1, 3) /
-                                            np.array([w, h, 1])).reshape(-1).tolist())
+                    if use_keypoints and ann.get("keypoints") is not None:
+                        keypoints.append(
+                            box + (np.array(ann["keypoints"]).reshape(-1, 3) / np.array([w, h, 1])).reshape(-1).tolist()
+                        )
 
             # Write
-            with open((fn / f).with_suffix('.txt'), 'a') as file:
+            with open((fn / f).with_suffix(".txt"), "a") as file:
                 for i in range(len(bboxes)):
                     if use_keypoints:
-                        line = *(keypoints[i]),  # cls, box, keypoints
+                        line = (*(keypoints[i]),)  # cls, box, keypoints
                     else:
-                        line = *(segments[i]
-                                 if use_segments and len(segments[i]) > 0 else bboxes[i]),  # cls, box or segments
-                    file.write(('%g ' * len(line)).rstrip() % line + '\n')
+                        line = (
+                            *(segments[i] if use_segments and len(segments[i]) > 0 else bboxes[i]),
+                        )  # cls, box or segments
+                    file.write(("%g " * len(line)).rstrip() % line + "\n")
+
+        if lvis:
+            with open((Path(save_dir) / json_file.name.replace("lvis_v1_", "").replace(".json", ".txt")), "a") as f:
+                for l in image_txt:
+                    f.write(f"{l}\n")
 
-    LOGGER.info(f'COCO data converted successfully.\nResults saved to {save_dir.resolve()}')
+    LOGGER.info(f"{'LVIS' if lvis else 'COCO'} data converted successfully.\nResults saved to {save_dir.resolve()}")
 
 
 def convert_dota_to_yolo_obb(dota_root_path: str):
     """
     Converts DOTA dataset annotations to YOLO OBB (Oriented Bounding Box) format.
 
     The function processes images in the 'train' and 'val' folders of the DOTA dataset. For each image, it reads the
@@ -163,94 +350,98 @@
         from ultralytics.data.converter import convert_dota_to_yolo_obb
 
         convert_dota_to_yolo_obb('path/to/DOTA')
         ```
 
     Notes:
         The directory structure assumed for the DOTA dataset:
+
             - DOTA
-                - images
-                    - train
-                    - val
-                - labels
-                    - train_original
-                    - val_original
+                 images
+                    train
+                    val
+                 labels
+                     train_original
+                     val_original
+
+        After execution, the function will organize the labels into:
 
-        After the function execution, the new labels will be saved in:
             - DOTA
-                - labels
-                    - train
-                    - val
+                 labels
+                     train
+                     val
     """
     dota_root_path = Path(dota_root_path)
 
     # Class names to indices mapping
     class_mapping = {
-        'plane': 0,
-        'ship': 1,
-        'storage-tank': 2,
-        'baseball-diamond': 3,
-        'tennis-court': 4,
-        'basketball-court': 5,
-        'ground-track-field': 6,
-        'harbor': 7,
-        'bridge': 8,
-        'large-vehicle': 9,
-        'small-vehicle': 10,
-        'helicopter': 11,
-        'roundabout': 12,
-        'soccer-ball-field': 13,
-        'swimming-pool': 14,
-        'container-crane': 15,
-        'airport': 16,
-        'helipad': 17}
+        "plane": 0,
+        "ship": 1,
+        "storage-tank": 2,
+        "baseball-diamond": 3,
+        "tennis-court": 4,
+        "basketball-court": 5,
+        "ground-track-field": 6,
+        "harbor": 7,
+        "bridge": 8,
+        "large-vehicle": 9,
+        "small-vehicle": 10,
+        "helicopter": 11,
+        "roundabout": 12,
+        "soccer-ball-field": 13,
+        "swimming-pool": 14,
+        "container-crane": 15,
+        "airport": 16,
+        "helipad": 17,
+    }
 
     def convert_label(image_name, image_width, image_height, orig_label_dir, save_dir):
         """Converts a single image's DOTA annotation to YOLO OBB format and saves it to a specified directory."""
-        orig_label_path = orig_label_dir / f'{image_name}.txt'
-        save_path = save_dir / f'{image_name}.txt'
+        orig_label_path = orig_label_dir / f"{image_name}.txt"
+        save_path = save_dir / f"{image_name}.txt"
 
-        with orig_label_path.open('r') as f, save_path.open('w') as g:
+        with orig_label_path.open("r") as f, save_path.open("w") as g:
             lines = f.readlines()
             for line in lines:
                 parts = line.strip().split()
                 if len(parts) < 9:
                     continue
                 class_name = parts[8]
                 class_idx = class_mapping[class_name]
                 coords = [float(p) for p in parts[:8]]
                 normalized_coords = [
-                    coords[i] / image_width if i % 2 == 0 else coords[i] / image_height for i in range(8)]
-                formatted_coords = ['{:.6g}'.format(coord) for coord in normalized_coords]
+                    coords[i] / image_width if i % 2 == 0 else coords[i] / image_height for i in range(8)
+                ]
+                formatted_coords = ["{:.6g}".format(coord) for coord in normalized_coords]
                 g.write(f"{class_idx} {' '.join(formatted_coords)}\n")
 
-    for phase in ['train', 'val']:
-        image_dir = dota_root_path / 'images' / phase
-        orig_label_dir = dota_root_path / 'labels' / f'{phase}_original'
-        save_dir = dota_root_path / 'labels' / phase
+    for phase in ["train", "val"]:
+        image_dir = dota_root_path / "images" / phase
+        orig_label_dir = dota_root_path / "labels" / f"{phase}_original"
+        save_dir = dota_root_path / "labels" / phase
 
         save_dir.mkdir(parents=True, exist_ok=True)
 
         image_paths = list(image_dir.iterdir())
-        for image_path in TQDM(image_paths, desc=f'Processing {phase} images'):
-            if image_path.suffix != '.png':
+        for image_path in TQDM(image_paths, desc=f"Processing {phase} images"):
+            if image_path.suffix != ".png":
                 continue
             image_name_without_ext = image_path.stem
             img = cv2.imread(str(image_path))
             h, w = img.shape[:2]
             convert_label(image_name_without_ext, w, h, orig_label_dir, save_dir)
 
 
 def min_index(arr1, arr2):
     """
     Find a pair of indexes with the shortest distance between two arrays of 2D points.
 
     Args:
-        arr1 (np.array): A NumPy array of shape (N, 2) representing N 2D points.
-        arr2 (np.array): A NumPy array of shape (M, 2) representing M 2D points.
+        arr1 (np.ndarray): A NumPy array of shape (N, 2) representing N 2D points.
+        arr2 (np.ndarray): A NumPy array of shape (M, 2) representing M 2D points.
 
     Returns:
         (tuple): A tuple containing the indexes of the points with the shortest distance in arr1 and arr2 respectively.
     """
     dis = ((arr1[:, None, :] - arr2[None, :, :]) ** 2).sum(-1)
     return np.unravel_index(np.argmin(dis, axis=None), dis.shape)
 
@@ -286,20 +477,85 @@
                 if len(idx) == 2 and idx[0] > idx[1]:
                     idx = idx[::-1]
                     segments[i] = segments[i][::-1, :]
 
                 segments[i] = np.roll(segments[i], -idx[0], axis=0)
                 segments[i] = np.concatenate([segments[i], segments[i][:1]])
                 # Deal with the first segment and the last one
-                if i in [0, len(idx_list) - 1]:
+                if i in {0, len(idx_list) - 1}:
                     s.append(segments[i])
                 else:
                     idx = [0, idx[1] - idx[0]]
-                    s.append(segments[i][idx[0]:idx[1] + 1])
+                    s.append(segments[i][idx[0] : idx[1] + 1])
 
         else:
             for i in range(len(idx_list) - 1, -1, -1):
-                if i not in [0, len(idx_list) - 1]:
+                if i not in {0, len(idx_list) - 1}:
                     idx = idx_list[i]
                     nidx = abs(idx[1] - idx[0])
                     s.append(segments[i][nidx:])
     return s
+
+
+def yolo_bbox2segment(im_dir, save_dir=None, sam_model="sam_b.pt"):
+    """
+    Converts existing object detection dataset (bounding boxes) to segmentation dataset or oriented bounding box (OBB)
+    in YOLO format. Generates segmentation data using SAM auto-annotator as needed.
+
+    Args:
+        im_dir (str | Path): Path to image directory to convert.
+        save_dir (str | Path): Path to save the generated labels, labels will be saved
+            into `labels-segment` in the same directory level of `im_dir` if save_dir is None. Default: None.
+        sam_model (str): Segmentation model to use for intermediate segmentation data; optional.
+
+    Notes:
+        The input directory structure assumed for dataset:
+
+            - im_dir
+                 001.jpg
+                 ..
+                 NNN.jpg
+            - labels
+                 001.txt
+                 ..
+                 NNN.txt
+    """
+    from tqdm import tqdm
+
+    from ultralytics import SAM
+    from ultralytics.data import YOLODataset
+    from ultralytics.utils import LOGGER
+    from ultralytics.utils.ops import xywh2xyxy
+
+    # NOTE: add placeholder to pass class index check
+    dataset = YOLODataset(im_dir, data=dict(names=list(range(1000))))
+    if len(dataset.labels[0]["segments"]) > 0:  # if it's segment data
+        LOGGER.info("Segmentation labels detected, no need to generate new ones!")
+        return
+
+    LOGGER.info("Detection labels detected, generating segment labels by SAM model!")
+    sam_model = SAM(sam_model)
+    for l in tqdm(dataset.labels, total=len(dataset.labels), desc="Generating segment labels"):
+        h, w = l["shape"]
+        boxes = l["bboxes"]
+        if len(boxes) == 0:  # skip empty labels
+            continue
+        boxes[:, [0, 2]] *= w
+        boxes[:, [1, 3]] *= h
+        im = cv2.imread(l["im_file"])
+        sam_results = sam_model(im, bboxes=xywh2xyxy(boxes), verbose=False, save=False)
+        l["segments"] = sam_results[0].masks.xyn
+
+    save_dir = Path(save_dir) if save_dir else Path(im_dir).parent / "labels-segment"
+    save_dir.mkdir(parents=True, exist_ok=True)
+    for l in dataset.labels:
+        texts = []
+        lb_name = Path(l["im_file"]).with_suffix(".txt").name
+        txt_file = save_dir / lb_name
+        cls = l["cls"]
+        for i, s in enumerate(l["segments"]):
+            line = (int(cls[i]), *s.reshape(-1))
+            texts.append(("%g " * len(line)).rstrip() % line)
+        if texts:
+            with open(txt_file, "a") as f:
+                f.writelines(text + "\n" for text in texts)
+    LOGGER.info(f"Generated segment labels saved in {save_dir}")
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/data/dataset.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/benchmarks.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,340 +1,403 @@
 # Ultralytics YOLO , AGPL-3.0 license
-import contextlib
-from itertools import repeat
-from multiprocessing.pool import ThreadPool
+"""
+Benchmark a YOLO model formats for speed and accuracy.
+
+Usage:
+    from ultralytics.utils.benchmarks import ProfileModels, benchmark
+    ProfileModels(['yolov8n.yaml', 'yolov8s.yaml']).profile()
+    benchmark(model='yolov8n.pt', imgsz=160)
+
+Format                  | `format=argument`         | Model
+---                     | ---                       | ---
+PyTorch                 | -                         | yolov8n.pt
+TorchScript             | `torchscript`             | yolov8n.torchscript
+ONNX                    | `onnx`                    | yolov8n.onnx
+OpenVINO                | `openvino`                | yolov8n_openvino_model/
+TensorRT                | `engine`                  | yolov8n.engine
+CoreML                  | `coreml`                  | yolov8n.mlpackage
+TensorFlow SavedModel   | `saved_model`             | yolov8n_saved_model/
+TensorFlow GraphDef     | `pb`                      | yolov8n.pb
+TensorFlow Lite         | `tflite`                  | yolov8n.tflite
+TensorFlow Edge TPU     | `edgetpu`                 | yolov8n_edgetpu.tflite
+TensorFlow.js           | `tfjs`                    | yolov8n_web_model/
+PaddlePaddle            | `paddle`                  | yolov8n_paddle_model/
+NCNN                    | `ncnn`                    | yolov8n_ncnn_model/
+"""
+
+import glob
+import platform
+import time
 from pathlib import Path
 
-import cv2
 import numpy as np
-import torch
-import torchvision
-
-from ultralytics.utils import LOCAL_RANK, NUM_THREADS, TQDM, colorstr, is_dir_writeable
-
-from .augment import Compose, Format, Instances, LetterBox, classify_albumentations, classify_transforms, v8_transforms
-from .base import BaseDataset
-from .utils import HELP_URL, LOGGER, get_hash, img2label_paths, verify_image, verify_image_label
+import torch.cuda
 
-# Ultralytics dataset *.cache version, >= 1.0.0 for YOLOv8
-DATASET_CACHE_VERSION = '1.0.3'
+from ultralytics import YOLO, YOLOWorld
+from ultralytics.cfg import TASK2DATA, TASK2METRIC
+from ultralytics.engine.exporter import export_formats
+from ultralytics.utils import ARM64, ASSETS, IS_JETSON, IS_RASPBERRYPI, LINUX, LOGGER, MACOS, TQDM, WEIGHTS_DIR
+from ultralytics.utils.checks import IS_PYTHON_3_12, check_requirements, check_yolo
+from ultralytics.utils.files import file_size
+from ultralytics.utils.torch_utils import select_device
 
 
-class YOLODataset(BaseDataset):
+def benchmark(
+    model=WEIGHTS_DIR / "yolov8n.pt", data=None, imgsz=160, half=False, int8=False, device="cpu", verbose=False
+):
     """
-    Dataset class for loading object detection and/or segmentation labels in YOLO format.
+    Benchmark a YOLO model across different formats for speed and accuracy.
 
     Args:
-        data (dict, optional): A dataset YAML dictionary. Defaults to None.
-        use_segments (bool, optional): If True, segmentation masks are used as labels. Defaults to False.
-        use_keypoints (bool, optional): If True, keypoints are used as labels. Defaults to False.
+        model (str | Path | optional): Path to the model file or directory. Default is
+            Path(SETTINGS['weights_dir']) / 'yolov8n.pt'.
+        data (str, optional): Dataset to evaluate on, inherited from TASK2DATA if not passed. Default is None.
+        imgsz (int, optional): Image size for the benchmark. Default is 160.
+        half (bool, optional): Use half-precision for the model if True. Default is False.
+        int8 (bool, optional): Use int8-precision for the model if True. Default is False.
+        device (str, optional): Device to run the benchmark on, either 'cpu' or 'cuda'. Default is 'cpu'.
+        verbose (bool | float | optional): If True or a float, assert benchmarks pass with given metric.
+            Default is False.
 
     Returns:
-        (torch.utils.data.Dataset): A PyTorch dataset object that can be used for training an object detection model.
-    """
+        df (pandas.DataFrame): A pandas DataFrame with benchmark results for each format, including file size,
+            metric, and inference time.
 
-    def __init__(self, *args, data=None, use_segments=False, use_keypoints=False, **kwargs):
-        """Initializes the YOLODataset with optional configurations for segments and keypoints."""
-        self.use_segments = use_segments
-        self.use_keypoints = use_keypoints
-        self.data = data
-        assert not (self.use_segments and self.use_keypoints), 'Can not use both segments and keypoints.'
-        super().__init__(*args, **kwargs)
+    Example:
+        ```python
+        from ultralytics.utils.benchmarks import benchmark
 
-    def cache_labels(self, path=Path('./labels.cache')):
-        """
-        Cache dataset labels, check images and read shapes.
+        benchmark(model='yolov8n.pt', imgsz=640)
+        ```
+    """
+    import pandas as pd  # scope for faster 'import ultralytics'
 
-        Args:
-            path (Path): path where to save the cache file (default: Path('./labels.cache')).
-        Returns:
-            (dict): labels.
-        """
-        x = {'labels': []}
-        nm, nf, ne, nc, msgs = 0, 0, 0, 0, []  # number missing, found, empty, corrupt, messages
-        desc = f'{self.prefix}Scanning {path.parent / path.stem}...'
-        total = len(self.im_files)
-        nkpt, ndim = self.data.get('kpt_shape', (0, 0))
-        if self.use_keypoints and (nkpt <= 0 or ndim not in (2, 3)):
-            raise ValueError("'kpt_shape' in data.yaml missing or incorrect. Should be a list with [number of "
-                             "keypoints, number of dims (2 for x,y or 3 for x,y,visible)], i.e. 'kpt_shape: [17, 3]'")
-        with ThreadPool(NUM_THREADS) as pool:
-            results = pool.imap(func=verify_image_label,
-                                iterable=zip(self.im_files, self.label_files, repeat(self.prefix),
-                                             repeat(self.use_keypoints), repeat(len(self.data['names'])), repeat(nkpt),
-                                             repeat(ndim)))
-            pbar = TQDM(results, desc=desc, total=total)
-            for im_file, lb, shape, segments, keypoint, nm_f, nf_f, ne_f, nc_f, msg in pbar:
-                nm += nm_f
-                nf += nf_f
-                ne += ne_f
-                nc += nc_f
-                if im_file:
-                    x['labels'].append(
-                        dict(
-                            im_file=im_file,
-                            shape=shape,
-                            cls=lb[:, 0:1],  # n, 1
-                            bboxes=lb[:, 1:],  # n, 4
-                            segments=segments,
-                            keypoints=keypoint,
-                            normalized=True,
-                            bbox_format='xywh'))
-                if msg:
-                    msgs.append(msg)
-                pbar.desc = f'{desc} {nf} images, {nm + ne} backgrounds, {nc} corrupt'
-            pbar.close()
-
-        if msgs:
-            LOGGER.info('\n'.join(msgs))
-        if nf == 0:
-            LOGGER.warning(f'{self.prefix}WARNING  No labels found in {path}. {HELP_URL}')
-        x['hash'] = get_hash(self.label_files + self.im_files)
-        x['results'] = nf, nm, ne, nc, len(self.im_files)
-        x['msgs'] = msgs  # warnings
-        save_dataset_cache_file(self.prefix, path, x)
-        return x
-
-    def get_labels(self):
-        """Returns dictionary of labels for YOLO training."""
-        self.label_files = img2label_paths(self.im_files)
-        cache_path = Path(self.label_files[0]).parent.with_suffix('.cache')
+    pd.options.display.max_columns = 10
+    pd.options.display.width = 120
+    device = select_device(device, verbose=False)
+    if isinstance(model, (str, Path)):
+        model = YOLO(model)
+
+    y = []
+    t0 = time.time()
+    for i, (name, format, suffix, cpu, gpu) in export_formats().iterrows():  # index, (name, format, suffix, CPU, GPU)
+        emoji, filename = "", None  # export defaults
         try:
-            cache, exists = load_dataset_cache_file(cache_path), True  # attempt to load a *.cache file
-            assert cache['version'] == DATASET_CACHE_VERSION  # matches current version
-            assert cache['hash'] == get_hash(self.label_files + self.im_files)  # identical hash
-        except (FileNotFoundError, AssertionError, AttributeError):
-            cache, exists = self.cache_labels(cache_path), False  # run cache ops
-
-        # Display cache
-        nf, nm, ne, nc, n = cache.pop('results')  # found, missing, empty, corrupt, total
-        if exists and LOCAL_RANK in (-1, 0):
-            d = f'Scanning {cache_path}... {nf} images, {nm + ne} backgrounds, {nc} corrupt'
-            TQDM(None, desc=self.prefix + d, total=n, initial=n)  # display results
-            if cache['msgs']:
-                LOGGER.info('\n'.join(cache['msgs']))  # display warnings
-
-        # Read cache
-        [cache.pop(k) for k in ('hash', 'version', 'msgs')]  # remove items
-        labels = cache['labels']
-        if not labels:
-            LOGGER.warning(f'WARNING  No images found in {cache_path}, training may not work correctly. {HELP_URL}')
-        self.im_files = [lb['im_file'] for lb in labels]  # update im_files
-
-        # Check if the dataset is all boxes or all segments
-        lengths = ((len(lb['cls']), len(lb['bboxes']), len(lb['segments'])) for lb in labels)
-        len_cls, len_boxes, len_segments = (sum(x) for x in zip(*lengths))
-        if len_segments and len_boxes != len_segments:
-            LOGGER.warning(
-                f'WARNING  Box and segment counts should be equal, but got len(segments) = {len_segments}, '
-                f'len(boxes) = {len_boxes}. To resolve this only boxes will be used and all segments will be removed. '
-                'To avoid this please supply either a detect or segment dataset, not a detect-segment mixed dataset.')
-            for lb in labels:
-                lb['segments'] = []
-        if len_cls == 0:
-            LOGGER.warning(f'WARNING  No labels found in {cache_path}, training may not work correctly. {HELP_URL}')
-        return labels
-
-    def build_transforms(self, hyp=None):
-        """Builds and appends transforms to the list."""
-        if self.augment:
-            hyp.mosaic = hyp.mosaic if self.augment and not self.rect else 0.0
-            hyp.mixup = hyp.mixup if self.augment and not self.rect else 0.0
-            transforms = v8_transforms(self, self.imgsz, hyp)
-        else:
-            transforms = Compose([LetterBox(new_shape=(self.imgsz, self.imgsz), scaleup=False)])
-        transforms.append(
-            Format(bbox_format='xywh',
-                   normalize=True,
-                   return_mask=self.use_segments,
-                   return_keypoint=self.use_keypoints,
-                   batch_idx=True,
-                   mask_ratio=hyp.mask_ratio,
-                   mask_overlap=hyp.overlap_mask))
-        return transforms
-
-    def close_mosaic(self, hyp):
-        """Sets mosaic, copy_paste and mixup options to 0.0 and builds transformations."""
-        hyp.mosaic = 0.0  # set mosaic ratio=0.0
-        hyp.copy_paste = 0.0  # keep the same behavior as previous v8 close-mosaic
-        hyp.mixup = 0.0  # keep the same behavior as previous v8 close-mosaic
-        self.transforms = self.build_transforms(hyp)
-
-    def update_labels_info(self, label):
-        """Custom your label format here."""
-        # NOTE: cls is not with bboxes now, classification and semantic segmentation need an independent cls label
-        # We can make it also support classification and semantic segmentation by add or remove some dict keys there.
-        bboxes = label.pop('bboxes')
-        segments = label.pop('segments')
-        keypoints = label.pop('keypoints', None)
-        bbox_format = label.pop('bbox_format')
-        normalized = label.pop('normalized')
-        label['instances'] = Instances(bboxes, segments, keypoints, bbox_format=bbox_format, normalized=normalized)
-        return label
+            # Checks
+            if i == 5:  # CoreML
+                assert not (IS_RASPBERRYPI or IS_JETSON), "CoreML export not supported on Raspberry Pi or NVIDIA Jetson"
+            if i == 9:  # Edge TPU
+                assert LINUX and not ARM64, "Edge TPU export only supported on non-aarch64 Linux"
+            elif i == 7:  # TF GraphDef
+                assert model.task != "obb", "TensorFlow GraphDef not supported for OBB task"
+            elif i in {5, 10}:  # CoreML and TF.js
+                assert MACOS or LINUX, "export only supported on macOS and Linux"
+            if i in {3, 5}:  # CoreML and OpenVINO
+                assert not IS_PYTHON_3_12, "CoreML and OpenVINO not supported on Python 3.12"
+            if i in {6, 7, 8, 9, 10}:  # All TF formats
+                assert not isinstance(model, YOLOWorld), "YOLOWorldv2 TensorFlow exports not supported by onnx2tf yet"
+            if i in {11}:  # Paddle
+                assert not isinstance(model, YOLOWorld), "YOLOWorldv2 Paddle exports not supported yet"
+            if i in {12}:  # NCNN
+                assert not isinstance(model, YOLOWorld), "YOLOWorldv2 NCNN exports not supported yet"
+            if "cpu" in device.type:
+                assert cpu, "inference not supported on CPU"
+            if "cuda" in device.type:
+                assert gpu, "inference not supported on GPU"
+
+            # Export
+            if format == "-":
+                filename = model.ckpt_path or model.cfg
+                exported_model = model  # PyTorch format
+            else:
+                filename = model.export(imgsz=imgsz, format=format, half=half, int8=int8, device=device, verbose=False)
+                exported_model = YOLO(filename, task=model.task)
+                assert suffix in str(filename), "export failed"
+            emoji = ""  # indicates export succeeded
+
+            # Predict
+            assert model.task != "pose" or i != 7, "GraphDef Pose inference is not supported"
+            assert i not in {9, 10}, "inference not supported"  # Edge TPU and TF.js are unsupported
+            assert i != 5 or platform.system() == "Darwin", "inference only supported on macOS>=10.13"  # CoreML
+            exported_model.predict(ASSETS / "bus.jpg", imgsz=imgsz, device=device, half=half)
+
+            # Validate
+            data = data or TASK2DATA[model.task]  # task to dataset, i.e. coco8.yaml for task=detect
+            key = TASK2METRIC[model.task]  # task to metric, i.e. metrics/mAP50-95(B) for task=detect
+            results = exported_model.val(
+                data=data, batch=1, imgsz=imgsz, plots=False, device=device, half=half, int8=int8, verbose=False
+            )
+            metric, speed = results.results_dict[key], results.speed["inference"]
+            y.append([name, "", round(file_size(filename), 1), round(metric, 4), round(speed, 2)])
+        except Exception as e:
+            if verbose:
+                assert type(e) is AssertionError, f"Benchmark failure for {name}: {e}"
+            LOGGER.warning(f"ERROR  Benchmark failure for {name}: {e}")
+            y.append([name, emoji, round(file_size(filename), 1), None, None])  # mAP, t_inference
+
+    # Print results
+    check_yolo(device=device)  # print system info
+    df = pd.DataFrame(y, columns=["Format", "Status", "Size (MB)", key, "Inference time (ms/im)"])
+
+    name = Path(model.ckpt_path).name
+    s = f"\nBenchmarks complete for {name} on {data} at imgsz={imgsz} ({time.time() - t0:.2f}s)\n{df}\n"
+    LOGGER.info(s)
+    with open("benchmarks.log", "a", errors="ignore", encoding="utf-8") as f:
+        f.write(s)
+
+    if verbose and isinstance(verbose, float):
+        metrics = df[key].array  # values to compare to floor
+        floor = verbose  # minimum metric floor to pass, i.e. = 0.29 mAP for YOLOv5n
+        assert all(x > floor for x in metrics if pd.notna(x)), f"Benchmark failure: metric(s) < floor {floor}"
 
-    @staticmethod
-    def collate_fn(batch):
-        """Collates data samples into batches."""
-        new_batch = {}
-        keys = batch[0].keys()
-        values = list(zip(*[list(b.values()) for b in batch]))
-        for i, k in enumerate(keys):
-            value = values[i]
-            if k == 'img':
-                value = torch.stack(value, 0)
-            if k in ['masks', 'keypoints', 'bboxes', 'cls']:
-                value = torch.cat(value, 0)
-            new_batch[k] = value
-        new_batch['batch_idx'] = list(new_batch['batch_idx'])
-        for i in range(len(new_batch['batch_idx'])):
-            new_batch['batch_idx'][i] += i  # add target image index for build_targets()
-        new_batch['batch_idx'] = torch.cat(new_batch['batch_idx'], 0)
-        return new_batch
+    return df
 
 
-# Classification dataloaders -------------------------------------------------------------------------------------------
-class ClassificationDataset(torchvision.datasets.ImageFolder):
+class ProfileModels:
     """
-    YOLO Classification Dataset.
+    ProfileModels class for profiling different models on ONNX and TensorRT.
 
-    Args:
-        root (str): Dataset path.
+    This class profiles the performance of different models, returning results such as model speed and FLOPs.
 
     Attributes:
-        cache_ram (bool): True if images should be cached in RAM, False otherwise.
-        cache_disk (bool): True if images should be cached on disk, False otherwise.
-        samples (list): List of samples containing file, index, npy, and im.
-        torch_transforms (callable): torchvision transforms applied to the dataset.
-        album_transforms (callable, optional): Albumentations transforms applied to the dataset if augment is True.
+        paths (list): Paths of the models to profile.
+        num_timed_runs (int): Number of timed runs for the profiling. Default is 100.
+        num_warmup_runs (int): Number of warmup runs before profiling. Default is 10.
+        min_time (float): Minimum number of seconds to profile for. Default is 60.
+        imgsz (int): Image size used in the models. Default is 640.
+
+    Methods:
+        profile(): Profiles the models and prints the result.
+
+    Example:
+        ```python
+        from ultralytics.utils.benchmarks import ProfileModels
+
+        ProfileModels(['yolov8n.yaml', 'yolov8s.yaml'], imgsz=640).profile()
+        ```
     """
 
-    def __init__(self, root, args, augment=False, cache=False, prefix=''):
+    def __init__(
+        self,
+        paths: list,
+        num_timed_runs=100,
+        num_warmup_runs=10,
+        min_time=60,
+        imgsz=640,
+        half=True,
+        trt=True,
+        device=None,
+    ):
         """
-        Initialize YOLO object with root, image size, augmentations, and cache settings.
+        Initialize the ProfileModels class for profiling models.
 
         Args:
-            root (str): Dataset path.
-            args (Namespace): Argument parser containing dataset related settings.
-            augment (bool, optional): True if dataset should be augmented, False otherwise. Defaults to False.
-            cache (bool | str | optional): Cache setting, can be True, False, 'ram' or 'disk'. Defaults to False.
+            paths (list): List of paths of the models to be profiled.
+            num_timed_runs (int, optional): Number of timed runs for the profiling. Default is 100.
+            num_warmup_runs (int, optional): Number of warmup runs before the actual profiling starts. Default is 10.
+            min_time (float, optional): Minimum time in seconds for profiling a model. Default is 60.
+            imgsz (int, optional): Size of the image used during profiling. Default is 640.
+            half (bool, optional): Flag to indicate whether to use half-precision floating point for profiling.
+            trt (bool, optional): Flag to indicate whether to profile using TensorRT. Default is True.
+            device (torch.device, optional): Device used for profiling. If None, it is determined automatically.
         """
-        super().__init__(root=root)
-        if augment and args.fraction < 1.0:  # reduce training fraction
-            self.samples = self.samples[:round(len(self.samples) * args.fraction)]
-        self.prefix = colorstr(f'{prefix}: ') if prefix else ''
-        self.cache_ram = cache is True or cache == 'ram'
-        self.cache_disk = cache == 'disk'
-        self.samples = self.verify_images()  # filter out bad images
-        self.samples = [list(x) + [Path(x[0]).with_suffix('.npy'), None] for x in self.samples]  # file, index, npy, im
-        self.torch_transforms = classify_transforms(args.imgsz, rect=args.rect)
-        self.album_transforms = classify_albumentations(
-            augment=augment,
-            size=args.imgsz,
-            scale=(1.0 - args.scale, 1.0),  # (0.08, 1.0)
-            hflip=args.fliplr,
-            vflip=args.flipud,
-            hsv_h=args.hsv_h,  # HSV-Hue augmentation (fraction)
-            hsv_s=args.hsv_s,  # HSV-Saturation augmentation (fraction)
-            hsv_v=args.hsv_v,  # HSV-Value augmentation (fraction)
-            mean=(0.0, 0.0, 0.0),  # IMAGENET_MEAN
-            std=(1.0, 1.0, 1.0),  # IMAGENET_STD
-            auto_aug=False) if augment else None
-
-    def __getitem__(self, i):
-        """Returns subset of data and targets corresponding to given indices."""
-        f, j, fn, im = self.samples[i]  # filename, index, filename.with_suffix('.npy'), image
-        if self.cache_ram and im is None:
-            im = self.samples[i][3] = cv2.imread(f)
-        elif self.cache_disk:
-            if not fn.exists():  # load npy
-                np.save(fn.as_posix(), cv2.imread(f), allow_pickle=False)
-            im = np.load(fn)
-        else:  # read image
-            im = cv2.imread(f)  # BGR
-        if self.album_transforms:
-            sample = self.album_transforms(image=cv2.cvtColor(im, cv2.COLOR_BGR2RGB))['image']
-        else:
-            sample = self.torch_transforms(im)
-        return {'img': sample, 'cls': j}
-
-    def __len__(self) -> int:
-        """Return the total number of samples in the dataset."""
-        return len(self.samples)
-
-    def verify_images(self):
-        """Verify all images in dataset."""
-        desc = f'{self.prefix}Scanning {self.root}...'
-        path = Path(self.root).with_suffix('.cache')  # *.cache file path
-
-        with contextlib.suppress(FileNotFoundError, AssertionError, AttributeError):
-            cache = load_dataset_cache_file(path)  # attempt to load a *.cache file
-            assert cache['version'] == DATASET_CACHE_VERSION  # matches current version
-            assert cache['hash'] == get_hash([x[0] for x in self.samples])  # identical hash
-            nf, nc, n, samples = cache.pop('results')  # found, missing, empty, corrupt, total
-            if LOCAL_RANK in (-1, 0):
-                d = f'{desc} {nf} images, {nc} corrupt'
-                TQDM(None, desc=d, total=n, initial=n)
-                if cache['msgs']:
-                    LOGGER.info('\n'.join(cache['msgs']))  # display warnings
-            return samples
-
-        # Run scan if *.cache retrieval failed
-        nf, nc, msgs, samples, x = 0, 0, [], [], {}
-        with ThreadPool(NUM_THREADS) as pool:
-            results = pool.imap(func=verify_image, iterable=zip(self.samples, repeat(self.prefix)))
-            pbar = TQDM(results, desc=desc, total=len(self.samples))
-            for sample, nf_f, nc_f, msg in pbar:
-                if nf_f:
-                    samples.append(sample)
-                if msg:
-                    msgs.append(msg)
-                nf += nf_f
-                nc += nc_f
-                pbar.desc = f'{desc} {nf} images, {nc} corrupt'
-            pbar.close()
-        if msgs:
-            LOGGER.info('\n'.join(msgs))
-        x['hash'] = get_hash([x[0] for x in self.samples])
-        x['results'] = nf, nc, len(samples), samples
-        x['msgs'] = msgs  # warnings
-        save_dataset_cache_file(self.prefix, path, x)
-        return samples
-
-
-def load_dataset_cache_file(path):
-    """Load an Ultralytics *.cache dictionary from path."""
-    import gc
-    gc.disable()  # reduce pickle load time https://github.com/ultralytics/ultralytics/pull/1585
-    cache = np.load(str(path), allow_pickle=True).item()  # load dict
-    gc.enable()
-    return cache
-
-
-def save_dataset_cache_file(prefix, path, x):
-    """Save an Ultralytics dataset *.cache dictionary x to path."""
-    x['version'] = DATASET_CACHE_VERSION  # add cache version
-    if is_dir_writeable(path.parent):
-        if path.exists():
-            path.unlink()  # remove *.cache file if exists
-        np.save(str(path), x)  # save cache for next time
-        path.with_suffix('.cache.npy').rename(path)  # remove .npy suffix
-        LOGGER.info(f'{prefix}New cache created: {path}')
-    else:
-        LOGGER.warning(f'{prefix}WARNING  Cache directory {path.parent} is not writeable, cache not saved.')
+        self.paths = paths
+        self.num_timed_runs = num_timed_runs
+        self.num_warmup_runs = num_warmup_runs
+        self.min_time = min_time
+        self.imgsz = imgsz
+        self.half = half
+        self.trt = trt  # run TensorRT profiling
+        self.device = device or torch.device(0 if torch.cuda.is_available() else "cpu")
+
+    def profile(self):
+        """Logs the benchmarking results of a model, checks metrics against floor and returns the results."""
+        files = self.get_files()
+
+        if not files:
+            print("No matching *.pt or *.onnx files found.")
+            return
+
+        table_rows = []
+        output = []
+        for file in files:
+            engine_file = file.with_suffix(".engine")
+            if file.suffix in {".pt", ".yaml", ".yml"}:
+                model = YOLO(str(file))
+                model.fuse()  # to report correct params and GFLOPs in model.info()
+                model_info = model.info()
+                if self.trt and self.device.type != "cpu" and not engine_file.is_file():
+                    engine_file = model.export(
+                        format="engine", half=self.half, imgsz=self.imgsz, device=self.device, verbose=False
+                    )
+                onnx_file = model.export(
+                    format="onnx", half=self.half, imgsz=self.imgsz, simplify=True, device=self.device, verbose=False
+                )
+            elif file.suffix == ".onnx":
+                model_info = self.get_onnx_model_info(file)
+                onnx_file = file
+            else:
+                continue
+
+            t_engine = self.profile_tensorrt_model(str(engine_file))
+            t_onnx = self.profile_onnx_model(str(onnx_file))
+            table_rows.append(self.generate_table_row(file.stem, t_onnx, t_engine, model_info))
+            output.append(self.generate_results_dict(file.stem, t_onnx, t_engine, model_info))
+
+        self.print_table(table_rows)
+        return output
+
+    def get_files(self):
+        """Returns a list of paths for all relevant model files given by the user."""
+        files = []
+        for path in self.paths:
+            path = Path(path)
+            if path.is_dir():
+                extensions = ["*.pt", "*.onnx", "*.yaml"]
+                files.extend([file for ext in extensions for file in glob.glob(str(path / ext))])
+            elif path.suffix in {".pt", ".yaml", ".yml"}:  # add non-existing
+                files.append(str(path))
+            else:
+                files.extend(glob.glob(str(path)))
+
+        print(f"Profiling: {sorted(files)}")
+        return [Path(file) for file in sorted(files)]
+
+    def get_onnx_model_info(self, onnx_file: str):
+        """Retrieves the information including number of layers, parameters, gradients and FLOPs for an ONNX model
+        file.
+        """
+        return 0.0, 0.0, 0.0, 0.0  # return (num_layers, num_params, num_gradients, num_flops)
 
+    @staticmethod
+    def iterative_sigma_clipping(data, sigma=2, max_iters=3):
+        """Applies an iterative sigma clipping algorithm to the given data times number of iterations."""
+        data = np.array(data)
+        for _ in range(max_iters):
+            mean, std = np.mean(data), np.std(data)
+            clipped_data = data[(data > mean - sigma * std) & (data < mean + sigma * std)]
+            if len(clipped_data) == len(data):
+                break
+            data = clipped_data
+        return data
+
+    def profile_tensorrt_model(self, engine_file: str, eps: float = 1e-3):
+        """Profiles the TensorRT model, measuring average run time and standard deviation among runs."""
+        if not self.trt or not Path(engine_file).is_file():
+            return 0.0, 0.0
+
+        # Model and input
+        model = YOLO(engine_file)
+        input_data = np.random.rand(self.imgsz, self.imgsz, 3).astype(np.float32)  # must be FP32
+
+        # Warmup runs
+        elapsed = 0.0
+        for _ in range(3):
+            start_time = time.time()
+            for _ in range(self.num_warmup_runs):
+                model(input_data, imgsz=self.imgsz, verbose=False)
+            elapsed = time.time() - start_time
+
+        # Compute number of runs as higher of min_time or num_timed_runs
+        num_runs = max(round(self.min_time / (elapsed + eps) * self.num_warmup_runs), self.num_timed_runs * 50)
+
+        # Timed runs
+        run_times = []
+        for _ in TQDM(range(num_runs), desc=engine_file):
+            results = model(input_data, imgsz=self.imgsz, verbose=False)
+            run_times.append(results[0].speed["inference"])  # Convert to milliseconds
+
+        run_times = self.iterative_sigma_clipping(np.array(run_times), sigma=2, max_iters=3)  # sigma clipping
+        return np.mean(run_times), np.std(run_times)
+
+    def profile_onnx_model(self, onnx_file: str, eps: float = 1e-3):
+        """Profiles an ONNX model by executing it multiple times and returns the mean and standard deviation of run
+        times.
+        """
+        check_requirements("onnxruntime")
+        import onnxruntime as ort
 
-# TODO: support semantic segmentation
-class SemanticDataset(BaseDataset):
-    """
-    Semantic Segmentation Dataset.
+        # Session with either 'TensorrtExecutionProvider', 'CUDAExecutionProvider', 'CPUExecutionProvider'
+        sess_options = ort.SessionOptions()
+        sess_options.graph_optimization_level = ort.GraphOptimizationLevel.ORT_ENABLE_ALL
+        sess_options.intra_op_num_threads = 8  # Limit the number of threads
+        sess = ort.InferenceSession(onnx_file, sess_options, providers=["CPUExecutionProvider"])
+
+        input_tensor = sess.get_inputs()[0]
+        input_type = input_tensor.type
+
+        # Mapping ONNX datatype to numpy datatype
+        if "float16" in input_type:
+            input_dtype = np.float16
+        elif "float" in input_type:
+            input_dtype = np.float32
+        elif "double" in input_type:
+            input_dtype = np.float64
+        elif "int64" in input_type:
+            input_dtype = np.int64
+        elif "int32" in input_type:
+            input_dtype = np.int32
+        else:
+            raise ValueError(f"Unsupported ONNX datatype {input_type}")
 
-    This class is responsible for handling datasets used for semantic segmentation tasks. It inherits functionalities
-    from the BaseDataset class.
+        input_data = np.random.rand(*input_tensor.shape).astype(input_dtype)
+        input_name = input_tensor.name
+        output_name = sess.get_outputs()[0].name
+
+        # Warmup runs
+        elapsed = 0.0
+        for _ in range(3):
+            start_time = time.time()
+            for _ in range(self.num_warmup_runs):
+                sess.run([output_name], {input_name: input_data})
+            elapsed = time.time() - start_time
+
+        # Compute number of runs as higher of min_time or num_timed_runs
+        num_runs = max(round(self.min_time / (elapsed + eps) * self.num_warmup_runs), self.num_timed_runs)
+
+        # Timed runs
+        run_times = []
+        for _ in TQDM(range(num_runs), desc=onnx_file):
+            start_time = time.time()
+            sess.run([output_name], {input_name: input_data})
+            run_times.append((time.time() - start_time) * 1000)  # Convert to milliseconds
+
+        run_times = self.iterative_sigma_clipping(np.array(run_times), sigma=2, max_iters=5)  # sigma clipping
+        return np.mean(run_times), np.std(run_times)
+
+    def generate_table_row(self, model_name, t_onnx, t_engine, model_info):
+        """Generates a formatted string for a table row that includes model performance and metric details."""
+        layers, params, gradients, flops = model_info
+        return (
+            f"| {model_name:18s} | {self.imgsz} | - | {t_onnx[0]:.2f}  {t_onnx[1]:.2f} ms | {t_engine[0]:.2f}  "
+            f"{t_engine[1]:.2f} ms | {params / 1e6:.1f} | {flops:.1f} |"
+        )
 
-    Note:
-        This class is currently a placeholder and needs to be populated with methods and attributes for supporting
-        semantic segmentation tasks.
-    """
+    @staticmethod
+    def generate_results_dict(model_name, t_onnx, t_engine, model_info):
+        """Generates a dictionary of model details including name, parameters, GFLOPS and speed metrics."""
+        layers, params, gradients, flops = model_info
+        return {
+            "model/name": model_name,
+            "model/parameters": params,
+            "model/GFLOPs": round(flops, 3),
+            "model/speed_ONNX(ms)": round(t_onnx[0], 3),
+            "model/speed_TensorRT(ms)": round(t_engine[0], 3),
+        }
 
-    def __init__(self):
-        """Initialize a SemanticDataset object."""
-        super().__init__()
+    @staticmethod
+    def print_table(table_rows):
+        """Formats and prints a comparison table for different models with given statistics and performance data."""
+        gpu = torch.cuda.get_device_name(0) if torch.cuda.is_available() else "GPU"
+        header = (
+            f"| Model | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | "
+            f"Speed<br><sup>{gpu} TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |"
+        )
+        separator = (
+            "|-------------|---------------------|--------------------|------------------------------|"
+            "-----------------------------------|------------------|-----------------|"
+        )
+
+        print(f"\n\n{header}")
+        print(separator)
+        for row in table_rows:
+            print(row)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/data/loaders.py` & `yolov8_pose_triton-8.2.0/ultralytics/data/loaders.py`

 * *Files 9% similar despite different names*

```diff
@@ -11,37 +11,35 @@
 
 import cv2
 import numpy as np
 import requests
 import torch
 from PIL import Image
 
-from ultralytics.data.utils import IMG_FORMATS, VID_FORMATS
-from ultralytics.utils import LOGGER, is_colab, is_kaggle, ops
+from ultralytics.data.utils import FORMATS_HELP_MSG, IMG_FORMATS, VID_FORMATS
+from ultralytics.utils import IS_COLAB, IS_KAGGLE, LOGGER, ops
 from ultralytics.utils.checks import check_requirements
 
 
 @dataclass
 class SourceTypes:
     """Class to represent various types of input sources for predictions."""
-    webcam: bool = False
+
+    stream: bool = False
     screenshot: bool = False
     from_img: bool = False
     tensor: bool = False
 
 
 class LoadStreams:
     """
-    Stream Loader for various types of video streams.
-
-    Suitable for use with `yolo predict source='rtsp://example.com/media.mp4'`, supports RTSP, RTMP, HTTP, and TCP streams.
+    Stream Loader for various types of video streams, Supports RTSP, RTMP, HTTP, and TCP streams.
 
     Attributes:
         sources (str): The source input paths or URLs for the video streams.
-        imgsz (int): The image size for processing, defaults to 640.
         vid_stride (int): Video frame-rate stride, defaults to 1.
         buffer (bool): Whether to buffer input streams, defaults to False.
         running (bool): Flag to indicate if the streaming thread is running.
         mode (str): Set to 'stream' indicating real-time capture.
         imgs (list): List of image frames for each stream.
         fps (list): List of FPS for each stream.
         frames (list): List of total frames for each stream.
@@ -53,79 +51,84 @@
     Methods:
         __init__: Initialize the stream loader.
         update: Read stream frames in daemon thread.
         close: Close stream loader and release resources.
         __iter__: Returns an iterator object for the class.
         __next__: Returns source paths, transformed, and original images for processing.
         __len__: Return the length of the sources object.
+
+    Example:
+         ```bash
+         yolo predict source='rtsp://example.com/media.mp4'
+         ```
     """
 
-    def __init__(self, sources='file.streams', imgsz=640, vid_stride=1, buffer=False):
+    def __init__(self, sources="file.streams", vid_stride=1, buffer=False):
         """Initialize instance variables and check for consistent input stream shapes."""
         torch.backends.cudnn.benchmark = True  # faster for fixed-size inference
         self.buffer = buffer  # buffer input streams
         self.running = True  # running flag for Thread
-        self.mode = 'stream'
-        self.imgsz = imgsz
+        self.mode = "stream"
         self.vid_stride = vid_stride  # video frame-rate stride
 
         sources = Path(sources).read_text().rsplit() if os.path.isfile(sources) else [sources]
         n = len(sources)
+        self.bs = n
         self.fps = [0] * n  # frames per second
         self.frames = [0] * n
         self.threads = [None] * n
         self.caps = [None] * n  # video capture objects
         self.imgs = [[] for _ in range(n)]  # images
         self.shape = [[] for _ in range(n)]  # image shapes
         self.sources = [ops.clean_str(x) for x in sources]  # clean source names for later
         for i, s in enumerate(sources):  # index, source
             # Start thread to read frames from video stream
-            st = f'{i + 1}/{n}: {s}... '
-            if urlparse(s).hostname in ('www.youtube.com', 'youtube.com', 'youtu.be'):  # if source is YouTube video
+            st = f"{i + 1}/{n}: {s}... "
+            if urlparse(s).hostname in {"www.youtube.com", "youtube.com", "youtu.be"}:  # if source is YouTube video
                 # YouTube format i.e. 'https://www.youtube.com/watch?v=Zgi9g1ksQHc' or 'https://youtu.be/LNwODJXcvt4'
                 s = get_best_youtube_url(s)
             s = eval(s) if s.isnumeric() else s  # i.e. s = '0' local webcam
-            if s == 0 and (is_colab() or is_kaggle()):
-                raise NotImplementedError("'source=0' webcam not supported in Colab and Kaggle notebooks. "
-                                          "Try running 'source=0' in a local environment.")
+            if s == 0 and (IS_COLAB or IS_KAGGLE):
+                raise NotImplementedError(
+                    "'source=0' webcam not supported in Colab and Kaggle notebooks. "
+                    "Try running 'source=0' in a local environment."
+                )
             self.caps[i] = cv2.VideoCapture(s)  # store video capture object
             if not self.caps[i].isOpened():
-                raise ConnectionError(f'{st}Failed to open {s}')
+                raise ConnectionError(f"{st}Failed to open {s}")
             w = int(self.caps[i].get(cv2.CAP_PROP_FRAME_WIDTH))
             h = int(self.caps[i].get(cv2.CAP_PROP_FRAME_HEIGHT))
             fps = self.caps[i].get(cv2.CAP_PROP_FPS)  # warning: may return 0 or nan
             self.frames[i] = max(int(self.caps[i].get(cv2.CAP_PROP_FRAME_COUNT)), 0) or float(
-                'inf')  # infinite stream fallback
+                "inf"
+            )  # infinite stream fallback
             self.fps[i] = max((fps if math.isfinite(fps) else 0) % 100, 0) or 30  # 30 FPS fallback
 
             success, im = self.caps[i].read()  # guarantee first frame
             if not success or im is None:
-                raise ConnectionError(f'{st}Failed to read images from {s}')
+                raise ConnectionError(f"{st}Failed to read images from {s}")
             self.imgs[i].append(im)
             self.shape[i] = im.shape
             self.threads[i] = Thread(target=self.update, args=([i, self.caps[i], s]), daemon=True)
-            LOGGER.info(f'{st}Success  ({self.frames[i]} frames of shape {w}x{h} at {self.fps[i]:.2f} FPS)')
+            LOGGER.info(f"{st}Success  ({self.frames[i]} frames of shape {w}x{h} at {self.fps[i]:.2f} FPS)")
             self.threads[i].start()
-        LOGGER.info('')  # newline
-
-        # Check for common shapes
-        self.bs = self.__len__()
+        LOGGER.info("")  # newline
 
     def update(self, i, cap, stream):
         """Read stream `i` frames in daemon thread."""
         n, f = 0, self.frames[i]  # frame number, frame array
         while self.running and cap.isOpened() and n < (f - 1):
             if len(self.imgs[i]) < 30:  # keep a <=30-image buffer
                 n += 1
                 cap.grab()  # .read() = .grab() followed by .retrieve()
                 if n % self.vid_stride == 0:
                     success, im = cap.retrieve()
                     if not success:
                         im = np.zeros(self.shape[i], dtype=np.uint8)
-                        LOGGER.warning('WARNING  Video stream unresponsive, please check your IP camera connection.')
+                        LOGGER.warning("WARNING  Video stream unresponsive, please check your IP camera connection.")
                         cap.open(stream)  # re-open stream if signal was lost
                     if self.buffer:
                         self.imgs[i].append(im)
                     else:
                         self.imgs[i] = [im]
             else:
                 time.sleep(0.01)  # wait until the buffer is empty
@@ -136,65 +139,63 @@
         for thread in self.threads:
             if thread.is_alive():
                 thread.join(timeout=5)  # Add timeout
         for cap in self.caps:  # Iterate through the stored VideoCapture objects
             try:
                 cap.release()  # release video capture
             except Exception as e:
-                LOGGER.warning(f'WARNING  Could not release VideoCapture object: {e}')
+                LOGGER.warning(f"WARNING  Could not release VideoCapture object: {e}")
         cv2.destroyAllWindows()
 
     def __iter__(self):
         """Iterates through YOLO image feed and re-opens unresponsive streams."""
         self.count = -1
         return self
 
     def __next__(self):
         """Returns source paths, transformed and original images for processing."""
         self.count += 1
 
         images = []
         for i, x in enumerate(self.imgs):
-
             # Wait until a frame is available in each buffer
             while not x:
-                if not self.threads[i].is_alive() or cv2.waitKey(1) == ord('q'):  # q to quit
+                if not self.threads[i].is_alive() or cv2.waitKey(1) == ord("q"):  # q to quit
                     self.close()
                     raise StopIteration
                 time.sleep(1 / min(self.fps))
                 x = self.imgs[i]
                 if not x:
-                    LOGGER.warning(f'WARNING  Waiting for stream {i}')
+                    LOGGER.warning(f"WARNING  Waiting for stream {i}")
 
             # Get and remove the first frame from imgs buffer
             if self.buffer:
                 images.append(x.pop(0))
 
             # Get the last frame, and clear the rest from the imgs buffer
             else:
                 images.append(x.pop(-1) if x else np.zeros(self.shape[i], dtype=np.uint8))
                 x.clear()
 
-        return self.sources, images, None, ''
+        return self.sources, images, [""] * self.bs
 
     def __len__(self):
         """Return the length of the sources object."""
-        return len(self.sources)  # 1E12 frames = 32 streams at 30 FPS for 30 years
+        return self.bs  # 1E12 frames = 32 streams at 30 FPS for 30 years
 
 
 class LoadScreenshots:
     """
     YOLOv8 screenshot dataloader.
 
     This class manages the loading of screenshot images for processing with YOLOv8.
     Suitable for use with `yolo predict source=screen`.
 
     Attributes:
         source (str): The source input indicating which screen to capture.
-        imgsz (int): The image size for processing, defaults to 640.
         screen (int): The screen number to capture.
         left (int): The left coordinate for screen capture area.
         top (int): The top coordinate for screen capture area.
         width (int): The width of the screen capture area.
         height (int): The height of the screen capture area.
         mode (str): Set to 'stream' indicating real-time capture.
         frame (int): Counter for captured frames.
@@ -203,63 +204,62 @@
         monitor (dict): Monitor configuration details.
 
     Methods:
         __iter__: Returns an iterator object.
         __next__: Captures the next screenshot and returns it.
     """
 
-    def __init__(self, source, imgsz=640):
+    def __init__(self, source):
         """Source = [screen_number left top width height] (pixels)."""
-        check_requirements('mss')
+        check_requirements("mss")
         import mss  # noqa
 
         source, *params = source.split()
         self.screen, left, top, width, height = 0, None, None, None, None  # default to full screen 0
         if len(params) == 1:
             self.screen = int(params[0])
         elif len(params) == 4:
             left, top, width, height = (int(x) for x in params)
         elif len(params) == 5:
             self.screen, left, top, width, height = (int(x) for x in params)
-        self.imgsz = imgsz
-        self.mode = 'stream'
+        self.mode = "stream"
         self.frame = 0
         self.sct = mss.mss()
         self.bs = 1
+        self.fps = 30
 
         # Parse monitor shape
         monitor = self.sct.monitors[self.screen]
-        self.top = monitor['top'] if top is None else (monitor['top'] + top)
-        self.left = monitor['left'] if left is None else (monitor['left'] + left)
-        self.width = width or monitor['width']
-        self.height = height or monitor['height']
-        self.monitor = {'left': self.left, 'top': self.top, 'width': self.width, 'height': self.height}
+        self.top = monitor["top"] if top is None else (monitor["top"] + top)
+        self.left = monitor["left"] if left is None else (monitor["left"] + left)
+        self.width = width or monitor["width"]
+        self.height = height or monitor["height"]
+        self.monitor = {"left": self.left, "top": self.top, "width": self.width, "height": self.height}
 
     def __iter__(self):
         """Returns an iterator of the object."""
         return self
 
     def __next__(self):
         """mss screen capture: get raw pixels from the screen as np array."""
         im0 = np.asarray(self.sct.grab(self.monitor))[:, :, :3]  # BGRA to BGR
-        s = f'screen {self.screen} (LTWH): {self.left},{self.top},{self.width},{self.height}: '
+        s = f"screen {self.screen} (LTWH): {self.left},{self.top},{self.width},{self.height}: "
 
         self.frame += 1
-        return [str(self.screen)], [im0], None, s  # screen, img, vid_cap, string
+        return [str(self.screen)], [im0], [s]  # screen, img, string
 
 
-class LoadImages:
+class LoadImagesAndVideos:
     """
     YOLOv8 image/video dataloader.
 
     This class manages the loading and pre-processing of image and video data for YOLOv8. It supports loading from
     various formats, including single image files, video files, and lists of image and video paths.
 
     Attributes:
-        imgsz (int): Image size, defaults to 640.
         files (list): List of image and video file paths.
         nf (int): Total number of files (images and videos).
         video_flag (list): Flags indicating whether a file is a video (True) or an image (False).
         mode (str): Current mode, 'image' or 'video'.
         vid_stride (int): Stride for video frame-rate, defaults to 1.
         bs (int): Batch size, set to 1 for this class.
         cap (cv2.VideoCapture): Video capture object for OpenCV.
@@ -267,156 +267,177 @@
         frames (int): Total number of frames in the video.
         count (int): Counter for iteration, initialized at 0 during `__iter__()`.
 
     Methods:
         _new_video(path): Create a new cv2.VideoCapture object for a given video path.
     """
 
-    def __init__(self, path, imgsz=640, vid_stride=1):
+    def __init__(self, path, batch=1, vid_stride=1):
         """Initialize the Dataloader and raise FileNotFoundError if file not found."""
         parent = None
-        if isinstance(path, str) and Path(path).suffix == '.txt':  # *.txt file with img/vid/dir on each line
+        if isinstance(path, str) and Path(path).suffix == ".txt":  # *.txt file with img/vid/dir on each line
             parent = Path(path).parent
             path = Path(path).read_text().splitlines()  # list of sources
         files = []
         for p in sorted(path) if isinstance(path, (list, tuple)) else [path]:
             a = str(Path(p).absolute())  # do not use .resolve() https://github.com/ultralytics/ultralytics/issues/2912
-            if '*' in a:
+            if "*" in a:
                 files.extend(sorted(glob.glob(a, recursive=True)))  # glob
             elif os.path.isdir(a):
-                files.extend(sorted(glob.glob(os.path.join(a, '*.*'))))  # dir
+                files.extend(sorted(glob.glob(os.path.join(a, "*.*"))))  # dir
             elif os.path.isfile(a):
                 files.append(a)  # files (absolute or relative to CWD)
             elif parent and (parent / p).is_file():
                 files.append(str((parent / p).absolute()))  # files (relative to *.txt file parent)
             else:
-                raise FileNotFoundError(f'{p} does not exist')
+                raise FileNotFoundError(f"{p} does not exist")
 
-        images = [x for x in files if x.split('.')[-1].lower() in IMG_FORMATS]
-        videos = [x for x in files if x.split('.')[-1].lower() in VID_FORMATS]
+        # Define files as images or videos
+        images, videos = [], []
+        for f in files:
+            suffix = f.split(".")[-1].lower()  # Get file extension without the dot and lowercase
+            if suffix in IMG_FORMATS:
+                images.append(f)
+            elif suffix in VID_FORMATS:
+                videos.append(f)
         ni, nv = len(images), len(videos)
 
-        self.imgsz = imgsz
         self.files = images + videos
         self.nf = ni + nv  # number of files
+        self.ni = ni  # number of images
         self.video_flag = [False] * ni + [True] * nv
-        self.mode = 'image'
+        self.mode = "image"
         self.vid_stride = vid_stride  # video frame-rate stride
-        self.bs = 1
+        self.bs = batch
         if any(videos):
             self._new_video(videos[0])  # new video
         else:
             self.cap = None
         if self.nf == 0:
-            raise FileNotFoundError(f'No images or videos found in {p}. '
-                                    f'Supported formats are:\nimages: {IMG_FORMATS}\nvideos: {VID_FORMATS}')
+            raise FileNotFoundError(f"No images or videos found in {p}. {FORMATS_HELP_MSG}")
 
     def __iter__(self):
         """Returns an iterator object for VideoStream or ImageFolder."""
         self.count = 0
         return self
 
     def __next__(self):
-        """Return next image, path and metadata from dataset."""
-        if self.count == self.nf:
-            raise StopIteration
-        path = self.files[self.count]
-
-        if self.video_flag[self.count]:
-            # Read video
-            self.mode = 'video'
-            for _ in range(self.vid_stride):
-                self.cap.grab()
-            success, im0 = self.cap.retrieve()
-            while not success:
-                self.count += 1
-                self.cap.release()
-                if self.count == self.nf:  # last video
+        """Returns the next batch of images or video frames along with their paths and metadata."""
+        paths, imgs, info = [], [], []
+        while len(imgs) < self.bs:
+            if self.count >= self.nf:  # end of file list
+                if len(imgs) > 0:
+                    return paths, imgs, info  # return last partial batch
+                else:
                     raise StopIteration
-                path = self.files[self.count]
-                self._new_video(path)
-                success, im0 = self.cap.read()
-
-            self.frame += 1
-            # im0 = self._cv2_rotate(im0)  # for use if cv2 autorotation is False
-            s = f'video {self.count + 1}/{self.nf} ({self.frame}/{self.frames}) {path}: '
 
-        else:
-            # Read image
-            self.count += 1
-            im0 = cv2.imread(path)  # BGR
-            if im0 is None:
-                raise FileNotFoundError(f'Image Not Found {path}')
-            s = f'image {self.count}/{self.nf} {path}: '
+            path = self.files[self.count]
+            if self.video_flag[self.count]:
+                self.mode = "video"
+                if not self.cap or not self.cap.isOpened():
+                    self._new_video(path)
+
+                for _ in range(self.vid_stride):
+                    success = self.cap.grab()
+                    if not success:
+                        break  # end of video or failure
+
+                if success:
+                    success, im0 = self.cap.retrieve()
+                    if success:
+                        self.frame += 1
+                        paths.append(path)
+                        imgs.append(im0)
+                        info.append(f"video {self.count + 1}/{self.nf} (frame {self.frame}/{self.frames}) {path}: ")
+                        if self.frame == self.frames:  # end of video
+                            self.count += 1
+                            self.cap.release()
+                else:
+                    # Move to the next file if the current video ended or failed to open
+                    self.count += 1
+                    if self.cap:
+                        self.cap.release()
+                    if self.count < self.nf:
+                        self._new_video(self.files[self.count])
+            else:
+                self.mode = "image"
+                im0 = cv2.imread(path)  # BGR
+                if im0 is None:
+                    raise FileNotFoundError(f"Image Not Found {path}")
+                paths.append(path)
+                imgs.append(im0)
+                info.append(f"image {self.count + 1}/{self.nf} {path}: ")
+                self.count += 1  # move to the next file
+                if self.count >= self.ni:  # end of image list
+                    break
 
-        return [path], [im0], self.cap, s
+        return paths, imgs, info
 
     def _new_video(self, path):
-        """Create a new video capture object."""
+        """Creates a new video capture object for the given path."""
         self.frame = 0
         self.cap = cv2.VideoCapture(path)
+        self.fps = int(self.cap.get(cv2.CAP_PROP_FPS))
+        if not self.cap.isOpened():
+            raise FileNotFoundError(f"Failed to open video {path}")
         self.frames = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT) / self.vid_stride)
 
     def __len__(self):
-        """Returns the number of files in the object."""
-        return self.nf  # number of files
+        """Returns the number of batches in the object."""
+        return math.ceil(self.nf / self.bs)  # number of files
 
 
 class LoadPilAndNumpy:
     """
     Load images from PIL and Numpy arrays for batch processing.
 
     This class is designed to manage loading and pre-processing of image data from both PIL and Numpy formats.
     It performs basic validation and format conversion to ensure that the images are in the required format for
     downstream processing.
 
     Attributes:
         paths (list): List of image paths or autogenerated filenames.
         im0 (list): List of images stored as Numpy arrays.
-        imgsz (int): Image size, defaults to 640.
         mode (str): Type of data being processed, defaults to 'image'.
         bs (int): Batch size, equivalent to the length of `im0`.
-        count (int): Counter for iteration, initialized at 0 during `__iter__()`.
 
     Methods:
         _single_check(im): Validate and format a single image to a Numpy array.
     """
 
-    def __init__(self, im0, imgsz=640):
+    def __init__(self, im0):
         """Initialize PIL and Numpy Dataloader."""
         if not isinstance(im0, list):
             im0 = [im0]
-        self.paths = [getattr(im, 'filename', f'image{i}.jpg') for i, im in enumerate(im0)]
+        self.paths = [getattr(im, "filename", f"image{i}.jpg") for i, im in enumerate(im0)]
         self.im0 = [self._single_check(im) for im in im0]
-        self.imgsz = imgsz
-        self.mode = 'image'
-        # Generate fake paths
+        self.mode = "image"
         self.bs = len(self.im0)
 
     @staticmethod
     def _single_check(im):
         """Validate and format an image to numpy array."""
-        assert isinstance(im, (Image.Image, np.ndarray)), f'Expected PIL/np.ndarray image type, but got {type(im)}'
+        assert isinstance(im, (Image.Image, np.ndarray)), f"Expected PIL/np.ndarray image type, but got {type(im)}"
         if isinstance(im, Image.Image):
-            if im.mode != 'RGB':
-                im = im.convert('RGB')
+            if im.mode != "RGB":
+                im = im.convert("RGB")
             im = np.asarray(im)[:, :, ::-1]
             im = np.ascontiguousarray(im)  # contiguous
         return im
 
     def __len__(self):
         """Returns the length of the 'im0' attribute."""
         return len(self.im0)
 
     def __next__(self):
         """Returns batch paths, images, processed images, None, ''."""
         if self.count == 1:  # loop only once as it's batch inference
             raise StopIteration
         self.count += 1
-        return self.paths, self.im0, None, ''
+        return self.paths, self.im0, [""] * self.bs
 
     def __iter__(self):
         """Enables iteration for class LoadPilAndNumpy."""
         self.count = 0
         return self
 
 
@@ -437,71 +458,74 @@
         _single_check(im, stride): Validate and possibly modify the input tensor.
     """
 
     def __init__(self, im0) -> None:
         """Initialize Tensor Dataloader."""
         self.im0 = self._single_check(im0)
         self.bs = self.im0.shape[0]
-        self.mode = 'image'
-        self.paths = [getattr(im, 'filename', f'image{i}.jpg') for i, im in enumerate(im0)]
+        self.mode = "image"
+        self.paths = [getattr(im, "filename", f"image{i}.jpg") for i, im in enumerate(im0)]
 
     @staticmethod
     def _single_check(im, stride=32):
         """Validate and format an image to torch.Tensor."""
-        s = f'WARNING  torch.Tensor inputs should be BCHW i.e. shape(1, 3, 640, 640) ' \
-            f'divisible by stride {stride}. Input shape{tuple(im.shape)} is incompatible.'
+        s = (
+            f"WARNING  torch.Tensor inputs should be BCHW i.e. shape(1, 3, 640, 640) "
+            f"divisible by stride {stride}. Input shape{tuple(im.shape)} is incompatible."
+        )
         if len(im.shape) != 4:
             if len(im.shape) != 3:
                 raise ValueError(s)
             LOGGER.warning(s)
             im = im.unsqueeze(0)
         if im.shape[2] % stride or im.shape[3] % stride:
             raise ValueError(s)
         if im.max() > 1.0 + torch.finfo(im.dtype).eps:  # torch.float32 eps is 1.2e-07
-            LOGGER.warning(f'WARNING  torch.Tensor inputs should be normalized 0.0-1.0 but max value is {im.max()}. '
-                           f'Dividing input by 255.')
+            LOGGER.warning(
+                f"WARNING  torch.Tensor inputs should be normalized 0.0-1.0 but max value is {im.max()}. "
+                f"Dividing input by 255."
+            )
             im = im.float() / 255.0
 
         return im
 
     def __iter__(self):
         """Returns an iterator object."""
         self.count = 0
         return self
 
     def __next__(self):
         """Return next item in the iterator."""
         if self.count == 1:
             raise StopIteration
         self.count += 1
-        return self.paths, self.im0, None, ''
+        return self.paths, self.im0, [""] * self.bs
 
     def __len__(self):
         """Returns the batch size."""
         return self.bs
 
 
 def autocast_list(source):
     """Merges a list of source of different types into a list of numpy arrays or PIL images."""
     files = []
     for im in source:
         if isinstance(im, (str, Path)):  # filename or uri
-            files.append(Image.open(requests.get(im, stream=True).raw if str(im).startswith('http') else im))
+            files.append(Image.open(requests.get(im, stream=True).raw if str(im).startswith("http") else im))
         elif isinstance(im, (Image.Image, np.ndarray)):  # PIL or np Image
             files.append(im)
         else:
-            raise TypeError(f'type {type(im).__name__} is not a supported Ultralytics prediction source type. \n'
-                            f'See https://docs.ultralytics.com/modes/predict for supported source types.')
+            raise TypeError(
+                f"type {type(im).__name__} is not a supported Ultralytics prediction source type. \n"
+                f"See https://docs.ultralytics.com/modes/predict for supported source types."
+            )
 
     return files
 
 
-LOADERS = LoadStreams, LoadPilAndNumpy, LoadImages, LoadScreenshots  # tuple
-
-
 def get_best_youtube_url(url, use_pafy=True):
     """
     Retrieves the URL of the best quality MP4 video stream from a given YouTube video.
 
     This function uses the pafy or yt_dlp library to extract the video info from YouTube. It then finds the highest
     quality MP4 format that has video codec but no audio codec, and returns the URL of this video stream.
 
@@ -509,20 +533,26 @@
         url (str): The URL of the YouTube video.
         use_pafy (bool): Use the pafy package, default=True, otherwise use yt_dlp package.
 
     Returns:
         (str): The URL of the best quality MP4 video stream, or None if no suitable stream is found.
     """
     if use_pafy:
-        check_requirements(('pafy', 'youtube_dl==2020.12.2'))
+        check_requirements(("pafy", "youtube_dl==2020.12.2"))
         import pafy  # noqa
-        return pafy.new(url).getbestvideo(preftype='mp4').url
+
+        return pafy.new(url).getbestvideo(preftype="mp4").url
     else:
-        check_requirements('yt-dlp')
+        check_requirements("yt-dlp")
         import yt_dlp
-        with yt_dlp.YoutubeDL({'quiet': True}) as ydl:
+
+        with yt_dlp.YoutubeDL({"quiet": True}) as ydl:
             info_dict = ydl.extract_info(url, download=False)  # extract info
-        for f in reversed(info_dict.get('formats', [])):  # reversed because best is usually last
+        for f in reversed(info_dict.get("formats", [])):  # reversed because best is usually last
             # Find a format with video codec, no audio, *.mp4 extension at least 1920x1080 size
-            good_size = (f.get('width') or 0) >= 1920 or (f.get('height') or 0) >= 1080
-            if good_size and f['vcodec'] != 'none' and f['acodec'] == 'none' and f['ext'] == 'mp4':
-                return f.get('url')
+            good_size = (f.get("width") or 0) >= 1920 or (f.get("height") or 0) >= 1080
+            if good_size and f["vcodec"] != "none" and f["acodec"] == "none" and f["ext"] == "mp4":
+                return f.get("url")
+
+
+# Define constants
+LOADERS = (LoadStreams, LoadPilAndNumpy, LoadImagesAndVideos, LoadScreenshots)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/data/utils.py` & `yolov8_pose_triton-8.2.0/ultralytics/data/utils.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,130 +13,144 @@
 from tarfile import is_tarfile
 
 import cv2
 import numpy as np
 from PIL import Image, ImageOps
 
 from ultralytics.nn.autobackend import check_class_names
-from ultralytics.utils import (DATASETS_DIR, LOGGER, NUM_THREADS, ROOT, SETTINGS_YAML, TQDM, clean_url, colorstr,
-                               emojis, yaml_load, yaml_save)
+from ultralytics.utils import (
+    DATASETS_DIR,
+    LOGGER,
+    NUM_THREADS,
+    ROOT,
+    SETTINGS_YAML,
+    TQDM,
+    clean_url,
+    colorstr,
+    emojis,
+    is_dir_writeable,
+    yaml_load,
+    yaml_save,
+)
 from ultralytics.utils.checks import check_file, check_font, is_ascii
 from ultralytics.utils.downloads import download, safe_download, unzip_file
 from ultralytics.utils.ops import segments2boxes
 
-HELP_URL = 'See https://docs.ultralytics.com/datasets/detect for dataset formatting guidance.'
-IMG_FORMATS = 'bmp', 'dng', 'jpeg', 'jpg', 'mpo', 'png', 'tif', 'tiff', 'webp', 'pfm'  # image suffixes
-VID_FORMATS = 'asf', 'avi', 'gif', 'm4v', 'mkv', 'mov', 'mp4', 'mpeg', 'mpg', 'ts', 'wmv', 'webm'  # video suffixes
-PIN_MEMORY = str(os.getenv('PIN_MEMORY', True)).lower() == 'true'  # global pin_memory for dataloaders
+HELP_URL = "See https://docs.ultralytics.com/datasets/detect for dataset formatting guidance."
+IMG_FORMATS = {"bmp", "dng", "jpeg", "jpg", "mpo", "png", "tif", "tiff", "webp", "pfm"}  # image suffixes
+VID_FORMATS = {"asf", "avi", "gif", "m4v", "mkv", "mov", "mp4", "mpeg", "mpg", "ts", "wmv", "webm"}  # video suffixes
+PIN_MEMORY = str(os.getenv("PIN_MEMORY", True)).lower() == "true"  # global pin_memory for dataloaders
+FORMATS_HELP_MSG = f"Supported formats are:\nimages: {IMG_FORMATS}\nvideos: {VID_FORMATS}"
 
 
 def img2label_paths(img_paths):
     """Define label paths as a function of image paths."""
-    sa, sb = f'{os.sep}images{os.sep}', f'{os.sep}labels{os.sep}'  # /images/, /labels/ substrings
-    return [sb.join(x.rsplit(sa, 1)).rsplit('.', 1)[0] + '.txt' for x in img_paths]
+    sa, sb = f"{os.sep}images{os.sep}", f"{os.sep}labels{os.sep}"  # /images/, /labels/ substrings
+    return [sb.join(x.rsplit(sa, 1)).rsplit(".", 1)[0] + ".txt" for x in img_paths]
 
 
 def get_hash(paths):
     """Returns a single hash value of a list of paths (files or dirs)."""
     size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes
     h = hashlib.sha256(str(size).encode())  # hash sizes
-    h.update(''.join(paths).encode())  # hash paths
+    h.update("".join(paths).encode())  # hash paths
     return h.hexdigest()  # return hash
 
 
 def exif_size(img: Image.Image):
     """Returns exif-corrected PIL size."""
     s = img.size  # (width, height)
-    if img.format == 'JPEG':  # only support JPEG images
+    if img.format == "JPEG":  # only support JPEG images
         with contextlib.suppress(Exception):
             exif = img.getexif()
             if exif:
                 rotation = exif.get(274, None)  # the EXIF key for the orientation tag is 274
-                if rotation in [6, 8]:  # rotation 270 or 90
+                if rotation in {6, 8}:  # rotation 270 or 90
                     s = s[1], s[0]
     return s
 
 
 def verify_image(args):
     """Verify one image."""
     (im_file, cls), prefix = args
     # Number (found, corrupt), message
-    nf, nc, msg = 0, 0, ''
+    nf, nc, msg = 0, 0, ""
     try:
         im = Image.open(im_file)
         im.verify()  # PIL verify
         shape = exif_size(im)  # image size
         shape = (shape[1], shape[0])  # hw
-        assert (shape[0] > 9) & (shape[1] > 9), f'image size {shape} <10 pixels'
-        assert im.format.lower() in IMG_FORMATS, f'invalid image format {im.format}'
-        if im.format.lower() in ('jpg', 'jpeg'):
-            with open(im_file, 'rb') as f:
+        assert (shape[0] > 9) & (shape[1] > 9), f"image size {shape} <10 pixels"
+        assert im.format.lower() in IMG_FORMATS, f"Invalid image format {im.format}. {FORMATS_HELP_MSG}"
+        if im.format.lower() in {"jpg", "jpeg"}:
+            with open(im_file, "rb") as f:
                 f.seek(-2, 2)
-                if f.read() != b'\xff\xd9':  # corrupt JPEG
-                    ImageOps.exif_transpose(Image.open(im_file)).save(im_file, 'JPEG', subsampling=0, quality=100)
-                    msg = f'{prefix}WARNING  {im_file}: corrupt JPEG restored and saved'
+                if f.read() != b"\xff\xd9":  # corrupt JPEG
+                    ImageOps.exif_transpose(Image.open(im_file)).save(im_file, "JPEG", subsampling=0, quality=100)
+                    msg = f"{prefix}WARNING  {im_file}: corrupt JPEG restored and saved"
         nf = 1
     except Exception as e:
         nc = 1
-        msg = f'{prefix}WARNING  {im_file}: ignoring corrupt image/label: {e}'
+        msg = f"{prefix}WARNING  {im_file}: ignoring corrupt image/label: {e}"
     return (im_file, cls), nf, nc, msg
 
 
 def verify_image_label(args):
     """Verify one image-label pair."""
     im_file, lb_file, prefix, keypoint, num_cls, nkpt, ndim = args
     # Number (missing, found, empty, corrupt), message, segments, keypoints
-    nm, nf, ne, nc, msg, segments, keypoints = 0, 0, 0, 0, '', [], None
+    nm, nf, ne, nc, msg, segments, keypoints = 0, 0, 0, 0, "", [], None
     try:
         # Verify images
         im = Image.open(im_file)
         im.verify()  # PIL verify
         shape = exif_size(im)  # image size
         shape = (shape[1], shape[0])  # hw
-        assert (shape[0] > 9) & (shape[1] > 9), f'image size {shape} <10 pixels'
-        assert im.format.lower() in IMG_FORMATS, f'invalid image format {im.format}'
-        if im.format.lower() in ('jpg', 'jpeg'):
-            with open(im_file, 'rb') as f:
+        assert (shape[0] > 9) & (shape[1] > 9), f"image size {shape} <10 pixels"
+        assert im.format.lower() in IMG_FORMATS, f"invalid image format {im.format}. {FORMATS_HELP_MSG}"
+        if im.format.lower() in {"jpg", "jpeg"}:
+            with open(im_file, "rb") as f:
                 f.seek(-2, 2)
-                if f.read() != b'\xff\xd9':  # corrupt JPEG
-                    ImageOps.exif_transpose(Image.open(im_file)).save(im_file, 'JPEG', subsampling=0, quality=100)
-                    msg = f'{prefix}WARNING  {im_file}: corrupt JPEG restored and saved'
+                if f.read() != b"\xff\xd9":  # corrupt JPEG
+                    ImageOps.exif_transpose(Image.open(im_file)).save(im_file, "JPEG", subsampling=0, quality=100)
+                    msg = f"{prefix}WARNING  {im_file}: corrupt JPEG restored and saved"
 
         # Verify labels
         if os.path.isfile(lb_file):
             nf = 1  # label found
             with open(lb_file) as f:
                 lb = [x.split() for x in f.read().strip().splitlines() if len(x)]
                 if any(len(x) > 6 for x in lb) and (not keypoint):  # is segment
                     classes = np.array([x[0] for x in lb], dtype=np.float32)
                     segments = [np.array(x[1:], dtype=np.float32).reshape(-1, 2) for x in lb]  # (cls, xy1...)
                     lb = np.concatenate((classes.reshape(-1, 1), segments2boxes(segments)), 1)  # (cls, xywh)
                 lb = np.array(lb, dtype=np.float32)
             nl = len(lb)
             if nl:
                 if keypoint:
-                    assert lb.shape[1] == (5 + nkpt * ndim), f'labels require {(5 + nkpt * ndim)} columns each'
+                    assert lb.shape[1] == (5 + nkpt * ndim), f"labels require {(5 + nkpt * ndim)} columns each"
                     points = lb[:, 5:].reshape(-1, ndim)[:, :2]
                 else:
-                    assert lb.shape[1] == 5, f'labels require 5 columns, {lb.shape[1]} columns detected'
+                    assert lb.shape[1] == 5, f"labels require 5 columns, {lb.shape[1]} columns detected"
                     points = lb[:, 1:]
-                assert points.max() <= 1, f'non-normalized or out of bounds coordinates {points[points > 1]}'
-                assert lb.min() >= 0, f'negative label values {lb[lb < 0]}'
+                assert points.max() <= 1, f"non-normalized or out of bounds coordinates {points[points > 1]}"
+                assert lb.min() >= 0, f"negative label values {lb[lb < 0]}"
 
                 # All labels
                 max_cls = lb[:, 0].max()  # max label count
-                assert max_cls <= num_cls, \
-                    f'Label class {int(max_cls)} exceeds dataset class count {num_cls}. ' \
-                    f'Possible class labels are 0-{num_cls - 1}'
+                assert max_cls <= num_cls, (
+                    f"Label class {int(max_cls)} exceeds dataset class count {num_cls}. "
+                    f"Possible class labels are 0-{num_cls - 1}"
+                )
                 _, i = np.unique(lb, axis=0, return_index=True)
                 if len(i) < nl:  # duplicate row check
                     lb = lb[i]  # remove duplicates
                     if segments:
                         segments = [segments[x] for x in i]
-                    msg = f'{prefix}WARNING  {im_file}: {nl - len(i)} duplicate labels removed'
+                    msg = f"{prefix}WARNING  {im_file}: {nl - len(i)} duplicate labels removed"
             else:
                 ne = 1  # label empty
                 lb = np.zeros((0, (5 + nkpt * ndim) if keypoint else 5), dtype=np.float32)
         else:
             nm = 1  # label missing
             lb = np.zeros((0, (5 + nkpt * ndim) if keypoints else 5), dtype=np.float32)
         if keypoint:
@@ -144,15 +158,15 @@
             if ndim == 2:
                 kpt_mask = np.where((keypoints[..., 0] < 0) | (keypoints[..., 1] < 0), 0.0, 1.0).astype(np.float32)
                 keypoints = np.concatenate([keypoints, kpt_mask[..., None]], axis=-1)  # (nl, nkpt, 3)
         lb = lb[:, :5]
         return im_file, lb, shape, segments, keypoints, nm, nf, ne, nc, msg
     except Exception as e:
         nc = 1
-        msg = f'{prefix}WARNING  {im_file}: ignoring corrupt image/label: {e}'
+        msg = f"{prefix}WARNING  {im_file}: ignoring corrupt image/label: {e}"
         return [None, None, None, None, None, nm, nf, ne, nc, msg]
 
 
 def polygon2mask(imgsz, polygons, color=1, downsample_ratio=1):
     """
     Convert a list of polygons to a binary mask of the specified image size.
 
@@ -190,16 +204,18 @@
         (np.ndarray): A set of binary masks of the specified image size with the polygons filled in.
     """
     return np.array([polygon2mask(imgsz, [x.reshape(-1)], color, downsample_ratio) for x in polygons])
 
 
 def polygons2masks_overlap(imgsz, segments, downsample_ratio=1):
     """Return a (640, 640) overlap mask."""
-    masks = np.zeros((imgsz[0] // downsample_ratio, imgsz[1] // downsample_ratio),
-                     dtype=np.int32 if len(segments) > 255 else np.uint8)
+    masks = np.zeros(
+        (imgsz[0] // downsample_ratio, imgsz[1] // downsample_ratio),
+        dtype=np.int32 if len(segments) > 255 else np.uint8,
+    )
     areas = []
     ms = []
     for si in range(len(segments)):
         mask = polygon2mask(imgsz, [segments[si].reshape(-1)], downsample_ratio=downsample_ratio, color=1)
         ms.append(mask)
         areas.append(mask.sum())
     areas = np.asarray(areas)
@@ -222,15 +238,15 @@
 
     Args:
         path (Path): The directory path to search for the YAML file.
 
     Returns:
         (Path): The path of the found YAML file.
     """
-    files = list(path.glob('*.yaml')) or list(path.rglob('*.yaml'))  # try root level first and then recursive
+    files = list(path.glob("*.yaml")) or list(path.rglob("*.yaml"))  # try root level first and then recursive
     assert files, f"No YAML file found in '{path.resolve()}'"
     if len(files) > 1:
         files = [f for f in files if f.stem == path.stem]  # prefer *.yaml files that match
     assert len(files) == 1, f"Expected 1 YAML file in '{path.resolve()}', but found {len(files)}.\n{files}"
     return files[0]
 
 
@@ -249,89 +265,90 @@
     Returns:
         (dict): Parsed dataset information and paths.
     """
 
     file = check_file(dataset)
 
     # Download (optional)
-    extract_dir = ''
+    extract_dir = ""
     if zipfile.is_zipfile(file) or is_tarfile(file):
         new_dir = safe_download(file, dir=DATASETS_DIR, unzip=True, delete=False)
         file = find_dataset_yaml(DATASETS_DIR / new_dir)
         extract_dir, autodownload = file.parent, False
 
     # Read YAML
     data = yaml_load(file, append_filename=True)  # dictionary
 
     # Checks
-    for k in 'train', 'val':
+    for k in "train", "val":
         if k not in data:
-            if k != 'val' or 'validation' not in data:
+            if k != "val" or "validation" not in data:
                 raise SyntaxError(
-                    emojis(f"{dataset} '{k}:' key missing .\n'train' and 'val' are required in all data YAMLs."))
+                    emojis(f"{dataset} '{k}:' key missing .\n'train' and 'val' are required in all data YAMLs.")
+                )
             LOGGER.info("WARNING  renaming data YAML 'validation' key to 'val' to match YOLO format.")
-            data['val'] = data.pop('validation')  # replace 'validation' key with 'val' key
-    if 'names' not in data and 'nc' not in data:
+            data["val"] = data.pop("validation")  # replace 'validation' key with 'val' key
+    if "names" not in data and "nc" not in data:
         raise SyntaxError(emojis(f"{dataset} key missing .\n either 'names' or 'nc' are required in all data YAMLs."))
-    if 'names' in data and 'nc' in data and len(data['names']) != data['nc']:
+    if "names" in data and "nc" in data and len(data["names"]) != data["nc"]:
         raise SyntaxError(emojis(f"{dataset} 'names' length {len(data['names'])} and 'nc: {data['nc']}' must match."))
-    if 'names' not in data:
-        data['names'] = [f'class_{i}' for i in range(data['nc'])]
+    if "names" not in data:
+        data["names"] = [f"class_{i}" for i in range(data["nc"])]
     else:
-        data['nc'] = len(data['names'])
+        data["nc"] = len(data["names"])
 
-    data['names'] = check_class_names(data['names'])
+    data["names"] = check_class_names(data["names"])
 
     # Resolve paths
-    path = Path(extract_dir or data.get('path') or Path(data.get('yaml_file', '')).parent)  # dataset root
+    path = Path(extract_dir or data.get("path") or Path(data.get("yaml_file", "")).parent)  # dataset root
     if not path.is_absolute():
         path = (DATASETS_DIR / path).resolve()
 
     # Set paths
-    data['path'] = path  # download scripts
-    for k in 'train', 'val', 'test':
+    data["path"] = path  # download scripts
+    for k in "train", "val", "test", "minival":
         if data.get(k):  # prepend path
             if isinstance(data[k], str):
                 x = (path / data[k]).resolve()
-                if not x.exists() and data[k].startswith('../'):
+                if not x.exists() and data[k].startswith("../"):
                     x = (path / data[k][3:]).resolve()
                 data[k] = str(x)
             else:
                 data[k] = [str((path / x).resolve()) for x in data[k]]
 
     # Parse YAML
-    val, s = (data.get(x) for x in ('val', 'download'))
+    val, s = (data.get(x) for x in ("val", "download"))
     if val:
         val = [Path(x).resolve() for x in (val if isinstance(val, list) else [val])]  # val path
         if not all(x.exists() for x in val):
             name = clean_url(dataset)  # dataset name with URL auth stripped
             m = f"\nDataset '{name}' images not found , missing path '{[x for x in val if not x.exists()][0]}'"
             if s and autodownload:
                 LOGGER.warning(m)
             else:
                 m += f"\nNote dataset download directory is '{DATASETS_DIR}'. You can update this in '{SETTINGS_YAML}'"
                 raise FileNotFoundError(m)
             t = time.time()
             r = None  # success
-            if s.startswith('http') and s.endswith('.zip'):  # URL
+            if s.startswith("http") and s.endswith(".zip"):  # URL
                 safe_download(url=s, dir=DATASETS_DIR, delete=True)
-            elif s.startswith('bash '):  # bash script
-                LOGGER.info(f'Running {s} ...')
+            elif s.startswith("bash "):  # bash script
+                LOGGER.info(f"Running {s} ...")
                 r = os.system(s)
             else:  # python script
-                exec(s, {'yaml': data})
-            dt = f'({round(time.time() - t, 1)}s)'
-            s = f"success  {dt}, saved to {colorstr('bold', DATASETS_DIR)}" if r in (0, None) else f'failure {dt} '
-            LOGGER.info(f'Dataset download {s}\n')
-    check_font('Arial.ttf' if is_ascii(data['names']) else 'Arial.Unicode.ttf')  # download fonts
+                exec(s, {"yaml": data})
+            dt = f"({round(time.time() - t, 1)}s)"
+            s = f"success  {dt}, saved to {colorstr('bold', DATASETS_DIR)}" if r in {0, None} else f"failure {dt} "
+            LOGGER.info(f"Dataset download {s}\n")
+    check_font("Arial.ttf" if is_ascii(data["names"]) else "Arial.Unicode.ttf")  # download fonts
 
     return data  # dictionary
 
 
-def check_cls_dataset(dataset, split=''):
+def check_cls_dataset(dataset, split=""):
     """
     Checks a classification dataset such as Imagenet.
 
     This function accepts a `dataset` name and attempts to retrieve the corresponding dataset information.
     If the dataset is not found locally, it attempts to download the dataset from the internet and save it locally.
 
     Args:
@@ -344,62 +361,70 @@
             - 'val' (Path): The directory path containing the validation set of the dataset.
             - 'test' (Path): The directory path containing the test set of the dataset.
             - 'nc' (int): The number of classes in the dataset.
             - 'names' (dict): A dictionary of class names in the dataset.
     """
 
     # Download (optional if dataset=https://file.zip is passed directly)
-    if str(dataset).startswith(('http:/', 'https:/')):
+    if str(dataset).startswith(("http:/", "https:/")):
         dataset = safe_download(dataset, dir=DATASETS_DIR, unzip=True, delete=False)
+    elif Path(dataset).suffix in {".zip", ".tar", ".gz"}:
+        file = check_file(dataset)
+        dataset = safe_download(file, dir=DATASETS_DIR, unzip=True, delete=False)
 
     dataset = Path(dataset)
     data_dir = (dataset if dataset.is_dir() else (DATASETS_DIR / dataset)).resolve()
     if not data_dir.is_dir():
-        LOGGER.warning(f'\nDataset not found , missing path {data_dir}, attempting download...')
+        LOGGER.warning(f"\nDataset not found , missing path {data_dir}, attempting download...")
         t = time.time()
-        if str(dataset) == 'imagenet':
+        if str(dataset) == "imagenet":
             subprocess.run(f"bash {ROOT / 'data/scripts/get_imagenet.sh'}", shell=True, check=True)
         else:
-            url = f'https://github.com/ultralytics/yolov5/releases/download/v1.0/{dataset}.zip'
+            url = f"https://github.com/ultralytics/yolov5/releases/download/v1.0/{dataset}.zip"
             download(url, dir=data_dir.parent)
         s = f"Dataset download success  ({time.time() - t:.1f}s), saved to {colorstr('bold', data_dir)}\n"
         LOGGER.info(s)
-    train_set = data_dir / 'train'
-    val_set = data_dir / 'val' if (data_dir / 'val').exists() else data_dir / 'validation' if \
-        (data_dir / 'validation').exists() else None  # data/test or data/val
-    test_set = data_dir / 'test' if (data_dir / 'test').exists() else None  # data/val or data/test
-    if split == 'val' and not val_set:
+    train_set = data_dir / "train"
+    val_set = (
+        data_dir / "val"
+        if (data_dir / "val").exists()
+        else data_dir / "validation"
+        if (data_dir / "validation").exists()
+        else None
+    )  # data/test or data/val
+    test_set = data_dir / "test" if (data_dir / "test").exists() else None  # data/val or data/test
+    if split == "val" and not val_set:
         LOGGER.warning("WARNING  Dataset 'split=val' not found, using 'split=test' instead.")
-    elif split == 'test' and not test_set:
+    elif split == "test" and not test_set:
         LOGGER.warning("WARNING  Dataset 'split=test' not found, using 'split=val' instead.")
 
-    nc = len([x for x in (data_dir / 'train').glob('*') if x.is_dir()])  # number of classes
-    names = [x.name for x in (data_dir / 'train').iterdir() if x.is_dir()]  # class names list
+    nc = len([x for x in (data_dir / "train").glob("*") if x.is_dir()])  # number of classes
+    names = [x.name for x in (data_dir / "train").iterdir() if x.is_dir()]  # class names list
     names = dict(enumerate(sorted(names)))
 
     # Print to console
-    for k, v in {'train': train_set, 'val': val_set, 'test': test_set}.items():
+    for k, v in {"train": train_set, "val": val_set, "test": test_set}.items():
         prefix = f'{colorstr(f"{k}:")} {v}...'
         if v is None:
             LOGGER.info(prefix)
         else:
-            files = [path for path in v.rglob('*.*') if path.suffix[1:].lower() in IMG_FORMATS]
+            files = [path for path in v.rglob("*.*") if path.suffix[1:].lower() in IMG_FORMATS]
             nf = len(files)  # number of files
             nd = len({file.parent for file in files})  # number of directories
             if nf == 0:
-                if k == 'train':
+                if k == "train":
                     raise FileNotFoundError(emojis(f"{dataset} '{k}:' no training images found  "))
                 else:
-                    LOGGER.warning(f'{prefix} found {nf} images in {nd} classes: WARNING  no images found')
+                    LOGGER.warning(f"{prefix} found {nf} images in {nd} classes: WARNING  no images found")
             elif nd != nc:
-                LOGGER.warning(f'{prefix} found {nf} images in {nd} classes: ERROR  requires {nc} classes, not {nd}')
+                LOGGER.warning(f"{prefix} found {nf} images in {nd} classes: ERROR  requires {nc} classes, not {nd}")
             else:
-                LOGGER.info(f'{prefix} found {nf} images in {nd} classes  ')
+                LOGGER.info(f"{prefix} found {nf} images in {nd} classes  ")
 
-    return {'train': train_set, 'val': val_set, 'test': test_set, 'nc': nc, 'names': names}
+    return {"train": train_set, "val": val_set, "test": test_set, "nc": nc, "names": names}
 
 
 class HUBDatasetStats:
     """
     A class for generating HUB dataset JSON and `-hub` dataset directory.
 
     Args:
@@ -419,147 +444,143 @@
         stats = HUBDatasetStats('path/to/imagenet10.zip', task='classify')  # classification dataset
 
         stats.get_json(save=True)
         stats.process_images()
         ```
     """
 
-    def __init__(self, path='coco8.yaml', task='detect', autodownload=False):
+    def __init__(self, path="coco8.yaml", task="detect", autodownload=False):
         """Initialize class."""
         path = Path(path).resolve()
-        LOGGER.info(f'Starting HUB dataset checks for {path}....')
+        LOGGER.info(f"Starting HUB dataset checks for {path}....")
 
         self.task = task  # detect, segment, pose, classify
-        if self.task == 'classify':
+        if self.task == "classify":
             unzip_dir = unzip_file(path)
             data = check_cls_dataset(unzip_dir)
-            data['path'] = unzip_dir
+            data["path"] = unzip_dir
         else:  # detect, segment, pose
-            zipped, data_dir, yaml_path = self._unzip(Path(path))
+            _, data_dir, yaml_path = self._unzip(Path(path))
             try:
                 # Load YAML with checks
                 data = yaml_load(yaml_path)
-                data['path'] = ''  # strip path since YAML should be in dataset root for all HUB datasets
+                data["path"] = ""  # strip path since YAML should be in dataset root for all HUB datasets
                 yaml_save(yaml_path, data)
                 data = check_det_dataset(yaml_path, autodownload)  # dict
-                data['path'] = data_dir  # YAML path should be set to '' (relative) or parent (absolute)
+                data["path"] = data_dir  # YAML path should be set to '' (relative) or parent (absolute)
             except Exception as e:
-                raise Exception('error/HUB/dataset_stats/init') from e
+                raise Exception("error/HUB/dataset_stats/init") from e
 
         self.hub_dir = Path(f'{data["path"]}-hub')
-        self.im_dir = self.hub_dir / 'images'
-        self.im_dir.mkdir(parents=True, exist_ok=True)  # makes /images
-        self.stats = {'nc': len(data['names']), 'names': list(data['names'].values())}  # statistics dictionary
+        self.im_dir = self.hub_dir / "images"
+        self.stats = {"nc": len(data["names"]), "names": list(data["names"].values())}  # statistics dictionary
         self.data = data
 
     @staticmethod
     def _unzip(path):
         """Unzip data.zip."""
-        if not str(path).endswith('.zip'):  # path is data.yaml
+        if not str(path).endswith(".zip"):  # path is data.yaml
             return False, None, path
         unzip_dir = unzip_file(path, path=path.parent)
-        assert unzip_dir.is_dir(), f'Error unzipping {path}, {unzip_dir} not found. ' \
-                                   f'path/to/abc.zip MUST unzip to path/to/abc/'
+        assert unzip_dir.is_dir(), (
+            f"Error unzipping {path}, {unzip_dir} not found. " f"path/to/abc.zip MUST unzip to path/to/abc/"
+        )
         return True, str(unzip_dir), find_dataset_yaml(unzip_dir)  # zipped, data_dir, yaml_path
 
     def _hub_ops(self, f):
         """Saves a compressed image for HUB previews."""
         compress_one_image(f, self.im_dir / Path(f).name)  # save to dataset-hub
 
     def get_json(self, save=False, verbose=False):
         """Return dataset JSON for Ultralytics HUB."""
 
         def _round(labels):
             """Update labels to integer class and 4 decimal place floats."""
-            if self.task == 'detect':
-                coordinates = labels['bboxes']
-            elif self.task == 'segment':
-                coordinates = [x.flatten() for x in labels['segments']]
-            elif self.task == 'pose':
-                n = labels['keypoints'].shape[0]
-                coordinates = np.concatenate((labels['bboxes'], labels['keypoints'].reshape(n, -1)), 1)
+            if self.task == "detect":
+                coordinates = labels["bboxes"]
+            elif self.task == "segment":
+                coordinates = [x.flatten() for x in labels["segments"]]
+            elif self.task == "pose":
+                n = labels["keypoints"].shape[0]
+                coordinates = np.concatenate((labels["bboxes"], labels["keypoints"].reshape(n, -1)), 1)
             else:
-                raise ValueError('Undefined dataset task.')
-            zipped = zip(labels['cls'], coordinates)
+                raise ValueError("Undefined dataset task.")
+            zipped = zip(labels["cls"], coordinates)
             return [[int(c[0]), *(round(float(x), 4) for x in points)] for c, points in zipped]
 
-        for split in 'train', 'val', 'test':
+        for split in "train", "val", "test":
             self.stats[split] = None  # predefine
             path = self.data.get(split)
 
             # Check split
             if path is None:  # no split
                 continue
-            files = [f for f in Path(path).rglob('*.*') if f.suffix[1:].lower() in IMG_FORMATS]  # image files in split
+            files = [f for f in Path(path).rglob("*.*") if f.suffix[1:].lower() in IMG_FORMATS]  # image files in split
             if not files:  # no images
                 continue
 
             # Get dataset statistics
-            if self.task == 'classify':
+            if self.task == "classify":
                 from torchvision.datasets import ImageFolder
 
                 dataset = ImageFolder(self.data[split])
 
                 x = np.zeros(len(dataset.classes)).astype(int)
                 for im in dataset.imgs:
                     x[im[1]] += 1
 
                 self.stats[split] = {
-                    'instance_stats': {
-                        'total': len(dataset),
-                        'per_class': x.tolist()},
-                    'image_stats': {
-                        'total': len(dataset),
-                        'unlabelled': 0,
-                        'per_class': x.tolist()},
-                    'labels': [{
-                        Path(k).name: v} for k, v in dataset.imgs]}
+                    "instance_stats": {"total": len(dataset), "per_class": x.tolist()},
+                    "image_stats": {"total": len(dataset), "unlabelled": 0, "per_class": x.tolist()},
+                    "labels": [{Path(k).name: v} for k, v in dataset.imgs],
+                }
             else:
                 from ultralytics.data import YOLODataset
 
-                dataset = YOLODataset(img_path=self.data[split],
-                                      data=self.data,
-                                      use_segments=self.task == 'segment',
-                                      use_keypoints=self.task == 'pose')
-                x = np.array([
-                    np.bincount(label['cls'].astype(int).flatten(), minlength=self.data['nc'])
-                    for label in TQDM(dataset.labels, total=len(dataset), desc='Statistics')])  # shape(128x80)
+                dataset = YOLODataset(img_path=self.data[split], data=self.data, task=self.task)
+                x = np.array(
+                    [
+                        np.bincount(label["cls"].astype(int).flatten(), minlength=self.data["nc"])
+                        for label in TQDM(dataset.labels, total=len(dataset), desc="Statistics")
+                    ]
+                )  # shape(128x80)
                 self.stats[split] = {
-                    'instance_stats': {
-                        'total': int(x.sum()),
-                        'per_class': x.sum(0).tolist()},
-                    'image_stats': {
-                        'total': len(dataset),
-                        'unlabelled': int(np.all(x == 0, 1).sum()),
-                        'per_class': (x > 0).sum(0).tolist()},
-                    'labels': [{
-                        Path(k).name: _round(v)} for k, v in zip(dataset.im_files, dataset.labels)]}
+                    "instance_stats": {"total": int(x.sum()), "per_class": x.sum(0).tolist()},
+                    "image_stats": {
+                        "total": len(dataset),
+                        "unlabelled": int(np.all(x == 0, 1).sum()),
+                        "per_class": (x > 0).sum(0).tolist(),
+                    },
+                    "labels": [{Path(k).name: _round(v)} for k, v in zip(dataset.im_files, dataset.labels)],
+                }
 
         # Save, print and return
         if save:
-            stats_path = self.hub_dir / 'stats.json'
-            LOGGER.info(f'Saving {stats_path.resolve()}...')
-            with open(stats_path, 'w') as f:
+            self.hub_dir.mkdir(parents=True, exist_ok=True)  # makes dataset-hub/
+            stats_path = self.hub_dir / "stats.json"
+            LOGGER.info(f"Saving {stats_path.resolve()}...")
+            with open(stats_path, "w") as f:
                 json.dump(self.stats, f)  # save stats.json
         if verbose:
             LOGGER.info(json.dumps(self.stats, indent=2, sort_keys=False))
         return self.stats
 
     def process_images(self):
         """Compress images for Ultralytics HUB."""
         from ultralytics.data import YOLODataset  # ClassificationDataset
 
-        for split in 'train', 'val', 'test':
+        self.im_dir.mkdir(parents=True, exist_ok=True)  # makes dataset-hub/images/
+        for split in "train", "val", "test":
             if self.data.get(split) is None:
                 continue
             dataset = YOLODataset(img_path=self.data[split], data=self.data)
             with ThreadPool(NUM_THREADS) as pool:
-                for _ in TQDM(pool.imap(self._hub_ops, dataset.im_files), total=len(dataset), desc=f'{split} images'):
+                for _ in TQDM(pool.imap(self._hub_ops, dataset.im_files), total=len(dataset), desc=f"{split} images"):
                     pass
-        LOGGER.info(f'Done. All images saved to {self.im_dir}')
+        LOGGER.info(f"Done. All images saved to {self.im_dir}")
         return self.im_dir
 
 
 def compress_one_image(f, f_new=None, max_dim=1920, quality=50):
     """
     Compresses a single image file to reduced size while preserving its aspect ratio and quality using either the Python
     Imaging Library (PIL) or OpenCV library. If the input image is smaller than the maximum dimension, it will not be
@@ -582,26 +603,26 @@
     """
 
     try:  # use PIL
         im = Image.open(f)
         r = max_dim / max(im.height, im.width)  # ratio
         if r < 1.0:  # image too large
             im = im.resize((int(im.width * r), int(im.height * r)))
-        im.save(f_new or f, 'JPEG', quality=quality, optimize=True)  # save
+        im.save(f_new or f, "JPEG", quality=quality, optimize=True)  # save
     except Exception as e:  # use OpenCV
-        LOGGER.info(f'WARNING  HUB ops PIL failure {f}: {e}')
+        LOGGER.info(f"WARNING  HUB ops PIL failure {f}: {e}")
         im = cv2.imread(f)
         im_height, im_width = im.shape[:2]
         r = max_dim / max(im_height, im_width)  # ratio
         if r < 1.0:  # image too large
             im = cv2.resize(im, (int(im_width * r), int(im_height * r)), interpolation=cv2.INTER_AREA)
         cv2.imwrite(str(f_new or f), im)
 
 
-def autosplit(path=DATASETS_DIR / 'coco8/images', weights=(0.9, 0.1, 0.0), annotated_only=False):
+def autosplit(path=DATASETS_DIR / "coco8/images", weights=(0.9, 0.1, 0.0), annotated_only=False):
     """
     Automatically split a dataset into train/val/test splits and save the resulting splits into autosplit_*.txt files.
 
     Args:
         path (Path, optional): Path to images directory. Defaults to DATASETS_DIR / 'coco8/images'.
         weights (list | tuple, optional): Train, validation, and test split fractions. Defaults to (0.9, 0.1, 0.0).
         annotated_only (bool, optional): If True, only images with an associated txt file are used. Defaults to False.
@@ -611,22 +632,45 @@
         from ultralytics.data.utils import autosplit
 
         autosplit()
         ```
     """
 
     path = Path(path)  # images dir
-    files = sorted(x for x in path.rglob('*.*') if x.suffix[1:].lower() in IMG_FORMATS)  # image files only
+    files = sorted(x for x in path.rglob("*.*") if x.suffix[1:].lower() in IMG_FORMATS)  # image files only
     n = len(files)  # number of files
     random.seed(0)  # for reproducibility
     indices = random.choices([0, 1, 2], weights=weights, k=n)  # assign each image to a split
 
-    txt = ['autosplit_train.txt', 'autosplit_val.txt', 'autosplit_test.txt']  # 3 txt files
+    txt = ["autosplit_train.txt", "autosplit_val.txt", "autosplit_test.txt"]  # 3 txt files
     for x in txt:
         if (path.parent / x).exists():
             (path.parent / x).unlink()  # remove existing
 
-    LOGGER.info(f'Autosplitting images from {path}' + ', using *.txt labeled images only' * annotated_only)
+    LOGGER.info(f"Autosplitting images from {path}" + ", using *.txt labeled images only" * annotated_only)
     for i, img in TQDM(zip(indices, files), total=n):
         if not annotated_only or Path(img2label_paths([str(img)])[0]).exists():  # check label
-            with open(path.parent / txt[i], 'a') as f:
-                f.write(f'./{img.relative_to(path.parent).as_posix()}' + '\n')  # add image to txt file
+            with open(path.parent / txt[i], "a") as f:
+                f.write(f"./{img.relative_to(path.parent).as_posix()}" + "\n")  # add image to txt file
+
+
+def load_dataset_cache_file(path):
+    """Load an Ultralytics *.cache dictionary from path."""
+    import gc
+
+    gc.disable()  # reduce pickle load time https://github.com/ultralytics/ultralytics/pull/1585
+    cache = np.load(str(path), allow_pickle=True).item()  # load dict
+    gc.enable()
+    return cache
+
+
+def save_dataset_cache_file(prefix, path, x, version):
+    """Save an Ultralytics dataset *.cache dictionary x to path."""
+    x["version"] = version  # add cache version
+    if is_dir_writeable(path.parent):
+        if path.exists():
+            path.unlink()  # remove *.cache file if exists
+        np.save(str(path), x)  # save cache for next time
+        path.with_suffix(".cache.npy").rename(path)  # remove .npy suffix
+        LOGGER.info(f"{prefix}New cache created: {path}")
+    else:
+        LOGGER.warning(f"{prefix}WARNING  Cache directory {path.parent} is not writeable, cache not saved.")
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/engine/exporter.py` & `yolov8_pose_triton-8.2.0/ultralytics/engine/exporter.py`

 * *Files 16% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 CoreML                  | `coreml`                  | yolov8n.mlpackage
 TensorFlow SavedModel   | `saved_model`             | yolov8n_saved_model/
 TensorFlow GraphDef     | `pb`                      | yolov8n.pb
 TensorFlow Lite         | `tflite`                  | yolov8n.tflite
 TensorFlow Edge TPU     | `edgetpu`                 | yolov8n_edgetpu.tflite
 TensorFlow.js           | `tfjs`                    | yolov8n_web_model/
 PaddlePaddle            | `paddle`                  | yolov8n_paddle_model/
-ncnn                    | `ncnn`                    | yolov8n_ncnn_model/
+NCNN                    | `ncnn`                    | yolov8n_ncnn_model/
 
 Requirements:
     $ pip install "ultralytics[export]"
 
 Python:
     from ultralytics import YOLO
     model = YOLO('yolov8n.pt')
@@ -37,21 +37,23 @@
                          yolov8n.engine             # TensorRT
                          yolov8n.mlpackage          # CoreML (macOS-only)
                          yolov8n_saved_model        # TensorFlow SavedModel
                          yolov8n.pb                 # TensorFlow GraphDef
                          yolov8n.tflite             # TensorFlow Lite
                          yolov8n_edgetpu.tflite     # TensorFlow Edge TPU
                          yolov8n_paddle_model       # PaddlePaddle
+                         yolov8n_ncnn_model         # NCNN
 
 TensorFlow.js:
     $ cd .. && git clone https://github.com/zldrobit/tfjs-yolov5-example.git && cd tfjs-yolov5-example
     $ npm install
     $ ln -s ../../yolov5/yolov8n_web_model public/yolov8n_web_model
     $ npm start
 """
+
 import json
 import os
 import shutil
 import subprocess
 import time
 import warnings
 from copy import deepcopy
@@ -60,69 +62,84 @@
 
 import numpy as np
 import torch
 
 from ultralytics.cfg import get_cfg
 from ultralytics.data.dataset import YOLODataset
 from ultralytics.data.utils import check_det_dataset
-from ultralytics.nn.autobackend import check_class_names
+from ultralytics.nn.autobackend import check_class_names, default_class_names
 from ultralytics.nn.modules import C2f, Detect, RTDETRDecoder
-from ultralytics.nn.tasks import DetectionModel, SegmentationModel
-from ultralytics.utils import (ARM64, DEFAULT_CFG, LINUX, LOGGER, MACOS, ROOT, WINDOWS, __version__, callbacks,
-                               colorstr, get_default_args, yaml_save)
+from ultralytics.nn.tasks import DetectionModel, SegmentationModel, WorldModel
+from ultralytics.utils import (
+    ARM64,
+    DEFAULT_CFG,
+    LINUX,
+    LOGGER,
+    MACOS,
+    PYTHON_VERSION,
+    ROOT,
+    WINDOWS,
+    __version__,
+    callbacks,
+    colorstr,
+    get_default_args,
+    yaml_save,
+)
 from ultralytics.utils.checks import check_imgsz, check_is_path_safe, check_requirements, check_version
 from ultralytics.utils.downloads import attempt_download_asset, get_github_assets
 from ultralytics.utils.files import file_size, spaces_in_path
 from ultralytics.utils.ops import Profile
-from ultralytics.utils.torch_utils import get_latest_opset, select_device, smart_inference_mode
+from ultralytics.utils.torch_utils import TORCH_1_13, get_latest_opset, select_device, smart_inference_mode
 
 
 def export_formats():
     """YOLOv8 export formats."""
-    import pandas
+    import pandas  # scope for faster 'import ultralytics'
+
     x = [
-        ['PyTorch', '-', '.pt', True, True],
-        ['TorchScript', 'torchscript', '.torchscript', True, True],
-        ['ONNX', 'onnx', '.onnx', True, True],
-        ['OpenVINO', 'openvino', '_openvino_model', True, False],
-        ['TensorRT', 'engine', '.engine', False, True],
-        ['CoreML', 'coreml', '.mlpackage', True, False],
-        ['TensorFlow SavedModel', 'saved_model', '_saved_model', True, True],
-        ['TensorFlow GraphDef', 'pb', '.pb', True, True],
-        ['TensorFlow Lite', 'tflite', '.tflite', True, False],
-        ['TensorFlow Edge TPU', 'edgetpu', '_edgetpu.tflite', True, False],
-        ['TensorFlow.js', 'tfjs', '_web_model', True, False],
-        ['PaddlePaddle', 'paddle', '_paddle_model', True, True],
-        ['ncnn', 'ncnn', '_ncnn_model', True, True], ]
-    return pandas.DataFrame(x, columns=['Format', 'Argument', 'Suffix', 'CPU', 'GPU'])
+        ["PyTorch", "-", ".pt", True, True],
+        ["TorchScript", "torchscript", ".torchscript", True, True],
+        ["ONNX", "onnx", ".onnx", True, True],
+        ["OpenVINO", "openvino", "_openvino_model", True, False],
+        ["TensorRT", "engine", ".engine", False, True],
+        ["CoreML", "coreml", ".mlpackage", True, False],
+        ["TensorFlow SavedModel", "saved_model", "_saved_model", True, True],
+        ["TensorFlow GraphDef", "pb", ".pb", True, True],
+        ["TensorFlow Lite", "tflite", ".tflite", True, False],
+        ["TensorFlow Edge TPU", "edgetpu", "_edgetpu.tflite", True, False],
+        ["TensorFlow.js", "tfjs", "_web_model", True, False],
+        ["PaddlePaddle", "paddle", "_paddle_model", True, True],
+        ["NCNN", "ncnn", "_ncnn_model", True, True],
+    ]
+    return pandas.DataFrame(x, columns=["Format", "Argument", "Suffix", "CPU", "GPU"])
 
 
 def gd_outputs(gd):
     """TensorFlow GraphDef model output node names."""
     name_list, input_list = [], []
     for node in gd.node:  # tensorflow.core.framework.node_def_pb2.NodeDef
         name_list.append(node.name)
         input_list.extend(node.input)
-    return sorted(f'{x}:0' for x in list(set(name_list) - set(input_list)) if not x.startswith('NoOp'))
+    return sorted(f"{x}:0" for x in list(set(name_list) - set(input_list)) if not x.startswith("NoOp"))
 
 
 def try_export(inner_func):
     """YOLOv8 export decorator, i..e @try_export."""
     inner_args = get_default_args(inner_func)
 
     def outer_func(*args, **kwargs):
         """Export a model."""
-        prefix = inner_args['prefix']
+        prefix = inner_args["prefix"]
         try:
             with Profile() as dt:
                 f, model = inner_func(*args, **kwargs)
             LOGGER.info(f"{prefix} export success  {dt.t:.1f}s, saved as '{f}' ({file_size(f):.1f} MB)")
             return f, model
         except Exception as e:
-            LOGGER.info(f'{prefix} export failure  {dt.t:.1f}s: {e}')
+            LOGGER.info(f"{prefix} export failure  {dt.t:.1f}s: {e}")
             raise e
 
     return outer_func
 
 
 class Exporter:
     """
@@ -139,665 +156,773 @@
 
         Args:
             cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.
             overrides (dict, optional): Configuration overrides. Defaults to None.
             _callbacks (dict, optional): Dictionary of callback functions. Defaults to None.
         """
         self.args = get_cfg(cfg, overrides)
-        if self.args.format.lower() in ('coreml', 'mlmodel'):  # fix attempt for protobuf<3.20.x errors
-            os.environ['PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION'] = 'python'  # must run before TensorBoard callback
+        if self.args.format.lower() in {"coreml", "mlmodel"}:  # fix attempt for protobuf<3.20.x errors
+            os.environ["PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION"] = "python"  # must run before TensorBoard callback
 
         self.callbacks = _callbacks or callbacks.get_default_callbacks()
         callbacks.add_integration_callbacks(self)
 
     @smart_inference_mode()
     def __call__(self, model=None):
         """Returns list of exported files/dirs after running callbacks."""
-        self.run_callbacks('on_export_start')
+        self.run_callbacks("on_export_start")
         t = time.time()
         fmt = self.args.format.lower()  # to lowercase
-        if fmt in ('tensorrt', 'trt'):  # 'engine' aliases
-            fmt = 'engine'
-        if fmt in ('mlmodel', 'mlpackage', 'mlprogram', 'apple', 'ios', 'coreml'):  # 'coreml' aliases
-            fmt = 'coreml'
-        fmts = tuple(export_formats()['Argument'][1:])  # available export formats
+        if fmt in {"tensorrt", "trt"}:  # 'engine' aliases
+            fmt = "engine"
+        if fmt in {"mlmodel", "mlpackage", "mlprogram", "apple", "ios", "coreml"}:  # 'coreml' aliases
+            fmt = "coreml"
+        fmts = tuple(export_formats()["Argument"][1:])  # available export formats
         flags = [x == fmt for x in fmts]
         if sum(flags) != 1:
             raise ValueError(f"Invalid export format='{fmt}'. Valid formats are {fmts}")
         jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle, ncnn = flags  # export booleans
 
         # Device
-        if fmt == 'engine' and self.args.device is None:
-            LOGGER.warning('WARNING  TensorRT requires GPU export, automatically assigning device=0')
-            self.args.device = '0'
-        self.device = select_device('cpu' if self.args.device is None else self.args.device)
+        if fmt == "engine" and self.args.device is None:
+            LOGGER.warning("WARNING  TensorRT requires GPU export, automatically assigning device=0")
+            self.args.device = "0"
+        self.device = select_device("cpu" if self.args.device is None else self.args.device)
 
         # Checks
+        if not hasattr(model, "names"):
+            model.names = default_class_names()
         model.names = check_class_names(model.names)
-        if self.args.half and onnx and self.device.type == 'cpu':
-            LOGGER.warning('WARNING  half=True only compatible with GPU export, i.e. use device=0')
+        if self.args.half and onnx and self.device.type == "cpu":
+            LOGGER.warning("WARNING  half=True only compatible with GPU export, i.e. use device=0")
             self.args.half = False
-            assert not self.args.dynamic, 'half=True not compatible with dynamic=True, i.e. use only one.'
+            assert not self.args.dynamic, "half=True not compatible with dynamic=True, i.e. use only one."
         self.imgsz = check_imgsz(self.args.imgsz, stride=model.stride, min_dim=2)  # check image size
         if self.args.optimize:
             assert not ncnn, "optimize=True not compatible with format='ncnn', i.e. use optimize=False"
-            assert self.device.type == 'cpu', "optimize=True not compatible with cuda devices, i.e. use device='cpu'"
+            assert self.device.type == "cpu", "optimize=True not compatible with cuda devices, i.e. use device='cpu'"
         if edgetpu and not LINUX:
-            raise SystemError('Edge TPU export only supported on Linux. See https://coral.ai/docs/edgetpu/compiler/')
+            raise SystemError("Edge TPU export only supported on Linux. See https://coral.ai/docs/edgetpu/compiler/")
+        if isinstance(model, WorldModel):
+            LOGGER.warning(
+                "WARNING  YOLOWorld (original version) export is not supported to any format.\n"
+                "WARNING  YOLOWorldv2 models (i.e. 'yolov8s-worldv2.pt') only support export to "
+                "(torchscript, onnx, openvino, engine, coreml) formats. "
+                "See https://docs.ultralytics.com/models/yolo-world for details."
+            )
 
         # Input
         im = torch.zeros(self.args.batch, 3, *self.imgsz).to(self.device)
         file = Path(
-            getattr(model, 'pt_path', None) or getattr(model, 'yaml_file', None) or model.yaml.get('yaml_file', ''))
-        if file.suffix in {'.yaml', '.yml'}:
+            getattr(model, "pt_path", None) or getattr(model, "yaml_file", None) or model.yaml.get("yaml_file", "")
+        )
+        if file.suffix in {".yaml", ".yml"}:
             file = Path(file.name)
 
         # Update model
         model = deepcopy(model).to(self.device)
         for p in model.parameters():
             p.requires_grad = False
         model.eval()
         model.float()
         model = model.fuse()
         for m in model.modules():
-            if isinstance(m, (Detect, RTDETRDecoder)):  # Segment and Pose use Detect base class
+            if isinstance(m, (Detect, RTDETRDecoder)):  # includes all Detect subclasses like Segment, Pose, OBB
                 m.dynamic = self.args.dynamic
                 m.export = True
                 m.format = self.args.format
             elif isinstance(m, C2f) and not any((saved_model, pb, tflite, edgetpu, tfjs)):
                 # EdgeTPU does not support FlexSplitV while split provides cleaner ONNX graph
                 m.forward = m.forward_split
 
         y = None
         for _ in range(2):
             y = model(im)  # dry runs
-        if self.args.half and (engine or onnx) and self.device.type != 'cpu':
+        if self.args.half and onnx and self.device.type != "cpu":
             im, model = im.half(), model.half()  # to FP16
 
         # Filter warnings
-        warnings.filterwarnings('ignore', category=torch.jit.TracerWarning)  # suppress TracerWarning
-        warnings.filterwarnings('ignore', category=UserWarning)  # suppress shape prim::Constant missing ONNX warning
-        warnings.filterwarnings('ignore', category=DeprecationWarning)  # suppress CoreML np.bool deprecation warning
+        warnings.filterwarnings("ignore", category=torch.jit.TracerWarning)  # suppress TracerWarning
+        warnings.filterwarnings("ignore", category=UserWarning)  # suppress shape prim::Constant missing ONNX warning
+        warnings.filterwarnings("ignore", category=DeprecationWarning)  # suppress CoreML np.bool deprecation warning
 
         # Assign
         self.im = im
         self.model = model
         self.file = file
-        self.output_shape = tuple(y.shape) if isinstance(y, torch.Tensor) else tuple(
-            tuple(x.shape if isinstance(x, torch.Tensor) else []) for x in y)
-        self.pretty_name = Path(self.model.yaml.get('yaml_file', self.file)).stem.replace('yolo', 'YOLO')
-        data = model.args['data'] if hasattr(model, 'args') and isinstance(model.args, dict) else ''
+        self.output_shape = (
+            tuple(y.shape)
+            if isinstance(y, torch.Tensor)
+            else tuple(tuple(x.shape if isinstance(x, torch.Tensor) else []) for x in y)
+        )
+        self.pretty_name = Path(self.model.yaml.get("yaml_file", self.file)).stem.replace("yolo", "YOLO")
+        data = model.args["data"] if hasattr(model, "args") and isinstance(model.args, dict) else ""
         description = f'Ultralytics {self.pretty_name} model {f"trained on {data}" if data else ""}'
         self.metadata = {
-            'description': description,
-            'author': 'Ultralytics',
-            'license': 'AGPL-3.0 https://ultralytics.com/license',
-            'date': datetime.now().isoformat(),
-            'version': __version__,
-            'stride': int(max(model.stride)),
-            'task': model.task,
-            'batch': self.args.batch,
-            'imgsz': self.imgsz,
-            'names': model.names}  # model metadata
-        if model.task == 'pose':
-            self.metadata['kpt_shape'] = model.model[-1].kpt_shape
+            "description": description,
+            "author": "Ultralytics",
+            "date": datetime.now().isoformat(),
+            "version": __version__,
+            "license": "AGPL-3.0 License (https://ultralytics.com/license)",
+            "docs": "https://docs.ultralytics.com",
+            "stride": int(max(model.stride)),
+            "task": model.task,
+            "batch": self.args.batch,
+            "imgsz": self.imgsz,
+            "names": model.names,
+        }  # model metadata
+        if model.task == "pose":
+            self.metadata["kpt_shape"] = model.model[-1].kpt_shape
 
-        LOGGER.info(f"\n{colorstr('PyTorch:')} starting from '{file}' with input shape {tuple(im.shape)} BCHW and "
-                    f'output shape(s) {self.output_shape} ({file_size(file):.1f} MB)')
+        LOGGER.info(
+            f"\n{colorstr('PyTorch:')} starting from '{file}' with input shape {tuple(im.shape)} BCHW and "
+            f'output shape(s) {self.output_shape} ({file_size(file):.1f} MB)'
+        )
 
         # Exports
-        f = [''] * len(fmts)  # exported filenames
+        f = [""] * len(fmts)  # exported filenames
         if jit or ncnn:  # TorchScript
             f[0], _ = self.export_torchscript()
         if engine:  # TensorRT required before ONNX
             f[1], _ = self.export_engine()
-        if onnx or xml:  # OpenVINO requires ONNX
+        if onnx:  # ONNX
             f[2], _ = self.export_onnx()
         if xml:  # OpenVINO
             f[3], _ = self.export_openvino()
         if coreml:  # CoreML
             f[4], _ = self.export_coreml()
         if any((saved_model, pb, tflite, edgetpu, tfjs)):  # TensorFlow formats
             self.args.int8 |= edgetpu
             f[5], keras_model = self.export_saved_model()
             if pb or tfjs:  # pb prerequisite to tfjs
                 f[6], _ = self.export_pb(keras_model=keras_model)
             if tflite:
                 f[7], _ = self.export_tflite(keras_model=keras_model, nms=False, agnostic_nms=self.args.agnostic_nms)
             if edgetpu:
-                f[8], _ = self.export_edgetpu(tflite_model=Path(f[5]) / f'{self.file.stem}_full_integer_quant.tflite')
+                f[8], _ = self.export_edgetpu(tflite_model=Path(f[5]) / f"{self.file.stem}_full_integer_quant.tflite")
             if tfjs:
                 f[9], _ = self.export_tfjs()
         if paddle:  # PaddlePaddle
             f[10], _ = self.export_paddle()
-        if ncnn:  # ncnn
+        if ncnn:  # NCNN
             f[11], _ = self.export_ncnn()
 
         # Finish
         f = [str(x) for x in f if x]  # filter out '' and None
         if any(f):
             f = str(Path(f[-1]))
             square = self.imgsz[0] == self.imgsz[1]
-            s = '' if square else f"WARNING  non-PyTorch val requires square images, 'imgsz={self.imgsz}' will not " \
-                                  f"work. Use export 'imgsz={max(self.imgsz)}' if val is required."
-            imgsz = self.imgsz[0] if square else str(self.imgsz)[1:-1].replace(' ', '')
-            predict_data = f'data={data}' if model.task == 'segment' and fmt == 'pb' else ''
-            q = 'int8' if self.args.int8 else 'half' if self.args.half else ''  # quantization
-            LOGGER.info(f'\nExport complete ({time.time() - t:.1f}s)'
-                        f"\nResults saved to {colorstr('bold', file.parent.resolve())}"
-                        f'\nPredict:         yolo predict task={model.task} model={f} imgsz={imgsz} {q} {predict_data}'
-                        f'\nValidate:        yolo val task={model.task} model={f} imgsz={imgsz} data={data} {q} {s}'
-                        f'\nVisualize:       https://netron.app')
+            s = (
+                ""
+                if square
+                else f"WARNING  non-PyTorch val requires square images, 'imgsz={self.imgsz}' will not "
+                f"work. Use export 'imgsz={max(self.imgsz)}' if val is required."
+            )
+            imgsz = self.imgsz[0] if square else str(self.imgsz)[1:-1].replace(" ", "")
+            predict_data = f"data={data}" if model.task == "segment" and fmt == "pb" else ""
+            q = "int8" if self.args.int8 else "half" if self.args.half else ""  # quantization
+            LOGGER.info(
+                f'\nExport complete ({time.time() - t:.1f}s)'
+                f"\nResults saved to {colorstr('bold', file.parent.resolve())}"
+                f'\nPredict:         yolo predict task={model.task} model={f} imgsz={imgsz} {q} {predict_data}'
+                f'\nValidate:        yolo val task={model.task} model={f} imgsz={imgsz} data={data} {q} {s}'
+                f'\nVisualize:       https://netron.app'
+            )
 
-        self.run_callbacks('on_export_end')
+        self.run_callbacks("on_export_end")
         return f  # return list of exported files/dirs
 
     @try_export
-    def export_torchscript(self, prefix=colorstr('TorchScript:')):
+    def export_torchscript(self, prefix=colorstr("TorchScript:")):
         """YOLOv8 TorchScript model export."""
-        LOGGER.info(f'\n{prefix} starting export with torch {torch.__version__}...')
-        f = self.file.with_suffix('.torchscript')
+        LOGGER.info(f"\n{prefix} starting export with torch {torch.__version__}...")
+        f = self.file.with_suffix(".torchscript")
 
         ts = torch.jit.trace(self.model, self.im, strict=False)
-        extra_files = {'config.txt': json.dumps(self.metadata)}  # torch._C.ExtraFilesMap()
+        extra_files = {"config.txt": json.dumps(self.metadata)}  # torch._C.ExtraFilesMap()
         if self.args.optimize:  # https://pytorch.org/tutorials/recipes/mobile_interpreter.html
-            LOGGER.info(f'{prefix} optimizing for mobile...')
+            LOGGER.info(f"{prefix} optimizing for mobile...")
             from torch.utils.mobile_optimizer import optimize_for_mobile
+
             optimize_for_mobile(ts)._save_for_lite_interpreter(str(f), _extra_files=extra_files)
         else:
             ts.save(str(f), _extra_files=extra_files)
         return f, None
 
     @try_export
-    def export_onnx(self, prefix=colorstr('ONNX:')):
+    def export_onnx(self, prefix=colorstr("ONNX:")):
         """YOLOv8 ONNX export."""
-        requirements = ['onnx>=1.12.0']
+        requirements = ["onnx>=1.12.0"]
         if self.args.simplify:
-            requirements += ['onnxsim>=0.4.33', 'onnxruntime-gpu' if torch.cuda.is_available() else 'onnxruntime']
+            requirements += ["onnxsim>=0.4.33", "onnxruntime-gpu" if torch.cuda.is_available() else "onnxruntime"]
+            if ARM64:
+                check_requirements("cmake")  # 'cmake' is needed to build onnxsim on aarch64
         check_requirements(requirements)
         import onnx  # noqa
 
         opset_version = self.args.opset or get_latest_opset()
-        LOGGER.info(f'\n{prefix} starting export with onnx {onnx.__version__} opset {opset_version}...')
-        f = str(self.file.with_suffix('.onnx'))
+        LOGGER.info(f"\n{prefix} starting export with onnx {onnx.__version__} opset {opset_version}...")
+        f = str(self.file.with_suffix(".onnx"))
 
-        output_names = ['output0', 'output1'] if isinstance(self.model, SegmentationModel) else ['output0']
+        output_names = ["output0", "output1"] if isinstance(self.model, SegmentationModel) else ["output0"]
         dynamic = self.args.dynamic
         if dynamic:
-            dynamic = {'images': {0: 'batch', 2: 'height', 3: 'width'}}  # shape(1,3,640,640)
+            dynamic = {"images": {0: "batch", 2: "height", 3: "width"}}  # shape(1,3,640,640)
             if isinstance(self.model, SegmentationModel):
-                dynamic['output0'] = {0: 'batch', 2: 'anchors'}  # shape(1, 116, 8400)
-                dynamic['output1'] = {0: 'batch', 2: 'mask_height', 3: 'mask_width'}  # shape(1,32,160,160)
+                dynamic["output0"] = {0: "batch", 2: "anchors"}  # shape(1, 116, 8400)
+                dynamic["output1"] = {0: "batch", 2: "mask_height", 3: "mask_width"}  # shape(1,32,160,160)
             elif isinstance(self.model, DetectionModel):
-                dynamic['output0'] = {0: 'batch', 2: 'anchors'}  # shape(1, 84, 8400)
+                dynamic["output0"] = {0: "batch", 2: "anchors"}  # shape(1, 84, 8400)
 
         torch.onnx.export(
             self.model.cpu() if dynamic else self.model,  # dynamic=True only compatible with cpu
             self.im.cpu() if dynamic else self.im,
             f,
             verbose=False,
             opset_version=opset_version,
             do_constant_folding=True,  # WARNING: DNN inference with torch>=1.12 may require do_constant_folding=False
-            input_names=['images'],
+            input_names=["images"],
             output_names=output_names,
-            dynamic_axes=dynamic or None)
+            dynamic_axes=dynamic or None,
+        )
 
         # Checks
         model_onnx = onnx.load(f)  # load onnx model
         # onnx.checker.check_model(model_onnx)  # check onnx model
 
         # Simplify
         if self.args.simplify:
             try:
                 import onnxsim
 
-                LOGGER.info(f'{prefix} simplifying with onnxsim {onnxsim.__version__}...')
+                LOGGER.info(f"{prefix} simplifying with onnxsim {onnxsim.__version__}...")
                 # subprocess.run(f'onnxsim "{f}" "{f}"', shell=True)
                 model_onnx, check = onnxsim.simplify(model_onnx)
-                assert check, 'Simplified ONNX model could not be validated'
+                assert check, "Simplified ONNX model could not be validated"
             except Exception as e:
-                LOGGER.info(f'{prefix} simplifier failure: {e}')
+                LOGGER.info(f"{prefix} simplifier failure: {e}")
 
         # Metadata
         for k, v in self.metadata.items():
             meta = model_onnx.metadata_props.add()
             meta.key, meta.value = k, str(v)
 
         onnx.save(model_onnx, f)
         return f, model_onnx
 
     @try_export
-    def export_openvino(self, prefix=colorstr('OpenVINO:')):
+    def export_openvino(self, prefix=colorstr("OpenVINO:")):
         """YOLOv8 OpenVINO export."""
-        check_requirements('openvino-dev>=2023.0')  # requires openvino-dev: https://pypi.org/project/openvino-dev/
-        import openvino.runtime as ov  # noqa
-        from openvino.tools import mo  # noqa
-
-        LOGGER.info(f'\n{prefix} starting export with openvino {ov.__version__}...')
-        f = str(self.file).replace(self.file.suffix, f'_openvino_model{os.sep}')
-        fq = str(self.file).replace(self.file.suffix, f'_int8_openvino_model{os.sep}')
-        f_onnx = self.file.with_suffix('.onnx')
-        f_ov = str(Path(f) / self.file.with_suffix('.xml').name)
-        fq_ov = str(Path(fq) / self.file.with_suffix('.xml').name)
+        check_requirements("openvino>=2024.0.0")  # requires openvino: https://pypi.org/project/openvino/
+        import openvino as ov
+
+        LOGGER.info(f"\n{prefix} starting export with openvino {ov.__version__}...")
+        assert TORCH_1_13, f"OpenVINO export requires torch>=1.13.0 but torch=={torch.__version__} is installed"
+        ov_model = ov.convert_model(
+            self.model.cpu(),
+            input=None if self.args.dynamic else [self.im.shape],
+            example_input=self.im,
+        )
 
         def serialize(ov_model, file):
             """Set RT info, serialize and save metadata YAML."""
-            ov_model.set_rt_info('YOLOv8', ['model_info', 'model_type'])
-            ov_model.set_rt_info(True, ['model_info', 'reverse_input_channels'])
-            ov_model.set_rt_info(114, ['model_info', 'pad_value'])
-            ov_model.set_rt_info([255.0], ['model_info', 'scale_values'])
-            ov_model.set_rt_info(self.args.iou, ['model_info', 'iou_threshold'])
-            ov_model.set_rt_info([v.replace(' ', '_') for v in self.model.names.values()], ['model_info', 'labels'])
-            if self.model.task != 'classify':
-                ov_model.set_rt_info('fit_to_window_letterbox', ['model_info', 'resize_type'])
-
-            ov.serialize(ov_model, file)  # save
-            yaml_save(Path(file).parent / 'metadata.yaml', self.metadata)  # add metadata.yaml
-
-        ov_model = mo.convert_model(f_onnx,
-                                    model_name=self.pretty_name,
-                                    framework='onnx',
-                                    compress_to_fp16=self.args.half)  # export
+            ov_model.set_rt_info("YOLOv8", ["model_info", "model_type"])
+            ov_model.set_rt_info(True, ["model_info", "reverse_input_channels"])
+            ov_model.set_rt_info(114, ["model_info", "pad_value"])
+            ov_model.set_rt_info([255.0], ["model_info", "scale_values"])
+            ov_model.set_rt_info(self.args.iou, ["model_info", "iou_threshold"])
+            ov_model.set_rt_info([v.replace(" ", "_") for v in self.model.names.values()], ["model_info", "labels"])
+            if self.model.task != "classify":
+                ov_model.set_rt_info("fit_to_window_letterbox", ["model_info", "resize_type"])
+
+            ov.runtime.save_model(ov_model, file, compress_to_fp16=self.args.half)
+            yaml_save(Path(file).parent / "metadata.yaml", self.metadata)  # add metadata.yaml
 
         if self.args.int8:
-            assert self.args.data, "INT8 export requires a data argument for calibration, i.e. 'data=coco8.yaml'"
-            check_requirements('nncf>=2.5.0')
+            fq = str(self.file).replace(self.file.suffix, f"_int8_openvino_model{os.sep}")
+            fq_ov = str(Path(fq) / self.file.with_suffix(".xml").name)
+            if not self.args.data:
+                self.args.data = DEFAULT_CFG.data or "coco128.yaml"
+                LOGGER.warning(
+                    f"{prefix} WARNING  INT8 export requires a missing 'data' arg for calibration. "
+                    f"Using default 'data={self.args.data}'."
+                )
+            check_requirements("nncf>=2.8.0")
             import nncf
 
             def transform_fn(data_item):
                 """Quantization transform function."""
-                im = data_item['img'].numpy().astype(np.float32) / 255.0  # uint8 to fp16/32 and 0 - 255 to 0.0 - 1.0
+                assert (
+                    data_item["img"].dtype == torch.uint8
+                ), "Input image must be uint8 for the quantization preprocessing"
+                im = data_item["img"].numpy().astype(np.float32) / 255.0  # uint8 to fp16/32 and 0 - 255 to 0.0 - 1.0
                 return np.expand_dims(im, 0) if im.ndim == 3 else im
 
             # Generate calibration data for integer quantization
             LOGGER.info(f"{prefix} collecting INT8 calibration images from 'data={self.args.data}'")
             data = check_det_dataset(self.args.data)
-            dataset = YOLODataset(data['val'], data=data, imgsz=self.imgsz[0], augment=False)
+            dataset = YOLODataset(data["val"], data=data, task=self.model.task, imgsz=self.imgsz[0], augment=False)
+            n = len(dataset)
+            if n < 300:
+                LOGGER.warning(f"{prefix} WARNING  >300 images recommended for INT8 calibration, found {n} images.")
             quantization_dataset = nncf.Dataset(dataset, transform_fn)
-            ignored_scope = nncf.IgnoredScope(types=['Multiply', 'Subtract', 'Sigmoid'])  # ignore operation
-            quantized_ov_model = nncf.quantize(ov_model,
-                                               quantization_dataset,
-                                               preset=nncf.QuantizationPreset.MIXED,
-                                               ignored_scope=ignored_scope)
+
+            ignored_scope = None
+            if isinstance(self.model.model[-1], Detect):
+                # Includes all Detect subclasses like Segment, Pose, OBB, WorldDetect
+                head_module_name = ".".join(list(self.model.named_modules())[-1][0].split(".")[:2])
+
+                ignored_scope = nncf.IgnoredScope(  # ignore operations
+                    patterns=[
+                        f".*{head_module_name}/.*/Add",
+                        f".*{head_module_name}/.*/Sub*",
+                        f".*{head_module_name}/.*/Mul*",
+                        f".*{head_module_name}/.*/Div*",
+                        f".*{head_module_name}\\.dfl.*",
+                    ],
+                    types=["Sigmoid"],
+                )
+
+            quantized_ov_model = nncf.quantize(
+                ov_model, quantization_dataset, preset=nncf.QuantizationPreset.MIXED, ignored_scope=ignored_scope
+            )
             serialize(quantized_ov_model, fq_ov)
             return fq, None
 
+        f = str(self.file).replace(self.file.suffix, f"_openvino_model{os.sep}")
+        f_ov = str(Path(f) / self.file.with_suffix(".xml").name)
+
         serialize(ov_model, f_ov)
         return f, None
 
     @try_export
-    def export_paddle(self, prefix=colorstr('PaddlePaddle:')):
+    def export_paddle(self, prefix=colorstr("PaddlePaddle:")):
         """YOLOv8 Paddle export."""
-        check_requirements(('paddlepaddle', 'x2paddle'))
+        check_requirements(("paddlepaddle", "x2paddle"))
         import x2paddle  # noqa
         from x2paddle.convert import pytorch2paddle  # noqa
 
-        LOGGER.info(f'\n{prefix} starting export with X2Paddle {x2paddle.__version__}...')
-        f = str(self.file).replace(self.file.suffix, f'_paddle_model{os.sep}')
+        LOGGER.info(f"\n{prefix} starting export with X2Paddle {x2paddle.__version__}...")
+        f = str(self.file).replace(self.file.suffix, f"_paddle_model{os.sep}")
 
-        pytorch2paddle(module=self.model, save_dir=f, jit_type='trace', input_examples=[self.im])  # export
-        yaml_save(Path(f) / 'metadata.yaml', self.metadata)  # add metadata.yaml
+        pytorch2paddle(module=self.model, save_dir=f, jit_type="trace", input_examples=[self.im])  # export
+        yaml_save(Path(f) / "metadata.yaml", self.metadata)  # add metadata.yaml
         return f, None
 
     @try_export
-    def export_ncnn(self, prefix=colorstr('ncnn:')):
+    def export_ncnn(self, prefix=colorstr("NCNN:")):
         """
-        YOLOv8 ncnn export using PNNX https://github.com/pnnx/pnnx.
+        YOLOv8 NCNN export using PNNX https://github.com/pnnx/pnnx.
         """
-        check_requirements('git+https://github.com/Tencent/ncnn.git' if ARM64 else 'ncnn')  # requires ncnn
+        check_requirements("ncnn")
         import ncnn  # noqa
 
-        LOGGER.info(f'\n{prefix} starting export with ncnn {ncnn.__version__}...')
-        f = Path(str(self.file).replace(self.file.suffix, f'_ncnn_model{os.sep}'))
-        f_ts = self.file.with_suffix('.torchscript')
+        LOGGER.info(f"\n{prefix} starting export with NCNN {ncnn.__version__}...")
+        f = Path(str(self.file).replace(self.file.suffix, f"_ncnn_model{os.sep}"))
+        f_ts = self.file.with_suffix(".torchscript")
 
-        name = Path('pnnx.exe' if WINDOWS else 'pnnx')  # PNNX filename
+        name = Path("pnnx.exe" if WINDOWS else "pnnx")  # PNNX filename
         pnnx = name if name.is_file() else ROOT / name
         if not pnnx.is_file():
             LOGGER.warning(
-                f'{prefix} WARNING  PNNX not found. Attempting to download binary file from '
-                'https://github.com/pnnx/pnnx/.\nNote PNNX Binary file must be placed in current working directory '
-                f'or in {ROOT}. See PNNX repo for full installation instructions.')
-            _, assets = get_github_assets(repo='pnnx/pnnx', retry=True)
-            system = 'macos' if MACOS else 'ubuntu' if LINUX else 'windows'  # operating system
-            asset = [x for x in assets if system in x][0] if assets else \
-                f'https://github.com/pnnx/pnnx/releases/download/20230816/pnnx-20230816-{system}.zip'  # fallback
-            asset = attempt_download_asset(asset, repo='pnnx/pnnx', release='latest')
+                f"{prefix} WARNING  PNNX not found. Attempting to download binary file from "
+                "https://github.com/pnnx/pnnx/.\nNote PNNX Binary file must be placed in current working directory "
+                f"or in {ROOT}. See PNNX repo for full installation instructions."
+            )
+            system = "macos" if MACOS else "windows" if WINDOWS else "linux-aarch64" if ARM64 else "linux"
+            try:
+                _, assets = get_github_assets(repo="pnnx/pnnx")
+                url = [x for x in assets if f"{system}.zip" in x][0]
+                assert url, "Unable to retrieve PNNX repo assets"
+            except Exception as e:
+                url = f"https://github.com/pnnx/pnnx/releases/download/20240410/pnnx-20240410-{system}.zip"
+                LOGGER.warning(f"{prefix} WARNING  PNNX GitHub assets not found: {e}, using default {url}")
+            asset = attempt_download_asset(url, repo="pnnx/pnnx", release="latest")
             if check_is_path_safe(Path.cwd(), asset):  # avoid path traversal security vulnerability
-                unzip_dir = Path(asset).with_suffix('')
+                unzip_dir = Path(asset).with_suffix("")
                 (unzip_dir / name).rename(pnnx)  # move binary to ROOT
                 shutil.rmtree(unzip_dir)  # delete unzip dir
                 Path(asset).unlink()  # delete zip
                 pnnx.chmod(0o777)  # set read, write, and execute permissions for everyone
 
         ncnn_args = [
             f'ncnnparam={f / "model.ncnn.param"}',
             f'ncnnbin={f / "model.ncnn.bin"}',
-            f'ncnnpy={f / "model_ncnn.py"}', ]
+            f'ncnnpy={f / "model_ncnn.py"}',
+        ]
 
         pnnx_args = [
             f'pnnxparam={f / "model.pnnx.param"}',
             f'pnnxbin={f / "model.pnnx.bin"}',
             f'pnnxpy={f / "model_pnnx.py"}',
-            f'pnnxonnx={f / "model.pnnx.onnx"}', ]
+            f'pnnxonnx={f / "model.pnnx.onnx"}',
+        ]
 
         cmd = [
             str(pnnx),
             str(f_ts),
             *ncnn_args,
             *pnnx_args,
-            f'fp16={int(self.args.half)}',
-            f'device={self.device.type}',
-            f'inputshape="{[self.args.batch, 3, *self.imgsz]}"', ]
+            f"fp16={int(self.args.half)}",
+            f"device={self.device.type}",
+            f'inputshape="{[self.args.batch, 3, *self.imgsz]}"',
+        ]
         f.mkdir(exist_ok=True)  # make ncnn_model directory
         LOGGER.info(f"{prefix} running '{' '.join(cmd)}'")
         subprocess.run(cmd, check=True)
 
         # Remove debug files
-        pnnx_files = [x.split('=')[-1] for x in pnnx_args]
-        for f_debug in ('debug.bin', 'debug.param', 'debug2.bin', 'debug2.param', *pnnx_files):
+        pnnx_files = [x.split("=")[-1] for x in pnnx_args]
+        for f_debug in ("debug.bin", "debug.param", "debug2.bin", "debug2.param", *pnnx_files):
             Path(f_debug).unlink(missing_ok=True)
 
-        yaml_save(f / 'metadata.yaml', self.metadata)  # add metadata.yaml
+        yaml_save(f / "metadata.yaml", self.metadata)  # add metadata.yaml
         return str(f), None
 
     @try_export
-    def export_coreml(self, prefix=colorstr('CoreML:')):
+    def export_coreml(self, prefix=colorstr("CoreML:")):
         """YOLOv8 CoreML export."""
-        mlmodel = self.args.format.lower() == 'mlmodel'  # legacy *.mlmodel export format requested
-        check_requirements('coremltools>=6.0,<=6.2' if mlmodel else 'coremltools>=7.0')
+        mlmodel = self.args.format.lower() == "mlmodel"  # legacy *.mlmodel export format requested
+        check_requirements("coremltools>=6.0,<=6.2" if mlmodel else "coremltools>=7.0")
         import coremltools as ct  # noqa
 
-        LOGGER.info(f'\n{prefix} starting export with coremltools {ct.__version__}...')
-        f = self.file.with_suffix('.mlmodel' if mlmodel else '.mlpackage')
+        LOGGER.info(f"\n{prefix} starting export with coremltools {ct.__version__}...")
+        assert not WINDOWS, "CoreML export is not supported on Windows, please run on macOS or Linux."
+        f = self.file.with_suffix(".mlmodel" if mlmodel else ".mlpackage")
         if f.is_dir():
             shutil.rmtree(f)
 
         bias = [0.0, 0.0, 0.0]
         scale = 1 / 255
         classifier_config = None
-        if self.model.task == 'classify':
+        if self.model.task == "classify":
             classifier_config = ct.ClassifierConfig(list(self.model.names.values())) if self.args.nms else None
             model = self.model
-        elif self.model.task == 'detect':
+        elif self.model.task == "detect":
             model = IOSDetectModel(self.model, self.im) if self.args.nms else self.model
         else:
             if self.args.nms:
                 LOGGER.warning(f"{prefix} WARNING  'nms=True' is only available for Detect models like 'yolov8n.pt'.")
                 # TODO CoreML Segment and Pose model pipelining
             model = self.model
 
         ts = torch.jit.trace(model.eval(), self.im, strict=False)  # TorchScript model
-        ct_model = ct.convert(ts,
-                              inputs=[ct.ImageType('image', shape=self.im.shape, scale=scale, bias=bias)],
-                              classifier_config=classifier_config,
-                              convert_to='neuralnetwork' if mlmodel else 'mlprogram')
-        bits, mode = (8, 'kmeans') if self.args.int8 else (16, 'linear') if self.args.half else (32, None)
+        ct_model = ct.convert(
+            ts,
+            inputs=[ct.ImageType("image", shape=self.im.shape, scale=scale, bias=bias)],
+            classifier_config=classifier_config,
+            convert_to="neuralnetwork" if mlmodel else "mlprogram",
+        )
+        bits, mode = (8, "kmeans") if self.args.int8 else (16, "linear") if self.args.half else (32, None)
         if bits < 32:
-            if 'kmeans' in mode:
-                check_requirements('scikit-learn')  # scikit-learn package required for k-means quantization
+            if "kmeans" in mode:
+                check_requirements("scikit-learn")  # scikit-learn package required for k-means quantization
             if mlmodel:
                 ct_model = ct.models.neural_network.quantization_utils.quantize_weights(ct_model, bits, mode)
             elif bits == 8:  # mlprogram already quantized to FP16
                 import coremltools.optimize.coreml as cto
-                op_config = cto.OpPalettizerConfig(mode='kmeans', nbits=bits, weight_threshold=512)
+
+                op_config = cto.OpPalettizerConfig(mode="kmeans", nbits=bits, weight_threshold=512)
                 config = cto.OptimizationConfig(global_config=op_config)
                 ct_model = cto.palettize_weights(ct_model, config=config)
-        if self.args.nms and self.model.task == 'detect':
+        if self.args.nms and self.model.task == "detect":
             if mlmodel:
-                import platform
-
                 # coremltools<=6.2 NMS export requires Python<3.11
-                check_version(platform.python_version(), '<3.11', name='Python ', hard=True)
+                check_version(PYTHON_VERSION, "<3.11", name="Python ", hard=True)
                 weights_dir = None
             else:
                 ct_model.save(str(f))  # save otherwise weights_dir does not exist
-                weights_dir = str(f / 'Data/com.apple.CoreML/weights')
+                weights_dir = str(f / "Data/com.apple.CoreML/weights")
             ct_model = self._pipeline_coreml(ct_model, weights_dir=weights_dir)
 
         m = self.metadata  # metadata dict
-        ct_model.short_description = m.pop('description')
-        ct_model.author = m.pop('author')
-        ct_model.license = m.pop('license')
-        ct_model.version = m.pop('version')
+        ct_model.short_description = m.pop("description")
+        ct_model.author = m.pop("author")
+        ct_model.license = m.pop("license")
+        ct_model.version = m.pop("version")
         ct_model.user_defined_metadata.update({k: str(v) for k, v in m.items()})
         try:
             ct_model.save(str(f))  # save *.mlpackage
         except Exception as e:
             LOGGER.warning(
-                f'{prefix} WARNING  CoreML export to *.mlpackage failed ({e}), reverting to *.mlmodel export. '
-                f'Known coremltools Python 3.11 and Windows bugs https://github.com/apple/coremltools/issues/1928.')
-            f = f.with_suffix('.mlmodel')
+                f"{prefix} WARNING  CoreML export to *.mlpackage failed ({e}), reverting to *.mlmodel export. "
+                f"Known coremltools Python 3.11 and Windows bugs https://github.com/apple/coremltools/issues/1928."
+            )
+            f = f.with_suffix(".mlmodel")
             ct_model.save(str(f))
         return f, ct_model
 
     @try_export
-    def export_engine(self, prefix=colorstr('TensorRT:')):
+    def export_engine(self, prefix=colorstr("TensorRT:")):
         """YOLOv8 TensorRT export https://developer.nvidia.com/tensorrt."""
-        assert self.im.device.type != 'cpu', "export running on CPU but must be on GPU, i.e. use 'device=0'"
+        assert self.im.device.type != "cpu", "export running on CPU but must be on GPU, i.e. use 'device=0'"
+        self.args.simplify = True
+        f_onnx, _ = self.export_onnx()  # run before trt import https://github.com/ultralytics/ultralytics/issues/7016
+
         try:
             import tensorrt as trt  # noqa
         except ImportError:
             if LINUX:
-                check_requirements('nvidia-tensorrt', cmds='-U --index-url https://pypi.ngc.nvidia.com')
+                check_requirements("nvidia-tensorrt", cmds="-U --index-url https://pypi.ngc.nvidia.com")
             import tensorrt as trt  # noqa
+        check_version(trt.__version__, "7.0.0", hard=True)  # require tensorrt>=7.0.0
 
-        check_version(trt.__version__, '7.0.0', hard=True)  # require tensorrt>=7.0.0
-        self.args.simplify = True
-        f_onnx, _ = self.export_onnx()
-
-        LOGGER.info(f'\n{prefix} starting export with TensorRT {trt.__version__}...')
-        assert Path(f_onnx).exists(), f'failed to export ONNX file: {f_onnx}'
-        f = self.file.with_suffix('.engine')  # TensorRT engine file
+        LOGGER.info(f"\n{prefix} starting export with TensorRT {trt.__version__}...")
+        is_trt10 = int(trt.__version__.split(".")[0]) >= 10  # is TensorRT >= 10
+        assert Path(f_onnx).exists(), f"failed to export ONNX file: {f_onnx}"
+        f = self.file.with_suffix(".engine")  # TensorRT engine file
         logger = trt.Logger(trt.Logger.INFO)
         if self.args.verbose:
             logger.min_severity = trt.Logger.Severity.VERBOSE
 
         builder = trt.Builder(logger)
         config = builder.create_builder_config()
-        config.max_workspace_size = self.args.workspace * 1 << 30
-        # config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, workspace << 30)  # fix TRT 8.4 deprecation notice
-
-        flag = (1 << int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH))
+        workspace = int(self.args.workspace * (1 << 30))
+        if is_trt10:
+            config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, workspace)
+        else:  # TensorRT versions 7, 8
+            config.max_workspace_size = workspace
+        flag = 1 << int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH)
         network = builder.create_network(flag)
         parser = trt.OnnxParser(network, logger)
         if not parser.parse_from_file(f_onnx):
-            raise RuntimeError(f'failed to load ONNX file: {f_onnx}')
+            raise RuntimeError(f"failed to load ONNX file: {f_onnx}")
 
         inputs = [network.get_input(i) for i in range(network.num_inputs)]
         outputs = [network.get_output(i) for i in range(network.num_outputs)]
         for inp in inputs:
             LOGGER.info(f'{prefix} input "{inp.name}" with shape{inp.shape} {inp.dtype}')
         for out in outputs:
             LOGGER.info(f'{prefix} output "{out.name}" with shape{out.shape} {out.dtype}')
 
         if self.args.dynamic:
             shape = self.im.shape
             if shape[0] <= 1:
                 LOGGER.warning(f"{prefix} WARNING  'dynamic=True' model requires max batch size, i.e. 'batch=16'")
             profile = builder.create_optimization_profile()
+            min_shape = (1, shape[1], 32, 32)  # minimum input shape
+            opt_shape = (max(1, shape[0] // 2), *shape[1:])  # optimal input shape
+            max_shape = (*shape[:2], *(max(1, self.args.workspace) * d for d in shape[2:]))  # max input shape
             for inp in inputs:
-                profile.set_shape(inp.name, (1, *shape[1:]), (max(1, shape[0] // 2), *shape[1:]), shape)
+                profile.set_shape(inp.name, min_shape, opt_shape, max_shape)
             config.add_optimization_profile(profile)
 
-        LOGGER.info(
-            f'{prefix} building FP{16 if builder.platform_has_fast_fp16 and self.args.half else 32} engine as {f}')
-        if builder.platform_has_fast_fp16 and self.args.half:
+        half = builder.platform_has_fast_fp16 and self.args.half
+        LOGGER.info(f"{prefix} building FP{16 if half else 32} engine as {f}")
+        if half:
             config.set_flag(trt.BuilderFlag.FP16)
 
+        # Free CUDA memory
         del self.model
         torch.cuda.empty_cache()
 
         # Write file
-        with builder.build_engine(network, config) as engine, open(f, 'wb') as t:
+        build = builder.build_serialized_network if is_trt10 else builder.build_engine
+        with build(network, config) as engine, open(f, "wb") as t:
             # Metadata
             meta = json.dumps(self.metadata)
-            t.write(len(meta).to_bytes(4, byteorder='little', signed=True))
+            t.write(len(meta).to_bytes(4, byteorder="little", signed=True))
             t.write(meta.encode())
             # Model
-            t.write(engine.serialize())
+            t.write(engine if is_trt10 else engine.serialize())
 
         return f, None
 
     @try_export
-    def export_saved_model(self, prefix=colorstr('TensorFlow SavedModel:')):
+    def export_saved_model(self, prefix=colorstr("TensorFlow SavedModel:")):
         """YOLOv8 TensorFlow SavedModel export."""
         cuda = torch.cuda.is_available()
         try:
             import tensorflow as tf  # noqa
         except ImportError:
-            check_requirements(f"tensorflow{'-macos' if MACOS else '-aarch64' if ARM64 else '' if cuda else '-cpu'}")
+            suffix = "-macos" if MACOS else "-aarch64" if ARM64 else "" if cuda else "-cpu"
+            version = "" if ARM64 else "<=2.13.1"
+            check_requirements(f"tensorflow{suffix}{version}")
             import tensorflow as tf  # noqa
+        if ARM64:
+            check_requirements("cmake")  # 'cmake' is needed to build onnxsim on aarch64
         check_requirements(
-            ('onnx', 'onnx2tf>=1.15.4,<=1.17.5', 'sng4onnx>=1.0.1', 'onnxsim>=0.4.33', 'onnx_graphsurgeon>=0.3.26',
-             'tflite_support', 'onnxruntime-gpu' if cuda else 'onnxruntime'),
-            cmds='--extra-index-url https://pypi.ngc.nvidia.com')  # onnx_graphsurgeon only on NVIDIA
-
-        LOGGER.info(f'\n{prefix} starting export with tensorflow {tf.__version__}...')
-        check_version(tf.__version__,
-                      '<=2.13.1',
-                      name='tensorflow',
-                      verbose=True,
-                      msg='https://github.com/ultralytics/ultralytics/issues/5161')
-        f = Path(str(self.file).replace(self.file.suffix, '_saved_model'))
+            (
+                "onnx>=1.12.0",
+                "onnx2tf>=1.15.4,<=1.17.5",
+                "sng4onnx>=1.0.1",
+                "onnxsim>=0.4.33",
+                "onnx_graphsurgeon>=0.3.26",
+                "tflite_support",
+                "flatbuffers>=23.5.26,<100",  # update old 'flatbuffers' included inside tensorflow package
+                "onnxruntime-gpu" if cuda else "onnxruntime",
+            ),
+            cmds="--extra-index-url https://pypi.ngc.nvidia.com",
+        )  # onnx_graphsurgeon only on NVIDIA
+
+        LOGGER.info(f"\n{prefix} starting export with tensorflow {tf.__version__}...")
+        check_version(
+            tf.__version__,
+            "<=2.13.1",
+            name="tensorflow",
+            verbose=True,
+            msg="https://github.com/ultralytics/ultralytics/issues/5161",
+        )
+        import onnx2tf
+
+        f = Path(str(self.file).replace(self.file.suffix, "_saved_model"))
         if f.is_dir():
-            import shutil
             shutil.rmtree(f)  # delete output folder
 
+        # Pre-download calibration file to fix https://github.com/PINTO0309/onnx2tf/issues/545
+        onnx2tf_file = Path("calibration_image_sample_data_20x128x128x3_float32.npy")
+        if not onnx2tf_file.exists():
+            attempt_download_asset(f"{onnx2tf_file}.zip", unzip=True, delete=True)
+
         # Export to ONNX
         self.args.simplify = True
         f_onnx, _ = self.export_onnx()
 
         # Export to TF
-        tmp_file = f / 'tmp_tflite_int8_calibration_images.npy'  # int8 calibration images file
+        tmp_file = f / "tmp_tflite_int8_calibration_images.npy"  # int8 calibration images file
+        np_data = None
         if self.args.int8:
-            verbosity = '--verbosity info'
+            verbosity = "info"
             if self.args.data:
                 # Generate calibration data for integer quantization
                 LOGGER.info(f"{prefix} collecting INT8 calibration images from 'data={self.args.data}'")
                 data = check_det_dataset(self.args.data)
-                dataset = YOLODataset(data['val'], data=data, imgsz=self.imgsz[0], augment=False)
+                dataset = YOLODataset(data["val"], data=data, imgsz=self.imgsz[0], augment=False)
                 images = []
                 for i, batch in enumerate(dataset):
                     if i >= 100:  # maximum number of calibration images
                         break
-                    im = batch['img'].permute(1, 2, 0)[None]  # list to nparray, CHW to BHWC
+                    im = batch["img"].permute(1, 2, 0)[None]  # list to nparray, CHW to BHWC
                     images.append(im)
                 f.mkdir()
                 images = torch.cat(images, 0).float()
                 # mean = images.view(-1, 3).mean(0)  # imagenet mean [123.675, 116.28, 103.53]
                 # std = images.view(-1, 3).std(0)  # imagenet std [58.395, 57.12, 57.375]
                 np.save(str(tmp_file), images.numpy())  # BHWC
-                int8 = f'-oiqt -qt per-tensor -cind images "{tmp_file}" "[[[[0, 0, 0]]]]" "[[[[255, 255, 255]]]]"'
-            else:
-                int8 = '-oiqt -qt per-tensor'
+                np_data = [["images", tmp_file, [[[[0, 0, 0]]]], [[[[255, 255, 255]]]]]]
         else:
-            verbosity = '--non_verbose'
-            int8 = ''
+            verbosity = "error"
 
-        cmd = f'onnx2tf -i "{f_onnx}" -o "{f}" -nuo {verbosity} {int8}'.strip()
-        LOGGER.info(f"{prefix} running '{cmd}'")
-        subprocess.run(cmd, shell=True)
-        yaml_save(f / 'metadata.yaml', self.metadata)  # add metadata.yaml
+        LOGGER.info(f"{prefix} starting TFLite export with onnx2tf {onnx2tf.__version__}...")
+        onnx2tf.convert(
+            input_onnx_file_path=f_onnx,
+            output_folder_path=str(f),
+            not_use_onnxsim=True,
+            verbosity=verbosity,
+            output_integer_quantized_tflite=self.args.int8,
+            quant_type="per-tensor",  # "per-tensor" (faster) or "per-channel" (slower but more accurate)
+            custom_input_op_name_np_data_path=np_data,
+        )
+        yaml_save(f / "metadata.yaml", self.metadata)  # add metadata.yaml
 
         # Remove/rename TFLite models
         if self.args.int8:
             tmp_file.unlink(missing_ok=True)
-            for file in f.rglob('*_dynamic_range_quant.tflite'):
-                file.rename(file.with_name(file.stem.replace('_dynamic_range_quant', '_int8') + file.suffix))
-            for file in f.rglob('*_integer_quant_with_int16_act.tflite'):
+            for file in f.rglob("*_dynamic_range_quant.tflite"):
+                file.rename(file.with_name(file.stem.replace("_dynamic_range_quant", "_int8") + file.suffix))
+            for file in f.rglob("*_integer_quant_with_int16_act.tflite"):
                 file.unlink()  # delete extra fp16 activation TFLite files
 
         # Add TFLite metadata
-        for file in f.rglob('*.tflite'):
-            f.unlink() if 'quant_with_int16_act.tflite' in str(f) else self._add_tflite_metadata(file)
+        for file in f.rglob("*.tflite"):
+            f.unlink() if "quant_with_int16_act.tflite" in str(f) else self._add_tflite_metadata(file)
 
         return str(f), tf.saved_model.load(f, tags=None, options=None)  # load saved_model as Keras model
 
     @try_export
-    def export_pb(self, keras_model, prefix=colorstr('TensorFlow GraphDef:')):
+    def export_pb(self, keras_model, prefix=colorstr("TensorFlow GraphDef:")):
         """YOLOv8 TensorFlow GraphDef *.pb export https://github.com/leimao/Frozen_Graph_TensorFlow."""
         import tensorflow as tf  # noqa
         from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2  # noqa
 
-        LOGGER.info(f'\n{prefix} starting export with tensorflow {tf.__version__}...')
-        f = self.file.with_suffix('.pb')
+        LOGGER.info(f"\n{prefix} starting export with tensorflow {tf.__version__}...")
+        f = self.file.with_suffix(".pb")
 
         m = tf.function(lambda x: keras_model(x))  # full model
         m = m.get_concrete_function(tf.TensorSpec(keras_model.inputs[0].shape, keras_model.inputs[0].dtype))
         frozen_func = convert_variables_to_constants_v2(m)
         frozen_func.graph.as_graph_def()
         tf.io.write_graph(graph_or_graph_def=frozen_func.graph, logdir=str(f.parent), name=f.name, as_text=False)
         return f, None
 
     @try_export
-    def export_tflite(self, keras_model, nms, agnostic_nms, prefix=colorstr('TensorFlow Lite:')):
+    def export_tflite(self, keras_model, nms, agnostic_nms, prefix=colorstr("TensorFlow Lite:")):
         """YOLOv8 TensorFlow Lite export."""
         import tensorflow as tf  # noqa
 
-        LOGGER.info(f'\n{prefix} starting export with tensorflow {tf.__version__}...')
-        saved_model = Path(str(self.file).replace(self.file.suffix, '_saved_model'))
+        LOGGER.info(f"\n{prefix} starting export with tensorflow {tf.__version__}...")
+        saved_model = Path(str(self.file).replace(self.file.suffix, "_saved_model"))
         if self.args.int8:
-            f = saved_model / f'{self.file.stem}_int8.tflite'  # fp32 in/out
+            f = saved_model / f"{self.file.stem}_int8.tflite"  # fp32 in/out
         elif self.args.half:
-            f = saved_model / f'{self.file.stem}_float16.tflite'  # fp32 in/out
+            f = saved_model / f"{self.file.stem}_float16.tflite"  # fp32 in/out
         else:
-            f = saved_model / f'{self.file.stem}_float32.tflite'
+            f = saved_model / f"{self.file.stem}_float32.tflite"
         return str(f), None
 
     @try_export
-    def export_edgetpu(self, tflite_model='', prefix=colorstr('Edge TPU:')):
+    def export_edgetpu(self, tflite_model="", prefix=colorstr("Edge TPU:")):
         """YOLOv8 Edge TPU export https://coral.ai/docs/edgetpu/models-intro/."""
-        LOGGER.warning(f'{prefix} WARNING  Edge TPU known bug https://github.com/ultralytics/ultralytics/issues/1185')
+        LOGGER.warning(f"{prefix} WARNING  Edge TPU known bug https://github.com/ultralytics/ultralytics/issues/1185")
 
-        cmd = 'edgetpu_compiler --version'
-        help_url = 'https://coral.ai/docs/edgetpu/compiler/'
-        assert LINUX, f'export only supported on Linux. See {help_url}'
+        cmd = "edgetpu_compiler --version"
+        help_url = "https://coral.ai/docs/edgetpu/compiler/"
+        assert LINUX, f"export only supported on Linux. See {help_url}"
         if subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True).returncode != 0:
-            LOGGER.info(f'\n{prefix} export requires Edge TPU compiler. Attempting install from {help_url}')
-            sudo = subprocess.run('sudo --version >/dev/null', shell=True).returncode == 0  # sudo installed on system
-            for c in ('curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -',
-                      'echo "deb https://packages.cloud.google.com/apt coral-edgetpu-stable main" | '
-                      'sudo tee /etc/apt/sources.list.d/coral-edgetpu.list', 'sudo apt-get update',
-                      'sudo apt-get install edgetpu-compiler'):
-                subprocess.run(c if sudo else c.replace('sudo ', ''), shell=True, check=True)
+            LOGGER.info(f"\n{prefix} export requires Edge TPU compiler. Attempting install from {help_url}")
+            sudo = subprocess.run("sudo --version >/dev/null", shell=True).returncode == 0  # sudo installed on system
+            for c in (
+                "curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -",
+                'echo "deb https://packages.cloud.google.com/apt coral-edgetpu-stable main" | '
+                "sudo tee /etc/apt/sources.list.d/coral-edgetpu.list",
+                "sudo apt-get update",
+                "sudo apt-get install edgetpu-compiler",
+            ):
+                subprocess.run(c if sudo else c.replace("sudo ", ""), shell=True, check=True)
         ver = subprocess.run(cmd, shell=True, capture_output=True, check=True).stdout.decode().split()[-1]
 
-        LOGGER.info(f'\n{prefix} starting export with Edge TPU compiler {ver}...')
-        f = str(tflite_model).replace('.tflite', '_edgetpu.tflite')  # Edge TPU model
+        LOGGER.info(f"\n{prefix} starting export with Edge TPU compiler {ver}...")
+        f = str(tflite_model).replace(".tflite", "_edgetpu.tflite")  # Edge TPU model
 
         cmd = f'edgetpu_compiler -s -d -k 10 --out_dir "{Path(f).parent}" "{tflite_model}"'
         LOGGER.info(f"{prefix} running '{cmd}'")
         subprocess.run(cmd, shell=True)
         self._add_tflite_metadata(f)
         return f, None
 
     @try_export
-    def export_tfjs(self, prefix=colorstr('TensorFlow.js:')):
+    def export_tfjs(self, prefix=colorstr("TensorFlow.js:")):
         """YOLOv8 TensorFlow.js export."""
-        check_requirements('tensorflowjs')
+        check_requirements("tensorflowjs")
+        if ARM64:
+            # Fix error: `np.object` was a deprecated alias for the builtin `object` when exporting to TF.js on ARM64
+            check_requirements("numpy==1.23.5")
         import tensorflow as tf
         import tensorflowjs as tfjs  # noqa
 
-        LOGGER.info(f'\n{prefix} starting export with tensorflowjs {tfjs.__version__}...')
-        f = str(self.file).replace(self.file.suffix, '_web_model')  # js dir
-        f_pb = str(self.file.with_suffix('.pb'))  # *.pb path
+        LOGGER.info(f"\n{prefix} starting export with tensorflowjs {tfjs.__version__}...")
+        f = str(self.file).replace(self.file.suffix, "_web_model")  # js dir
+        f_pb = str(self.file.with_suffix(".pb"))  # *.pb path
 
         gd = tf.Graph().as_graph_def()  # TF GraphDef
-        with open(f_pb, 'rb') as file:
+        with open(f_pb, "rb") as file:
             gd.ParseFromString(file.read())
-        outputs = ','.join(gd_outputs(gd))
-        LOGGER.info(f'\n{prefix} output node names: {outputs}')
+        outputs = ",".join(gd_outputs(gd))
+        LOGGER.info(f"\n{prefix} output node names: {outputs}")
 
+        quantization = "--quantize_float16" if self.args.half else "--quantize_uint8" if self.args.int8 else ""
         with spaces_in_path(f_pb) as fpb_, spaces_in_path(f) as f_:  # exporter can not handle spaces in path
-            cmd = f'tensorflowjs_converter --input_format=tf_frozen_model --output_node_names={outputs} "{fpb_}" "{f_}"'
+            cmd = (
+                "tensorflowjs_converter "
+                f'--input_format=tf_frozen_model {quantization} --output_node_names={outputs} "{fpb_}" "{f_}"'
+            )
             LOGGER.info(f"{prefix} running '{cmd}'")
             subprocess.run(cmd, shell=True)
 
-        if ' ' in f:
+        if " " in f:
             LOGGER.warning(f"{prefix} WARNING  your model may not work correctly with spaces in path '{f}'.")
 
         # f_json = Path(f) / 'model.json'  # *.json path
         # with open(f_json, 'w') as j:  # sort JSON Identity_* in ascending order
         #     subst = re.sub(
         #         r'{"outputs": {"Identity.?.?": {"name": "Identity.?.?"}, '
         #         r'"Identity.?.?": {"name": "Identity.?.?"}, '
@@ -806,101 +931,102 @@
         #         r'{"outputs": {"Identity": {"name": "Identity"}, '
         #         r'"Identity_1": {"name": "Identity_1"}, '
         #         r'"Identity_2": {"name": "Identity_2"}, '
         #         r'"Identity_3": {"name": "Identity_3"}}}',
         #         f_json.read_text(),
         #     )
         #     j.write(subst)
-        yaml_save(Path(f) / 'metadata.yaml', self.metadata)  # add metadata.yaml
+        yaml_save(Path(f) / "metadata.yaml", self.metadata)  # add metadata.yaml
         return f, None
 
     def _add_tflite_metadata(self, file):
         """Add metadata to *.tflite models per https://www.tensorflow.org/lite/models/convert/metadata."""
         from tflite_support import flatbuffers  # noqa
         from tflite_support import metadata as _metadata  # noqa
         from tflite_support import metadata_schema_py_generated as _metadata_fb  # noqa
 
         # Create model info
         model_meta = _metadata_fb.ModelMetadataT()
-        model_meta.name = self.metadata['description']
-        model_meta.version = self.metadata['version']
-        model_meta.author = self.metadata['author']
-        model_meta.license = self.metadata['license']
+        model_meta.name = self.metadata["description"]
+        model_meta.version = self.metadata["version"]
+        model_meta.author = self.metadata["author"]
+        model_meta.license = self.metadata["license"]
 
         # Label file
-        tmp_file = Path(file).parent / 'temp_meta.txt'
-        with open(tmp_file, 'w') as f:
+        tmp_file = Path(file).parent / "temp_meta.txt"
+        with open(tmp_file, "w") as f:
             f.write(str(self.metadata))
 
         label_file = _metadata_fb.AssociatedFileT()
         label_file.name = tmp_file.name
         label_file.type = _metadata_fb.AssociatedFileType.TENSOR_AXIS_LABELS
 
         # Create input info
         input_meta = _metadata_fb.TensorMetadataT()
-        input_meta.name = 'image'
-        input_meta.description = 'Input image to be detected.'
+        input_meta.name = "image"
+        input_meta.description = "Input image to be detected."
         input_meta.content = _metadata_fb.ContentT()
         input_meta.content.contentProperties = _metadata_fb.ImagePropertiesT()
         input_meta.content.contentProperties.colorSpace = _metadata_fb.ColorSpaceType.RGB
         input_meta.content.contentPropertiesType = _metadata_fb.ContentProperties.ImageProperties
 
         # Create output info
         output1 = _metadata_fb.TensorMetadataT()
-        output1.name = 'output'
-        output1.description = 'Coordinates of detected objects, class labels, and confidence score'
+        output1.name = "output"
+        output1.description = "Coordinates of detected objects, class labels, and confidence score"
         output1.associatedFiles = [label_file]
-        if self.model.task == 'segment':
+        if self.model.task == "segment":
             output2 = _metadata_fb.TensorMetadataT()
-            output2.name = 'output'
-            output2.description = 'Mask protos'
+            output2.name = "output"
+            output2.description = "Mask protos"
             output2.associatedFiles = [label_file]
 
         # Create subgraph info
         subgraph = _metadata_fb.SubGraphMetadataT()
         subgraph.inputTensorMetadata = [input_meta]
-        subgraph.outputTensorMetadata = [output1, output2] if self.model.task == 'segment' else [output1]
+        subgraph.outputTensorMetadata = [output1, output2] if self.model.task == "segment" else [output1]
         model_meta.subgraphMetadata = [subgraph]
 
         b = flatbuffers.Builder(0)
         b.Finish(model_meta.Pack(b), _metadata.MetadataPopulator.METADATA_FILE_IDENTIFIER)
         metadata_buf = b.Output()
 
         populator = _metadata.MetadataPopulator.with_model_file(str(file))
         populator.load_metadata_buffer(metadata_buf)
         populator.load_associated_files([str(tmp_file)])
         populator.populate()
         tmp_file.unlink()
 
-    def _pipeline_coreml(self, model, weights_dir=None, prefix=colorstr('CoreML Pipeline:')):
+    def _pipeline_coreml(self, model, weights_dir=None, prefix=colorstr("CoreML Pipeline:")):
         """YOLOv8 CoreML pipeline."""
         import coremltools as ct  # noqa
 
-        LOGGER.info(f'{prefix} starting pipeline with coremltools {ct.__version__}...')
+        LOGGER.info(f"{prefix} starting pipeline with coremltools {ct.__version__}...")
         _, _, h, w = list(self.im.shape)  # BCHW
 
         # Output shapes
         spec = model.get_spec()
         out0, out1 = iter(spec.description.output)
         if MACOS:
             from PIL import Image
-            img = Image.new('RGB', (w, h))  # w=192, h=320
-            out = model.predict({'image': img})
+
+            img = Image.new("RGB", (w, h))  # w=192, h=320
+            out = model.predict({"image": img})
             out0_shape = out[out0.name].shape  # (3780, 80)
             out1_shape = out[out1.name].shape  # (3780, 4)
         else:  # linux and windows can not run model.predict(), get sizes from PyTorch model output y
             out0_shape = self.output_shape[2], self.output_shape[1] - 4  # (3780, 80)
             out1_shape = self.output_shape[2], 4  # (3780, 4)
 
         # Checks
-        names = self.metadata['names']
+        names = self.metadata["names"]
         nx, ny = spec.description.input[0].type.imageType.width, spec.description.input[0].type.imageType.height
         _, nc = out0_shape  # number of anchors, number of classes
         # _, nc = out0.type.multiArrayType.shape
-        assert len(names) == nc, f'{len(names)} names found for nc={nc}'  # check
+        assert len(names) == nc, f"{len(names)} names found for nc={nc}"  # check
 
         # Define output shapes (missing)
         out0.type.multiArrayType.shape[:] = out0_shape  # (3780, 80)
         out1.type.multiArrayType.shape[:] = out1_shape  # (3780, 4)
         # spec.neuralNetwork.preprocessing[0].featureName = '0'
 
         # Flexible input shapes
@@ -926,16 +1052,16 @@
         for i in range(2):
             decoder_output = model._spec.description.output[i].SerializeToString()
             nms_spec.description.input.add()
             nms_spec.description.input[i].ParseFromString(decoder_output)
             nms_spec.description.output.add()
             nms_spec.description.output[i].ParseFromString(decoder_output)
 
-        nms_spec.description.output[0].name = 'confidence'
-        nms_spec.description.output[1].name = 'coordinates'
+        nms_spec.description.output[0].name = "confidence"
+        nms_spec.description.output[1].name = "coordinates"
 
         output_sizes = [nc, 4]
         for i in range(2):
             ma_type = nms_spec.description.output[i].type.multiArrayType
             ma_type.shapeRange.sizeRanges.add()
             ma_type.shapeRange.sizeRanges[0].lowerBound = 0
             ma_type.shapeRange.sizeRanges[0].upperBound = -1
@@ -943,52 +1069,57 @@
             ma_type.shapeRange.sizeRanges[1].lowerBound = output_sizes[i]
             ma_type.shapeRange.sizeRanges[1].upperBound = output_sizes[i]
             del ma_type.shape[:]
 
         nms = nms_spec.nonMaximumSuppression
         nms.confidenceInputFeatureName = out0.name  # 1x507x80
         nms.coordinatesInputFeatureName = out1.name  # 1x507x4
-        nms.confidenceOutputFeatureName = 'confidence'
-        nms.coordinatesOutputFeatureName = 'coordinates'
-        nms.iouThresholdInputFeatureName = 'iouThreshold'
-        nms.confidenceThresholdInputFeatureName = 'confidenceThreshold'
+        nms.confidenceOutputFeatureName = "confidence"
+        nms.coordinatesOutputFeatureName = "coordinates"
+        nms.iouThresholdInputFeatureName = "iouThreshold"
+        nms.confidenceThresholdInputFeatureName = "confidenceThreshold"
         nms.iouThreshold = 0.45
         nms.confidenceThreshold = 0.25
         nms.pickTop.perClass = True
         nms.stringClassLabels.vector.extend(names.values())
         nms_model = ct.models.MLModel(nms_spec)
 
         # 4. Pipeline models together
-        pipeline = ct.models.pipeline.Pipeline(input_features=[('image', ct.models.datatypes.Array(3, ny, nx)),
-                                                               ('iouThreshold', ct.models.datatypes.Double()),
-                                                               ('confidenceThreshold', ct.models.datatypes.Double())],
-                                               output_features=['confidence', 'coordinates'])
+        pipeline = ct.models.pipeline.Pipeline(
+            input_features=[
+                ("image", ct.models.datatypes.Array(3, ny, nx)),
+                ("iouThreshold", ct.models.datatypes.Double()),
+                ("confidenceThreshold", ct.models.datatypes.Double()),
+            ],
+            output_features=["confidence", "coordinates"],
+        )
         pipeline.add_model(model)
         pipeline.add_model(nms_model)
 
         # Correct datatypes
         pipeline.spec.description.input[0].ParseFromString(model._spec.description.input[0].SerializeToString())
         pipeline.spec.description.output[0].ParseFromString(nms_model._spec.description.output[0].SerializeToString())
         pipeline.spec.description.output[1].ParseFromString(nms_model._spec.description.output[1].SerializeToString())
 
         # Update metadata
         pipeline.spec.specificationVersion = 5
-        pipeline.spec.description.metadata.userDefined.update({
-            'IoU threshold': str(nms.iouThreshold),
-            'Confidence threshold': str(nms.confidenceThreshold)})
+        pipeline.spec.description.metadata.userDefined.update(
+            {"IoU threshold": str(nms.iouThreshold), "Confidence threshold": str(nms.confidenceThreshold)}
+        )
 
         # Save the model
         model = ct.models.MLModel(pipeline.spec, weights_dir=weights_dir)
-        model.input_description['image'] = 'Input image'
-        model.input_description['iouThreshold'] = f'(optional) IOU threshold override (default: {nms.iouThreshold})'
-        model.input_description['confidenceThreshold'] = \
-            f'(optional) Confidence threshold override (default: {nms.confidenceThreshold})'
-        model.output_description['confidence'] = 'Boxes  Class confidence (see user-defined metadata "classes")'
-        model.output_description['coordinates'] = 'Boxes  [x, y, width, height] (relative to image size)'
-        LOGGER.info(f'{prefix} pipeline success')
+        model.input_description["image"] = "Input image"
+        model.input_description["iouThreshold"] = f"(optional) IoU threshold override (default: {nms.iouThreshold})"
+        model.input_description["confidenceThreshold"] = (
+            f"(optional) Confidence threshold override (default: {nms.confidenceThreshold})"
+        )
+        model.output_description["confidence"] = 'Boxes  Class confidence (see user-defined metadata "classes")'
+        model.output_description["coordinates"] = "Boxes  [x, y, width, height] (relative to image size)"
+        LOGGER.info(f"{prefix} pipeline success")
         return model
 
     def add_callback(self, event: str, callback):
         """Appends the given callback."""
         self.callbacks[event].append(callback)
 
     def run_callbacks(self, event: str):
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/engine/model.py` & `yolov8_pose_triton-8.2.0/ultralytics/engine/predictor.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,430 +1,397 @@
 # Ultralytics YOLO , AGPL-3.0 license
+"""
+Run prediction on images, videos, directories, globs, YouTube, webcam, streams, etc.
 
-import inspect
-import sys
+Usage - sources:
+    $ yolo mode=predict model=yolov8n.pt source=0                               # webcam
+                                                img.jpg                         # image
+                                                vid.mp4                         # video
+                                                screen                          # screenshot
+                                                path/                           # directory
+                                                list.txt                        # list of images
+                                                list.streams                    # list of streams
+                                                'path/*.jpg'                    # glob
+                                                'https://youtu.be/LNwODJXcvt4'  # YouTube
+                                                'rtsp://example.com/media.mp4'  # RTSP, RTMP, HTTP, TCP stream
+
+Usage - formats:
+    $ yolo mode=predict model=yolov8n.pt                 # PyTorch
+                              yolov8n.torchscript        # TorchScript
+                              yolov8n.onnx               # ONNX Runtime or OpenCV DNN with dnn=True
+                              yolov8n_openvino_model     # OpenVINO
+                              yolov8n.engine             # TensorRT
+                              yolov8n.mlpackage          # CoreML (macOS-only)
+                              yolov8n_saved_model        # TensorFlow SavedModel
+                              yolov8n.pb                 # TensorFlow GraphDef
+                              yolov8n.tflite             # TensorFlow Lite
+                              yolov8n_edgetpu.tflite     # TensorFlow Edge TPU
+                              yolov8n_paddle_model       # PaddlePaddle
+                              yolov8n_ncnn_model         # NCNN
+"""
+
+import platform
+import re
+import threading
 from pathlib import Path
-from typing import Union
 
-from ultralytics.cfg import TASK2DATA, get_cfg, get_save_dir
-from ultralytics.hub.utils import HUB_WEB_ROOT
-from ultralytics.nn.tasks import attempt_load_one_weight, guess_model_task, nn, yaml_model_load
-from ultralytics.utils import ASSETS, DEFAULT_CFG_DICT, LOGGER, RANK, callbacks, checks, emojis, yaml_load
+import cv2
+import numpy as np
+import torch
+
+from ultralytics.cfg import get_cfg, get_save_dir
+from ultralytics.data import load_inference_source
+from ultralytics.data.augment import LetterBox, classify_transforms
+from ultralytics.nn.autobackend import AutoBackend
+from ultralytics.utils import DEFAULT_CFG, LOGGER, MACOS, WINDOWS, callbacks, colorstr, ops
+from ultralytics.utils.checks import check_imgsz, check_imshow
+from ultralytics.utils.files import increment_path
+from ultralytics.utils.torch_utils import select_device, smart_inference_mode
+
+STREAM_WARNING = """
+WARNING  inference results will accumulate in RAM unless `stream=True` is passed, causing potential out-of-memory
+errors for large sources or long-running streams and videos. See https://docs.ultralytics.com/modes/predict/ for help.
+
+Example:
+    results = model(source=..., stream=True)  # generator of Results objects
+    for r in results:
+        boxes = r.boxes  # Boxes object for bbox outputs
+        masks = r.masks  # Masks object for segment masks outputs
+        probs = r.probs  # Class probabilities for classification outputs
+"""
 
 
-class Model(nn.Module):
+class BasePredictor:
     """
-    A base class to unify APIs for all models.
+    BasePredictor.
 
-    Args:
-        model (str, Path): Path to the model file to load or create.
-        task (Any, optional): Task type for the YOLO model. Defaults to None.
+    A base class for creating predictors.
 
     Attributes:
-        predictor (Any): The predictor object.
-        model (Any): The model object.
-        trainer (Any): The trainer object.
-        task (str): The type of model task.
-        ckpt (Any): The checkpoint object if the model loaded from *.pt file.
-        cfg (str): The model configuration if loaded from *.yaml file.
-        ckpt_path (str): The checkpoint file path.
-        overrides (dict): Overrides for the trainer object.
-        metrics (Any): The data for metrics.
-
-    Methods:
-        __call__(source=None, stream=False, **kwargs):
-            Alias for the predict method.
-        _new(cfg:str, verbose:bool=True) -> None:
-            Initializes a new model and infers the task type from the model definitions.
-        _load(weights:str, task:str='') -> None:
-            Initializes a new model and infers the task type from the model head.
-        _check_is_pytorch_model() -> None:
-            Raises TypeError if the model is not a PyTorch model.
-        reset() -> None:
-            Resets the model modules.
-        info(verbose:bool=False) -> None:
-            Logs the model info.
-        fuse() -> None:
-            Fuses the model for faster inference.
-        predict(source=None, stream=False, **kwargs) -> List[ultralytics.engine.results.Results]:
-            Performs prediction using the YOLO model.
-
-    Returns:
-        list(ultralytics.engine.results.Results): The prediction results.
+        args (SimpleNamespace): Configuration for the predictor.
+        save_dir (Path): Directory to save results.
+        done_warmup (bool): Whether the predictor has finished setup.
+        model (nn.Module): Model used for prediction.
+        data (dict): Data configuration.
+        device (torch.device): Device used for prediction.
+        dataset (Dataset): Dataset used for prediction.
+        vid_writer (dict): Dictionary of {save_path: video_writer, ...} writer for saving video output.
     """
 
-    def __init__(self, model: Union[str, Path] = 'yolov8n.pt', task=None) -> None:
-        """
-        Initializes the YOLO model.
-
-        Args:
-            model (Union[str, Path], optional): Path or name of the model to load or create. Defaults to 'yolov8n.pt'.
-            task (Any, optional): Task type for the YOLO model. Defaults to None.
-        """
-        super().__init__()
-        self.callbacks = callbacks.get_default_callbacks()
-        self.predictor = None  # reuse predictor
-        self.model = None  # model object
-        self.trainer = None  # trainer object
-        self.ckpt = None  # if loaded from *.pt
-        self.cfg = None  # if loaded from *.yaml
-        self.ckpt_path = None
-        self.overrides = {}  # overrides for trainer object
-        self.metrics = None  # validation/training metrics
-        self.session = None  # HUB session
-        self.task = task  # task type
-        model = str(model).strip()  # strip spaces
-
-        # Check if Ultralytics HUB model from https://hub.ultralytics.com
-        if self.is_hub_model(model):
-            from ultralytics.hub.session import HUBTrainingSession
-            self.session = HUBTrainingSession(model)
-            model = self.session.model_file
-
-        # Check if Triton Server model
-        elif self.is_triton_model(model):
-            self.model = model
-            self.task = task
-            return
-
-        # Load or create new YOLO model
-        model = checks.check_model_file_from_stem(model)  # add suffix, i.e. yolov8n -> yolov8n.pt
-        if Path(model).suffix in ('.yaml', '.yml'):
-            self._new(model, task)
-        else:
-            self._load(model, task)
-
-    def __call__(self, source=None, stream=False, **kwargs):
-        """Calls the 'predict' function with given arguments to perform object detection."""
-        return self.predict(source, stream, **kwargs)
-
-    @staticmethod
-    def is_triton_model(model):
-        """Is model a Triton Server URL string, i.e. <scheme>://<netloc>/<endpoint>/<task_name>"""
-        from urllib.parse import urlsplit
-        url = urlsplit(model)
-        return url.netloc and url.path and url.scheme in {'http', 'grpc'}
-
-    @staticmethod
-    def is_hub_model(model):
-        """Check if the provided model is a HUB model."""
-        return any((
-            model.startswith(f'{HUB_WEB_ROOT}/models/'),  # i.e. https://hub.ultralytics.com/models/MODEL_ID
-            [len(x) for x in model.split('_')] == [42, 20],  # APIKEY_MODELID
-            len(model) == 20 and not Path(model).exists() and all(x not in model for x in './\\')))  # MODELID
-
-    def _new(self, cfg: str, task=None, model=None, verbose=True):
-        """
-        Initializes a new model and infers the task type from the model definitions.
-
-        Args:
-            cfg (str): model configuration file
-            task (str | None): model task
-            model (BaseModel): Customized model.
-            verbose (bool): display model info on load
-        """
-        cfg_dict = yaml_model_load(cfg)
-        self.cfg = cfg
-        self.task = task or guess_model_task(cfg_dict)
-        self.model = (model or self._smart_load('model'))(cfg_dict, verbose=verbose and RANK == -1)  # build model
-        self.overrides['model'] = self.cfg
-        self.overrides['task'] = self.task
-
-        # Below added to allow export from YAMLs
-        self.model.args = {**DEFAULT_CFG_DICT, **self.overrides}  # combine default and model args (prefer model args)
-        self.model.task = self.task
-
-    def _load(self, weights: str, task=None):
+    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):
         """
-        Initializes a new model and infers the task type from the model head.
+        Initializes the BasePredictor class.
 
         Args:
-            weights (str): model checkpoint to be loaded
-            task (str | None): model task
+            cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.
+            overrides (dict, optional): Configuration overrides. Defaults to None.
         """
-        suffix = Path(weights).suffix
-        if suffix == '.pt':
-            self.model, self.ckpt = attempt_load_one_weight(weights)
-            self.task = self.model.args['task']
-            self.overrides = self.model.args = self._reset_ckpt_args(self.model.args)
-            self.ckpt_path = self.model.pt_path
-        else:
-            weights = checks.check_file(weights)
-            self.model, self.ckpt = weights, None
-            self.task = task or guess_model_task(weights)
-            self.ckpt_path = weights
-        self.overrides['model'] = weights
-        self.overrides['task'] = self.task
-
-    def _check_is_pytorch_model(self):
-        """Raises TypeError is model is not a PyTorch model."""
-        pt_str = isinstance(self.model, (str, Path)) and Path(self.model).suffix == '.pt'
-        pt_module = isinstance(self.model, nn.Module)
-        if not (pt_module or pt_str):
-            raise TypeError(
-                f"model='{self.model}' should be a *.pt PyTorch model to run this method, but is a different format. "
-                f"PyTorch models can train, val, predict and export, i.e. 'model.train(data=...)', but exported "
-                f"formats like ONNX, TensorRT etc. only support 'predict' and 'val' modes, "
-                f"i.e. 'yolo predict model=yolov8n.onnx'.\nTo run CUDA or MPS inference please pass the device "
-                f"argument directly in your inference command, i.e. 'model.predict(source=..., device=0)'")
-
-    def reset_weights(self):
-        """Resets the model modules parameters to randomly initialized values, losing all training information."""
-        self._check_is_pytorch_model()
-        for m in self.model.modules():
-            if hasattr(m, 'reset_parameters'):
-                m.reset_parameters()
-        for p in self.model.parameters():
-            p.requires_grad = True
-        return self
-
-    def load(self, weights='yolov8n.pt'):
-        """Transfers parameters with matching names and shapes from 'weights' to model."""
-        self._check_is_pytorch_model()
-        if isinstance(weights, (str, Path)):
-            weights, self.ckpt = attempt_load_one_weight(weights)
-        self.model.load(weights)
-        return self
+        self.args = get_cfg(cfg, overrides)
+        self.save_dir = get_save_dir(self.args)
+        if self.args.conf is None:
+            self.args.conf = 0.25  # default conf=0.25
+        self.done_warmup = False
+        if self.args.show:
+            self.args.show = check_imshow(warn=True)
+
+        # Usable if setup is done
+        self.model = None
+        self.data = self.args.data  # data_dict
+        self.imgsz = None
+        self.device = None
+        self.dataset = None
+        self.vid_writer = {}  # dict of {save_path: video_writer, ...}
+        self.plotted_img = None
+        self.source_type = None
+        self.seen = 0
+        self.windows = []
+        self.batch = None
+        self.results = None
+        self.transforms = None
+        self.callbacks = _callbacks or callbacks.get_default_callbacks()
+        self.txt_path = None
+        self._lock = threading.Lock()  # for automatic thread-safe inference
+        callbacks.add_integration_callbacks(self)
 
-    def info(self, detailed=False, verbose=True):
+    def preprocess(self, im):
         """
-        Logs model info.
+        Prepares input image before inference.
 
         Args:
-            detailed (bool): Show detailed information about model.
-            verbose (bool): Controls verbosity.
+            im (torch.Tensor | List(np.ndarray)): BCHW for tensor, [(HWC) x B] for list.
         """
-        self._check_is_pytorch_model()
-        return self.model.info(detailed=detailed, verbose=verbose)
-
-    def fuse(self):
-        """Fuse PyTorch Conv2d and BatchNorm2d layers."""
-        self._check_is_pytorch_model()
-        self.model.fuse()
+        not_tensor = not isinstance(im, torch.Tensor)
+        if not_tensor:
+            im = np.stack(self.pre_transform(im))
+            im = im[..., ::-1].transpose((0, 3, 1, 2))  # BGR to RGB, BHWC to BCHW, (n, 3, h, w)
+            im = np.ascontiguousarray(im)  # contiguous
+            im = torch.from_numpy(im)
+
+        im = im.to(self.device)
+        im = im.half() if self.model.fp16 else im.float()  # uint8 to fp16/32
+        if not_tensor:
+            im /= 255  # 0 - 255 to 0.0 - 1.0
+        return im
+
+    def inference(self, im, *args, **kwargs):
+        """Runs inference on a given image using the specified model and arguments."""
+        visualize = (
+            increment_path(self.save_dir / Path(self.batch[0][0]).stem, mkdir=True)
+            if self.args.visualize and (not self.source_type.tensor)
+            else False
+        )
+        return self.model(im, augment=self.args.augment, visualize=visualize, embed=self.args.embed, *args, **kwargs)
 
-    def predict(self, source=None, stream=False, predictor=None, **kwargs):
+    def pre_transform(self, im):
         """
-        Perform prediction using the YOLO model.
+        Pre-transform input image before inference.
 
         Args:
-            source (str | int | PIL | np.ndarray): The source of the image to make predictions on.
-                Accepts all source types accepted by the YOLO model.
-            stream (bool): Whether to stream the predictions or not. Defaults to False.
-            predictor (BasePredictor): Customized predictor.
-            **kwargs : Additional keyword arguments passed to the predictor.
-                Check the 'configuration' section in the documentation for all available options.
+            im (List(np.ndarray)): (N, 3, h, w) for tensor, [(h, w, 3) x N] for list.
 
         Returns:
-            (List[ultralytics.engine.results.Results]): The prediction results.
-        """
-        if source is None:
-            source = ASSETS
-            LOGGER.warning(f"WARNING  'source' is missing. Using 'source={source}'.")
-
-        is_cli = (sys.argv[0].endswith('yolo') or sys.argv[0].endswith('ultralytics')) and any(
-            x in sys.argv for x in ('predict', 'track', 'mode=predict', 'mode=track'))
-
-        custom = {'conf': 0.25, 'save': is_cli}  # method defaults
-        args = {**self.overrides, **custom, **kwargs, 'mode': 'predict'}  # highest priority args on the right
-        prompts = args.pop('prompts', None)  # for SAM-type models
-
-        if not self.predictor:
-            self.predictor = (predictor or self._smart_load('predictor'))(overrides=args, _callbacks=self.callbacks)
-            self.predictor.setup_model(model=self.model, verbose=is_cli)
-        else:  # only update args if predictor is already setup
-            self.predictor.args = get_cfg(self.predictor.args, args)
-            if 'project' in args or 'name' in args:
-                self.predictor.save_dir = get_save_dir(self.predictor.args)
-        if prompts and hasattr(self.predictor, 'set_prompts'):  # for SAM-type models
-            self.predictor.set_prompts(prompts)
-        return self.predictor.predict_cli(source=source) if is_cli else self.predictor(source=source, stream=stream)
-
-    def track(self, source=None, stream=False, persist=False, **kwargs):
-        """
-        Perform object tracking on the input source using the registered trackers.
-
-        Args:
-            source (str, optional): The input source for object tracking. Can be a file path or a video stream.
-            stream (bool, optional): Whether the input source is a video stream. Defaults to False.
-            persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.
-            **kwargs (optional): Additional keyword arguments for the tracking process.
-
-        Returns:
-            (List[ultralytics.engine.results.Results]): The tracking results.
-        """
-        if not hasattr(self.predictor, 'trackers'):
-            from ultralytics.trackers import register_tracker
-            register_tracker(self, persist)
-        kwargs['conf'] = kwargs.get('conf') or 0.1  # ByteTrack-based method needs low confidence predictions as input
-        kwargs['mode'] = 'track'
-        return self.predict(source=source, stream=stream, **kwargs)
-
-    def val(self, validator=None, **kwargs):
-        """
-        Validate a model on a given dataset.
-
-        Args:
-            validator (BaseValidator): Customized validator.
-            **kwargs : Any other args accepted by the validators. To see all args check 'configuration' section in docs
-        """
-        custom = {'rect': True}  # method defaults
-        args = {**self.overrides, **custom, **kwargs, 'mode': 'val'}  # highest priority args on the right
-
-        validator = (validator or self._smart_load('validator'))(args=args, _callbacks=self.callbacks)
-        validator(model=self.model)
-        self.metrics = validator.metrics
-        return validator.metrics
-
-    def benchmark(self, **kwargs):
-        """
-        Benchmark a model on all export formats.
-
-        Args:
-            **kwargs : Any other args accepted by the validators. To see all args check 'configuration' section in docs
-        """
-        self._check_is_pytorch_model()
-        from ultralytics.utils.benchmarks import benchmark
-
-        custom = {'verbose': False}  # method defaults
-        args = {**DEFAULT_CFG_DICT, **self.model.args, **custom, **kwargs, 'mode': 'benchmark'}
-        return benchmark(
-            model=self,
-            data=kwargs.get('data'),  # if no 'data' argument passed set data=None for default datasets
-            imgsz=args['imgsz'],
-            half=args['half'],
-            int8=args['int8'],
-            device=args['device'],
-            verbose=kwargs.get('verbose'))
-
-    def export(self, **kwargs):
-        """
-        Export model.
-
-        Args:
-            **kwargs : Any other args accepted by the Exporter. To see all args check 'configuration' section in docs.
+            (list): A list of transformed images.
         """
-        self._check_is_pytorch_model()
-        from .exporter import Exporter
-
-        custom = {'imgsz': self.model.args['imgsz'], 'batch': 1, 'data': None, 'verbose': False}  # method defaults
-        args = {**self.overrides, **custom, **kwargs, 'mode': 'export'}  # highest priority args on the right
-        return Exporter(overrides=args, _callbacks=self.callbacks)(model=self.model)
+        same_shapes = len({x.shape for x in im}) == 1
+        letterbox = LetterBox(self.imgsz, auto=same_shapes and self.model.pt, stride=self.model.stride)
+        return [letterbox(image=x) for x in im]
+
+    def postprocess(self, preds, img, orig_imgs):
+        """Post-processes predictions for an image and returns them."""
+        return preds
+
+    def __call__(self, source=None, model=None, stream=False, *args, **kwargs):
+        """Performs inference on an image or stream."""
+        self.stream = stream
+        if stream:
+            return self.stream_inference(source, model, *args, **kwargs)
+        else:
+            return list(self.stream_inference(source, model, *args, **kwargs))  # merge list of Result into one
 
-    def train(self, trainer=None, **kwargs):
+    def predict_cli(self, source=None, model=None):
         """
-        Trains the model on a given dataset.
+        Method used for CLI prediction.
 
-        Args:
-            trainer (BaseTrainer, optional): Customized trainer.
-            **kwargs (Any): Any number of arguments representing the training configuration.
+        It uses always generator as outputs as not required by CLI mode.
         """
-        self._check_is_pytorch_model()
-        if self.session:  # Ultralytics HUB session
-            if any(kwargs):
-                LOGGER.warning('WARNING  using HUB training arguments, ignoring local training arguments.')
-            kwargs = self.session.train_args
-        checks.check_pip_update_available()
-
-        overrides = yaml_load(checks.check_yaml(kwargs['cfg'])) if kwargs.get('cfg') else self.overrides
-        custom = {'data': TASK2DATA[self.task]}  # method defaults
-        args = {**overrides, **custom, **kwargs, 'mode': 'train'}  # highest priority args on the right
-        if args.get('resume'):
-            args['resume'] = self.ckpt_path
-
-        self.trainer = (trainer or self._smart_load('trainer'))(overrides=args, _callbacks=self.callbacks)
-        if not args.get('resume'):  # manually set model only if not resuming
-            self.trainer.model = self.trainer.get_model(weights=self.model if self.ckpt else None, cfg=self.model.yaml)
-            self.model = self.trainer.model
-        self.trainer.hub_session = self.session  # attach optional HUB session
-        self.trainer.train()
-        # Update model and cfg after training
-        if RANK in (-1, 0):
-            ckpt = self.trainer.best if self.trainer.best.exists() else self.trainer.last
-            self.model, _ = attempt_load_one_weight(ckpt)
-            self.overrides = self.model.args
-            self.metrics = getattr(self.trainer.validator, 'metrics', None)  # TODO: no metrics returned by DDP
-        return self.metrics
+        gen = self.stream_inference(source, model)
+        for _ in gen:  # noqa, running CLI inference without accumulating any outputs (do not modify)
+            pass
+
+    def setup_source(self, source):
+        """Sets up source and inference mode."""
+        self.imgsz = check_imgsz(self.args.imgsz, stride=self.model.stride, min_dim=2)  # check image size
+        self.transforms = (
+            getattr(
+                self.model.model,
+                "transforms",
+                classify_transforms(self.imgsz[0], crop_fraction=self.args.crop_fraction),
+            )
+            if self.args.task == "classify"
+            else None
+        )
+        self.dataset = load_inference_source(
+            source=source,
+            batch=self.args.batch,
+            vid_stride=self.args.vid_stride,
+            buffer=self.args.stream_buffer,
+        )
+        self.source_type = self.dataset.source_type
+        if not getattr(self, "stream", True) and (
+            self.source_type.stream
+            or self.source_type.screenshot
+            or len(self.dataset) > 1000  # many images
+            or any(getattr(self.dataset, "video_flag", [False]))
+        ):  # videos
+            LOGGER.warning(STREAM_WARNING)
+        self.vid_writer = {}
+
+    @smart_inference_mode()
+    def stream_inference(self, source=None, model=None, *args, **kwargs):
+        """Streams real-time inference on camera feed and saves results to file."""
+        if self.args.verbose:
+            LOGGER.info("")
+
+        # Setup model
+        if not self.model:
+            self.setup_model(model)
+
+        with self._lock:  # for thread-safe inference
+            # Setup source every time predict is called
+            self.setup_source(source if source is not None else self.args.source)
+
+            # Check if save_dir/ label file exists
+            if self.args.save or self.args.save_txt:
+                (self.save_dir / "labels" if self.args.save_txt else self.save_dir).mkdir(parents=True, exist_ok=True)
+
+            # Warmup model
+            if not self.done_warmup:
+                self.model.warmup(imgsz=(1 if self.model.pt or self.model.triton else self.dataset.bs, 3, *self.imgsz))
+                self.done_warmup = True
+
+            self.seen, self.windows, self.batch = 0, [], None
+            profilers = (
+                ops.Profile(device=self.device),
+                ops.Profile(device=self.device),
+                ops.Profile(device=self.device),
+            )
+            self.run_callbacks("on_predict_start")
+            for self.batch in self.dataset:
+                self.run_callbacks("on_predict_batch_start")
+                paths, im0s, s = self.batch
+
+                # Preprocess
+                with profilers[0]:
+                    im = self.preprocess(im0s)
+
+                # Inference
+                with profilers[1]:
+                    preds = self.inference(im, *args, **kwargs)
+                    if self.args.embed:
+                        yield from [preds] if isinstance(preds, torch.Tensor) else preds  # yield embedding tensors
+                        continue
+
+                # Postprocess
+                with profilers[2]:
+                    self.results = self.postprocess(preds, im, im0s)
+                self.run_callbacks("on_predict_postprocess_end")
+
+                # Visualize, save, write results
+                n = len(im0s)
+                for i in range(n):
+                    self.seen += 1
+                    self.results[i].speed = {
+                        "preprocess": profilers[0].dt * 1e3 / n,
+                        "inference": profilers[1].dt * 1e3 / n,
+                        "postprocess": profilers[2].dt * 1e3 / n,
+                    }
+                    if self.args.verbose or self.args.save or self.args.save_txt or self.args.show:
+                        s[i] += self.write_results(i, Path(paths[i]), im, s)
+
+                # Print batch results
+                if self.args.verbose:
+                    LOGGER.info("\n".join(s))
+
+                self.run_callbacks("on_predict_batch_end")
+                yield from self.results
+
+        # Release assets
+        for v in self.vid_writer.values():
+            if isinstance(v, cv2.VideoWriter):
+                v.release()
+
+        # Print final results
+        if self.args.verbose and self.seen:
+            t = tuple(x.t / self.seen * 1e3 for x in profilers)  # speeds per image
+            LOGGER.info(
+                f"Speed: %.1fms preprocess, %.1fms inference, %.1fms postprocess per image at shape "
+                f"{(min(self.args.batch, self.seen), 3, *im.shape[2:])}" % t
+            )
+        if self.args.save or self.args.save_txt or self.args.save_crop:
+            nl = len(list(self.save_dir.glob("labels/*.txt")))  # number of labels
+            s = f"\n{nl} label{'s' * (nl > 1)} saved to {self.save_dir / 'labels'}" if self.args.save_txt else ""
+            LOGGER.info(f"Results saved to {colorstr('bold', self.save_dir)}{s}")
+        self.run_callbacks("on_predict_end")
+
+    def setup_model(self, model, verbose=True):
+        """Initialize YOLO model with given parameters and set it to evaluation mode."""
+        self.model = AutoBackend(
+            weights=model or self.args.model,
+            device=select_device(self.args.device, verbose=verbose),
+            dnn=self.args.dnn,
+            data=self.args.data,
+            fp16=self.args.half,
+            batch=self.args.batch,
+            fuse=True,
+            verbose=verbose,
+        )
+
+        self.device = self.model.device  # update device
+        self.args.half = self.model.fp16  # update half
+        self.model.eval()
+
+    def write_results(self, i, p, im, s):
+        """Write inference results to a file or directory."""
+        string = ""  # print string
+        if len(im.shape) == 3:
+            im = im[None]  # expand for batch dim
+        if self.source_type.stream or self.source_type.from_img or self.source_type.tensor:  # batch_size >= 1
+            string += f"{i}: "
+            frame = self.dataset.count
+        else:
+            match = re.search(r"frame (\d+)/", s[i])
+            frame = int(match.group(1)) if match else None  # 0 if frame undetermined
 
-    def tune(self, use_ray=False, iterations=10, *args, **kwargs):
-        """
-        Runs hyperparameter tuning, optionally using Ray Tune. See ultralytics.utils.tuner.run_ray_tune for Args.
+        self.txt_path = self.save_dir / "labels" / (p.stem + ("" if self.dataset.mode == "image" else f"_{frame}"))
+        string += "%gx%g " % im.shape[2:]
+        result = self.results[i]
+        result.save_dir = self.save_dir.__str__()  # used in other locations
+        string += result.verbose() + f"{result.speed['inference']:.1f}ms"
+
+        # Add predictions to image
+        if self.args.save or self.args.show:
+            self.plotted_img = result.plot(
+                line_width=self.args.line_width,
+                boxes=self.args.show_boxes,
+                conf=self.args.show_conf,
+                labels=self.args.show_labels,
+                im_gpu=None if self.args.retina_masks else im[i],
+            )
+
+        # Save results
+        if self.args.save_txt:
+            result.save_txt(f"{self.txt_path}.txt", save_conf=self.args.save_conf)
+        if self.args.save_crop:
+            result.save_crop(save_dir=self.save_dir / "crops", file_name=self.txt_path.stem)
+        if self.args.show:
+            self.show(str(p))
+        if self.args.save:
+            self.save_predicted_images(str(self.save_dir / p.name), frame)
+
+        return string
+
+    def save_predicted_images(self, save_path="", frame=0):
+        """Save video predictions as mp4 at specified path."""
+        im = self.plotted_img
+
+        # Save videos and streams
+        if self.dataset.mode in {"stream", "video"}:
+            fps = self.dataset.fps if self.dataset.mode == "video" else 30
+            frames_path = f'{save_path.split(".", 1)[0]}_frames/'
+            if save_path not in self.vid_writer:  # new video
+                if self.args.save_frames:
+                    Path(frames_path).mkdir(parents=True, exist_ok=True)
+                suffix, fourcc = (".mp4", "avc1") if MACOS else (".avi", "WMV2") if WINDOWS else (".avi", "MJPG")
+                self.vid_writer[save_path] = cv2.VideoWriter(
+                    filename=str(Path(save_path).with_suffix(suffix)),
+                    fourcc=cv2.VideoWriter_fourcc(*fourcc),
+                    fps=fps,  # integer required, floats produce error in MP4 codec
+                    frameSize=(im.shape[1], im.shape[0]),  # (width, height)
+                )
+
+            # Save video
+            self.vid_writer[save_path].write(im)
+            if self.args.save_frames:
+                cv2.imwrite(f"{frames_path}{frame}.jpg", im)
 
-        Returns:
-            (dict): A dictionary containing the results of the hyperparameter search.
-        """
-        self._check_is_pytorch_model()
-        if use_ray:
-            from ultralytics.utils.tuner import run_ray_tune
-            return run_ray_tune(self, max_samples=iterations, *args, **kwargs)
+        # Save images
         else:
-            from .tuner import Tuner
+            cv2.imwrite(save_path, im)
 
-            custom = {}  # method defaults
-            args = {**self.overrides, **custom, **kwargs, 'mode': 'train'}  # highest priority args on the right
-            return Tuner(args=args, _callbacks=self.callbacks)(model=self, iterations=iterations)
-
-    def _apply(self, fn):
-        """Apply to(), cpu(), cuda(), half(), float() to model tensors that are not parameters or registered buffers."""
-        self._check_is_pytorch_model()
-        self = super()._apply(fn)  # noqa
-        self.predictor = None  # reset predictor as device may have changed
-        self.overrides['device'] = self.device  # was str(self.device) i.e. device(type='cuda', index=0) -> 'cuda:0'
-        return self
-
-    @property
-    def names(self):
-        """Returns class names of the loaded model."""
-        return self.model.names if hasattr(self.model, 'names') else None
-
-    @property
-    def device(self):
-        """Returns device if PyTorch model."""
-        return next(self.model.parameters()).device if isinstance(self.model, nn.Module) else None
-
-    @property
-    def transforms(self):
-        """Returns transform of the loaded model."""
-        return self.model.transforms if hasattr(self.model, 'transforms') else None
+    def show(self, p=""):
+        """Display an image in a window using OpenCV imshow()."""
+        im = self.plotted_img
+        if platform.system() == "Linux" and p not in self.windows:
+            self.windows.append(p)
+            cv2.namedWindow(p, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)
+            cv2.resizeWindow(p, im.shape[1], im.shape[0])  # (width, height)
+        cv2.imshow(p, im)
+        cv2.waitKey(300 if self.dataset.mode == "image" else 1)  # 1 millisecond
+
+    def run_callbacks(self, event: str):
+        """Runs all registered callbacks for a specific event."""
+        for callback in self.callbacks.get(event, []):
+            callback(self)
 
     def add_callback(self, event: str, func):
-        """Add a callback."""
+        """Add callback."""
         self.callbacks[event].append(func)
-
-    def clear_callback(self, event: str):
-        """Clear all event callbacks."""
-        self.callbacks[event] = []
-
-    def reset_callbacks(self):
-        """Reset all registered callbacks."""
-        for event in callbacks.default_callbacks.keys():
-            self.callbacks[event] = [callbacks.default_callbacks[event][0]]
-
-    @staticmethod
-    def _reset_ckpt_args(args):
-        """Reset arguments when loading a PyTorch model."""
-        include = {'imgsz', 'data', 'task', 'single_cls'}  # only remember these arguments when loading a PyTorch model
-        return {k: v for k, v in args.items() if k in include}
-
-    # def __getattr__(self, attr):
-    #    """Raises error if object has no requested attribute."""
-    #    name = self.__class__.__name__
-    #    raise AttributeError(f"'{name}' object has no attribute '{attr}'. See valid attributes below.\n{self.__doc__}")
-
-    def _smart_load(self, key):
-        """Load model/trainer/validator/predictor."""
-        try:
-            return self.task_map[self.task][key]
-        except Exception as e:
-            name = self.__class__.__name__
-            mode = inspect.stack()[1][3]  # get the function name.
-            raise NotImplementedError(
-                emojis(f"WARNING  '{name}' model does not support '{mode}' mode for '{self.task}' task yet.")) from e
-
-    @property
-    def task_map(self):
-        """
-        Map head to model, trainer, validator, and predictor classes.
-
-        Returns:
-            task_map (dict): The map of model task to mode classes.
-        """
-        raise NotImplementedError('Please provide task map for your model!')
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/engine/predictor.py` & `yolov8_pose_triton-8.2.0/ultralytics/engine/validator.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,366 +1,338 @@
 # Ultralytics YOLO , AGPL-3.0 license
 """
-Run prediction on images, videos, directories, globs, YouTube, webcam, streams, etc.
+Check a model's accuracy on a test or val split of a dataset.
 
-Usage - sources:
-    $ yolo mode=predict model=yolov8n.pt source=0                               # webcam
-                                                img.jpg                         # image
-                                                vid.mp4                         # video
-                                                screen                          # screenshot
-                                                path/                           # directory
-                                                list.txt                        # list of images
-                                                list.streams                    # list of streams
-                                                'path/*.jpg'                    # glob
-                                                'https://youtu.be/LNwODJXcvt4'  # YouTube
-                                                'rtsp://example.com/media.mp4'  # RTSP, RTMP, HTTP, TCP stream
+Usage:
+    $ yolo mode=val model=yolov8n.pt data=coco128.yaml imgsz=640
 
 Usage - formats:
-    $ yolo mode=predict model=yolov8n.pt                 # PyTorch
-                              yolov8n.torchscript        # TorchScript
-                              yolov8n.onnx               # ONNX Runtime or OpenCV DNN with dnn=True
-                              yolov8n_openvino_model     # OpenVINO
-                              yolov8n.engine             # TensorRT
-                              yolov8n.mlpackage          # CoreML (macOS-only)
-                              yolov8n_saved_model        # TensorFlow SavedModel
-                              yolov8n.pb                 # TensorFlow GraphDef
-                              yolov8n.tflite             # TensorFlow Lite
-                              yolov8n_edgetpu.tflite     # TensorFlow Edge TPU
-                              yolov8n_paddle_model       # PaddlePaddle
+    $ yolo mode=val model=yolov8n.pt                 # PyTorch
+                          yolov8n.torchscript        # TorchScript
+                          yolov8n.onnx               # ONNX Runtime or OpenCV DNN with dnn=True
+                          yolov8n_openvino_model     # OpenVINO
+                          yolov8n.engine             # TensorRT
+                          yolov8n.mlpackage          # CoreML (macOS-only)
+                          yolov8n_saved_model        # TensorFlow SavedModel
+                          yolov8n.pb                 # TensorFlow GraphDef
+                          yolov8n.tflite             # TensorFlow Lite
+                          yolov8n_edgetpu.tflite     # TensorFlow Edge TPU
+                          yolov8n_paddle_model       # PaddlePaddle
+                          yolov8n_ncnn_model         # NCNN
 """
-import platform
-import threading
+
+import json
+import time
 from pathlib import Path
 
-import cv2
 import numpy as np
 import torch
 
 from ultralytics.cfg import get_cfg, get_save_dir
-from ultralytics.data import load_inference_source
-from ultralytics.data.augment import LetterBox, classify_transforms
+from ultralytics.data.utils import check_cls_dataset, check_det_dataset
 from ultralytics.nn.autobackend import AutoBackend
-from ultralytics.utils import DEFAULT_CFG, LOGGER, MACOS, WINDOWS, callbacks, colorstr, ops
-from ultralytics.utils.checks import check_imgsz, check_imshow
-from ultralytics.utils.files import increment_path
-from ultralytics.utils.torch_utils import select_device, smart_inference_mode
-
-STREAM_WARNING = """
-WARNING  inference results will accumulate in RAM unless `stream=True` is passed, causing potential out-of-memory
-errors for large sources or long-running streams and videos. See https://docs.ultralytics.com/modes/predict/ for help.
-
-Example:
-    results = model(source=..., stream=True)  # generator of Results objects
-    for r in results:
-        boxes = r.boxes  # Boxes object for bbox outputs
-        masks = r.masks  # Masks object for segment masks outputs
-        probs = r.probs  # Class probabilities for classification outputs
-"""
+from ultralytics.utils import LOGGER, TQDM, callbacks, colorstr, emojis
+from ultralytics.utils.checks import check_imgsz
+from ultralytics.utils.ops import Profile
+from ultralytics.utils.torch_utils import de_parallel, select_device, smart_inference_mode
 
 
-class BasePredictor:
+class BaseValidator:
     """
-    BasePredictor.
+    BaseValidator.
 
-    A base class for creating predictors.
+    A base class for creating validators.
 
     Attributes:
-        args (SimpleNamespace): Configuration for the predictor.
+        args (SimpleNamespace): Configuration for the validator.
+        dataloader (DataLoader): Dataloader to use for validation.
+        pbar (tqdm): Progress bar to update during validation.
+        model (nn.Module): Model to validate.
+        data (dict): Data dictionary.
+        device (torch.device): Device to use for validation.
+        batch_i (int): Current batch index.
+        training (bool): Whether the model is in training mode.
+        names (dict): Class names.
+        seen: Records the number of images seen so far during validation.
+        stats: Placeholder for statistics during validation.
+        confusion_matrix: Placeholder for a confusion matrix.
+        nc: Number of classes.
+        iouv: (torch.Tensor): IoU thresholds from 0.50 to 0.95 in spaces of 0.05.
+        jdict (dict): Dictionary to store JSON validation results.
+        speed (dict): Dictionary with keys 'preprocess', 'inference', 'loss', 'postprocess' and their respective
+                      batch processing times in milliseconds.
         save_dir (Path): Directory to save results.
-        done_warmup (bool): Whether the predictor has finished setup.
-        model (nn.Module): Model used for prediction.
-        data (dict): Data configuration.
-        device (torch.device): Device used for prediction.
-        dataset (Dataset): Dataset used for prediction.
-        vid_path (str): Path to video file.
-        vid_writer (cv2.VideoWriter): Video writer for saving video output.
-        data_path (str): Path to data.
+        plots (dict): Dictionary to store plots for visualization.
+        callbacks (dict): Dictionary to store various callback functions.
     """
 
-    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):
+    def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):
         """
-        Initializes the BasePredictor class.
+        Initializes a BaseValidator instance.
 
         Args:
-            cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.
-            overrides (dict, optional): Configuration overrides. Defaults to None.
+            dataloader (torch.utils.data.DataLoader): Dataloader to be used for validation.
+            save_dir (Path, optional): Directory to save results.
+            pbar (tqdm.tqdm): Progress bar for displaying progress.
+            args (SimpleNamespace): Configuration for the validator.
+            _callbacks (dict): Dictionary to store various callback functions.
         """
-        self.args = get_cfg(cfg, overrides)
-        self.save_dir = get_save_dir(self.args)
-        if self.args.conf is None:
-            self.args.conf = 0.25  # default conf=0.25
-        self.done_warmup = False
-        if self.args.show:
-            self.args.show = check_imshow(warn=True)
-
-        # Usable if setup is done
-        self.model = None
-        self.data = self.args.data  # data_dict
-        self.imgsz = None
+        self.args = get_cfg(overrides=args)
+        self.dataloader = dataloader
+        self.pbar = pbar
+        self.stride = None
+        self.data = None
         self.device = None
-        self.dataset = None
-        self.vid_path, self.vid_writer = None, None
-        self.plotted_img = None
-        self.data_path = None
-        self.source_type = None
-        self.batch = None
-        self.results = None
-        self.transforms = None
-        self.callbacks = _callbacks or callbacks.get_default_callbacks()
-        self.txt_path = None
-        self._lock = threading.Lock()  # for automatic thread-safe inference
-        callbacks.add_integration_callbacks(self)
-
-    def preprocess(self, im):
-        """
-        Prepares input image before inference.
-
-        Args:
-            im (torch.Tensor | List(np.ndarray)): BCHW for tensor, [(HWC) x B] for list.
-        """
-        not_tensor = not isinstance(im, torch.Tensor)
-        if not_tensor:
-            im = np.stack(self.pre_transform(im))
-            im = im[..., ::-1].transpose((0, 3, 1, 2))  # BGR to RGB, BHWC to BCHW, (n, 3, h, w)
-            im = np.ascontiguousarray(im)  # contiguous
-            im = torch.from_numpy(im)
-
-        im = im.to(self.device)
-        im = im.half() if self.model.fp16 else im.float()  # uint8 to fp16/32
-        if not_tensor:
-            im /= 255  # 0 - 255 to 0.0 - 1.0
-        return im
-
-    def inference(self, im, *args, **kwargs):
-        """Runs inference on a given image using the specified model and arguments."""
-        visualize = increment_path(self.save_dir / Path(self.batch[0][0]).stem,
-                                   mkdir=True) if self.args.visualize and (not self.source_type.tensor) else False
-        return self.model(im, augment=self.args.augment, visualize=visualize)
+        self.batch_i = None
+        self.training = True
+        self.names = None
+        self.seen = None
+        self.stats = None
+        self.confusion_matrix = None
+        self.nc = None
+        self.iouv = None
+        self.jdict = None
+        self.speed = {"preprocess": 0.0, "inference": 0.0, "loss": 0.0, "postprocess": 0.0}
 
-    def pre_transform(self, im):
-        """
-        Pre-transform input image before inference.
+        self.save_dir = save_dir or get_save_dir(self.args)
+        (self.save_dir / "labels" if self.args.save_txt else self.save_dir).mkdir(parents=True, exist_ok=True)
+        if self.args.conf is None:
+            self.args.conf = 0.001  # default conf=0.001
+        self.args.imgsz = check_imgsz(self.args.imgsz, max_dim=1)
 
-        Args:
-            im (List(np.ndarray)): (N, 3, h, w) for tensor, [(h, w, 3) x N] for list.
+        self.plots = {}
+        self.callbacks = _callbacks or callbacks.get_default_callbacks()
 
-        Returns:
-            (list): A list of transformed images.
+    @smart_inference_mode()
+    def __call__(self, trainer=None, model=None):
+        """Supports validation of a pre-trained model if passed or a model being trained if trainer is passed (trainer
+        gets priority).
         """
-        same_shapes = all(x.shape == im[0].shape for x in im)
-        letterbox = LetterBox(self.imgsz, auto=same_shapes and self.model.pt, stride=self.model.stride)
-        return [letterbox(image=x) for x in im]
-
-    def write_results(self, idx, results, batch):
-        """Write inference results to a file or directory."""
-        p, im, _ = batch
-        log_string = ''
-        if len(im.shape) == 3:
-            im = im[None]  # expand for batch dim
-        if self.source_type.webcam or self.source_type.from_img or self.source_type.tensor:  # batch_size >= 1
-            log_string += f'{idx}: '
-            frame = self.dataset.count
+        self.training = trainer is not None
+        augment = self.args.augment and (not self.training)
+        if self.training:
+            self.device = trainer.device
+            self.data = trainer.data
+            self.args.half = self.device.type != "cpu"  # force FP16 val during training
+            model = trainer.ema.ema or trainer.model
+            model = model.half() if self.args.half else model.float()
+            # self.model = model
+            self.loss = torch.zeros_like(trainer.loss_items, device=trainer.device)
+            self.args.plots &= trainer.stopper.possible_stop or (trainer.epoch == trainer.epochs - 1)
+            model.eval()
         else:
-            frame = getattr(self.dataset, 'frame', 0)
-        self.data_path = p
-        self.txt_path = str(self.save_dir / 'labels' / p.stem) + ('' if self.dataset.mode == 'image' else f'_{frame}')
-        log_string += '%gx%g ' % im.shape[2:]  # print string
-        result = results[idx]
-        log_string += result.verbose()
-
-        if self.args.save or self.args.show:  # Add bbox to image
-            plot_args = {
-                'line_width': self.args.line_width,
-                'boxes': self.args.show_boxes,
-                'conf': self.args.show_conf,
-                'labels': self.args.show_labels}
-            if not self.args.retina_masks:
-                plot_args['im_gpu'] = im[idx]
-            self.plotted_img = result.plot(**plot_args)
-        # Write
-        if self.args.save_txt:
-            result.save_txt(f'{self.txt_path}.txt', save_conf=self.args.save_conf)
-        if self.args.save_crop:
-            result.save_crop(save_dir=self.save_dir / 'crops',
-                             file_name=self.data_path.stem + ('' if self.dataset.mode == 'image' else f'_{frame}'))
-
-        return log_string
-
-    def postprocess(self, preds, img, orig_imgs):
-        """Post-processes predictions for an image and returns them."""
-        return preds
-
-    def __call__(self, source=None, model=None, stream=False, *args, **kwargs):
-        """Performs inference on an image or stream."""
-        self.stream = stream
-        if stream:
-            return self.stream_inference(source, model, *args, **kwargs)
+            callbacks.add_integration_callbacks(self)
+            model = AutoBackend(
+                weights=model or self.args.model,
+                device=select_device(self.args.device, self.args.batch),
+                dnn=self.args.dnn,
+                data=self.args.data,
+                fp16=self.args.half,
+            )
+            # self.model = model
+            self.device = model.device  # update device
+            self.args.half = model.fp16  # update half
+            stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine
+            imgsz = check_imgsz(self.args.imgsz, stride=stride)
+            if engine:
+                self.args.batch = model.batch_size
+            elif not pt and not jit:
+                self.args.batch = 1  # export.py models default to batch-size 1
+                LOGGER.info(f"Forcing batch=1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models")
+
+            if str(self.args.data).split(".")[-1] in {"yaml", "yml"}:
+                self.data = check_det_dataset(self.args.data)
+            elif self.args.task == "classify":
+                self.data = check_cls_dataset(self.args.data, split=self.args.split)
+            else:
+                raise FileNotFoundError(emojis(f"Dataset '{self.args.data}' for task={self.args.task} not found "))
+
+            if self.device.type in {"cpu", "mps"}:
+                self.args.workers = 0  # faster CPU val as time dominated by inference, not dataloading
+            if not pt:
+                self.args.rect = False
+            self.stride = model.stride  # used in get_dataloader() for padding
+            self.dataloader = self.dataloader or self.get_dataloader(self.data.get(self.args.split), self.args.batch)
+
+            model.eval()
+            model.warmup(imgsz=(1 if pt else self.args.batch, 3, imgsz, imgsz))  # warmup
+
+        self.run_callbacks("on_val_start")
+        dt = (
+            Profile(device=self.device),
+            Profile(device=self.device),
+            Profile(device=self.device),
+            Profile(device=self.device),
+        )
+        bar = TQDM(self.dataloader, desc=self.get_desc(), total=len(self.dataloader))
+        self.init_metrics(de_parallel(model))
+        self.jdict = []  # empty before each val
+        for batch_i, batch in enumerate(bar):
+            self.run_callbacks("on_val_batch_start")
+            self.batch_i = batch_i
+            # Preprocess
+            with dt[0]:
+                batch = self.preprocess(batch)
+
+            # Inference
+            with dt[1]:
+                preds = model(batch["img"], augment=augment)
+
+            # Loss
+            with dt[2]:
+                if self.training:
+                    self.loss += model.loss(batch, preds)[1]
+
+            # Postprocess
+            with dt[3]:
+                preds = self.postprocess(preds)
+
+            self.update_metrics(preds, batch)
+            if self.args.plots and batch_i < 3:
+                self.plot_val_samples(batch, batch_i)
+                self.plot_predictions(batch, preds, batch_i)
+
+            self.run_callbacks("on_val_batch_end")
+        stats = self.get_stats()
+        self.check_stats(stats)
+        self.speed = dict(zip(self.speed.keys(), (x.t / len(self.dataloader.dataset) * 1e3 for x in dt)))
+        self.finalize_metrics()
+        self.print_results()
+        self.run_callbacks("on_val_end")
+        if self.training:
+            model.float()
+            results = {**stats, **trainer.label_loss_items(self.loss.cpu() / len(self.dataloader), prefix="val")}
+            return {k: round(float(v), 5) for k, v in results.items()}  # return results as 5 decimal place floats
         else:
-            return list(self.stream_inference(source, model, *args, **kwargs))  # merge list of Result into one
+            LOGGER.info(
+                "Speed: %.1fms preprocess, %.1fms inference, %.1fms loss, %.1fms postprocess per image"
+                % tuple(self.speed.values())
+            )
+            if self.args.save_json and self.jdict:
+                with open(str(self.save_dir / "predictions.json"), "w") as f:
+                    LOGGER.info(f"Saving {f.name}...")
+                    json.dump(self.jdict, f)  # flatten and save
+                stats = self.eval_json(stats)  # update stats
+            if self.args.plots or self.args.save_json:
+                LOGGER.info(f"Results saved to {colorstr('bold', self.save_dir)}")
+            return stats
 
-    def predict_cli(self, source=None, model=None):
+    def match_predictions(self, pred_classes, true_classes, iou, use_scipy=False):
         """
-        Method used for CLI prediction.
+        Matches predictions to ground truth objects (pred_classes, true_classes) using IoU.
 
-        It uses always generator as outputs as not required by CLI mode.
-        """
-        gen = self.stream_inference(source, model)
-        for _ in gen:  # running CLI inference without accumulating any outputs (do not modify)
-            pass
-
-    def setup_source(self, source):
-        """Sets up source and inference mode."""
-        self.imgsz = check_imgsz(self.args.imgsz, stride=self.model.stride, min_dim=2)  # check image size
-        self.transforms = getattr(self.model.model, 'transforms', classify_transforms(
-            self.imgsz[0])) if self.args.task == 'classify' else None
-        self.dataset = load_inference_source(source=source,
-                                             imgsz=self.imgsz,
-                                             vid_stride=self.args.vid_stride,
-                                             buffer=self.args.stream_buffer)
-        self.source_type = self.dataset.source_type
-        if not getattr(self, 'stream', True) and (self.dataset.mode == 'stream' or  # streams
-                                                  len(self.dataset) > 1000 or  # images
-                                                  any(getattr(self.dataset, 'video_flag', [False]))):  # videos
-            LOGGER.warning(STREAM_WARNING)
-        self.vid_path, self.vid_writer = [None] * self.dataset.bs, [None] * self.dataset.bs
+        Args:
+            pred_classes (torch.Tensor): Predicted class indices of shape(N,).
+            true_classes (torch.Tensor): Target class indices of shape(M,).
+            iou (torch.Tensor): An NxM tensor containing the pairwise IoU values for predictions and ground of truth
+            use_scipy (bool): Whether to use scipy for matching (more precise).
 
-    @smart_inference_mode()
-    def stream_inference(self, source=None, model=None, *args, **kwargs):
-        """Streams real-time inference on camera feed and saves results to file."""
-        if self.args.verbose:
-            LOGGER.info('')
-
-        # Setup model
-        if not self.model:
-            self.setup_model(model)
-
-        with self._lock:  # for thread-safe inference
-            # Setup source every time predict is called
-            self.setup_source(source if source is not None else self.args.source)
-
-            # Check if save_dir/ label file exists
-            if self.args.save or self.args.save_txt:
-                (self.save_dir / 'labels' if self.args.save_txt else self.save_dir).mkdir(parents=True, exist_ok=True)
-
-            # Warmup model
-            if not self.done_warmup:
-                self.model.warmup(imgsz=(1 if self.model.pt or self.model.triton else self.dataset.bs, 3, *self.imgsz))
-                self.done_warmup = True
-
-            self.seen, self.windows, self.batch, profilers = 0, [], None, (ops.Profile(), ops.Profile(), ops.Profile())
-            self.run_callbacks('on_predict_start')
-
-            for batch in self.dataset:
-                self.run_callbacks('on_predict_batch_start')
-                self.batch = batch
-                path, im0s, vid_cap, s = batch
-
-                # Preprocess
-                with profilers[0]:
-                    im = self.preprocess(im0s)
-
-                # Inference
-                with profilers[1]:
-                    preds = self.inference(im, *args, **kwargs)
-
-                # Postprocess
-                with profilers[2]:
-                    self.results = self.postprocess(preds, im, im0s)
-
-                self.run_callbacks('on_predict_postprocess_end')
-                # Visualize, save, write results
-                n = len(im0s)
-                for i in range(n):
-                    self.seen += 1
-                    self.results[i].speed = {
-                        'preprocess': profilers[0].dt * 1E3 / n,
-                        'inference': profilers[1].dt * 1E3 / n,
-                        'postprocess': profilers[2].dt * 1E3 / n}
-                    p, im0 = path[i], None if self.source_type.tensor else im0s[i].copy()
-                    p = Path(p)
-
-                    if self.args.verbose or self.args.save or self.args.save_txt or self.args.show:
-                        s += self.write_results(i, self.results, (p, im, im0))
-                    if self.args.save or self.args.save_txt:
-                        self.results[i].save_dir = self.save_dir.__str__()
-                    if self.args.show and self.plotted_img is not None:
-                        self.show(p)
-                    if self.args.save and self.plotted_img is not None:
-                        self.save_preds(vid_cap, i, str(self.save_dir / p.name))
-
-                self.run_callbacks('on_predict_batch_end')
-                yield from self.results
-
-                # Print time (inference-only)
-                if self.args.verbose:
-                    LOGGER.info(f'{s}{profilers[1].dt * 1E3:.1f}ms')
-
-        # Release assets
-        if isinstance(self.vid_writer[-1], cv2.VideoWriter):
-            self.vid_writer[-1].release()  # release final video writer
-
-        # Print results
-        if self.args.verbose and self.seen:
-            t = tuple(x.t / self.seen * 1E3 for x in profilers)  # speeds per image
-            LOGGER.info(f'Speed: %.1fms preprocess, %.1fms inference, %.1fms postprocess per image at shape '
-                        f'{(1, 3, *im.shape[2:])}' % t)
-        if self.args.save or self.args.save_txt or self.args.save_crop:
-            nl = len(list(self.save_dir.glob('labels/*.txt')))  # number of labels
-            s = f"\n{nl} label{'s' * (nl > 1)} saved to {self.save_dir / 'labels'}" if self.args.save_txt else ''
-            LOGGER.info(f"Results saved to {colorstr('bold', self.save_dir)}{s}")
-
-        self.run_callbacks('on_predict_end')
-
-    def setup_model(self, model, verbose=True):
-        """Initialize YOLO model with given parameters and set it to evaluation mode."""
-        self.model = AutoBackend(model or self.args.model,
-                                 device=select_device(self.args.device, verbose=verbose),
-                                 dnn=self.args.dnn,
-                                 data=self.args.data,
-                                 fp16=self.args.half,
-                                 fuse=True,
-                                 verbose=verbose)
-
-        self.device = self.model.device  # update device
-        self.args.half = self.model.fp16  # update half
-        self.model.eval()
-
-    def show(self, p):
-        """Display an image in a window using OpenCV imshow()."""
-        im0 = self.plotted_img
-        if platform.system() == 'Linux' and p not in self.windows:
-            self.windows.append(p)
-            cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)
-            cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])
-        cv2.imshow(str(p), im0)
-        cv2.waitKey(500 if self.batch[3].startswith('image') else 1)  # 1 millisecond
-
-    def save_preds(self, vid_cap, idx, save_path):
-        """Save video predictions as mp4 at specified path."""
-        im0 = self.plotted_img
-        # Save imgs
-        if self.dataset.mode == 'image':
-            cv2.imwrite(save_path, im0)
-        else:  # 'video' or 'stream'
-            if self.vid_path[idx] != save_path:  # new video
-                self.vid_path[idx] = save_path
-                if isinstance(self.vid_writer[idx], cv2.VideoWriter):
-                    self.vid_writer[idx].release()  # release previous video writer
-                if vid_cap:  # video
-                    fps = int(vid_cap.get(cv2.CAP_PROP_FPS))  # integer required, floats produce error in MP4 codec
-                    w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))
-                    h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
-                else:  # stream
-                    fps, w, h = 30, im0.shape[1], im0.shape[0]
-                suffix, fourcc = ('.mp4', 'avc1') if MACOS else ('.avi', 'WMV2') if WINDOWS else ('.avi', 'MJPG')
-                save_path = str(Path(save_path).with_suffix(suffix))
-                self.vid_writer[idx] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*fourcc), fps, (w, h))
-            self.vid_writer[idx].write(im0)
+        Returns:
+            (torch.Tensor): Correct tensor of shape(N,10) for 10 IoU thresholds.
+        """
+        # Dx10 matrix, where D - detections, 10 - IoU thresholds
+        correct = np.zeros((pred_classes.shape[0], self.iouv.shape[0])).astype(bool)
+        # LxD matrix where L - labels (rows), D - detections (columns)
+        correct_class = true_classes[:, None] == pred_classes
+        iou = iou * correct_class  # zero out the wrong classes
+        iou = iou.cpu().numpy()
+        for i, threshold in enumerate(self.iouv.cpu().tolist()):
+            if use_scipy:
+                # WARNING: known issue that reduces mAP in https://github.com/ultralytics/ultralytics/pull/4708
+                import scipy  # scope import to avoid importing for all commands
+
+                cost_matrix = iou * (iou >= threshold)
+                if cost_matrix.any():
+                    labels_idx, detections_idx = scipy.optimize.linear_sum_assignment(cost_matrix, maximize=True)
+                    valid = cost_matrix[labels_idx, detections_idx] > 0
+                    if valid.any():
+                        correct[detections_idx[valid], i] = True
+            else:
+                matches = np.nonzero(iou >= threshold)  # IoU > threshold and classes match
+                matches = np.array(matches).T
+                if matches.shape[0]:
+                    if matches.shape[0] > 1:
+                        matches = matches[iou[matches[:, 0], matches[:, 1]].argsort()[::-1]]
+                        matches = matches[np.unique(matches[:, 1], return_index=True)[1]]
+                        # matches = matches[matches[:, 2].argsort()[::-1]]
+                        matches = matches[np.unique(matches[:, 0], return_index=True)[1]]
+                    correct[matches[:, 1].astype(int), i] = True
+        return torch.tensor(correct, dtype=torch.bool, device=pred_classes.device)
+
+    def add_callback(self, event: str, callback):
+        """Appends the given callback."""
+        self.callbacks[event].append(callback)
 
     def run_callbacks(self, event: str):
-        """Runs all registered callbacks for a specific event."""
+        """Runs all callbacks associated with a specified event."""
         for callback in self.callbacks.get(event, []):
             callback(self)
 
-    def add_callback(self, event: str, func):
-        """Add callback."""
-        self.callbacks[event].append(func)
+    def get_dataloader(self, dataset_path, batch_size):
+        """Get data loader from dataset path and batch size."""
+        raise NotImplementedError("get_dataloader function not implemented for this validator")
+
+    def build_dataset(self, img_path):
+        """Build dataset."""
+        raise NotImplementedError("build_dataset function not implemented in validator")
+
+    def preprocess(self, batch):
+        """Preprocesses an input batch."""
+        return batch
+
+    def postprocess(self, preds):
+        """Describes and summarizes the purpose of 'postprocess()' but no details mentioned."""
+        return preds
+
+    def init_metrics(self, model):
+        """Initialize performance metrics for the YOLO model."""
+        pass
+
+    def update_metrics(self, preds, batch):
+        """Updates metrics based on predictions and batch."""
+        pass
+
+    def finalize_metrics(self, *args, **kwargs):
+        """Finalizes and returns all metrics."""
+        pass
+
+    def get_stats(self):
+        """Returns statistics about the model's performance."""
+        return {}
+
+    def check_stats(self, stats):
+        """Checks statistics."""
+        pass
+
+    def print_results(self):
+        """Prints the results of the model's predictions."""
+        pass
+
+    def get_desc(self):
+        """Get description of the YOLO model."""
+        pass
+
+    @property
+    def metric_keys(self):
+        """Returns the metric keys used in YOLO training/validation."""
+        return []
+
+    def on_plot(self, name, data=None):
+        """Registers plots (e.g. to be consumed in callbacks)"""
+        self.plots[Path(name)] = {"data": data, "timestamp": time.time()}
+
+    # TODO: may need to put these following functions into callback
+    def plot_val_samples(self, batch, ni):
+        """Plots validation samples during training."""
+        pass
+
+    def plot_predictions(self, batch, preds, ni):
+        """Plots YOLO model predictions on batch images."""
+        pass
+
+    def pred_to_json(self, preds, batch):
+        """Convert predictions to JSON format."""
+        pass
+
+    def eval_json(self, stats):
+        """Evaluate and return JSON format of prediction statistics."""
+        pass
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/engine/results.py` & `yolov8_pose_triton-8.2.0/ultralytics/engine/results.py`

 * *Files 10% similar despite different names*

```diff
@@ -63,70 +63,89 @@
         return self.__class__(self.data[idx], self.orig_shape)
 
 
 class Results(SimpleClass):
     """
     A class for storing and manipulating inference results.
 
-    Args:
-        orig_img (numpy.ndarray): The original image as a numpy array.
-        path (str): The path to the image file.
-        names (dict): A dictionary of class names.
-        boxes (torch.tensor, optional): A 2D tensor of bounding box coordinates for each detection.
-        masks (torch.tensor, optional): A 3D tensor of detection masks, where each mask is a binary image.
-        probs (torch.tensor, optional): A 1D tensor of probabilities of each class for classification task.
-        keypoints (List[List[float]], optional): A list of detected keypoints for each object.
-
     Attributes:
-        orig_img (numpy.ndarray): The original image as a numpy array.
-        orig_shape (tuple): The original image shape in (height, width) format.
-        boxes (Boxes, optional): A Boxes object containing the detection bounding boxes.
-        masks (Masks, optional): A Masks object containing the detection masks.
-        probs (Probs, optional): A Probs object containing probabilities of each class for classification task.
-        keypoints (Keypoints, optional): A Keypoints object containing detected keypoints for each object.
-        speed (dict): A dictionary of preprocess, inference, and postprocess speeds in milliseconds per image.
-        names (dict): A dictionary of class names.
-        path (str): The path to the image file.
-        _keys (tuple): A tuple of attribute names for non-empty attributes.
+        orig_img (numpy.ndarray): Original image as a numpy array.
+        orig_shape (tuple): Original image shape in (height, width) format.
+        boxes (Boxes, optional): Object containing detection bounding boxes.
+        masks (Masks, optional): Object containing detection masks.
+        probs (Probs, optional): Object containing class probabilities for classification tasks.
+        keypoints (Keypoints, optional): Object containing detected keypoints for each object.
+        speed (dict): Dictionary of preprocess, inference, and postprocess speeds (ms/image).
+        names (dict): Dictionary of class names.
+        path (str): Path to the image file.
+
+    Methods:
+        update(boxes=None, masks=None, probs=None, obb=None): Updates object attributes with new detection results.
+        cpu(): Returns a copy of the Results object with all tensors on CPU memory.
+        numpy(): Returns a copy of the Results object with all tensors as numpy arrays.
+        cuda(): Returns a copy of the Results object with all tensors on GPU memory.
+        to(*args, **kwargs): Returns a copy of the Results object with tensors on a specified device and dtype.
+        new(): Returns a new Results object with the same image, path, and names.
+        plot(...): Plots detection results on an input image, returning an annotated image.
+        show(): Show annotated results to screen.
+        save(filename): Save annotated results to file.
+        verbose(): Returns a log string for each task, detailing detections and classifications.
+        save_txt(txt_file, save_conf=False): Saves detection results to a text file.
+        save_crop(save_dir, file_name=Path("im.jpg")): Saves cropped detection images.
+        tojson(normalize=False): Converts detection results to JSON format.
     """
 
-    def __init__(self, orig_img, path, names, boxes=None, masks=None, probs=None, keypoints=None) -> None:
-        """Initialize the Results class."""
+    def __init__(self, orig_img, path, names, boxes=None, masks=None, probs=None, keypoints=None, obb=None) -> None:
+        """
+        Initialize the Results class.
+
+        Args:
+            orig_img (numpy.ndarray): The original image as a numpy array.
+            path (str): The path to the image file.
+            names (dict): A dictionary of class names.
+            boxes (torch.tensor, optional): A 2D tensor of bounding box coordinates for each detection.
+            masks (torch.tensor, optional): A 3D tensor of detection masks, where each mask is a binary image.
+            probs (torch.tensor, optional): A 1D tensor of probabilities of each class for classification task.
+            keypoints (torch.tensor, optional): A 2D tensor of keypoint coordinates for each detection.
+            obb (torch.tensor, optional): A 2D tensor of oriented bounding box coordinates for each detection.
+        """
         self.orig_img = orig_img
         self.orig_shape = orig_img.shape[:2]
         self.boxes = Boxes(boxes, self.orig_shape) if boxes is not None else None  # native size boxes
         self.masks = Masks(masks, self.orig_shape) if masks is not None else None  # native size or imgsz masks
         self.probs = Probs(probs) if probs is not None else None
         self.keypoints = Keypoints(keypoints, self.orig_shape) if keypoints is not None else None
-        self.speed = {'preprocess': None, 'inference': None, 'postprocess': None}  # milliseconds per image
+        self.obb = OBB(obb, self.orig_shape) if obb is not None else None
+        self.speed = {"preprocess": None, "inference": None, "postprocess": None}  # milliseconds per image
         self.names = names
         self.path = path
         self.save_dir = None
-        self._keys = 'boxes', 'masks', 'probs', 'keypoints'
+        self._keys = "boxes", "masks", "probs", "keypoints", "obb"
 
     def __getitem__(self, idx):
         """Return a Results object for the specified index."""
-        return self._apply('__getitem__', idx)
+        return self._apply("__getitem__", idx)
 
     def __len__(self):
         """Return the number of detections in the Results object."""
         for k in self._keys:
             v = getattr(self, k)
             if v is not None:
                 return len(v)
 
-    def update(self, boxes=None, masks=None, probs=None):
+    def update(self, boxes=None, masks=None, probs=None, obb=None):
         """Update the boxes, masks, and probs attributes of the Results object."""
         if boxes is not None:
-            ops.clip_boxes(boxes, self.orig_shape)  # clip boxes
-            self.boxes = Boxes(boxes, self.orig_shape)
+            self.boxes = Boxes(ops.clip_boxes(boxes, self.orig_shape), self.orig_shape)
         if masks is not None:
             self.masks = Masks(masks, self.orig_shape)
         if probs is not None:
             self.probs = probs
+        if obb is not None:
+            self.obb = OBB(obb, self.orig_shape)
 
     def _apply(self, fn, *args, **kwargs):
         """
         Applies a function to all non-empty attributes and returns a new Results object with modified attributes. This
         function is internally called by methods like .to(), .cuda(), .cpu(), etc.
 
         Args:
@@ -142,47 +161,50 @@
             v = getattr(self, k)
             if v is not None:
                 setattr(r, k, getattr(v, fn)(*args, **kwargs))
         return r
 
     def cpu(self):
         """Return a copy of the Results object with all tensors on CPU memory."""
-        return self._apply('cpu')
+        return self._apply("cpu")
 
     def numpy(self):
         """Return a copy of the Results object with all tensors as numpy arrays."""
-        return self._apply('numpy')
+        return self._apply("numpy")
 
     def cuda(self):
         """Return a copy of the Results object with all tensors on GPU memory."""
-        return self._apply('cuda')
+        return self._apply("cuda")
 
     def to(self, *args, **kwargs):
         """Return a copy of the Results object with tensors on the specified device and dtype."""
-        return self._apply('to', *args, **kwargs)
+        return self._apply("to", *args, **kwargs)
 
     def new(self):
         """Return a new Results object with the same image, path, and names."""
         return Results(orig_img=self.orig_img, path=self.path, names=self.names)
 
     def plot(
         self,
         conf=True,
         line_width=None,
         font_size=None,
-        font='Arial.ttf',
+        font="Arial.ttf",
         pil=False,
         img=None,
         im_gpu=None,
         kpt_radius=5,
         kpt_line=True,
         labels=True,
         boxes=True,
         masks=True,
         probs=True,
+        show=False,
+        save=False,
+        filename=None,
     ):
         """
         Plots the detection results on an input RGB image. Accepts a numpy array (cv2) or a PIL Image.
 
         Args:
             conf (bool): Whether to plot the detection confidence score.
             line_width (float, optional): The line width of the bounding boxes. If None, it is scaled to the image size.
@@ -193,14 +215,17 @@
             im_gpu (torch.Tensor): Normalized image in gpu with shape (1, 3, 640, 640), for faster mask plotting.
             kpt_radius (int, optional): Radius of the drawn keypoints. Default is 5.
             kpt_line (bool): Whether to draw lines connecting keypoints.
             labels (bool): Whether to plot the label of bounding boxes.
             boxes (bool): Whether to plot the bounding boxes.
             masks (bool): Whether to plot the masks.
             probs (bool): Whether to plot classification probability
+            show (bool): Whether to display the annotated image directly.
+            save (bool): Whether to save the annotated image to `filename`.
+            filename (str): Filename to save image to if save is True.
 
         Returns:
             (numpy.ndarray): A numpy array of the annotated image.
 
         Example:
             ```python
             from PIL import Image
@@ -215,62 +240,89 @@
                 im.save('results.jpg')  # save image
             ```
         """
         if img is None and isinstance(self.orig_img, torch.Tensor):
             img = (self.orig_img[0].detach().permute(1, 2, 0).contiguous() * 255).to(torch.uint8).cpu().numpy()
 
         names = self.names
-        pred_boxes, show_boxes = self.boxes, boxes
+        is_obb = self.obb is not None
+        pred_boxes, show_boxes = self.obb if is_obb else self.boxes, boxes
         pred_masks, show_masks = self.masks, masks
         pred_probs, show_probs = self.probs, probs
         annotator = Annotator(
             deepcopy(self.orig_img if img is None else img),
             line_width,
             font_size,
             font,
             pil or (pred_probs is not None and show_probs),  # Classify tasks default to pil=True
-            example=names)
+            example=names,
+        )
 
         # Plot Segment results
         if pred_masks and show_masks:
             if im_gpu is None:
                 img = LetterBox(pred_masks.shape[1:])(image=annotator.result())
-                im_gpu = torch.as_tensor(img, dtype=torch.float16, device=pred_masks.data.device).permute(
-                    2, 0, 1).flip(0).contiguous() / 255
+                im_gpu = (
+                    torch.as_tensor(img, dtype=torch.float16, device=pred_masks.data.device)
+                    .permute(2, 0, 1)
+                    .flip(0)
+                    .contiguous()
+                    / 255
+                )
             idx = pred_boxes.cls if pred_boxes else range(len(pred_masks))
             annotator.masks(pred_masks.data, colors=[colors(x, True) for x in idx], im_gpu=im_gpu)
 
         # Plot Detect results
-        if pred_boxes and show_boxes:
+        if pred_boxes is not None and show_boxes:
             for d in reversed(pred_boxes):
                 c, conf, id = int(d.cls), float(d.conf) if conf else None, None if d.id is None else int(d.id.item())
-                name = ('' if id is None else f'id:{id} ') + names[c]
-                label = (f'{name} {conf:.2f}' if conf else name) if labels else None
-                annotator.box_label(d.xyxy.squeeze(), label, color=colors(c, True))
+                name = ("" if id is None else f"id:{id} ") + names[c]
+                label = (f"{name} {conf:.2f}" if conf else name) if labels else None
+                box = d.xyxyxyxy.reshape(-1, 4, 2).squeeze() if is_obb else d.xyxy.squeeze()
+                annotator.box_label(box, label, color=colors(c, True), rotated=is_obb)
 
         # Plot Classify results
         if pred_probs is not None and show_probs:
-            text = ',\n'.join(f'{names[j] if names else j} {pred_probs.data[j]:.2f}' for j in pred_probs.top5)
+            text = ",\n".join(f"{names[j] if names else j} {pred_probs.data[j]:.2f}" for j in pred_probs.top5)
             x = round(self.orig_shape[0] * 0.03)
             annotator.text([x, x], text, txt_color=(255, 255, 255))  # TODO: allow setting colors
 
         # Plot Pose results
         if self.keypoints is not None:
             for k in reversed(self.keypoints.data):
                 annotator.kpts(k, self.orig_shape, radius=kpt_radius, kpt_line=kpt_line)
 
+        # Show results
+        if show:
+            annotator.show(self.path)
+
+        # Save results
+        if save:
+            annotator.save(filename)
+
         return annotator.result()
 
+    def show(self, *args, **kwargs):
+        """Show annotated results image."""
+        self.plot(show=True, *args, **kwargs)
+
+    def save(self, filename=None, *args, **kwargs):
+        """Save annotated results image."""
+        if not filename:
+            filename = f"results_{Path(self.path).name}"
+        self.plot(save=True, filename=filename, *args, **kwargs)
+        return filename
+
     def verbose(self):
         """Return log string for each task."""
-        log_string = ''
+        log_string = ""
         probs = self.probs
         boxes = self.boxes
         if len(self) == 0:
-            return log_string if probs is not None else f'{log_string}(no detections), '
+            return log_string if probs is not None else f"{log_string}(no detections), "
         if probs is not None:
             log_string += f"{', '.join(f'{self.names[j]} {probs.data[j]:.2f}' for j in probs.top5)}, "
         if boxes:
             for c in boxes.cls.unique():
                 n = (boxes.cls == c).sum()  # detections per class
                 log_string += f"{n} {self.names[int(c)]}{'s' * (n > 1)}, "
         return log_string
@@ -279,123 +331,150 @@
         """
         Save predictions into txt file.
 
         Args:
             txt_file (str): txt file path.
             save_conf (bool): save confidence score or not.
         """
-        boxes = self.boxes
+        is_obb = self.obb is not None
+        boxes = self.obb if is_obb else self.boxes
         masks = self.masks
         probs = self.probs
         kpts = self.keypoints
         texts = []
         if probs is not None:
             # Classify
-            [texts.append(f'{probs.data[j]:.2f} {self.names[j]}') for j in probs.top5]
+            [texts.append(f"{probs.data[j]:.2f} {self.names[j]}") for j in probs.top5]
         elif boxes:
             # Detect/segment/pose
             for j, d in enumerate(boxes):
                 c, conf, id = int(d.cls), float(d.conf), None if d.id is None else int(d.id.item())
-                line = (c, *d.xywhn.view(-1))
+                line = (c, *(d.xyxyxyxyn.view(-1) if is_obb else d.xywhn.view(-1)))
                 if masks:
                     seg = masks[j].xyn[0].copy().reshape(-1)  # reversed mask.xyn, (n,2) to (n*2)
                     line = (c, *seg)
                 if kpts is not None:
                     kpt = torch.cat((kpts[j].xyn, kpts[j].conf[..., None]), 2) if kpts[j].has_visible else kpts[j].xyn
-                    line += (*kpt.reshape(-1).tolist(), )
-                line += (conf, ) * save_conf + (() if id is None else (id, ))
-                texts.append(('%g ' * len(line)).rstrip() % line)
+                    line += (*kpt.reshape(-1).tolist(),)
+                line += (conf,) * save_conf + (() if id is None else (id,))
+                texts.append(("%g " * len(line)).rstrip() % line)
 
         if texts:
             Path(txt_file).parent.mkdir(parents=True, exist_ok=True)  # make directory
-            with open(txt_file, 'a') as f:
-                f.writelines(text + '\n' for text in texts)
+            with open(txt_file, "a") as f:
+                f.writelines(text + "\n" for text in texts)
 
-    def save_crop(self, save_dir, file_name=Path('im.jpg')):
+    def save_crop(self, save_dir, file_name=Path("im.jpg")):
         """
         Save cropped predictions to `save_dir/cls/file_name.jpg`.
 
         Args:
             save_dir (str | pathlib.Path): Save path.
             file_name (str | pathlib.Path): File name.
         """
         if self.probs is not None:
-            LOGGER.warning('WARNING  Classify task do not support `save_crop`.')
+            LOGGER.warning("WARNING  Classify task do not support `save_crop`.")
+            return
+        if self.obb is not None:
+            LOGGER.warning("WARNING  OBB task do not support `save_crop`.")
             return
         for d in self.boxes:
-            save_one_box(d.xyxy,
-                         self.orig_img.copy(),
-                         file=Path(save_dir) / self.names[int(d.cls)] / f'{Path(file_name).stem}.jpg',
-                         BGR=True)
+            save_one_box(
+                d.xyxy,
+                self.orig_img.copy(),
+                file=Path(save_dir) / self.names[int(d.cls)] / f"{Path(file_name)}.jpg",
+                BGR=True,
+            )
 
-    def tojson(self, normalize=False):
-        """Convert the object to JSON format."""
+    def summary(self, normalize=False, decimals=5):
+        """Convert the results to a summarized format."""
         if self.probs is not None:
-            LOGGER.warning('Warning: Classify task do not support `tojson` yet.')
+            LOGGER.warning("Warning: Classify results do not support the `summary()` method yet.")
             return
 
-        import json
-
         # Create list of detection dictionaries
         results = []
         data = self.boxes.data.cpu().tolist()
         h, w = self.orig_shape if normalize else (1, 1)
         for i, row in enumerate(data):  # xyxy, track_id if tracking, conf, class_id
-            box = {'x1': row[0] / w, 'y1': row[1] / h, 'x2': row[2] / w, 'y2': row[3] / h}
-            conf = row[-2]
+            box = {
+                "x1": round(row[0] / w, decimals),
+                "y1": round(row[1] / h, decimals),
+                "x2": round(row[2] / w, decimals),
+                "y2": round(row[3] / h, decimals),
+            }
+            conf = round(row[-2], decimals)
             class_id = int(row[-1])
-            name = self.names[class_id]
-            result = {'name': name, 'class': class_id, 'confidence': conf, 'box': box}
+            result = {"name": self.names[class_id], "class": class_id, "confidence": conf, "box": box}
             if self.boxes.is_track:
-                result['track_id'] = int(row[-3])  # track ID
+                result["track_id"] = int(row[-3])  # track ID
             if self.masks:
-                x, y = self.masks.xy[i][:, 0], self.masks.xy[i][:, 1]  # numpy array
-                result['segments'] = {'x': (x / w).tolist(), 'y': (y / h).tolist()}
+                result["segments"] = {
+                    "x": (self.masks.xy[i][:, 0] / w).round(decimals).tolist(),
+                    "y": (self.masks.xy[i][:, 1] / h).round(decimals).tolist(),
+                }
             if self.keypoints is not None:
                 x, y, visible = self.keypoints[i].data[0].cpu().unbind(dim=1)  # torch Tensor
-                result['keypoints'] = {'x': (x / w).tolist(), 'y': (y / h).tolist(), 'visible': visible.tolist()}
+                result["keypoints"] = {
+                    "x": (x / w).numpy().round(decimals).tolist(),  # decimals named argument required
+                    "y": (y / h).numpy().round(decimals).tolist(),
+                    "visible": visible.numpy().round(decimals).tolist(),
+                }
             results.append(result)
 
-        # Convert detections to JSON
-        return json.dumps(results, indent=2)
+        return results
+
+    def tojson(self, normalize=False, decimals=5):
+        """Convert the results to JSON format."""
+        import json
+
+        return json.dumps(self.summary(normalize=normalize, decimals=decimals), indent=2)
 
 
 class Boxes(BaseTensor):
     """
-    A class for storing and manipulating detection boxes.
-
-    Args:
-        boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes,
-            with shape (num_boxes, 6) or (num_boxes, 7). The last two columns contain confidence and class values.
-            If present, the third last column contains track IDs.
-        orig_shape (tuple): Original image size, in the format (height, width).
+    Manages detection boxes, providing easy access and manipulation of box coordinates, confidence scores, class
+    identifiers, and optional tracking IDs. Supports multiple formats for box coordinates, including both absolute and
+    normalized forms.
 
     Attributes:
-        xyxy (torch.Tensor | numpy.ndarray): The boxes in xyxy format.
-        conf (torch.Tensor | numpy.ndarray): The confidence values of the boxes.
-        cls (torch.Tensor | numpy.ndarray): The class values of the boxes.
-        id (torch.Tensor | numpy.ndarray): The track IDs of the boxes (if available).
-        xywh (torch.Tensor | numpy.ndarray): The boxes in xywh format.
-        xyxyn (torch.Tensor | numpy.ndarray): The boxes in xyxy format normalized by original image size.
-        xywhn (torch.Tensor | numpy.ndarray): The boxes in xywh format normalized by original image size.
-        data (torch.Tensor): The raw bboxes tensor (alias for `boxes`).
+        data (torch.Tensor): The raw tensor containing detection boxes and their associated data.
+        orig_shape (tuple): The original image size as a tuple (height, width), used for normalization.
+        is_track (bool): Indicates whether tracking IDs are included in the box data.
+
+    Properties:
+        xyxy (torch.Tensor | numpy.ndarray): Boxes in [x1, y1, x2, y2] format.
+        conf (torch.Tensor | numpy.ndarray): Confidence scores for each box.
+        cls (torch.Tensor | numpy.ndarray): Class labels for each box.
+        id (torch.Tensor | numpy.ndarray, optional): Tracking IDs for each box, if available.
+        xywh (torch.Tensor | numpy.ndarray): Boxes in [x, y, width, height] format, calculated on demand.
+        xyxyn (torch.Tensor | numpy.ndarray): Normalized [x1, y1, x2, y2] boxes, relative to `orig_shape`.
+        xywhn (torch.Tensor | numpy.ndarray): Normalized [x, y, width, height] boxes, relative to `orig_shape`.
 
     Methods:
-        cpu(): Move the object to CPU memory.
-        numpy(): Convert the object to a numpy array.
-        cuda(): Move the object to CUDA memory.
-        to(*args, **kwargs): Move the object to the specified device.
+        cpu(): Moves the boxes to CPU memory.
+        numpy(): Converts the boxes to a numpy array format.
+        cuda(): Moves the boxes to CUDA (GPU) memory.
+        to(device, dtype=None): Moves the boxes to the specified device.
     """
 
     def __init__(self, boxes, orig_shape) -> None:
-        """Initialize the Boxes class."""
+        """
+        Initialize the Boxes class.
+
+        Args:
+            boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes, with
+                shape (num_boxes, 6) or (num_boxes, 7). The last two columns contain confidence and class values.
+                If present, the third last column contains track IDs.
+            orig_shape (tuple): Original image size, in the format (height, width).
+        """
         if boxes.ndim == 1:
             boxes = boxes[None, :]
         n = boxes.shape[-1]
-        assert n in (6, 7), f'expected `n` in [6, 7], but got {n}'  # xyxy, track_id, conf, cls
+        assert n in {6, 7}, f"expected 6 or 7 values but got {n}"  # xyxy, track_id, conf, cls
         super().__init__(boxes, orig_shape)
         self.is_track = n == 7
         self.orig_shape = orig_shape
 
     @property
     def xyxy(self):
         """Return the boxes in xyxy format."""
@@ -464,23 +543,25 @@
 
     @property
     @lru_cache(maxsize=1)
     def xyn(self):
         """Return normalized segments."""
         return [
             ops.scale_coords(self.data.shape[1:], x, self.orig_shape, normalize=True)
-            for x in ops.masks2segments(self.data)]
+            for x in ops.masks2segments(self.data)
+        ]
 
     @property
     @lru_cache(maxsize=1)
     def xy(self):
         """Return segments in pixel coordinates."""
         return [
             ops.scale_coords(self.data.shape[1:], x, self.orig_shape, normalize=False)
-            for x in ops.masks2segments(self.data)]
+            for x in ops.masks2segments(self.data)
+        ]
 
 
 class Keypoints(BaseTensor):
     """
     A class for storing and manipulating detection keypoints.
 
     Attributes:
@@ -568,7 +649,95 @@
         return self.data[self.top1]
 
     @property
     @lru_cache(maxsize=1)
     def top5conf(self):
         """Return the confidences of top 5."""
         return self.data[self.top5]
+
+
+class OBB(BaseTensor):
+    """
+    A class for storing and manipulating Oriented Bounding Boxes (OBB).
+
+    Args:
+        boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes,
+            with shape (num_boxes, 7) or (num_boxes, 8). The last two columns contain confidence and class values.
+            If present, the third last column contains track IDs, and the fifth column from the left contains rotation.
+        orig_shape (tuple): Original image size, in the format (height, width).
+
+    Attributes:
+        xywhr (torch.Tensor | numpy.ndarray): The boxes in [x_center, y_center, width, height, rotation] format.
+        conf (torch.Tensor | numpy.ndarray): The confidence values of the boxes.
+        cls (torch.Tensor | numpy.ndarray): The class values of the boxes.
+        id (torch.Tensor | numpy.ndarray): The track IDs of the boxes (if available).
+        xyxyxyxyn (torch.Tensor | numpy.ndarray): The rotated boxes in xyxyxyxy format normalized by orig image size.
+        xyxyxyxy (torch.Tensor | numpy.ndarray): The rotated boxes in xyxyxyxy format.
+        xyxy (torch.Tensor | numpy.ndarray): The horizontal boxes in xyxyxyxy format.
+        data (torch.Tensor): The raw OBB tensor (alias for `boxes`).
+
+    Methods:
+        cpu(): Move the object to CPU memory.
+        numpy(): Convert the object to a numpy array.
+        cuda(): Move the object to CUDA memory.
+        to(*args, **kwargs): Move the object to the specified device.
+    """
+
+    def __init__(self, boxes, orig_shape) -> None:
+        """Initialize the Boxes class."""
+        if boxes.ndim == 1:
+            boxes = boxes[None, :]
+        n = boxes.shape[-1]
+        assert n in {7, 8}, f"expected 7 or 8 values but got {n}"  # xywh, rotation, track_id, conf, cls
+        super().__init__(boxes, orig_shape)
+        self.is_track = n == 8
+        self.orig_shape = orig_shape
+
+    @property
+    def xywhr(self):
+        """Return the rotated boxes in xywhr format."""
+        return self.data[:, :5]
+
+    @property
+    def conf(self):
+        """Return the confidence values of the boxes."""
+        return self.data[:, -2]
+
+    @property
+    def cls(self):
+        """Return the class values of the boxes."""
+        return self.data[:, -1]
+
+    @property
+    def id(self):
+        """Return the track IDs of the boxes (if available)."""
+        return self.data[:, -3] if self.is_track else None
+
+    @property
+    @lru_cache(maxsize=2)
+    def xyxyxyxy(self):
+        """Return the boxes in xyxyxyxy format, (N, 4, 2)."""
+        return ops.xywhr2xyxyxyxy(self.xywhr)
+
+    @property
+    @lru_cache(maxsize=2)
+    def xyxyxyxyn(self):
+        """Return the boxes in xyxyxyxy format, (N, 4, 2)."""
+        xyxyxyxyn = self.xyxyxyxy.clone() if isinstance(self.xyxyxyxy, torch.Tensor) else np.copy(self.xyxyxyxy)
+        xyxyxyxyn[..., 0] /= self.orig_shape[1]
+        xyxyxyxyn[..., 1] /= self.orig_shape[0]
+        return xyxyxyxyn
+
+    @property
+    @lru_cache(maxsize=2)
+    def xyxy(self):
+        """
+        Return the horizontal boxes in xyxy format, (N, 4).
+
+        Accepts both torch and numpy boxes.
+        """
+        x1 = self.xyxyxyxy[..., 0].min(1).values
+        x2 = self.xyxyxyxy[..., 0].max(1).values
+        y1 = self.xyxyxyxy[..., 1].min(1).values
+        y2 = self.xyxyxyxy[..., 1].max(1).values
+        xyxy = [x1, y1, x2, y2]
+        return np.stack(xyxy, axis=-1) if isinstance(self.data, np.ndarray) else torch.stack(xyxy, dim=-1)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/engine/trainer.py` & `yolov8_pose_triton-8.2.0/ultralytics/engine/trainer.py`

 * *Files 5% similar despite different names*

```diff
@@ -19,22 +19,39 @@
 import torch
 from torch import distributed as dist
 from torch import nn, optim
 
 from ultralytics.cfg import get_cfg, get_save_dir
 from ultralytics.data.utils import check_cls_dataset, check_det_dataset
 from ultralytics.nn.tasks import attempt_load_one_weight, attempt_load_weights
-from ultralytics.utils import (DEFAULT_CFG, LOGGER, RANK, TQDM, __version__, callbacks, clean_url, colorstr, emojis,
-                               yaml_save)
+from ultralytics.utils import (
+    DEFAULT_CFG,
+    LOGGER,
+    RANK,
+    TQDM,
+    __version__,
+    callbacks,
+    clean_url,
+    colorstr,
+    emojis,
+    yaml_save,
+)
 from ultralytics.utils.autobatch import check_train_batch_size
 from ultralytics.utils.checks import check_amp, check_file, check_imgsz, check_model_file_from_stem, print_args
 from ultralytics.utils.dist import ddp_cleanup, generate_ddp_command
 from ultralytics.utils.files import get_latest_run
-from ultralytics.utils.torch_utils import (EarlyStopping, ModelEMA, de_parallel, init_seeds, one_cycle, select_device,
-                                           strip_optimizer)
+from ultralytics.utils.torch_utils import (
+    EarlyStopping,
+    ModelEMA,
+    convert_optimizer_state_dict_to_fp16,
+    init_seeds,
+    one_cycle,
+    select_device,
+    strip_optimizer,
+)
 
 
 class BaseTrainer:
     """
     BaseTrainer.
 
     A base class for creating trainers.
@@ -85,64 +102,53 @@
         self.metrics = None
         self.plots = {}
         init_seeds(self.args.seed + 1 + RANK, deterministic=self.args.deterministic)
 
         # Dirs
         self.save_dir = get_save_dir(self.args)
         self.args.name = self.save_dir.name  # update name for loggers
-        self.wdir = self.save_dir / 'weights'  # weights dir
-        if RANK in (-1, 0):
+        self.wdir = self.save_dir / "weights"  # weights dir
+        if RANK in {-1, 0}:
             self.wdir.mkdir(parents=True, exist_ok=True)  # make dir
             self.args.save_dir = str(self.save_dir)
-            yaml_save(self.save_dir / 'args.yaml', vars(self.args))  # save run args
-        self.last, self.best = self.wdir / 'last.pt', self.wdir / 'best.pt'  # checkpoint paths
+            yaml_save(self.save_dir / "args.yaml", vars(self.args))  # save run args
+        self.last, self.best = self.wdir / "last.pt", self.wdir / "best.pt"  # checkpoint paths
         self.save_period = self.args.save_period
 
         self.batch_size = self.args.batch
         self.epochs = self.args.epochs
         self.start_epoch = 0
         if RANK == -1:
             print_args(vars(self.args))
 
         # Device
-        if self.device.type in ('cpu', 'mps'):
+        if self.device.type in {"cpu", "mps"}:
             self.args.workers = 0  # faster CPU training as time dominated by inference, not dataloading
 
         # Model and Dataset
         self.model = check_model_file_from_stem(self.args.model)  # add suffix, i.e. yolov8n -> yolov8n.pt
-        try:
-            if self.args.task == 'classify':
-                self.data = check_cls_dataset(self.args.data)
-            elif self.args.data.split('.')[-1] in ('yaml', 'yml') or self.args.task in ('detect', 'segment', 'pose'):
-                self.data = check_det_dataset(self.args.data)
-                if 'yaml_file' in self.data:
-                    self.args.data = self.data['yaml_file']  # for validating 'yolo train data=url.zip' usage
-        except Exception as e:
-            raise RuntimeError(emojis(f"Dataset '{clean_url(self.args.data)}' error  {e}")) from e
-
-        self.trainset, self.testset = self.get_dataset(self.data)
+        self.trainset, self.testset = self.get_dataset()
         self.ema = None
-        self.resume = False
 
         # Optimization utils init
         self.lf = None
         self.scheduler = None
 
         # Epoch level metrics
         self.best_fitness = None
         self.fitness = None
         self.loss = None
         self.tloss = None
-        self.loss_names = ['Loss']
-        self.csv = self.save_dir / 'results.csv'
+        self.loss_names = ["Loss"]
+        self.csv = self.save_dir / "results.csv"
         self.plot_idx = [0, 1, 2]
 
         # Callbacks
         self.callbacks = _callbacks or callbacks.get_default_callbacks()
-        if RANK in (-1, 0):
+        if RANK in {-1, 0}:
             callbacks.add_integration_callbacks(self)
 
     def add_callback(self, event: str, callback):
         """Appends the given callback."""
         self.callbacks[event].append(callback)
 
     def set_callback(self, event: str, callback):
@@ -153,31 +159,33 @@
         """Run all existing callbacks associated with a particular event."""
         for callback in self.callbacks.get(event, []):
             callback(self)
 
     def train(self):
         """Allow device='', device=None on Multi-GPU systems to default to device=0."""
         if isinstance(self.args.device, str) and len(self.args.device):  # i.e. device='0' or device='0,1,2,3'
-            world_size = len(self.args.device.split(','))
+            world_size = len(self.args.device.split(","))
         elif isinstance(self.args.device, (tuple, list)):  # i.e. device=[0, 1, 2, 3] (multi-GPU from CLI is list)
             world_size = len(self.args.device)
         elif torch.cuda.is_available():  # i.e. device=None or device='' or device=number
             world_size = 1  # default to device 0
         else:  # i.e. device='cpu' or 'mps'
             world_size = 0
 
         # Run subprocess if DDP training, else train normally
-        if world_size > 1 and 'LOCAL_RANK' not in os.environ:
+        if world_size > 1 and "LOCAL_RANK" not in os.environ:
             # Argument checks
             if self.args.rect:
                 LOGGER.warning("WARNING  'rect=True' is incompatible with Multi-GPU training, setting 'rect=False'")
                 self.args.rect = False
             if self.args.batch == -1:
-                LOGGER.warning("WARNING  'batch=-1' for AutoBatch is incompatible with Multi-GPU training, setting "
-                               "default 'batch=16'")
+                LOGGER.warning(
+                    "WARNING  'batch=-1' for AutoBatch is incompatible with Multi-GPU training, setting "
+                    "default 'batch=16'"
+                )
                 self.args.batch = 16
 
             # Command
             cmd, file = generate_ddp_command(world_size, self)
             try:
                 LOGGER.info(f'{colorstr("DDP:")} debug command {" ".join(cmd)}')
                 subprocess.run(cmd, check=True)
@@ -185,280 +193,346 @@
                 raise e
             finally:
                 ddp_cleanup(self, str(file))
 
         else:
             self._do_train(world_size)
 
+    def _setup_scheduler(self):
+        """Initialize training learning rate scheduler."""
+        if self.args.cos_lr:
+            self.lf = one_cycle(1, self.args.lrf, self.epochs)  # cosine 1->hyp['lrf']
+        else:
+            self.lf = lambda x: max(1 - x / self.epochs, 0) * (1.0 - self.args.lrf) + self.args.lrf  # linear
+        self.scheduler = optim.lr_scheduler.LambdaLR(self.optimizer, lr_lambda=self.lf)
+
     def _setup_ddp(self, world_size):
         """Initializes and sets the DistributedDataParallel parameters for training."""
         torch.cuda.set_device(RANK)
-        self.device = torch.device('cuda', RANK)
+        self.device = torch.device("cuda", RANK)
         # LOGGER.info(f'DDP info: RANK {RANK}, WORLD_SIZE {world_size}, DEVICE {self.device}')
-        os.environ['NCCL_BLOCKING_WAIT'] = '1'  # set to enforce timeout
+        os.environ["TORCH_NCCL_BLOCKING_WAIT"] = "1"  # set to enforce timeout
         dist.init_process_group(
-            'nccl' if dist.is_nccl_available() else 'gloo',
+            backend="nccl" if dist.is_nccl_available() else "gloo",
             timeout=timedelta(seconds=10800),  # 3 hours
             rank=RANK,
-            world_size=world_size)
+            world_size=world_size,
+        )
 
     def _setup_train(self, world_size):
         """Builds dataloaders and optimizer on correct rank process."""
 
         # Model
-        self.run_callbacks('on_pretrain_routine_start')
+        self.run_callbacks("on_pretrain_routine_start")
         ckpt = self.setup_model()
         self.model = self.model.to(self.device)
         self.set_model_attributes()
 
         # Freeze layers
-        freeze_list = self.args.freeze if isinstance(
-            self.args.freeze, list) else range(self.args.freeze) if isinstance(self.args.freeze, int) else []
-        always_freeze_names = ['.dfl']  # always freeze these layers
-        freeze_layer_names = [f'model.{x}.' for x in freeze_list] + always_freeze_names
+        freeze_list = (
+            self.args.freeze
+            if isinstance(self.args.freeze, list)
+            else range(self.args.freeze)
+            if isinstance(self.args.freeze, int)
+            else []
+        )
+        always_freeze_names = [".dfl"]  # always freeze these layers
+        freeze_layer_names = [f"model.{x}." for x in freeze_list] + always_freeze_names
         for k, v in self.model.named_parameters():
             # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN to 0 (commented for erratic training results)
             if any(x in k for x in freeze_layer_names):
                 LOGGER.info(f"Freezing layer '{k}'")
                 v.requires_grad = False
-            elif not v.requires_grad:
-                LOGGER.info(f"WARNING  setting 'requires_grad=True' for frozen layer '{k}'. "
-                            'See ultralytics.engine.trainer for customization of frozen layers.')
+            elif not v.requires_grad and v.dtype.is_floating_point:  # only floating point Tensor can require gradients
+                LOGGER.info(
+                    f"WARNING  setting 'requires_grad=True' for frozen layer '{k}'. "
+                    "See ultralytics.engine.trainer for customization of frozen layers."
+                )
                 v.requires_grad = True
 
         # Check AMP
         self.amp = torch.tensor(self.args.amp).to(self.device)  # True or False
-        if self.amp and RANK in (-1, 0):  # Single-GPU and DDP
+        if self.amp and RANK in {-1, 0}:  # Single-GPU and DDP
             callbacks_backup = callbacks.default_callbacks.copy()  # backup callbacks as check_amp() resets them
             self.amp = torch.tensor(check_amp(self.model), device=self.device)
             callbacks.default_callbacks = callbacks_backup  # restore callbacks
         if RANK > -1 and world_size > 1:  # DDP
             dist.broadcast(self.amp, src=0)  # broadcast the tensor from rank 0 to all other ranks (returns None)
         self.amp = bool(self.amp)  # as boolean
         self.scaler = torch.cuda.amp.GradScaler(enabled=self.amp)
         if world_size > 1:
             self.model = nn.parallel.DistributedDataParallel(self.model, device_ids=[RANK])
 
         # Check imgsz
-        gs = max(int(self.model.stride.max() if hasattr(self.model, 'stride') else 32), 32)  # grid size (max stride)
+        gs = max(int(self.model.stride.max() if hasattr(self.model, "stride") else 32), 32)  # grid size (max stride)
         self.args.imgsz = check_imgsz(self.args.imgsz, stride=gs, floor=gs, max_dim=1)
+        self.stride = gs  # for multiscale training
 
         # Batch size
         if self.batch_size == -1 and RANK == -1:  # single-GPU only, estimate best batch size
             self.args.batch = self.batch_size = check_train_batch_size(self.model, self.args.imgsz, self.amp)
 
         # Dataloaders
         batch_size = self.batch_size // max(world_size, 1)
-        self.train_loader = self.get_dataloader(self.trainset, batch_size=batch_size, rank=RANK, mode='train')
-        if RANK in (-1, 0):
-            self.test_loader = self.get_dataloader(self.testset, batch_size=batch_size * 2, rank=-1, mode='val')
+        self.train_loader = self.get_dataloader(self.trainset, batch_size=batch_size, rank=RANK, mode="train")
+        if RANK in {-1, 0}:
+            # Note: When training DOTA dataset, double batch size could get OOM on images with >2000 objects.
+            self.test_loader = self.get_dataloader(
+                self.testset, batch_size=batch_size if self.args.task == "obb" else batch_size * 2, rank=-1, mode="val"
+            )
             self.validator = self.get_validator()
-            metric_keys = self.validator.metrics.keys + self.label_loss_items(prefix='val')
+            metric_keys = self.validator.metrics.keys + self.label_loss_items(prefix="val")
             self.metrics = dict(zip(metric_keys, [0] * len(metric_keys)))
             self.ema = ModelEMA(self.model)
             if self.args.plots:
                 self.plot_training_labels()
 
         # Optimizer
         self.accumulate = max(round(self.args.nbs / self.batch_size), 1)  # accumulate loss before optimizing
         weight_decay = self.args.weight_decay * self.batch_size * self.accumulate / self.args.nbs  # scale weight_decay
         iterations = math.ceil(len(self.train_loader.dataset) / max(self.batch_size, self.args.nbs)) * self.epochs
-        self.optimizer = self.build_optimizer(model=self.model,
-                                              name=self.args.optimizer,
-                                              lr=self.args.lr0,
-                                              momentum=self.args.momentum,
-                                              decay=weight_decay,
-                                              iterations=iterations)
+        self.optimizer = self.build_optimizer(
+            model=self.model,
+            name=self.args.optimizer,
+            lr=self.args.lr0,
+            momentum=self.args.momentum,
+            decay=weight_decay,
+            iterations=iterations,
+        )
         # Scheduler
-        if self.args.cos_lr:
-            self.lf = one_cycle(1, self.args.lrf, self.epochs)  # cosine 1->hyp['lrf']
-        else:
-            self.lf = lambda x: (1 - x / self.epochs) * (1.0 - self.args.lrf) + self.args.lrf  # linear
-        self.scheduler = optim.lr_scheduler.LambdaLR(self.optimizer, lr_lambda=self.lf)
+        self._setup_scheduler()
         self.stopper, self.stop = EarlyStopping(patience=self.args.patience), False
         self.resume_training(ckpt)
         self.scheduler.last_epoch = self.start_epoch - 1  # do not move
-        self.run_callbacks('on_pretrain_routine_end')
+        self.run_callbacks("on_pretrain_routine_end")
 
     def _do_train(self, world_size=1):
         """Train completed, evaluate and plot if specified by arguments."""
         if world_size > 1:
             self._setup_ddp(world_size)
         self._setup_train(world_size)
 
-        self.epoch_time = None
-        self.epoch_time_start = time.time()
-        self.train_time_start = time.time()
         nb = len(self.train_loader)  # number of batches
         nw = max(round(self.args.warmup_epochs * nb), 100) if self.args.warmup_epochs > 0 else -1  # warmup iterations
         last_opt_step = -1
-        self.run_callbacks('on_train_start')
-        LOGGER.info(f'Image sizes {self.args.imgsz} train, {self.args.imgsz} val\n'
-                    f'Using {self.train_loader.num_workers * (world_size or 1)} dataloader workers\n'
-                    f"Logging results to {colorstr('bold', self.save_dir)}\n"
-                    f'Starting training for {self.epochs} epochs...')
+        self.epoch_time = None
+        self.epoch_time_start = time.time()
+        self.train_time_start = time.time()
+        self.run_callbacks("on_train_start")
+        LOGGER.info(
+            f'Image sizes {self.args.imgsz} train, {self.args.imgsz} val\n'
+            f'Using {self.train_loader.num_workers * (world_size or 1)} dataloader workers\n'
+            f"Logging results to {colorstr('bold', self.save_dir)}\n"
+            f'Starting training for ' + (f"{self.args.time} hours..." if self.args.time else f"{self.epochs} epochs...")
+        )
         if self.args.close_mosaic:
             base_idx = (self.epochs - self.args.close_mosaic) * nb
             self.plot_idx.extend([base_idx, base_idx + 1, base_idx + 2])
-        epoch = self.epochs  # predefine for resume fully trained model edge cases
-        for epoch in range(self.start_epoch, self.epochs):
+        epoch = self.start_epoch
+        while True:
             self.epoch = epoch
-            self.run_callbacks('on_train_epoch_start')
+            self.run_callbacks("on_train_epoch_start")
+            with warnings.catch_warnings():
+                warnings.simplefilter("ignore")  # suppress 'Detected lr_scheduler.step() before optimizer.step()'
+                self.scheduler.step()
+
             self.model.train()
             if RANK != -1:
                 self.train_loader.sampler.set_epoch(epoch)
             pbar = enumerate(self.train_loader)
             # Update dataloader attributes (optional)
             if epoch == (self.epochs - self.args.close_mosaic):
                 self._close_dataloader_mosaic()
                 self.train_loader.reset()
 
-            if RANK in (-1, 0):
+            if RANK in {-1, 0}:
                 LOGGER.info(self.progress_string())
                 pbar = TQDM(enumerate(self.train_loader), total=nb)
             self.tloss = None
             self.optimizer.zero_grad()
             for i, batch in pbar:
-                self.run_callbacks('on_train_batch_start')
+                self.run_callbacks("on_train_batch_start")
                 # Warmup
                 ni = i + nb * epoch
                 if ni <= nw:
                     xi = [0, nw]  # x interp
-                    self.accumulate = max(1, np.interp(ni, xi, [1, self.args.nbs / self.batch_size]).round())
+                    self.accumulate = max(1, int(np.interp(ni, xi, [1, self.args.nbs / self.batch_size]).round()))
                     for j, x in enumerate(self.optimizer.param_groups):
                         # Bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0
-                        x['lr'] = np.interp(
-                            ni, xi, [self.args.warmup_bias_lr if j == 0 else 0.0, x['initial_lr'] * self.lf(epoch)])
-                        if 'momentum' in x:
-                            x['momentum'] = np.interp(ni, xi, [self.args.warmup_momentum, self.args.momentum])
+                        x["lr"] = np.interp(
+                            ni, xi, [self.args.warmup_bias_lr if j == 0 else 0.0, x["initial_lr"] * self.lf(epoch)]
+                        )
+                        if "momentum" in x:
+                            x["momentum"] = np.interp(ni, xi, [self.args.warmup_momentum, self.args.momentum])
 
                 # Forward
                 with torch.cuda.amp.autocast(self.amp):
                     batch = self.preprocess_batch(batch)
                     self.loss, self.loss_items = self.model(batch)
                     if RANK != -1:
                         self.loss *= world_size
-                    self.tloss = (self.tloss * i + self.loss_items) / (i + 1) if self.tloss is not None \
-                        else self.loss_items
+                    self.tloss = (
+                        (self.tloss * i + self.loss_items) / (i + 1) if self.tloss is not None else self.loss_items
+                    )
 
                 # Backward
                 self.scaler.scale(self.loss).backward()
 
                 # Optimize - https://pytorch.org/docs/master/notes/amp_examples.html
                 if ni - last_opt_step >= self.accumulate:
                     self.optimizer_step()
                     last_opt_step = ni
 
+                    # Timed stopping
+                    if self.args.time:
+                        self.stop = (time.time() - self.train_time_start) > (self.args.time * 3600)
+                        if RANK != -1:  # if DDP training
+                            broadcast_list = [self.stop if RANK == 0 else None]
+                            dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks
+                            self.stop = broadcast_list[0]
+                        if self.stop:  # training time exceeded
+                            break
+
                 # Log
-                mem = f'{torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g}G'  # (GB)
-                loss_len = self.tloss.shape[0] if len(self.tloss.size()) else 1
+                mem = f"{torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g}G"  # (GB)
+                loss_len = self.tloss.shape[0] if len(self.tloss.shape) else 1
                 losses = self.tloss if loss_len > 1 else torch.unsqueeze(self.tloss, 0)
-                if RANK in (-1, 0):
+                if RANK in {-1, 0}:
                     pbar.set_description(
-                        ('%11s' * 2 + '%11.4g' * (2 + loss_len)) %
-                        (f'{epoch + 1}/{self.epochs}', mem, *losses, batch['cls'].shape[0], batch['img'].shape[-1]))
-                    self.run_callbacks('on_batch_end')
+                        ("%11s" * 2 + "%11.4g" * (2 + loss_len))
+                        % (f"{epoch + 1}/{self.epochs}", mem, *losses, batch["cls"].shape[0], batch["img"].shape[-1])
+                    )
+                    self.run_callbacks("on_batch_end")
                     if self.args.plots and ni in self.plot_idx:
                         self.plot_training_samples(batch, ni)
 
-                self.run_callbacks('on_train_batch_end')
-
-            self.lr = {f'lr/pg{ir}': x['lr'] for ir, x in enumerate(self.optimizer.param_groups)}  # for loggers
+                self.run_callbacks("on_train_batch_end")
 
-            with warnings.catch_warnings():
-                warnings.simplefilter('ignore')  # suppress 'Detected lr_scheduler.step() before optimizer.step()'
-                self.scheduler.step()
-            self.run_callbacks('on_train_epoch_end')
-
-            if RANK in (-1, 0):
+            self.lr = {f"lr/pg{ir}": x["lr"] for ir, x in enumerate(self.optimizer.param_groups)}  # for loggers
+            self.run_callbacks("on_train_epoch_end")
+            if RANK in {-1, 0}:
+                final_epoch = epoch + 1 >= self.epochs
+                self.ema.update_attr(self.model, include=["yaml", "nc", "args", "names", "stride", "class_weights"])
 
                 # Validation
-                self.ema.update_attr(self.model, include=['yaml', 'nc', 'args', 'names', 'stride', 'class_weights'])
-                final_epoch = (epoch + 1 == self.epochs) or self.stopper.possible_stop
-
-                if self.args.val or final_epoch:
+                if self.args.val or final_epoch or self.stopper.possible_stop or self.stop:
                     self.metrics, self.fitness = self.validate()
                 self.save_metrics(metrics={**self.label_loss_items(self.tloss), **self.metrics, **self.lr})
-                self.stop = self.stopper(epoch + 1, self.fitness)
+                self.stop |= self.stopper(epoch + 1, self.fitness) or final_epoch
+                if self.args.time:
+                    self.stop |= (time.time() - self.train_time_start) > (self.args.time * 3600)
 
                 # Save model
-                if self.args.save or (epoch + 1 == self.epochs):
+                if self.args.save or final_epoch:
                     self.save_model()
-                    self.run_callbacks('on_model_save')
+                    self.run_callbacks("on_model_save")
 
-            tnow = time.time()
-            self.epoch_time = tnow - self.epoch_time_start
-            self.epoch_time_start = tnow
-            self.run_callbacks('on_fit_epoch_end')
+            # Scheduler
+            t = time.time()
+            self.epoch_time = t - self.epoch_time_start
+            self.epoch_time_start = t
+            if self.args.time:
+                mean_epoch_time = (t - self.train_time_start) / (epoch - self.start_epoch + 1)
+                self.epochs = self.args.epochs = math.ceil(self.args.time * 3600 / mean_epoch_time)
+                self._setup_scheduler()
+                self.scheduler.last_epoch = self.epoch  # do not move
+                self.stop |= epoch >= self.epochs  # stop if exceeded epochs
+            self.run_callbacks("on_fit_epoch_end")
             torch.cuda.empty_cache()  # clear GPU memory at end of epoch, may help reduce CUDA out of memory errors
 
             # Early Stopping
             if RANK != -1:  # if DDP training
                 broadcast_list = [self.stop if RANK == 0 else None]
                 dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks
-                if RANK != 0:
-                    self.stop = broadcast_list[0]
+                self.stop = broadcast_list[0]
             if self.stop:
                 break  # must break all DDP ranks
+            epoch += 1
 
-        if RANK in (-1, 0):
+        if RANK in {-1, 0}:
             # Do final val with best.pt
-            LOGGER.info(f'\n{epoch - self.start_epoch + 1} epochs completed in '
-                        f'{(time.time() - self.train_time_start) / 3600:.3f} hours.')
+            LOGGER.info(
+                f"\n{epoch - self.start_epoch + 1} epochs completed in "
+                f"{(time.time() - self.train_time_start) / 3600:.3f} hours."
+            )
             self.final_eval()
             if self.args.plots:
                 self.plot_metrics()
-            self.run_callbacks('on_train_end')
+            self.run_callbacks("on_train_end")
         torch.cuda.empty_cache()
-        self.run_callbacks('teardown')
+        self.run_callbacks("teardown")
 
     def save_model(self):
         """Save model training checkpoints with additional metadata."""
-        import pandas as pd  # scope for faster startup
-        metrics = {**self.metrics, **{'fitness': self.fitness}}
-        results = {k.strip(): v for k, v in pd.read_csv(self.csv).to_dict(orient='list').items()}
-        ckpt = {
-            'epoch': self.epoch,
-            'best_fitness': self.best_fitness,
-            'model': deepcopy(de_parallel(self.model)).half(),
-            'ema': deepcopy(self.ema.ema).half(),
-            'updates': self.ema.updates,
-            'optimizer': self.optimizer.state_dict(),
-            'train_args': vars(self.args),  # save as dict
-            'train_metrics': metrics,
-            'train_results': results,
-            'date': datetime.now().isoformat(),
-            'version': __version__}
+        import io
 
-        # Save last and best
-        torch.save(ckpt, self.last)
+        import pandas as pd  # scope for faster 'import ultralytics'
+
+        # Serialize ckpt to a byte buffer once (faster than repeated torch.save() calls)
+        buffer = io.BytesIO()
+        torch.save(
+            {
+                "epoch": self.epoch,
+                "best_fitness": self.best_fitness,
+                "model": None,  # resume and final checkpoints derive from EMA
+                "ema": deepcopy(self.ema.ema).half(),
+                "updates": self.ema.updates,
+                "optimizer": convert_optimizer_state_dict_to_fp16(deepcopy(self.optimizer.state_dict())),
+                "train_args": vars(self.args),  # save as dict
+                "train_metrics": {**self.metrics, **{"fitness": self.fitness}},
+                "train_results": {k.strip(): v for k, v in pd.read_csv(self.csv).to_dict(orient="list").items()},
+                "date": datetime.now().isoformat(),
+                "version": __version__,
+                "license": "AGPL-3.0 (https://ultralytics.com/license)",
+                "docs": "https://docs.ultralytics.com",
+            },
+            buffer,
+        )
+        serialized_ckpt = buffer.getvalue()  # get the serialized content to save
+
+        # Save checkpoints
+        self.last.write_bytes(serialized_ckpt)  # save last.pt
         if self.best_fitness == self.fitness:
-            torch.save(ckpt, self.best)
+            self.best.write_bytes(serialized_ckpt)  # save best.pt
         if (self.save_period > 0) and (self.epoch > 0) and (self.epoch % self.save_period == 0):
-            torch.save(ckpt, self.wdir / f'epoch{self.epoch}.pt')
+            (self.wdir / f"epoch{self.epoch}.pt").write_bytes(serialized_ckpt)  # save epoch, i.e. 'epoch3.pt'
 
-    @staticmethod
-    def get_dataset(data):
+    def get_dataset(self):
         """
         Get train, val path from data dict if it exists.
 
         Returns None if data format is not recognized.
         """
-        return data['train'], data.get('val') or data.get('test')
+        try:
+            if self.args.task == "classify":
+                data = check_cls_dataset(self.args.data)
+            elif self.args.data.split(".")[-1] in {"yaml", "yml"} or self.args.task in {
+                "detect",
+                "segment",
+                "pose",
+                "obb",
+            }:
+                data = check_det_dataset(self.args.data)
+                if "yaml_file" in data:
+                    self.args.data = data["yaml_file"]  # for validating 'yolo train data=url.zip' usage
+        except Exception as e:
+            raise RuntimeError(emojis(f"Dataset '{clean_url(self.args.data)}' error  {e}")) from e
+        self.data = data
+        return data["train"], data.get("val") or data.get("test")
 
     def setup_model(self):
         """Load/create/download model for any task."""
         if isinstance(self.model, torch.nn.Module):  # if model is loaded beforehand. No setup needed
             return
 
         model, weights = self.model, None
         ckpt = None
-        if str(model).endswith('.pt'):
+        if str(model).endswith(".pt"):
             weights, ckpt = attempt_load_one_weight(model)
-            cfg = ckpt['model'].yaml
+            cfg = weights.yaml
         else:
             cfg = model
         self.model = self.get_model(cfg=cfg, weights=weights, verbose=RANK == -1)  # calls Model(cfg, weights)
         return ckpt
 
     def optimizer_step(self):
         """Perform a single step of the training optimizer with gradient clipping and EMA update."""
@@ -477,151 +551,157 @@
     def validate(self):
         """
         Runs validation on test set using self.validator.
 
         The returned dict is expected to contain "fitness" key.
         """
         metrics = self.validator(self)
-        fitness = metrics.pop('fitness', -self.loss.detach().cpu().numpy())  # use loss as fitness measure if not found
+        fitness = metrics.pop("fitness", -self.loss.detach().cpu().numpy())  # use loss as fitness measure if not found
         if not self.best_fitness or self.best_fitness < fitness:
             self.best_fitness = fitness
         return metrics, fitness
 
     def get_model(self, cfg=None, weights=None, verbose=True):
         """Get model and raise NotImplementedError for loading cfg files."""
         raise NotImplementedError("This task trainer doesn't support loading cfg files")
 
     def get_validator(self):
         """Returns a NotImplementedError when the get_validator function is called."""
-        raise NotImplementedError('get_validator function not implemented in trainer')
+        raise NotImplementedError("get_validator function not implemented in trainer")
 
-    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode='train'):
+    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode="train"):
         """Returns dataloader derived from torch.data.Dataloader."""
-        raise NotImplementedError('get_dataloader function not implemented in trainer')
+        raise NotImplementedError("get_dataloader function not implemented in trainer")
 
-    def build_dataset(self, img_path, mode='train', batch=None):
+    def build_dataset(self, img_path, mode="train", batch=None):
         """Build dataset."""
-        raise NotImplementedError('build_dataset function not implemented in trainer')
+        raise NotImplementedError("build_dataset function not implemented in trainer")
 
-    def label_loss_items(self, loss_items=None, prefix='train'):
-        """Returns a loss dict with labelled training loss items tensor."""
-        # Not needed for classification but necessary for segmentation & detection
-        return {'loss': loss_items} if loss_items is not None else ['loss']
+    def label_loss_items(self, loss_items=None, prefix="train"):
+        """
+        Returns a loss dict with labelled training loss items tensor.
+
+        Note:
+            This is not needed for classification but necessary for segmentation & detection
+        """
+        return {"loss": loss_items} if loss_items is not None else ["loss"]
 
     def set_model_attributes(self):
         """To set or update model parameters before training."""
-        self.model.names = self.data['names']
+        self.model.names = self.data["names"]
 
     def build_targets(self, preds, targets):
         """Builds target tensors for training YOLO model."""
         pass
 
     def progress_string(self):
         """Returns a string describing training progress."""
-        return ''
+        return ""
 
     # TODO: may need to put these following functions into callback
     def plot_training_samples(self, batch, ni):
         """Plots training samples during YOLO training."""
         pass
 
     def plot_training_labels(self):
         """Plots training labels for YOLO model."""
         pass
 
     def save_metrics(self, metrics):
         """Saves training metrics to a CSV file."""
         keys, vals = list(metrics.keys()), list(metrics.values())
         n = len(metrics) + 1  # number of cols
-        s = '' if self.csv.exists() else (('%23s,' * n % tuple(['epoch'] + keys)).rstrip(',') + '\n')  # header
-        with open(self.csv, 'a') as f:
-            f.write(s + ('%23.5g,' * n % tuple([self.epoch + 1] + vals)).rstrip(',') + '\n')
+        s = "" if self.csv.exists() else (("%23s," * n % tuple(["epoch"] + keys)).rstrip(",") + "\n")  # header
+        with open(self.csv, "a") as f:
+            f.write(s + ("%23.5g," * n % tuple([self.epoch + 1] + vals)).rstrip(",") + "\n")
 
     def plot_metrics(self):
         """Plot and display metrics visually."""
         pass
 
     def on_plot(self, name, data=None):
         """Registers plots (e.g. to be consumed in callbacks)"""
         path = Path(name)
-        self.plots[path] = {'data': data, 'timestamp': time.time()}
+        self.plots[path] = {"data": data, "timestamp": time.time()}
 
     def final_eval(self):
         """Performs final evaluation and validation for object detection YOLO model."""
         for f in self.last, self.best:
             if f.exists():
                 strip_optimizer(f)  # strip optimizers
                 if f is self.best:
-                    LOGGER.info(f'\nValidating {f}...')
+                    LOGGER.info(f"\nValidating {f}...")
                     self.validator.args.plots = self.args.plots
                     self.metrics = self.validator(model=f)
-                    self.metrics.pop('fitness', None)
-                    self.run_callbacks('on_fit_epoch_end')
+                    self.metrics.pop("fitness", None)
+                    self.run_callbacks("on_fit_epoch_end")
 
     def check_resume(self, overrides):
         """Check if resume checkpoint exists and update arguments accordingly."""
         resume = self.args.resume
         if resume:
             try:
                 exists = isinstance(resume, (str, Path)) and Path(resume).exists()
                 last = Path(check_file(resume) if exists else get_latest_run())
 
                 # Check that resume data YAML exists, otherwise strip to force re-download of dataset
                 ckpt_args = attempt_load_weights(last).args
-                if not Path(ckpt_args['data']).exists():
-                    ckpt_args['data'] = self.args.data
+                if not Path(ckpt_args["data"]).exists():
+                    ckpt_args["data"] = self.args.data
 
                 resume = True
                 self.args = get_cfg(ckpt_args)
-                self.args.model = str(last)  # reinstate model
-                for k in 'imgsz', 'batch':  # allow arg updates to reduce memory on resume if crashed due to CUDA OOM
+                self.args.model = self.args.resume = str(last)  # reinstate model
+                for k in "imgsz", "batch", "device":  # allow arg updates to reduce memory or update device on resume
                     if k in overrides:
                         setattr(self.args, k, overrides[k])
 
             except Exception as e:
-                raise FileNotFoundError('Resume checkpoint not found. Please pass a valid checkpoint to resume from, '
-                                        "i.e. 'yolo train resume model=path/to/last.pt'") from e
+                raise FileNotFoundError(
+                    "Resume checkpoint not found. Please pass a valid checkpoint to resume from, "
+                    "i.e. 'yolo train resume model=path/to/last.pt'"
+                ) from e
         self.resume = resume
 
     def resume_training(self, ckpt):
         """Resume YOLO training from given epoch and best fitness."""
-        if ckpt is None:
+        if ckpt is None or not self.resume:
             return
         best_fitness = 0.0
-        start_epoch = ckpt['epoch'] + 1
-        if ckpt['optimizer'] is not None:
-            self.optimizer.load_state_dict(ckpt['optimizer'])  # optimizer
-            best_fitness = ckpt['best_fitness']
-        if self.ema and ckpt.get('ema'):
-            self.ema.ema.load_state_dict(ckpt['ema'].float().state_dict())  # EMA
-            self.ema.updates = ckpt['updates']
-        if self.resume:
-            assert start_epoch > 0, \
-                f'{self.args.model} training to {self.epochs} epochs is finished, nothing to resume.\n' \
-                f"Start a new training without resuming, i.e. 'yolo train model={self.args.model}'"
-            LOGGER.info(
-                f'Resuming training from {self.args.model} from epoch {start_epoch + 1} to {self.epochs} total epochs')
+        start_epoch = ckpt.get("epoch", -1) + 1
+        if ckpt.get("optimizer", None) is not None:
+            self.optimizer.load_state_dict(ckpt["optimizer"])  # optimizer
+            best_fitness = ckpt["best_fitness"]
+        if self.ema and ckpt.get("ema"):
+            self.ema.ema.load_state_dict(ckpt["ema"].float().state_dict())  # EMA
+            self.ema.updates = ckpt["updates"]
+        assert start_epoch > 0, (
+            f"{self.args.model} training to {self.epochs} epochs is finished, nothing to resume.\n"
+            f"Start a new training without resuming, i.e. 'yolo train model={self.args.model}'"
+        )
+        LOGGER.info(f"Resuming training {self.args.model} from epoch {start_epoch + 1} to {self.epochs} total epochs")
         if self.epochs < start_epoch:
             LOGGER.info(
-                f"{self.model} has been trained for {ckpt['epoch']} epochs. Fine-tuning for {self.epochs} more epochs.")
-            self.epochs += ckpt['epoch']  # finetune additional epochs
+                f"{self.model} has been trained for {ckpt['epoch']} epochs. Fine-tuning for {self.epochs} more epochs."
+            )
+            self.epochs += ckpt["epoch"]  # finetune additional epochs
         self.best_fitness = best_fitness
         self.start_epoch = start_epoch
         if start_epoch > (self.epochs - self.args.close_mosaic):
             self._close_dataloader_mosaic()
 
     def _close_dataloader_mosaic(self):
         """Update dataloaders to stop using mosaic augmentation."""
-        if hasattr(self.train_loader.dataset, 'mosaic'):
+        if hasattr(self.train_loader.dataset, "mosaic"):
             self.train_loader.dataset.mosaic = False
-        if hasattr(self.train_loader.dataset, 'close_mosaic'):
-            LOGGER.info('Closing dataloader mosaic')
+        if hasattr(self.train_loader.dataset, "close_mosaic"):
+            LOGGER.info("Closing dataloader mosaic")
             self.train_loader.dataset.close_mosaic(hyp=self.args)
 
-    def build_optimizer(self, model, name='auto', lr=0.001, momentum=0.9, decay=1e-5, iterations=1e5):
+    def build_optimizer(self, model, name="auto", lr=0.001, momentum=0.9, decay=1e-5, iterations=1e5):
         """
         Constructs an optimizer for the given model, based on the specified optimizer name, learning rate, momentum,
         weight decay, and number of iterations.
 
         Args:
             model (torch.nn.Module): The model for which to build an optimizer.
             name (str, optional): The name of the optimizer to use. If 'auto', the optimizer is selected
@@ -633,45 +713,49 @@
                 name is 'auto'. Default: 1e5.
 
         Returns:
             (torch.optim.Optimizer): The constructed optimizer.
         """
 
         g = [], [], []  # optimizer parameter groups
-        bn = tuple(v for k, v in nn.__dict__.items() if 'Norm' in k)  # normalization layers, i.e. BatchNorm2d()
-        if name == 'auto':
-            LOGGER.info(f"{colorstr('optimizer:')} 'optimizer=auto' found, "
-                        f"ignoring 'lr0={self.args.lr0}' and 'momentum={self.args.momentum}' and "
-                        f"determining best 'optimizer', 'lr0' and 'momentum' automatically... ")
-            nc = getattr(model, 'nc', 10)  # number of classes
+        bn = tuple(v for k, v in nn.__dict__.items() if "Norm" in k)  # normalization layers, i.e. BatchNorm2d()
+        if name == "auto":
+            LOGGER.info(
+                f"{colorstr('optimizer:')} 'optimizer=auto' found, "
+                f"ignoring 'lr0={self.args.lr0}' and 'momentum={self.args.momentum}' and "
+                f"determining best 'optimizer', 'lr0' and 'momentum' automatically... "
+            )
+            nc = getattr(model, "nc", 10)  # number of classes
             lr_fit = round(0.002 * 5 / (4 + nc), 6)  # lr0 fit equation to 6 decimal places
-            name, lr, momentum = ('SGD', 0.01, 0.9) if iterations > 10000 else ('AdamW', lr_fit, 0.9)
+            name, lr, momentum = ("SGD", 0.01, 0.9) if iterations > 10000 else ("AdamW", lr_fit, 0.9)
             self.args.warmup_bias_lr = 0.0  # no higher than 0.01 for Adam
 
         for module_name, module in model.named_modules():
             for param_name, param in module.named_parameters(recurse=False):
-                fullname = f'{module_name}.{param_name}' if module_name else param_name
-                if 'bias' in fullname:  # bias (no decay)
+                fullname = f"{module_name}.{param_name}" if module_name else param_name
+                if "bias" in fullname:  # bias (no decay)
                     g[2].append(param)
                 elif isinstance(module, bn):  # weight (no decay)
                     g[1].append(param)
                 else:  # weight (with decay)
                     g[0].append(param)
 
-        if name in ('Adam', 'Adamax', 'AdamW', 'NAdam', 'RAdam'):
+        if name in {"Adam", "Adamax", "AdamW", "NAdam", "RAdam"}:
             optimizer = getattr(optim, name, optim.Adam)(g[2], lr=lr, betas=(momentum, 0.999), weight_decay=0.0)
-        elif name == 'RMSProp':
+        elif name == "RMSProp":
             optimizer = optim.RMSprop(g[2], lr=lr, momentum=momentum)
-        elif name == 'SGD':
+        elif name == "SGD":
             optimizer = optim.SGD(g[2], lr=lr, momentum=momentum, nesterov=True)
         else:
             raise NotImplementedError(
                 f"Optimizer '{name}' not found in list of available optimizers "
-                f'[Adam, AdamW, NAdam, RAdam, RMSProp, SGD, auto].'
-                'To request support for addition optimizers please visit https://github.com/ultralytics/ultralytics.')
+                f"[Adam, AdamW, NAdam, RAdam, RMSProp, SGD, auto]."
+                "To request support for addition optimizers please visit https://github.com/ultralytics/ultralytics."
+            )
 
-        optimizer.add_param_group({'params': g[0], 'weight_decay': decay})  # add g0 with weight_decay
-        optimizer.add_param_group({'params': g[1], 'weight_decay': 0.0})  # add g1 (BatchNorm2d weights)
+        optimizer.add_param_group({"params": g[0], "weight_decay": decay})  # add g0 with weight_decay
+        optimizer.add_param_group({"params": g[1], "weight_decay": 0.0})  # add g1 (BatchNorm2d weights)
         LOGGER.info(
             f"{colorstr('optimizer:')} {type(optimizer).__name__}(lr={lr}, momentum={momentum}) with parameter groups "
-            f'{len(g[1])} weight(decay=0.0), {len(g[0])} weight(decay={decay}), {len(g[2])} bias(decay=0.0)')
+            f'{len(g[1])} weight(decay=0.0), {len(g[0])} weight(decay={decay}), {len(g[2])} bias(decay=0.0)'
+        )
         return optimizer
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/engine/tuner.py` & `yolov8_pose_triton-8.2.0/ultralytics/engine/tuner.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,14 +12,15 @@
     ```python
     from ultralytics import YOLO
 
     model = YOLO('yolov8n.pt')
     model.tune(data='coco8.yaml', epochs=10, iterations=300, optimizer='AdamW', plots=False, save=False, val=False)
     ```
 """
+
 import random
 import shutil
 import subprocess
 import time
 
 import numpy as np
 import torch
@@ -52,80 +53,92 @@
         Tune hyperparameters for YOLOv8n on COCO8 at imgsz=640 and epochs=30 for 300 tuning iterations.
         ```python
         from ultralytics import YOLO
 
         model = YOLO('yolov8n.pt')
         model.tune(data='coco8.yaml', epochs=10, iterations=300, optimizer='AdamW', plots=False, save=False, val=False)
         ```
+
+        Tune with custom search space.
+        ```python
+        from ultralytics import YOLO
+
+        model = YOLO('yolov8n.pt')
+        model.tune(space={key1: val1, key2: val2})  # custom search space dictionary
+        ```
     """
 
     def __init__(self, args=DEFAULT_CFG, _callbacks=None):
         """
         Initialize the Tuner with configurations.
 
         Args:
             args (dict, optional): Configuration for hyperparameter evolution.
         """
-        self.args = get_cfg(overrides=args)
-        self.space = {  # key: (min, max, gain(optional))
+        self.space = args.pop("space", None) or {  # key: (min, max, gain(optional))
             # 'optimizer': tune.choice(['SGD', 'Adam', 'AdamW', 'NAdam', 'RAdam', 'RMSProp']),
-            'lr0': (1e-5, 1e-1),
-            'lrf': (0.0001, 0.1),  # final OneCycleLR learning rate (lr0 * lrf)
-            'momentum': (0.7, 0.98, 0.3),  # SGD momentum/Adam beta1
-            'weight_decay': (0.0, 0.001),  # optimizer weight decay 5e-4
-            'warmup_epochs': (0.0, 5.0),  # warmup epochs (fractions ok)
-            'warmup_momentum': (0.0, 0.95),  # warmup initial momentum
-            'box': (1.0, 20.0),  # box loss gain
-            'cls': (0.2, 4.0),  # cls loss gain (scale with pixels)
-            'dfl': (0.4, 6.0),  # dfl loss gain
-            'hsv_h': (0.0, 0.1),  # image HSV-Hue augmentation (fraction)
-            'hsv_s': (0.0, 0.9),  # image HSV-Saturation augmentation (fraction)
-            'hsv_v': (0.0, 0.9),  # image HSV-Value augmentation (fraction)
-            'degrees': (0.0, 45.0),  # image rotation (+/- deg)
-            'translate': (0.0, 0.9),  # image translation (+/- fraction)
-            'scale': (0.0, 0.95),  # image scale (+/- gain)
-            'shear': (0.0, 10.0),  # image shear (+/- deg)
-            'perspective': (0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001
-            'flipud': (0.0, 1.0),  # image flip up-down (probability)
-            'fliplr': (0.0, 1.0),  # image flip left-right (probability)
-            'mosaic': (0.0, 1.0),  # image mixup (probability)
-            'mixup': (0.0, 1.0),  # image mixup (probability)
-            'copy_paste': (0.0, 1.0)}  # segment copy-paste (probability)
-        self.tune_dir = get_save_dir(self.args, name='tune')
-        self.tune_csv = self.tune_dir / 'tune_results.csv'
+            "lr0": (1e-5, 1e-1),  # initial learning rate (i.e. SGD=1E-2, Adam=1E-3)
+            "lrf": (0.0001, 0.1),  # final OneCycleLR learning rate (lr0 * lrf)
+            "momentum": (0.7, 0.98, 0.3),  # SGD momentum/Adam beta1
+            "weight_decay": (0.0, 0.001),  # optimizer weight decay 5e-4
+            "warmup_epochs": (0.0, 5.0),  # warmup epochs (fractions ok)
+            "warmup_momentum": (0.0, 0.95),  # warmup initial momentum
+            "box": (1.0, 20.0),  # box loss gain
+            "cls": (0.2, 4.0),  # cls loss gain (scale with pixels)
+            "dfl": (0.4, 6.0),  # dfl loss gain
+            "hsv_h": (0.0, 0.1),  # image HSV-Hue augmentation (fraction)
+            "hsv_s": (0.0, 0.9),  # image HSV-Saturation augmentation (fraction)
+            "hsv_v": (0.0, 0.9),  # image HSV-Value augmentation (fraction)
+            "degrees": (0.0, 45.0),  # image rotation (+/- deg)
+            "translate": (0.0, 0.9),  # image translation (+/- fraction)
+            "scale": (0.0, 0.95),  # image scale (+/- gain)
+            "shear": (0.0, 10.0),  # image shear (+/- deg)
+            "perspective": (0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001
+            "flipud": (0.0, 1.0),  # image flip up-down (probability)
+            "fliplr": (0.0, 1.0),  # image flip left-right (probability)
+            "bgr": (0.0, 1.0),  # image channel bgr (probability)
+            "mosaic": (0.0, 1.0),  # image mixup (probability)
+            "mixup": (0.0, 1.0),  # image mixup (probability)
+            "copy_paste": (0.0, 1.0),  # segment copy-paste (probability)
+        }
+        self.args = get_cfg(overrides=args)
+        self.tune_dir = get_save_dir(self.args, name="tune")
+        self.tune_csv = self.tune_dir / "tune_results.csv"
         self.callbacks = _callbacks or callbacks.get_default_callbacks()
-        self.prefix = colorstr('Tuner: ')
+        self.prefix = colorstr("Tuner: ")
         callbacks.add_integration_callbacks(self)
-        LOGGER.info(f"{self.prefix}Initialized Tuner instance with 'tune_dir={self.tune_dir}'\n"
-                    f'{self.prefix} Learn about tuning at https://docs.ultralytics.com/guides/hyperparameter-tuning')
+        LOGGER.info(
+            f"{self.prefix}Initialized Tuner instance with 'tune_dir={self.tune_dir}'\n"
+            f"{self.prefix} Learn about tuning at https://docs.ultralytics.com/guides/hyperparameter-tuning"
+        )
 
-    def _mutate(self, parent='single', n=5, mutation=0.8, sigma=0.2):
+    def _mutate(self, parent="single", n=5, mutation=0.8, sigma=0.2):
         """
         Mutates the hyperparameters based on bounds and scaling factors specified in `self.space`.
 
         Args:
             parent (str): Parent selection method: 'single' or 'weighted'.
             n (int): Number of parents to consider.
             mutation (float): Probability of a parameter mutation in any given iteration.
             sigma (float): Standard deviation for Gaussian random number generator.
 
         Returns:
             (dict): A dictionary containing mutated hyperparameters.
         """
         if self.tune_csv.exists():  # if CSV file exists: select best hyps and mutate
             # Select parent(s)
-            x = np.loadtxt(self.tune_csv, ndmin=2, delimiter=',', skiprows=1)
+            x = np.loadtxt(self.tune_csv, ndmin=2, delimiter=",", skiprows=1)
             fitness = x[:, 0]  # first column
             n = min(n, len(x))  # number of previous results to consider
             x = x[np.argsort(-fitness)][:n]  # top n mutations
-            w = x[:, 0] - x[:, 0].min() + 1E-6  # weights (sum > 0)
-            if parent == 'single' or len(x) == 1:
+            w = x[:, 0] - x[:, 0].min() + 1e-6  # weights (sum > 0)
+            if parent == "single" or len(x) == 1:
                 # x = x[random.randint(0, n - 1)]  # random selection
                 x = x[random.choices(range(n), weights=w)[0]]  # weighted selection
-            elif parent == 'weighted':
+            elif parent == "weighted":
                 x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # weighted combination
 
             # Mutate
             r = np.random  # method
             r.seed(int(time.time()))
             g = np.array([v[2] if len(v) == 3 else 1.0 for k, v in self.space.items()])  # gains 0-1
             ng = len(self.space)
@@ -162,63 +175,68 @@
         Note:
            The method utilizes the `self.tune_csv` Path object to read and log hyperparameters and fitness scores.
            Ensure this path is set correctly in the Tuner instance.
         """
 
         t0 = time.time()
         best_save_dir, best_metrics = None, None
-        (self.tune_dir / 'weights').mkdir(parents=True, exist_ok=True)
+        (self.tune_dir / "weights").mkdir(parents=True, exist_ok=True)
         for i in range(iterations):
             # Mutate hyperparameters
             mutated_hyp = self._mutate()
-            LOGGER.info(f'{self.prefix}Starting iteration {i + 1}/{iterations} with hyperparameters: {mutated_hyp}')
+            LOGGER.info(f"{self.prefix}Starting iteration {i + 1}/{iterations} with hyperparameters: {mutated_hyp}")
 
             metrics = {}
             train_args = {**vars(self.args), **mutated_hyp}
             save_dir = get_save_dir(get_cfg(train_args))
+            weights_dir = save_dir / "weights"
             try:
                 # Train YOLO model with mutated hyperparameters (run in subprocess to avoid dataloader hang)
-                weights_dir = save_dir / 'weights'
-                cmd = ['yolo', 'train', *(f'{k}={v}' for k, v in train_args.items())]
-                assert subprocess.run(cmd, check=True).returncode == 0, 'training failed'
-                ckpt_file = weights_dir / ('best.pt' if (weights_dir / 'best.pt').exists() else 'last.pt')
-                metrics = torch.load(ckpt_file)['train_metrics']
+                cmd = ["yolo", "train", *(f"{k}={v}" for k, v in train_args.items())]
+                return_code = subprocess.run(cmd, check=True).returncode
+                ckpt_file = weights_dir / ("best.pt" if (weights_dir / "best.pt").exists() else "last.pt")
+                metrics = torch.load(ckpt_file)["train_metrics"]
+                assert return_code == 0, "training failed"
 
             except Exception as e:
-                LOGGER.warning(f'WARNING  training failure for hyperparameter tuning iteration {i + 1}\n{e}')
+                LOGGER.warning(f"WARNING  training failure for hyperparameter tuning iteration {i + 1}\n{e}")
 
             # Save results and mutated_hyp to CSV
-            fitness = metrics.get('fitness', 0.0)
+            fitness = metrics.get("fitness", 0.0)
             log_row = [round(fitness, 5)] + [mutated_hyp[k] for k in self.space.keys()]
-            headers = '' if self.tune_csv.exists() else (','.join(['fitness'] + list(self.space.keys())) + '\n')
-            with open(self.tune_csv, 'a') as f:
-                f.write(headers + ','.join(map(str, log_row)) + '\n')
+            headers = "" if self.tune_csv.exists() else (",".join(["fitness"] + list(self.space.keys())) + "\n")
+            with open(self.tune_csv, "a") as f:
+                f.write(headers + ",".join(map(str, log_row)) + "\n")
 
             # Get best results
-            x = np.loadtxt(self.tune_csv, ndmin=2, delimiter=',', skiprows=1)
+            x = np.loadtxt(self.tune_csv, ndmin=2, delimiter=",", skiprows=1)
             fitness = x[:, 0]  # first column
             best_idx = fitness.argmax()
             best_is_current = best_idx == i
             if best_is_current:
                 best_save_dir = save_dir
                 best_metrics = {k: round(v, 5) for k, v in metrics.items()}
-                for ckpt in weights_dir.glob('*.pt'):
-                    shutil.copy2(ckpt, self.tune_dir / 'weights')
+                for ckpt in weights_dir.glob("*.pt"):
+                    shutil.copy2(ckpt, self.tune_dir / "weights")
             elif cleanup:
-                shutil.rmtree(ckpt_file.parent)  # remove iteration weights/ dir to reduce storage space
+                shutil.rmtree(weights_dir, ignore_errors=True)  # remove iteration weights/ dir to reduce storage space
 
             # Plot tune results
             plot_tune_results(self.tune_csv)
 
             # Save and print tune results
-            header = (f'{self.prefix}{i + 1}/{iterations} iterations complete  ({time.time() - t0:.2f}s)\n'
-                      f'{self.prefix}Results saved to {colorstr("bold", self.tune_dir)}\n'
-                      f'{self.prefix}Best fitness={fitness[best_idx]} observed at iteration {best_idx + 1}\n'
-                      f'{self.prefix}Best fitness metrics are {best_metrics}\n'
-                      f'{self.prefix}Best fitness model is {best_save_dir}\n'
-                      f'{self.prefix}Best fitness hyperparameters are printed below.\n')
-            LOGGER.info('\n' + header)
+            header = (
+                f'{self.prefix}{i + 1}/{iterations} iterations complete  ({time.time() - t0:.2f}s)\n'
+                f'{self.prefix}Results saved to {colorstr("bold", self.tune_dir)}\n'
+                f'{self.prefix}Best fitness={fitness[best_idx]} observed at iteration {best_idx + 1}\n'
+                f'{self.prefix}Best fitness metrics are {best_metrics}\n'
+                f'{self.prefix}Best fitness model is {best_save_dir}\n'
+                f'{self.prefix}Best fitness hyperparameters are printed below.\n'
+            )
+            LOGGER.info("\n" + header)
             data = {k: float(x[best_idx, i + 1]) for i, k in enumerate(self.space.keys())}
-            yaml_save(self.tune_dir / 'best_hyperparameters.yaml',
-                      data=data,
-                      header=remove_colorstr(header.replace(self.prefix, '# ')) + '\n')
-            yaml_print(self.tune_dir / 'best_hyperparameters.yaml')
+            yaml_save(
+                self.tune_dir / "best_hyperparameters.yaml",
+                data=data,
+                header=remove_colorstr(header.replace(self.prefix, "# ")) + "\n",
+            )
+            yaml_print(self.tune_dir / "best_hyperparameters.yaml")
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/engine/validator.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/detect/val.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,326 +1,318 @@
 # Ultralytics YOLO , AGPL-3.0 license
-"""
-Check a model's accuracy on a test or val split of a dataset.
 
-Usage:
-    $ yolo mode=val model=yolov8n.pt data=coco128.yaml imgsz=640
-
-Usage - formats:
-    $ yolo mode=val model=yolov8n.pt                 # PyTorch
-                          yolov8n.torchscript        # TorchScript
-                          yolov8n.onnx               # ONNX Runtime or OpenCV DNN with dnn=True
-                          yolov8n_openvino_model     # OpenVINO
-                          yolov8n.engine             # TensorRT
-                          yolov8n.mlpackage          # CoreML (macOS-only)
-                          yolov8n_saved_model        # TensorFlow SavedModel
-                          yolov8n.pb                 # TensorFlow GraphDef
-                          yolov8n.tflite             # TensorFlow Lite
-                          yolov8n_edgetpu.tflite     # TensorFlow Edge TPU
-                          yolov8n_paddle_model       # PaddlePaddle
-"""
-import json
-import time
+import os
 from pathlib import Path
 
 import numpy as np
 import torch
 
-from ultralytics.cfg import get_cfg, get_save_dir
-from ultralytics.data.utils import check_cls_dataset, check_det_dataset
-from ultralytics.nn.autobackend import AutoBackend
-from ultralytics.utils import LOGGER, TQDM, callbacks, colorstr, emojis
-from ultralytics.utils.checks import check_imgsz
-from ultralytics.utils.ops import Profile
-from ultralytics.utils.torch_utils import de_parallel, select_device, smart_inference_mode
+from ultralytics.data import build_dataloader, build_yolo_dataset, converter
+from ultralytics.engine.validator import BaseValidator
+from ultralytics.utils import LOGGER, ops
+from ultralytics.utils.checks import check_requirements
+from ultralytics.utils.metrics import ConfusionMatrix, DetMetrics, box_iou
+from ultralytics.utils.plotting import output_to_target, plot_images
 
 
-class BaseValidator:
+class DetectionValidator(BaseValidator):
     """
-    BaseValidator.
-
-    A base class for creating validators.
+    A class extending the BaseValidator class for validation based on a detection model.
 
-    Attributes:
-        args (SimpleNamespace): Configuration for the validator.
-        dataloader (DataLoader): Dataloader to use for validation.
-        pbar (tqdm): Progress bar to update during validation.
-        model (nn.Module): Model to validate.
-        data (dict): Data dictionary.
-        device (torch.device): Device to use for validation.
-        batch_i (int): Current batch index.
-        training (bool): Whether the model is in training mode.
-        names (dict): Class names.
-        seen: Records the number of images seen so far during validation.
-        stats: Placeholder for statistics during validation.
-        confusion_matrix: Placeholder for a confusion matrix.
-        nc: Number of classes.
-        iouv: (torch.Tensor): IoU thresholds from 0.50 to 0.95 in spaces of 0.05.
-        jdict (dict): Dictionary to store JSON validation results.
-        speed (dict): Dictionary with keys 'preprocess', 'inference', 'loss', 'postprocess' and their respective
-                      batch processing times in milliseconds.
-        save_dir (Path): Directory to save results.
-        plots (dict): Dictionary to store plots for visualization.
-        callbacks (dict): Dictionary to store various callback functions.
+    Example:
+        ```python
+        from ultralytics.models.yolo.detect import DetectionValidator
+
+        args = dict(model='yolov8n.pt', data='coco8.yaml')
+        validator = DetectionValidator(args=args)
+        validator()
+        ```
     """
 
     def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):
-        """
-        Initializes a BaseValidator instance.
-
-        Args:
-            dataloader (torch.utils.data.DataLoader): Dataloader to be used for validation.
-            save_dir (Path, optional): Directory to save results.
-            pbar (tqdm.tqdm): Progress bar for displaying progress.
-            args (SimpleNamespace): Configuration for the validator.
-            _callbacks (dict): Dictionary to store various callback functions.
-        """
-        self.args = get_cfg(overrides=args)
-        self.dataloader = dataloader
-        self.pbar = pbar
-        self.stride = None
-        self.data = None
-        self.device = None
-        self.batch_i = None
-        self.training = True
-        self.names = None
-        self.seen = None
-        self.stats = None
-        self.confusion_matrix = None
-        self.nc = None
-        self.iouv = None
-        self.jdict = None
-        self.speed = {'preprocess': 0.0, 'inference': 0.0, 'loss': 0.0, 'postprocess': 0.0}
-
-        self.save_dir = save_dir or get_save_dir(self.args)
-        (self.save_dir / 'labels' if self.args.save_txt else self.save_dir).mkdir(parents=True, exist_ok=True)
-        if self.args.conf is None:
-            self.args.conf = 0.001  # default conf=0.001
-        self.args.imgsz = check_imgsz(self.args.imgsz, max_dim=1)
-
-        self.plots = {}
-        self.callbacks = _callbacks or callbacks.get_default_callbacks()
-
-    @smart_inference_mode()
-    def __call__(self, trainer=None, model=None):
-        """Supports validation of a pre-trained model if passed or a model being trained if trainer is passed (trainer
-        gets priority).
-        """
-        self.training = trainer is not None
-        augment = self.args.augment and (not self.training)
-        if self.training:
-            self.device = trainer.device
-            self.data = trainer.data
-            self.args.half = self.device.type != 'cpu'  # force FP16 val during training
-            model = trainer.ema.ema or trainer.model
-            model = model.half() if self.args.half else model.float()
-            # self.model = model
-            self.loss = torch.zeros_like(trainer.loss_items, device=trainer.device)
-            self.args.plots &= trainer.stopper.possible_stop or (trainer.epoch == trainer.epochs - 1)
-            model.eval()
-        else:
-            callbacks.add_integration_callbacks(self)
-            model = AutoBackend(model or self.args.model,
-                                device=select_device(self.args.device, self.args.batch),
-                                dnn=self.args.dnn,
-                                data=self.args.data,
-                                fp16=self.args.half)
-            # self.model = model
-            self.device = model.device  # update device
-            self.args.half = model.fp16  # update half
-            stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine
-            imgsz = check_imgsz(self.args.imgsz, stride=stride)
-            if engine:
-                self.args.batch = model.batch_size
-            elif not pt and not jit:
-                self.args.batch = 1  # export.py models default to batch-size 1
-                LOGGER.info(f'Forcing batch=1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models')
-
-            if isinstance(self.args.data, str) and self.args.data.split('.')[-1] in ('yaml', 'yml'):
-                self.data = check_det_dataset(self.args.data)
-            elif self.args.task == 'classify':
-                self.data = check_cls_dataset(self.args.data, split=self.args.split)
-            else:
-                raise FileNotFoundError(emojis(f"Dataset '{self.args.data}' for task={self.args.task} not found "))
-
-            if self.device.type in ('cpu', 'mps'):
-                self.args.workers = 0  # faster CPU val as time dominated by inference, not dataloading
-            if not pt:
-                self.args.rect = False
-            self.stride = model.stride  # used in get_dataloader() for padding
-            self.dataloader = self.dataloader or self.get_dataloader(self.data.get(self.args.split), self.args.batch)
-
-            model.eval()
-            model.warmup(imgsz=(1 if pt else self.args.batch, 3, imgsz, imgsz))  # warmup
-
-        self.run_callbacks('on_val_start')
-        dt = Profile(), Profile(), Profile(), Profile()
-        bar = TQDM(self.dataloader, desc=self.get_desc(), total=len(self.dataloader))
-        self.init_metrics(de_parallel(model))
-        self.jdict = []  # empty before each val
-        for batch_i, batch in enumerate(bar):
-            self.run_callbacks('on_val_batch_start')
-            self.batch_i = batch_i
-            # Preprocess
-            with dt[0]:
-                batch = self.preprocess(batch)
-
-            # Inference
-            with dt[1]:
-                preds = model(batch['img'], augment=augment)
-
-            # Loss
-            with dt[2]:
-                if self.training:
-                    self.loss += model.loss(batch, preds)[1]
-
-            # Postprocess
-            with dt[3]:
-                preds = self.postprocess(preds)
-
-            self.update_metrics(preds, batch)
-            if self.args.plots and batch_i < 3:
-                self.plot_val_samples(batch, batch_i)
-                self.plot_predictions(batch, preds, batch_i)
-
-            self.run_callbacks('on_val_batch_end')
-        stats = self.get_stats()
-        self.check_stats(stats)
-        self.speed = dict(zip(self.speed.keys(), (x.t / len(self.dataloader.dataset) * 1E3 for x in dt)))
-        self.finalize_metrics()
-        self.print_results()
-        self.run_callbacks('on_val_end')
-        if self.training:
-            model.float()
-            results = {**stats, **trainer.label_loss_items(self.loss.cpu() / len(self.dataloader), prefix='val')}
-            return {k: round(float(v), 5) for k, v in results.items()}  # return results as 5 decimal place floats
-        else:
-            LOGGER.info('Speed: %.1fms preprocess, %.1fms inference, %.1fms loss, %.1fms postprocess per image' %
-                        tuple(self.speed.values()))
-            if self.args.save_json and self.jdict:
-                with open(str(self.save_dir / 'predictions.json'), 'w') as f:
-                    LOGGER.info(f'Saving {f.name}...')
-                    json.dump(self.jdict, f)  # flatten and save
-                stats = self.eval_json(stats)  # update stats
-            if self.args.plots or self.args.save_json:
-                LOGGER.info(f"Results saved to {colorstr('bold', self.save_dir)}")
-            return stats
+        """Initialize detection model with necessary variables and settings."""
+        super().__init__(dataloader, save_dir, pbar, args, _callbacks)
+        self.nt_per_class = None
+        self.is_coco = False
+        self.is_lvis = False
+        self.class_map = None
+        self.args.task = "detect"
+        self.metrics = DetMetrics(save_dir=self.save_dir, on_plot=self.on_plot)
+        self.iouv = torch.linspace(0.5, 0.95, 10)  # IoU vector for mAP@0.5:0.95
+        self.niou = self.iouv.numel()
+        self.lb = []  # for autolabelling
 
-    def match_predictions(self, pred_classes, true_classes, iou, use_scipy=False):
-        """
-        Matches predictions to ground truth objects (pred_classes, true_classes) using IoU.
-
-        Args:
-            pred_classes (torch.Tensor): Predicted class indices of shape(N,).
-            true_classes (torch.Tensor): Target class indices of shape(M,).
-            iou (torch.Tensor): An NxM tensor containing the pairwise IoU values for predictions and ground of truth
-            use_scipy (bool): Whether to use scipy for matching (more precise).
-
-        Returns:
-            (torch.Tensor): Correct tensor of shape(N,10) for 10 IoU thresholds.
-        """
-        # Dx10 matrix, where D - detections, 10 - IoU thresholds
-        correct = np.zeros((pred_classes.shape[0], self.iouv.shape[0])).astype(bool)
-        # LxD matrix where L - labels (rows), D - detections (columns)
-        correct_class = true_classes[:, None] == pred_classes
-        iou = iou * correct_class  # zero out the wrong classes
-        iou = iou.cpu().numpy()
-        for i, threshold in enumerate(self.iouv.cpu().tolist()):
-            if use_scipy:
-                # WARNING: known issue that reduces mAP in https://github.com/ultralytics/ultralytics/pull/4708
-                import scipy  # scope import to avoid importing for all commands
-                cost_matrix = iou * (iou >= threshold)
-                if cost_matrix.any():
-                    labels_idx, detections_idx = scipy.optimize.linear_sum_assignment(cost_matrix, maximize=True)
-                    valid = cost_matrix[labels_idx, detections_idx] > 0
-                    if valid.any():
-                        correct[detections_idx[valid], i] = True
-            else:
-                matches = np.nonzero(iou >= threshold)  # IoU > threshold and classes match
-                matches = np.array(matches).T
-                if matches.shape[0]:
-                    if matches.shape[0] > 1:
-                        matches = matches[iou[matches[:, 0], matches[:, 1]].argsort()[::-1]]
-                        matches = matches[np.unique(matches[:, 1], return_index=True)[1]]
-                        # matches = matches[matches[:, 2].argsort()[::-1]]
-                        matches = matches[np.unique(matches[:, 0], return_index=True)[1]]
-                    correct[matches[:, 1].astype(int), i] = True
-        return torch.tensor(correct, dtype=torch.bool, device=pred_classes.device)
-
-    def add_callback(self, event: str, callback):
-        """Appends the given callback."""
-        self.callbacks[event].append(callback)
-
-    def run_callbacks(self, event: str):
-        """Runs all callbacks associated with a specified event."""
-        for callback in self.callbacks.get(event, []):
-            callback(self)
+    def preprocess(self, batch):
+        """Preprocesses batch of images for YOLO training."""
+        batch["img"] = batch["img"].to(self.device, non_blocking=True)
+        batch["img"] = (batch["img"].half() if self.args.half else batch["img"].float()) / 255
+        for k in ["batch_idx", "cls", "bboxes"]:
+            batch[k] = batch[k].to(self.device)
+
+        if self.args.save_hybrid:
+            height, width = batch["img"].shape[2:]
+            nb = len(batch["img"])
+            bboxes = batch["bboxes"] * torch.tensor((width, height, width, height), device=self.device)
+            self.lb = (
+                [
+                    torch.cat([batch["cls"][batch["batch_idx"] == i], bboxes[batch["batch_idx"] == i]], dim=-1)
+                    for i in range(nb)
+                ]
+                if self.args.save_hybrid
+                else []
+            )  # for autolabelling
 
-    def get_dataloader(self, dataset_path, batch_size):
-        """Get data loader from dataset path and batch size."""
-        raise NotImplementedError('get_dataloader function not implemented for this validator')
+        return batch
 
-    def build_dataset(self, img_path):
-        """Build dataset."""
-        raise NotImplementedError('build_dataset function not implemented in validator')
+    def init_metrics(self, model):
+        """Initialize evaluation metrics for YOLO."""
+        val = self.data.get(self.args.split, "")  # validation path
+        self.is_coco = isinstance(val, str) and "coco" in val and val.endswith(f"{os.sep}val2017.txt")  # is COCO
+        self.is_lvis = isinstance(val, str) and "lvis" in val and not self.is_coco  # is LVIS
+        self.class_map = converter.coco80_to_coco91_class() if self.is_coco else list(range(len(model.names)))
+        self.args.save_json |= (self.is_coco or self.is_lvis) and not self.training  # run on final val if training COCO
+        self.names = model.names
+        self.nc = len(model.names)
+        self.metrics.names = self.names
+        self.metrics.plot = self.args.plots
+        self.confusion_matrix = ConfusionMatrix(nc=self.nc, conf=self.args.conf)
+        self.seen = 0
+        self.jdict = []
+        self.stats = dict(tp=[], conf=[], pred_cls=[], target_cls=[])
 
-    def preprocess(self, batch):
-        """Preprocesses an input batch."""
-        return batch
+    def get_desc(self):
+        """Return a formatted string summarizing class metrics of YOLO model."""
+        return ("%22s" + "%11s" * 6) % ("Class", "Images", "Instances", "Box(P", "R", "mAP50", "mAP50-95)")
 
     def postprocess(self, preds):
-        """Describes and summarizes the purpose of 'postprocess()' but no details mentioned."""
-        return preds
-
-    def init_metrics(self, model):
-        """Initialize performance metrics for the YOLO model."""
-        pass
+        """Apply Non-maximum suppression to prediction outputs."""
+        return ops.non_max_suppression(
+            preds,
+            self.args.conf,
+            self.args.iou,
+            labels=self.lb,
+            multi_label=True,
+            agnostic=self.args.single_cls,
+            max_det=self.args.max_det,
+        )
+
+    def _prepare_batch(self, si, batch):
+        """Prepares a batch of images and annotations for validation."""
+        idx = batch["batch_idx"] == si
+        cls = batch["cls"][idx].squeeze(-1)
+        bbox = batch["bboxes"][idx]
+        ori_shape = batch["ori_shape"][si]
+        imgsz = batch["img"].shape[2:]
+        ratio_pad = batch["ratio_pad"][si]
+        if len(cls):
+            bbox = ops.xywh2xyxy(bbox) * torch.tensor(imgsz, device=self.device)[[1, 0, 1, 0]]  # target boxes
+            ops.scale_boxes(imgsz, bbox, ori_shape, ratio_pad=ratio_pad)  # native-space labels
+        return {"cls": cls, "bbox": bbox, "ori_shape": ori_shape, "imgsz": imgsz, "ratio_pad": ratio_pad}
+
+    def _prepare_pred(self, pred, pbatch):
+        """Prepares a batch of images and annotations for validation."""
+        predn = pred.clone()
+        ops.scale_boxes(
+            pbatch["imgsz"], predn[:, :4], pbatch["ori_shape"], ratio_pad=pbatch["ratio_pad"]
+        )  # native-space pred
+        return predn
 
     def update_metrics(self, preds, batch):
-        """Updates metrics based on predictions and batch."""
-        pass
+        """Metrics."""
+        for si, pred in enumerate(preds):
+            self.seen += 1
+            npr = len(pred)
+            stat = dict(
+                conf=torch.zeros(0, device=self.device),
+                pred_cls=torch.zeros(0, device=self.device),
+                tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),
+            )
+            pbatch = self._prepare_batch(si, batch)
+            cls, bbox = pbatch.pop("cls"), pbatch.pop("bbox")
+            nl = len(cls)
+            stat["target_cls"] = cls
+            if npr == 0:
+                if nl:
+                    for k in self.stats.keys():
+                        self.stats[k].append(stat[k])
+                    if self.args.plots:
+                        self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)
+                continue
+
+            # Predictions
+            if self.args.single_cls:
+                pred[:, 5] = 0
+            predn = self._prepare_pred(pred, pbatch)
+            stat["conf"] = predn[:, 4]
+            stat["pred_cls"] = predn[:, 5]
+
+            # Evaluate
+            if nl:
+                stat["tp"] = self._process_batch(predn, bbox, cls)
+                if self.args.plots:
+                    self.confusion_matrix.process_batch(predn, bbox, cls)
+            for k in self.stats.keys():
+                self.stats[k].append(stat[k])
+
+            # Save
+            if self.args.save_json:
+                self.pred_to_json(predn, batch["im_file"][si])
+            if self.args.save_txt:
+                file = self.save_dir / "labels" / f'{Path(batch["im_file"][si]).stem}.txt'
+                self.save_one_txt(predn, self.args.save_conf, pbatch["ori_shape"], file)
 
     def finalize_metrics(self, *args, **kwargs):
-        """Finalizes and returns all metrics."""
-        pass
+        """Set final values for metrics speed and confusion matrix."""
+        self.metrics.speed = self.speed
+        self.metrics.confusion_matrix = self.confusion_matrix
 
     def get_stats(self):
-        """Returns statistics about the model's performance."""
-        return {}
-
-    def check_stats(self, stats):
-        """Checks statistics."""
-        pass
+        """Returns metrics statistics and results dictionary."""
+        stats = {k: torch.cat(v, 0).cpu().numpy() for k, v in self.stats.items()}  # to numpy
+        if len(stats) and stats["tp"].any():
+            self.metrics.process(**stats)
+        self.nt_per_class = np.bincount(
+            stats["target_cls"].astype(int), minlength=self.nc
+        )  # number of targets per class
+        return self.metrics.results_dict
 
     def print_results(self):
-        """Prints the results of the model's predictions."""
-        pass
+        """Prints training/validation set metrics per class."""
+        pf = "%22s" + "%11i" * 2 + "%11.3g" * len(self.metrics.keys)  # print format
+        LOGGER.info(pf % ("all", self.seen, self.nt_per_class.sum(), *self.metrics.mean_results()))
+        if self.nt_per_class.sum() == 0:
+            LOGGER.warning(f"WARNING  no labels found in {self.args.task} set, can not compute metrics without labels")
+
+        # Print results per class
+        if self.args.verbose and not self.training and self.nc > 1 and len(self.stats):
+            for i, c in enumerate(self.metrics.ap_class_index):
+                LOGGER.info(pf % (self.names[c], self.seen, self.nt_per_class[c], *self.metrics.class_result(i)))
+
+        if self.args.plots:
+            for normalize in True, False:
+                self.confusion_matrix.plot(
+                    save_dir=self.save_dir, names=self.names.values(), normalize=normalize, on_plot=self.on_plot
+                )
 
-    def get_desc(self):
-        """Get description of the YOLO model."""
-        pass
+    def _process_batch(self, detections, gt_bboxes, gt_cls):
+        """
+        Return correct prediction matrix.
+
+        Args:
+            detections (torch.Tensor): Tensor of shape [N, 6] representing detections.
+                Each detection is of the format: x1, y1, x2, y2, conf, class.
+            labels (torch.Tensor): Tensor of shape [M, 5] representing labels.
+                Each label is of the format: class, x1, y1, x2, y2.
+
+        Returns:
+            (torch.Tensor): Correct prediction matrix of shape [N, 10] for 10 IoU levels.
+        """
+        iou = box_iou(gt_bboxes, detections[:, :4])
+        return self.match_predictions(detections[:, 5], gt_cls, iou)
 
-    @property
-    def metric_keys(self):
-        """Returns the metric keys used in YOLO training/validation."""
-        return []
-
-    def on_plot(self, name, data=None):
-        """Registers plots (e.g. to be consumed in callbacks)"""
-        self.plots[Path(name)] = {'data': data, 'timestamp': time.time()}
+    def build_dataset(self, img_path, mode="val", batch=None):
+        """
+        Build YOLO Dataset.
+
+        Args:
+            img_path (str): Path to the folder containing images.
+            mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.
+            batch (int, optional): Size of batches, this is for `rect`. Defaults to None.
+        """
+        return build_yolo_dataset(self.args, img_path, batch, self.data, mode=mode, stride=self.stride)
+
+    def get_dataloader(self, dataset_path, batch_size):
+        """Construct and return dataloader."""
+        dataset = self.build_dataset(dataset_path, batch=batch_size, mode="val")
+        return build_dataloader(dataset, batch_size, self.args.workers, shuffle=False, rank=-1)  # return dataloader
 
-    # TODO: may need to put these following functions into callback
     def plot_val_samples(self, batch, ni):
-        """Plots validation samples during training."""
-        pass
+        """Plot validation image samples."""
+        plot_images(
+            batch["img"],
+            batch["batch_idx"],
+            batch["cls"].squeeze(-1),
+            batch["bboxes"],
+            paths=batch["im_file"],
+            fname=self.save_dir / f"val_batch{ni}_labels.jpg",
+            names=self.names,
+            on_plot=self.on_plot,
+        )
 
     def plot_predictions(self, batch, preds, ni):
-        """Plots YOLO model predictions on batch images."""
-        pass
-
-    def pred_to_json(self, preds, batch):
-        """Convert predictions to JSON format."""
-        pass
+        """Plots predicted bounding boxes on input images and saves the result."""
+        plot_images(
+            batch["img"],
+            *output_to_target(preds, max_det=self.args.max_det),
+            paths=batch["im_file"],
+            fname=self.save_dir / f"val_batch{ni}_pred.jpg",
+            names=self.names,
+            on_plot=self.on_plot,
+        )  # pred
+
+    def save_one_txt(self, predn, save_conf, shape, file):
+        """Save YOLO detections to a txt file in normalized coordinates in a specific format."""
+        gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh
+        for *xyxy, conf, cls in predn.tolist():
+            xywh = (ops.xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh
+            line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format
+            with open(file, "a") as f:
+                f.write(("%g " * len(line)).rstrip() % line + "\n")
+
+    def pred_to_json(self, predn, filename):
+        """Serialize YOLO predictions to COCO json format."""
+        stem = Path(filename).stem
+        image_id = int(stem) if stem.isnumeric() else stem
+        box = ops.xyxy2xywh(predn[:, :4])  # xywh
+        box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner
+        for p, b in zip(predn.tolist(), box.tolist()):
+            self.jdict.append(
+                {
+                    "image_id": image_id,
+                    "category_id": self.class_map[int(p[5])]
+                    + (1 if self.is_lvis else 0),  # index starts from 1 if it's lvis
+                    "bbox": [round(x, 3) for x in b],
+                    "score": round(p[4], 5),
+                }
+            )
 
     def eval_json(self, stats):
-        """Evaluate and return JSON format of prediction statistics."""
-        pass
+        """Evaluates YOLO output in JSON format and returns performance statistics."""
+        if self.args.save_json and (self.is_coco or self.is_lvis) and len(self.jdict):
+            pred_json = self.save_dir / "predictions.json"  # predictions
+            anno_json = (
+                self.data["path"]
+                / "annotations"
+                / ("instances_val2017.json" if self.is_coco else f"lvis_v1_{self.args.split}.json")
+            )  # annotations
+            pkg = "pycocotools" if self.is_coco else "lvis"
+            LOGGER.info(f"\nEvaluating {pkg} mAP using {pred_json} and {anno_json}...")
+            try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb
+                for x in pred_json, anno_json:
+                    assert x.is_file(), f"{x} file not found"
+                check_requirements("pycocotools>=2.0.6" if self.is_coco else "lvis>=0.5.3")
+                if self.is_coco:
+                    from pycocotools.coco import COCO  # noqa
+                    from pycocotools.cocoeval import COCOeval  # noqa
+
+                    anno = COCO(str(anno_json))  # init annotations api
+                    pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)
+                    eval = COCOeval(anno, pred, "bbox")
+                else:
+                    from lvis import LVIS, LVISEval
+
+                    anno = LVIS(str(anno_json))  # init annotations api
+                    pred = anno._load_json(str(pred_json))  # init predictions api (must pass string, not Path)
+                    eval = LVISEval(anno, pred, "bbox")
+                eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # images to eval
+                eval.evaluate()
+                eval.accumulate()
+                eval.summarize()
+                if self.is_lvis:
+                    eval.print_results()  # explicitly call print_results
+                # update mAP50-95 and mAP50
+                stats[self.metrics.keys[-1]], stats[self.metrics.keys[-2]] = (
+                    eval.stats[:2] if self.is_coco else [eval.results["AP50"], eval.results["AP"]]
+                )
+            except Exception as e:
+                LOGGER.warning(f"{pkg} unable to run: {e}")
+        return stats
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/hub/__init__.py` & `yolov8_pose_triton-8.2.0/ultralytics/hub/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,88 +1,116 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import requests
 
 from ultralytics.data.utils import HUBDatasetStats
 from ultralytics.hub.auth import Auth
 from ultralytics.hub.utils import HUB_API_ROOT, HUB_WEB_ROOT, PREFIX
-from ultralytics.utils import LOGGER, SETTINGS
+from ultralytics.utils import LOGGER, SETTINGS, checks
 
 
-def login(api_key=''):
+def login(api_key: str = None, save=True) -> bool:
     """
     Log in to the Ultralytics HUB API using the provided API key.
 
-    Args:
-        api_key (str, optional): May be an API key or a combination API key and model ID, i.e. key_id
-
-    Example:
-        ```python
-        from ultralytics import hub
+    The session is not stored; a new session is created when needed using the saved SETTINGS or the HUB_API_KEY
+    environment variable if successfully authenticated.
 
-        hub.login('API_KEY')
-        ```
-    """
-    Auth(api_key, verbose=True)
+    Args:
+        api_key (str, optional): API key to use for authentication.
+            If not provided, it will be retrieved from SETTINGS or HUB_API_KEY environment variable.
+        save (bool, optional): Whether to save the API key to SETTINGS if authentication is successful.
+
+    Returns:
+        (bool): True if authentication is successful, False otherwise.
+    """
+    checks.check_requirements("hub-sdk>=0.0.6")
+    from hub_sdk import HUBClient
+
+    api_key_url = f"{HUB_WEB_ROOT}/settings?tab=api+keys"  # set the redirect URL
+    saved_key = SETTINGS.get("api_key")
+    active_key = api_key or saved_key
+    credentials = {"api_key": active_key} if active_key and active_key != "" else None  # set credentials
+
+    client = HUBClient(credentials)  # initialize HUBClient
+
+    if client.authenticated:
+        # Successfully authenticated with HUB
+
+        if save and client.api_key != saved_key:
+            SETTINGS.update({"api_key": client.api_key})  # update settings with valid API key
+
+        # Set message based on whether key was provided or retrieved from settings
+        log_message = (
+            "New authentication successful " if client.api_key == api_key or not credentials else "Authenticated "
+        )
+        LOGGER.info(f"{PREFIX}{log_message}")
+
+        return True
+    else:
+        # Failed to authenticate with HUB
+        LOGGER.info(f"{PREFIX}Get API key from {api_key_url} and then run 'yolo hub login API_KEY'")
+        return False
 
 
 def logout():
     """
     Log out of Ultralytics HUB by removing the API key from the settings file. To log in again, use 'yolo hub login'.
 
     Example:
         ```python
         from ultralytics import hub
 
         hub.logout()
         ```
     """
-    SETTINGS['api_key'] = ''
+    SETTINGS["api_key"] = ""
     SETTINGS.save()
     LOGGER.info(f"{PREFIX}logged out . To log in again, use 'yolo hub login'.")
 
 
-def reset_model(model_id=''):
+def reset_model(model_id=""):
     """Reset a trained model to an untrained state."""
-    r = requests.post(f'{HUB_API_ROOT}/model-reset', json={'apiKey': Auth().api_key, 'modelId': model_id})
+    r = requests.post(f"{HUB_API_ROOT}/model-reset", json={"modelId": model_id}, headers={"x-api-key": Auth().api_key})
     if r.status_code == 200:
-        LOGGER.info(f'{PREFIX}Model reset successfully')
+        LOGGER.info(f"{PREFIX}Model reset successfully")
         return
-    LOGGER.warning(f'{PREFIX}Model reset failure {r.status_code} {r.reason}')
+    LOGGER.warning(f"{PREFIX}Model reset failure {r.status_code} {r.reason}")
 
 
 def export_fmts_hub():
     """Returns a list of HUB-supported export formats."""
     from ultralytics.engine.exporter import export_formats
-    return list(export_formats()['Argument'][1:]) + ['ultralytics_tflite', 'ultralytics_coreml']
+
+    return list(export_formats()["Argument"][1:]) + ["ultralytics_tflite", "ultralytics_coreml"]
 
 
-def export_model(model_id='', format='torchscript'):
+def export_model(model_id="", format="torchscript"):
     """Export a model to all formats."""
     assert format in export_fmts_hub(), f"Unsupported export format '{format}', valid formats are {export_fmts_hub()}"
-    r = requests.post(f'{HUB_API_ROOT}/v1/models/{model_id}/export',
-                      json={'format': format},
-                      headers={'x-api-key': Auth().api_key})
-    assert r.status_code == 200, f'{PREFIX}{format} export failure {r.status_code} {r.reason}'
-    LOGGER.info(f'{PREFIX}{format} export started ')
+    r = requests.post(
+        f"{HUB_API_ROOT}/v1/models/{model_id}/export", json={"format": format}, headers={"x-api-key": Auth().api_key}
+    )
+    assert r.status_code == 200, f"{PREFIX}{format} export failure {r.status_code} {r.reason}"
+    LOGGER.info(f"{PREFIX}{format} export started ")
 
 
-def get_export(model_id='', format='torchscript'):
+def get_export(model_id="", format="torchscript"):
     """Get an exported model dictionary with download URL."""
     assert format in export_fmts_hub(), f"Unsupported export format '{format}', valid formats are {export_fmts_hub()}"
-    r = requests.post(f'{HUB_API_ROOT}/get-export',
-                      json={
-                          'apiKey': Auth().api_key,
-                          'modelId': model_id,
-                          'format': format})
-    assert r.status_code == 200, f'{PREFIX}{format} get_export failure {r.status_code} {r.reason}'
+    r = requests.post(
+        f"{HUB_API_ROOT}/get-export",
+        json={"apiKey": Auth().api_key, "modelId": model_id, "format": format},
+        headers={"x-api-key": Auth().api_key},
+    )
+    assert r.status_code == 200, f"{PREFIX}{format} get_export failure {r.status_code} {r.reason}"
     return r.json()
 
 
-def check_dataset(path='', task='detect'):
+def check_dataset(path="", task="detect"):
     """
     Function for error-checking HUB dataset Zip file before upload. It checks a dataset for errors before it is uploaded
     to the HUB. Usage examples are given below.
 
     Args:
         path (str, optional): Path to data.zip (with data.yaml inside data.zip). Defaults to ''.
         task (str, optional): Dataset task. Options are 'detect', 'segment', 'pose', 'classify'. Defaults to 'detect'.
@@ -93,8 +121,8 @@
 
         check_dataset('path/to/coco8.zip', task='detect')  # detect dataset
         check_dataset('path/to/coco8-seg.zip', task='segment')  # segment dataset
         check_dataset('path/to/coco8-pose.zip', task='pose')  # pose dataset
         ```
     """
     HUBDatasetStats(path=path, task=task).get_json()
-    LOGGER.info(f'Checks completed correctly . Upload this dataset to {HUB_WEB_ROOT}/datasets/.')
+    LOGGER.info(f"Checks completed correctly . Upload this dataset to {HUB_WEB_ROOT}/datasets/.")
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/hub/auth.py` & `yolov8_pose_triton-8.2.0/ultralytics/hub/auth.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import requests
 
 from ultralytics.hub.utils import HUB_API_ROOT, HUB_WEB_ROOT, PREFIX, request_with_credentials
-from ultralytics.utils import LOGGER, SETTINGS, emojis, is_colab
+from ultralytics.utils import IS_COLAB, LOGGER, SETTINGS, emojis
 
-API_KEY_URL = f'{HUB_WEB_ROOT}/settings?tab=api+keys'
+API_KEY_URL = f"{HUB_WEB_ROOT}/settings?tab=api+keys"
 
 
 class Auth:
     """
     Manages authentication processes including API key handling, cookie-based authentication, and header generation.
 
     The class supports different methods of authentication:
@@ -18,117 +18,119 @@
     3. Prompting the user to enter an API key.
 
     Attributes:
         id_token (str or bool): Token used for identity verification, initialized as False.
         api_key (str or bool): API key for authentication, initialized as False.
         model_key (bool): Placeholder for model key, initialized as False.
     """
+
     id_token = api_key = model_key = False
 
-    def __init__(self, api_key='', verbose=False):
+    def __init__(self, api_key="", verbose=False):
         """
         Initialize the Auth class with an optional API key.
 
         Args:
             api_key (str, optional): May be an API key or a combination API key and model ID, i.e. key_id
         """
         # Split the input API key in case it contains a combined key_model and keep only the API key part
-        api_key = api_key.split('_')[0]
+        api_key = api_key.split("_")[0]
 
         # Set API key attribute as value passed or SETTINGS API key if none passed
-        self.api_key = api_key or SETTINGS.get('api_key', '')
+        self.api_key = api_key or SETTINGS.get("api_key", "")
 
         # If an API key is provided
         if self.api_key:
             # If the provided API key matches the API key in the SETTINGS
-            if self.api_key == SETTINGS.get('api_key'):
+            if self.api_key == SETTINGS.get("api_key"):
                 # Log that the user is already logged in
                 if verbose:
-                    LOGGER.info(f'{PREFIX}Authenticated ')
+                    LOGGER.info(f"{PREFIX}Authenticated ")
                 return
             else:
                 # Attempt to authenticate with the provided API key
                 success = self.authenticate()
         # If the API key is not provided and the environment is a Google Colab notebook
-        elif is_colab():
+        elif IS_COLAB:
             # Attempt to authenticate using browser cookies
             success = self.auth_with_cookies()
         else:
             # Request an API key
             success = self.request_api_key()
 
         # Update SETTINGS with the new API key after successful authentication
         if success:
-            SETTINGS.update({'api_key': self.api_key})
+            SETTINGS.update({"api_key": self.api_key})
             # Log that the new login was successful
             if verbose:
-                LOGGER.info(f'{PREFIX}New authentication successful ')
+                LOGGER.info(f"{PREFIX}New authentication successful ")
         elif verbose:
-            LOGGER.info(f'{PREFIX}Retrieve API key from {API_KEY_URL}')
+            LOGGER.info(f"{PREFIX}Get API key from {API_KEY_URL} and then run 'yolo hub login API_KEY'")
 
     def request_api_key(self, max_attempts=3):
         """
         Prompt the user to input their API key.
 
         Returns the model ID.
         """
         import getpass
+
         for attempts in range(max_attempts):
-            LOGGER.info(f'{PREFIX}Login. Attempt {attempts + 1} of {max_attempts}')
-            input_key = getpass.getpass(f'Enter API key from {API_KEY_URL} ')
-            self.api_key = input_key.split('_')[0]  # remove model id if present
+            LOGGER.info(f"{PREFIX}Login. Attempt {attempts + 1} of {max_attempts}")
+            input_key = getpass.getpass(f"Enter API key from {API_KEY_URL} ")
+            self.api_key = input_key.split("_")[0]  # remove model id if present
             if self.authenticate():
                 return True
-        raise ConnectionError(emojis(f'{PREFIX}Failed to authenticate '))
+        raise ConnectionError(emojis(f"{PREFIX}Failed to authenticate "))
 
     def authenticate(self) -> bool:
         """
         Attempt to authenticate with the server using either id_token or API key.
 
         Returns:
-            bool: True if authentication is successful, False otherwise.
+            (bool): True if authentication is successful, False otherwise.
         """
         try:
             if header := self.get_auth_header():
-                r = requests.post(f'{HUB_API_ROOT}/v1/auth', headers=header)
-                if not r.json().get('success', False):
-                    raise ConnectionError('Unable to authenticate.')
+                r = requests.post(f"{HUB_API_ROOT}/v1/auth", headers=header)
+                if not r.json().get("success", False):
+                    raise ConnectionError("Unable to authenticate.")
                 return True
-            raise ConnectionError('User has not authenticated locally.')
+            raise ConnectionError("User has not authenticated locally.")
         except ConnectionError:
             self.id_token = self.api_key = False  # reset invalid
-            LOGGER.warning(f'{PREFIX}Invalid API key ')
+            LOGGER.warning(f"{PREFIX}Invalid API key ")
             return False
 
     def auth_with_cookies(self) -> bool:
         """
         Attempt to fetch authentication via cookies and set id_token. User must be logged in to HUB and running in a
         supported browser.
 
         Returns:
-            bool: True if authentication is successful, False otherwise.
+            (bool): True if authentication is successful, False otherwise.
         """
-        if not is_colab():
+        if not IS_COLAB:
             return False  # Currently only works with Colab
         try:
-            authn = request_with_credentials(f'{HUB_API_ROOT}/v1/auth/auto')
-            if authn.get('success', False):
-                self.id_token = authn.get('data', {}).get('idToken', None)
+            authn = request_with_credentials(f"{HUB_API_ROOT}/v1/auth/auto")
+            if authn.get("success", False):
+                self.id_token = authn.get("data", {}).get("idToken", None)
                 self.authenticate()
                 return True
-            raise ConnectionError('Unable to fetch browser authentication details.')
+            raise ConnectionError("Unable to fetch browser authentication details.")
         except ConnectionError:
             self.id_token = False  # reset invalid
             return False
 
     def get_auth_header(self):
         """
         Get the authentication header for making API requests.
 
         Returns:
             (dict): The authentication header if id_token or API key is set, None otherwise.
         """
         if self.id_token:
-            return {'authorization': f'Bearer {self.id_token}'}
+            return {"authorization": f"Bearer {self.id_token}"}
         elif self.api_key:
-            return {'x-api-key': self.api_key}
+            return {"x-api-key": self.api_key}
         # else returns None
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/hub/session.py` & `yolov8_pose_triton-8.2.0/ultralytics/hub/utils.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,191 +1,247 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
-import signal
-import sys
+import os
+import platform
+import random
+import threading
+import time
 from pathlib import Path
-from time import sleep
 
 import requests
 
-from ultralytics.hub.utils import HUB_API_ROOT, HUB_WEB_ROOT, PREFIX, smart_request
-from ultralytics.utils import LOGGER, __version__, checks, emojis, is_colab, threaded
-from ultralytics.utils.errors import HUBModelError
+from ultralytics.utils import (
+    ARGV,
+    ENVIRONMENT,
+    IS_COLAB,
+    IS_GIT_DIR,
+    IS_PIP_PACKAGE,
+    LOGGER,
+    ONLINE,
+    RANK,
+    SETTINGS,
+    TESTS_RUNNING,
+    TQDM,
+    TryExcept,
+    __version__,
+    colorstr,
+    get_git_origin_url,
+)
+from ultralytics.utils.downloads import GITHUB_ASSETS_NAMES
 
-AGENT_NAME = f'python-{__version__}-colab' if is_colab() else f'python-{__version__}-local'
+HUB_API_ROOT = os.environ.get("ULTRALYTICS_HUB_API", "https://api.ultralytics.com")
+HUB_WEB_ROOT = os.environ.get("ULTRALYTICS_HUB_WEB", "https://hub.ultralytics.com")
 
+PREFIX = colorstr("Ultralytics HUB: ")
+HELP_MSG = "If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance."
 
-class HUBTrainingSession:
+
+def request_with_credentials(url: str) -> any:
     """
-    HUB training session for Ultralytics HUB YOLO models. Handles model initialization, heartbeats, and checkpointing.
+    Make an AJAX request with cookies attached in a Google Colab environment.
 
     Args:
-        url (str): Model identifier used to initialize the HUB training session.
+        url (str): The URL to make the request to.
 
-    Attributes:
-        agent_id (str): Identifier for the instance communicating with the server.
-        model_id (str): Identifier for the YOLO model being trained.
-        model_url (str): URL for the model in Ultralytics HUB.
-        api_url (str): API URL for the model in Ultralytics HUB.
-        auth_header (dict): Authentication header for the Ultralytics HUB API requests.
-        rate_limits (dict): Rate limits for different API calls (in seconds).
-        timers (dict): Timers for rate limiting.
-        metrics_queue (dict): Queue for the model's metrics.
-        model (dict): Model data fetched from Ultralytics HUB.
-        alive (bool): Indicates if the heartbeat loop is active.
+    Returns:
+        (any): The response data from the AJAX request.
+
+    Raises:
+        OSError: If the function is not run in a Google Colab environment.
     """
+    if not IS_COLAB:
+        raise OSError("request_with_credentials() must run in a Colab environment")
+    from google.colab import output  # noqa
+    from IPython import display  # noqa
+
+    display.display(
+        display.Javascript(
+            """
+            window._hub_tmp = new Promise((resolve, reject) => {
+                const timeout = setTimeout(() => reject("Failed authenticating existing browser session"), 5000)
+                fetch("%s", {
+                    method: 'POST',
+                    credentials: 'include'
+                })
+                    .then((response) => resolve(response.json()))
+                    .then((json) => {
+                    clearTimeout(timeout);
+                    }).catch((err) => {
+                    clearTimeout(timeout);
+                    reject(err);
+                });
+            });
+            """
+            % url
+        )
+    )
+    return output.eval_js("_hub_tmp")
 
-    def __init__(self, url):
-        """
-        Initialize the HUBTrainingSession with the provided model identifier.
 
-        Args:
-            url (str): Model identifier used to initialize the HUB training session.
-                         It can be a URL string or a model key with specific format.
+def requests_with_progress(method, url, **kwargs):
+    """
+    Make an HTTP request using the specified method and URL, with an optional progress bar.
 
-        Raises:
-            ValueError: If the provided model identifier is invalid.
-            ConnectionError: If connecting with global API key is not supported.
-        """
+    Args:
+        method (str): The HTTP method to use (e.g. 'GET', 'POST').
+        url (str): The URL to send the request to.
+        **kwargs (any): Additional keyword arguments to pass to the underlying `requests.request` function.
+
+    Returns:
+        (requests.Response): The response object from the HTTP request.
+
+    Note:
+        - If 'progress' is set to True, the progress bar will display the download progress for responses with a known
+        content length.
+        - If 'progress' is a number then progress bar will display assuming content length = progress.
+    """
+    progress = kwargs.pop("progress", False)
+    if not progress:
+        return requests.request(method, url, **kwargs)
+    response = requests.request(method, url, stream=True, **kwargs)
+    total = int(response.headers.get("content-length", 0) if isinstance(progress, bool) else progress)  # total size
+    try:
+        pbar = TQDM(total=total, unit="B", unit_scale=True, unit_divisor=1024)
+        for data in response.iter_content(chunk_size=1024):
+            pbar.update(len(data))
+        pbar.close()
+    except requests.exceptions.ChunkedEncodingError:  # avoid 'Connection broken: IncompleteRead' warnings
+        response.close()
+    return response
 
-        from ultralytics.hub.auth import Auth
 
-        # Parse input
-        if url.startswith(f'{HUB_WEB_ROOT}/models/'):
-            url = url.split(f'{HUB_WEB_ROOT}/models/')[-1]
-        if [len(x) for x in url.split('_')] == [42, 20]:
-            key, model_id = url.split('_')
-        elif len(url) == 20:
-            key, model_id = '', url
-        else:
-            raise HUBModelError(f"model='{url}' not found. Check format is correct, i.e. "
-                                f"model='{HUB_WEB_ROOT}/models/MODEL_ID' and try again.")
-
-        # Authorize
-        auth = Auth(key)
-        self.agent_id = None  # identifies which instance is communicating with server
-        self.model_id = model_id
-        self.model_url = f'{HUB_WEB_ROOT}/models/{model_id}'
-        self.api_url = f'{HUB_API_ROOT}/v1/models/{model_id}'
-        self.auth_header = auth.get_auth_header()
-        self.rate_limits = {'metrics': 3.0, 'ckpt': 900.0, 'heartbeat': 300.0}  # rate limits (seconds)
-        self.timers = {}  # rate limit timers (seconds)
-        self.metrics_queue = {}  # metrics queue
-        self.model = self._get_model()
-        self.alive = True
-        self._start_heartbeat()  # start heartbeats
-        self._register_signal_handlers()
-        LOGGER.info(f'{PREFIX}View model at {self.model_url} ')
-
-    def _register_signal_handlers(self):
-        """Register signal handlers for SIGTERM and SIGINT signals to gracefully handle termination."""
-        signal.signal(signal.SIGTERM, self._handle_signal)
-        signal.signal(signal.SIGINT, self._handle_signal)
+def smart_request(method, url, retry=3, timeout=30, thread=True, code=-1, verbose=True, progress=False, **kwargs):
+    """
+    Makes an HTTP request using the 'requests' library, with exponential backoff retries up to a specified timeout.
 
-    def _handle_signal(self, signum, frame):
-        """
-        Handle kill signals and prevent heartbeats from being sent on Colab after termination.
+    Args:
+        method (str): The HTTP method to use for the request. Choices are 'post' and 'get'.
+        url (str): The URL to make the request to.
+        retry (int, optional): Number of retries to attempt before giving up. Default is 3.
+        timeout (int, optional): Timeout in seconds after which the function will give up retrying. Default is 30.
+        thread (bool, optional): Whether to execute the request in a separate daemon thread. Default is True.
+        code (int, optional): An identifier for the request, used for logging purposes. Default is -1.
+        verbose (bool, optional): A flag to determine whether to print out to console or not. Default is True.
+        progress (bool, optional): Whether to show a progress bar during the request. Default is False.
+        **kwargs (any): Keyword arguments to be passed to the requests function specified in method.
 
-        This method does not use frame, it is included as it is passed by signal.
-        """
-        if self.alive is True:
-            LOGGER.info(f'{PREFIX}Kill signal received! ')
-            self._stop_heartbeat()
-            sys.exit(signum)
-
-    def _stop_heartbeat(self):
-        """Terminate the heartbeat loop."""
-        self.alive = False
-
-    def upload_metrics(self):
-        """Upload model metrics to Ultralytics HUB."""
-        payload = {'metrics': self.metrics_queue.copy(), 'type': 'metrics'}
-        smart_request('post', self.api_url, json=payload, headers=self.auth_header, code=2)
-
-    def _get_model(self):
-        """Fetch and return model data from Ultralytics HUB."""
-        api_url = f'{HUB_API_ROOT}/v1/models/{self.model_id}'
-
-        try:
-            response = smart_request('get', api_url, headers=self.auth_header, thread=False, code=0)
-            data = response.json().get('data', None)
-
-            if data.get('status', None) == 'trained':
-                raise ValueError(emojis(f'Model is already trained and uploaded to {self.model_url} '))
-
-            if not data.get('data', None):
-                raise ValueError('Dataset may still be processing. Please wait a minute and try again.')  # RF fix
-            self.model_id = data['id']
-
-            if data['status'] == 'new':  # new model to start training
-                self.train_args = {
-                    'batch': data['batch_size'],  # note HUB argument is slightly different
-                    'epochs': data['epochs'],
-                    'imgsz': data['imgsz'],
-                    'patience': data['patience'],
-                    'device': data['device'],
-                    'cache': data['cache'],
-                    'data': data['data']}
-                self.model_file = data.get('cfg') or data.get('weights')  # cfg for pretrained=False
-                self.model_file = checks.check_yolov5u_filename(self.model_file, verbose=False)  # YOLOv5->YOLOv5u
-            elif data['status'] == 'training':  # existing model to resume training
-                self.train_args = {'data': data['data'], 'resume': True}
-                self.model_file = data['resume']
-
-            return data
-        except requests.exceptions.ConnectionError as e:
-            raise ConnectionRefusedError('ERROR: The HUB server is not online. Please try again later.') from e
-        except Exception:
-            raise
+    Returns:
+        (requests.Response): The HTTP response object. If the request is executed in a separate thread, returns None.
+    """
+    retry_codes = (408, 500)  # retry only these codes
+
+    @TryExcept(verbose=verbose)
+    def func(func_method, func_url, **func_kwargs):
+        """Make HTTP requests with retries and timeouts, with optional progress tracking."""
+        r = None  # response
+        t0 = time.time()  # initial time for timer
+        for i in range(retry + 1):
+            if (time.time() - t0) > timeout:
+                break
+            r = requests_with_progress(func_method, func_url, **func_kwargs)  # i.e. get(url, data, json, files)
+            if r.status_code < 300:  # return codes in the 2xx range are generally considered "good" or "successful"
+                break
+            try:
+                m = r.json().get("message", "No JSON message.")
+            except AttributeError:
+                m = "Unable to read JSON."
+            if i == 0:
+                if r.status_code in retry_codes:
+                    m += f" Retrying {retry}x for {timeout}s." if retry else ""
+                elif r.status_code == 429:  # rate limit
+                    h = r.headers  # response headers
+                    m = (
+                        f"Rate limit reached ({h['X-RateLimit-Remaining']}/{h['X-RateLimit-Limit']}). "
+                        f"Please retry after {h['Retry-After']}s."
+                    )
+                if verbose:
+                    LOGGER.warning(f"{PREFIX}{m} {HELP_MSG} ({r.status_code} #{code})")
+                if r.status_code not in retry_codes:
+                    return r
+            time.sleep(2**i)  # exponential standoff
+        return r
+
+    args = method, url
+    kwargs["progress"] = progress
+    if thread:
+        threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True).start()
+    else:
+        return func(*args, **kwargs)
+
+
+class Events:
+    """
+    A class for collecting anonymous event analytics. Event analytics are enabled when sync=True in settings and
+    disabled when sync=False. Run 'yolo settings' to see and update settings YAML file.
+
+    Attributes:
+        url (str): The URL to send anonymous events.
+        rate_limit (float): The rate limit in seconds for sending events.
+        metadata (dict): A dictionary containing metadata about the environment.
+        enabled (bool): A flag to enable or disable Events based on certain conditions.
+    """
+
+    url = "https://www.google-analytics.com/mp/collect?measurement_id=G-X8NCJYTQXM&api_secret=QLQrATrNSwGRFRLE-cbHJw"
 
-    def upload_model(self, epoch, weights, is_best=False, map=0.0, final=False):
+    def __init__(self):
+        """Initializes the Events object with default values for events, rate_limit, and metadata."""
+        self.events = []  # events list
+        self.rate_limit = 60.0  # rate limit (seconds)
+        self.t = 0.0  # rate limit timer (seconds)
+        self.metadata = {
+            "cli": Path(ARGV[0]).name == "yolo",
+            "install": "git" if IS_GIT_DIR else "pip" if IS_PIP_PACKAGE else "other",
+            "python": ".".join(platform.python_version_tuple()[:2]),  # i.e. 3.10
+            "version": __version__,
+            "env": ENVIRONMENT,
+            "session_id": round(random.random() * 1e15),
+            "engagement_time_msec": 1000,
+        }
+        self.enabled = (
+            SETTINGS["sync"]
+            and RANK in {-1, 0}
+            and not TESTS_RUNNING
+            and ONLINE
+            and (IS_PIP_PACKAGE or get_git_origin_url() == "https://github.com/ultralytics/ultralytics.git")
+        )
+
+    def __call__(self, cfg):
         """
-        Upload a model checkpoint to Ultralytics HUB.
+        Attempts to add a new event to the events list and send events if the rate limit is reached.
 
         Args:
-            epoch (int): The current training epoch.
-            weights (str): Path to the model weights file.
-            is_best (bool): Indicates if the current model is the best one so far.
-            map (float): Mean average precision of the model.
-            final (bool): Indicates if the model is the final model after training.
+            cfg (IterableSimpleNamespace): The configuration object containing mode and task information.
         """
-        if Path(weights).is_file():
-            with open(weights, 'rb') as f:
-                file = f.read()
-        else:
-            LOGGER.warning(f'{PREFIX}WARNING  Model upload issue. Missing model {weights}.')
-            file = None
-        url = f'{self.api_url}/upload'
-        # url = 'http://httpbin.org/post'  # for debug
-        data = {'epoch': epoch}
-        if final:
-            data.update({'type': 'final', 'map': map})
-            filesize = Path(weights).stat().st_size
-            smart_request('post',
-                          url,
-                          data=data,
-                          files={'best.pt': file},
-                          headers=self.auth_header,
-                          retry=10,
-                          timeout=3600,
-                          thread=False,
-                          progress=filesize,
-                          code=4)
-        else:
-            data.update({'type': 'epoch', 'isBest': bool(is_best)})
-            smart_request('post', url, data=data, files={'last.pt': file}, headers=self.auth_header, code=3)
-
-    @threaded
-    def _start_heartbeat(self):
-        """Begin a threaded heartbeat loop to report the agent's status to Ultralytics HUB."""
-        while self.alive:
-            r = smart_request('post',
-                              f'{HUB_API_ROOT}/v1/agent/heartbeat/models/{self.model_id}',
-                              json={
-                                  'agent': AGENT_NAME,
-                                  'agentId': self.agent_id},
-                              headers=self.auth_header,
-                              retry=0,
-                              code=5,
-                              thread=False)  # already in a thread
-            self.agent_id = r.json().get('data', {}).get('agentId', None)
-            sleep(self.rate_limits['heartbeat'])
+        if not self.enabled:
+            # Events disabled, do nothing
+            return
+
+        # Attempt to add to events
+        if len(self.events) < 25:  # Events list limited to 25 events (drop any events past this)
+            params = {
+                **self.metadata,
+                "task": cfg.task,
+                "model": cfg.model if cfg.model in GITHUB_ASSETS_NAMES else "custom",
+            }
+            if cfg.mode == "export":
+                params["format"] = cfg.format
+            self.events.append({"name": cfg.mode, "params": params})
+
+        # Check rate limit
+        t = time.time()
+        if (t - self.t) < self.rate_limit:
+            # Time is under rate limiter, wait to send
+            return
+
+        # Time is over rate limiter, send now
+        data = {"client_id": SETTINGS["uuid"], "events": self.events}  # SHA-256 anonymized UUID hash and events list
+
+        # POST equivalent to requests.post(self.url, json=data)
+        smart_request("post", self.url, json=data, retry=0, verbose=False)
+
+        # Reset events and rate limit timer
+        self.events = []
+        self.t = t
+
+
+# Run below code on hub/utils init -------------------------------------------------------------------------------------
+events = Events()
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/model.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/model.py`

 * *Files 16% similar despite different names*

```diff
@@ -17,18 +17,18 @@
         from ultralytics import FastSAM
 
         model = FastSAM('last.pt')
         results = model.predict('ultralytics/assets/bus.jpg')
         ```
     """
 
-    def __init__(self, model='FastSAM-x.pt'):
+    def __init__(self, model="FastSAM-x.pt"):
         """Call the __init__ method of the parent class (YOLO) with the updated default model."""
-        if str(model) == 'FastSAM.pt':
-            model = 'FastSAM-x.pt'
-        assert Path(model).suffix not in ('.yaml', '.yml'), 'FastSAM models only support pre-trained models.'
-        super().__init__(model=model, task='segment')
+        if str(model) == "FastSAM.pt":
+            model = "FastSAM-x.pt"
+        assert Path(model).suffix not in {".yaml", ".yml"}, "FastSAM models only support pre-trained models."
+        super().__init__(model=model, task="segment")
 
     @property
     def task_map(self):
         """Returns a dictionary mapping segment task to corresponding predictor and validator classes."""
-        return {'segment': {'predictor': FastSAMPredictor, 'validator': FastSAMValidator}}
+        return {"segment": {"predictor": FastSAMPredictor, "validator": FastSAMValidator}}
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/predict.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/predict.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,15 +29,15 @@
 
         Args:
             cfg (dict): Configuration parameters for prediction.
             overrides (dict, optional): Optional parameter overrides for custom behavior.
             _callbacks (dict, optional): Optional list of callback functions to be invoked during prediction.
         """
         super().__init__(cfg, overrides, _callbacks)
-        self.args.task = 'segment'
+        self.args.task = "segment"
 
     def postprocess(self, preds, img, orig_imgs):
         """
         Perform post-processing steps on predictions, including non-max suppression and scaling boxes to original image
         size, and returns the final results.
 
         Args:
@@ -51,15 +51,16 @@
         p = ops.non_max_suppression(
             preds[0],
             self.args.conf,
             self.args.iou,
             agnostic=self.args.agnostic_nms,
             max_det=self.args.max_det,
             nc=1,  # set to 1 class since SAM has no class predictions
-            classes=self.args.classes)
+            classes=self.args.classes,
+        )
         full_box = torch.zeros(p[0].shape[1], device=p[0].device)
         full_box[2], full_box[3], full_box[4], full_box[6:] = img.shape[3], img.shape[2], 1.0, 1.0
         full_box = full_box.view(1, -1)
         critical_iou_index = bbox_iou(full_box[0][:4], p[0][:, :4], iou_thres=0.9, image_shape=img.shape[2:])
         if critical_iou_index.numel() != 0:
             full_box[0][4] = p[0][critical_iou_index][:, 4]
             full_box[0][6:] = p[0][critical_iou_index][:, 6:]
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/prompt.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/prompt.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,79 +1,78 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import os
 from pathlib import Path
 
 import cv2
-import matplotlib.pyplot as plt
 import numpy as np
 import torch
 from PIL import Image
 
-from ultralytics.utils import TQDM
+from ultralytics.utils import TQDM, checks
 
 
 class FastSAMPrompt:
     """
     Fast Segment Anything Model class for image annotation and visualization.
 
     Attributes:
         device (str): Computing device ('cuda' or 'cpu').
         results: Object detection or segmentation results.
         source: Source image or image path.
         clip: CLIP model for linear assignment.
     """
 
-    def __init__(self, source, results, device='cuda') -> None:
+    def __init__(self, source, results, device="cuda") -> None:
         """Initializes FastSAMPrompt with given source, results and device, and assigns clip for linear assignment."""
         self.device = device
         self.results = results
         self.source = source
 
         # Import and assign clip
         try:
-            import clip  # for linear_assignment
+            import clip
         except ImportError:
-            from ultralytics.utils.checks import check_requirements
-            check_requirements('git+https://github.com/openai/CLIP.git')
+            checks.check_requirements("git+https://github.com/ultralytics/CLIP.git")
             import clip
         self.clip = clip
 
     @staticmethod
     def _segment_image(image, bbox):
         """Segments the given image according to the provided bounding box coordinates."""
         image_array = np.array(image)
         segmented_image_array = np.zeros_like(image_array)
         x1, y1, x2, y2 = bbox
         segmented_image_array[y1:y2, x1:x2] = image_array[y1:y2, x1:x2]
         segmented_image = Image.fromarray(segmented_image_array)
-        black_image = Image.new('RGB', image.size, (255, 255, 255))
+        black_image = Image.new("RGB", image.size, (255, 255, 255))
         # transparency_mask = np.zeros_like((), dtype=np.uint8)
         transparency_mask = np.zeros((image_array.shape[0], image_array.shape[1]), dtype=np.uint8)
         transparency_mask[y1:y2, x1:x2] = 255
-        transparency_mask_image = Image.fromarray(transparency_mask, mode='L')
+        transparency_mask_image = Image.fromarray(transparency_mask, mode="L")
         black_image.paste(segmented_image, mask=transparency_mask_image)
         return black_image
 
     @staticmethod
     def _format_results(result, filter=0):
         """Formats detection results into list of annotations each containing ID, segmentation, bounding box, score and
         area.
         """
         annotations = []
         n = len(result.masks.data) if result.masks is not None else 0
         for i in range(n):
             mask = result.masks.data[i] == 1.0
             if torch.sum(mask) >= filter:
                 annotation = {
-                    'id': i,
-                    'segmentation': mask.cpu().numpy(),
-                    'bbox': result.boxes.data[i],
-                    'score': result.boxes.conf[i]}
-                annotation['area'] = annotation['segmentation'].sum()
+                    "id": i,
+                    "segmentation": mask.cpu().numpy(),
+                    "bbox": result.boxes.data[i],
+                    "score": result.boxes.conf[i],
+                }
+                annotation["area"] = annotation["segmentation"].sum()
                 annotations.append(annotation)
         return annotations
 
     @staticmethod
     def _get_bbox_from_mask(mask):
         """Applies morphological transformations to the mask, displays it, and if with_contours is True, draws
         contours.
@@ -87,38 +86,43 @@
                 x_t, y_t, w_t, h_t = cv2.boundingRect(b)
                 x1 = min(x1, x_t)
                 y1 = min(y1, y_t)
                 x2 = max(x2, x_t + w_t)
                 y2 = max(y2, y_t + h_t)
         return [x1, y1, x2, y2]
 
-    def plot(self,
-             annotations,
-             output,
-             bbox=None,
-             points=None,
-             point_label=None,
-             mask_random_color=True,
-             better_quality=True,
-             retina=False,
-             with_contours=True):
+    def plot(
+        self,
+        annotations,
+        output,
+        bbox=None,
+        points=None,
+        point_label=None,
+        mask_random_color=True,
+        better_quality=True,
+        retina=False,
+        with_contours=True,
+    ):
         """
         Plots annotations, bounding boxes, and points on images and saves the output.
 
         Args:
             annotations (list): Annotations to be plotted.
             output (str or Path): Output directory for saving the plots.
             bbox (list, optional): Bounding box coordinates [x1, y1, x2, y2]. Defaults to None.
             points (list, optional): Points to be plotted. Defaults to None.
             point_label (list, optional): Labels for the points. Defaults to None.
             mask_random_color (bool, optional): Whether to use random color for masks. Defaults to True.
-            better_quality (bool, optional): Whether to apply morphological transformations for better mask quality. Defaults to True.
+            better_quality (bool, optional): Whether to apply morphological transformations for better mask quality.
+                Defaults to True.
             retina (bool, optional): Whether to use retina mask. Defaults to False.
             with_contours (bool, optional): Whether to plot contours. Defaults to True.
         """
+        import matplotlib.pyplot as plt
+
         pbar = TQDM(annotations, total=len(annotations))
         for ann in pbar:
             result_name = os.path.basename(ann.path)
             image = ann.orig_img[..., ::-1]  # BGR to RGB
             original_h, original_w = ann.orig_shape
             # For macOS only
             # plt.switch_backend('TkAgg')
@@ -135,23 +139,25 @@
                 if better_quality:
                     if isinstance(masks[0], torch.Tensor):
                         masks = np.array(masks.cpu())
                     for i, mask in enumerate(masks):
                         mask = cv2.morphologyEx(mask.astype(np.uint8), cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))
                         masks[i] = cv2.morphologyEx(mask.astype(np.uint8), cv2.MORPH_OPEN, np.ones((8, 8), np.uint8))
 
-                self.fast_show_mask(masks,
-                                    plt.gca(),
-                                    random_color=mask_random_color,
-                                    bbox=bbox,
-                                    points=points,
-                                    pointlabel=point_label,
-                                    retinamask=retina,
-                                    target_height=original_h,
-                                    target_width=original_w)
+                self.fast_show_mask(
+                    masks,
+                    plt.gca(),
+                    random_color=mask_random_color,
+                    bbox=bbox,
+                    points=points,
+                    pointlabel=point_label,
+                    retinamask=retina,
+                    target_height=original_h,
+                    target_width=original_w,
+                )
 
                 if with_contours:
                     contour_all = []
                     temp = np.zeros((original_h, original_w, 1))
                     for i, mask in enumerate(masks):
                         mask = mask.astype(np.uint8)
                         if not retina:
@@ -162,18 +168,18 @@
                     color = np.array([0 / 255, 0 / 255, 1.0, 0.8])
                     contour_mask = temp / 255 * color.reshape(1, 1, -1)
                     plt.imshow(contour_mask)
 
             # Save the figure
             save_path = Path(output) / result_name
             save_path.parent.mkdir(exist_ok=True, parents=True)
-            plt.axis('off')
-            plt.savefig(save_path, bbox_inches='tight', pad_inches=0, transparent=True)
+            plt.axis("off")
+            plt.savefig(save_path, bbox_inches="tight", pad_inches=0, transparent=True)
             plt.close()
-            pbar.set_description(f'Saving {result_name} to {save_path}')
+            pbar.set_description(f"Saving {result_name} to {save_path}")
 
     @staticmethod
     def fast_show_mask(
         annotation,
         ax,
         random_color=False,
         bbox=None,
@@ -193,14 +199,16 @@
             bbox (list, optional): Bounding box coordinates [x1, y1, x2, y2]. Defaults to None.
             points (list, optional): Points to be plotted. Defaults to None.
             pointlabel (list, optional): Labels for the points. Defaults to None.
             retinamask (bool, optional): Whether to use retina mask. Defaults to True.
             target_height (int, optional): Target height for resizing. Defaults to 960.
             target_width (int, optional): Target width for resizing. Defaults to 960.
         """
+        import matplotlib.pyplot as plt
+
         n, h, w = annotation.shape  # batch, height, width
 
         areas = np.sum(annotation, axis=(1, 2))
         annotation = annotation[np.argsort(areas)]
 
         index = (annotation != 0).argmax(axis=0)
         if random_color:
@@ -208,34 +216,34 @@
         else:
             color = np.ones((n, 1, 1, 3)) * np.array([30 / 255, 144 / 255, 1.0])
         transparency = np.ones((n, 1, 1, 1)) * 0.6
         visual = np.concatenate([color, transparency], axis=-1)
         mask_image = np.expand_dims(annotation, -1) * visual
 
         show = np.zeros((h, w, 4))
-        h_indices, w_indices = np.meshgrid(np.arange(h), np.arange(w), indexing='ij')
+        h_indices, w_indices = np.meshgrid(np.arange(h), np.arange(w), indexing="ij")
         indices = (index[h_indices, w_indices], h_indices, w_indices, slice(None))
 
         show[h_indices, w_indices, :] = mask_image[indices]
         if bbox is not None:
             x1, y1, x2, y2 = bbox
-            ax.add_patch(plt.Rectangle((x1, y1), x2 - x1, y2 - y1, fill=False, edgecolor='b', linewidth=1))
+            ax.add_patch(plt.Rectangle((x1, y1), x2 - x1, y2 - y1, fill=False, edgecolor="b", linewidth=1))
         # Draw point
         if points is not None:
             plt.scatter(
                 [point[0] for i, point in enumerate(points) if pointlabel[i] == 1],
                 [point[1] for i, point in enumerate(points) if pointlabel[i] == 1],
                 s=20,
-                c='y',
+                c="y",
             )
             plt.scatter(
                 [point[0] for i, point in enumerate(points) if pointlabel[i] == 0],
                 [point[1] for i, point in enumerate(points) if pointlabel[i] == 0],
                 s=20,
-                c='m',
+                c="m",
             )
 
         if not retinamask:
             show = cv2.resize(show, (target_width, target_height), interpolation=cv2.INTER_NEAREST)
         ax.imshow(show)
 
     @torch.no_grad()
@@ -254,56 +262,57 @@
     def _crop_image(self, format_results):
         """Crops an image based on provided annotation format and returns cropped images and related data."""
         if os.path.isdir(self.source):
             raise ValueError(f"'{self.source}' is a directory, not a valid source for this function.")
         image = Image.fromarray(cv2.cvtColor(self.results[0].orig_img, cv2.COLOR_BGR2RGB))
         ori_w, ori_h = image.size
         annotations = format_results
-        mask_h, mask_w = annotations[0]['segmentation'].shape
+        mask_h, mask_w = annotations[0]["segmentation"].shape
         if ori_w != mask_w or ori_h != mask_h:
             image = image.resize((mask_w, mask_h))
         cropped_boxes = []
         cropped_images = []
         not_crop = []
         filter_id = []
         for _, mask in enumerate(annotations):
-            if np.sum(mask['segmentation']) <= 100:
+            if np.sum(mask["segmentation"]) <= 100:
                 filter_id.append(_)
                 continue
-            bbox = self._get_bbox_from_mask(mask['segmentation'])  # mask  bbox
-            cropped_boxes.append(self._segment_image(image, bbox))  # 
-            cropped_images.append(bbox)  # bbox
+            bbox = self._get_bbox_from_mask(mask["segmentation"])  # bbox from mask
+            cropped_boxes.append(self._segment_image(image, bbox))  # save cropped image
+            cropped_images.append(bbox)  # save cropped image bbox
 
         return cropped_boxes, cropped_images, not_crop, filter_id, annotations
 
     def box_prompt(self, bbox):
         """Modifies the bounding box properties and calculates IoU between masks and bounding box."""
         if self.results[0].masks is not None:
-            assert (bbox[2] != 0 and bbox[3] != 0)
+            assert bbox[2] != 0 and bbox[3] != 0
             if os.path.isdir(self.source):
                 raise ValueError(f"'{self.source}' is a directory, not a valid source for this function.")
             masks = self.results[0].masks.data
             target_height, target_width = self.results[0].orig_shape
             h = masks.shape[1]
             w = masks.shape[2]
             if h != target_height or w != target_width:
                 bbox = [
                     int(bbox[0] * w / target_width),
                     int(bbox[1] * h / target_height),
                     int(bbox[2] * w / target_width),
-                    int(bbox[3] * h / target_height), ]
+                    int(bbox[3] * h / target_height),
+                ]
             bbox[0] = max(round(bbox[0]), 0)
             bbox[1] = max(round(bbox[1]), 0)
             bbox[2] = min(round(bbox[2]), w)
             bbox[3] = min(round(bbox[3]), h)
 
             # IoUs = torch.zeros(len(masks), dtype=torch.float32)
             bbox_area = (bbox[3] - bbox[1]) * (bbox[2] - bbox[0])
 
-            masks_area = torch.sum(masks[:, bbox[1]:bbox[3], bbox[0]:bbox[2]], dim=(1, 2))
+            masks_area = torch.sum(masks[:, bbox[1] : bbox[3], bbox[0] : bbox[2]], dim=(1, 2))
             orig_masks_area = torch.sum(masks, dim=(1, 2))
 
             union = bbox_area + orig_masks_area - masks_area
             iou = masks_area / union
             max_iou_index = torch.argmax(iou)
 
             self.results[0].masks.data = torch.tensor(np.array([masks[max_iou_index].cpu().numpy()]))
@@ -312,39 +321,39 @@
     def point_prompt(self, points, pointlabel):  # numpy
         """Adjusts points on detected masks based on user input and returns the modified results."""
         if self.results[0].masks is not None:
             if os.path.isdir(self.source):
                 raise ValueError(f"'{self.source}' is a directory, not a valid source for this function.")
             masks = self._format_results(self.results[0], 0)
             target_height, target_width = self.results[0].orig_shape
-            h = masks[0]['segmentation'].shape[0]
-            w = masks[0]['segmentation'].shape[1]
+            h = masks[0]["segmentation"].shape[0]
+            w = masks[0]["segmentation"].shape[1]
             if h != target_height or w != target_width:
                 points = [[int(point[0] * w / target_width), int(point[1] * h / target_height)] for point in points]
             onemask = np.zeros((h, w))
             for annotation in masks:
-                mask = annotation['segmentation'] if isinstance(annotation, dict) else annotation
+                mask = annotation["segmentation"] if isinstance(annotation, dict) else annotation
                 for i, point in enumerate(points):
                     if mask[point[1], point[0]] == 1 and pointlabel[i] == 1:
                         onemask += mask
                     if mask[point[1], point[0]] == 1 and pointlabel[i] == 0:
                         onemask -= mask
             onemask = onemask >= 1
             self.results[0].masks.data = torch.tensor(np.array([onemask]))
         return self.results
 
     def text_prompt(self, text):
         """Processes a text prompt, applies it to existing results and returns the updated results."""
         if self.results[0].masks is not None:
             format_results = self._format_results(self.results[0], 0)
             cropped_boxes, cropped_images, not_crop, filter_id, annotations = self._crop_image(format_results)
-            clip_model, preprocess = self.clip.load('ViT-B/32', device=self.device)
+            clip_model, preprocess = self.clip.load("ViT-B/32", device=self.device)
             scores = self.retrieve(clip_model, preprocess, cropped_boxes, text, device=self.device)
             max_idx = scores.argsort()
             max_idx = max_idx[-1]
             max_idx += sum(np.array(filter_id) <= int(max_idx))
-            self.results[0].masks.data = torch.tensor(np.array([annotations[max_idx]['segmentation']]))
+            self.results[0].masks.data = torch.tensor(np.array([annotations[max_idx]["segmentation"]]))
         return self.results
 
     def everything_prompt(self):
         """Returns the processed results from the previous methods in the class."""
         return self.results
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/utils.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/utils.py`

 * *Files identical despite different names*

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/fastsam/val.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/fastsam/val.py`

 * *Files 1% similar despite different names*

```diff
@@ -31,10 +31,10 @@
             args (SimpleNamespace): Configuration for the validator.
             _callbacks (dict): Dictionary to store various callback functions.
 
         Notes:
             Plots for ConfusionMatrix and other related metrics are disabled in this class to avoid errors.
         """
         super().__init__(dataloader, save_dir, pbar, args, _callbacks)
-        self.args.task = 'segment'
+        self.args.task = "segment"
         self.args.plots = False  # disable ConfusionMatrix and other plots to avoid errors
         self.metrics = SegmentMetrics(save_dir=self.save_dir, on_plot=self.on_plot)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/nas/model.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/nas/model.py`

 * *Files 4% similar despite different names*

```diff
@@ -40,44 +40,45 @@
     Attributes:
         model (str): Path to the pre-trained model or model name. Defaults to 'yolo_nas_s.pt'.
 
     Note:
         YOLO-NAS models only support pre-trained models. Do not provide YAML configuration files.
     """
 
-    def __init__(self, model='yolo_nas_s.pt') -> None:
+    def __init__(self, model="yolo_nas_s.pt") -> None:
         """Initializes the NAS model with the provided or default 'yolo_nas_s.pt' model."""
-        assert Path(model).suffix not in ('.yaml', '.yml'), 'YOLO-NAS models only support pre-trained models.'
-        super().__init__(model, task='detect')
+        assert Path(model).suffix not in {".yaml", ".yml"}, "YOLO-NAS models only support pre-trained models."
+        super().__init__(model, task="detect")
 
     @smart_inference_mode()
     def _load(self, weights: str, task: str):
         """Loads an existing NAS model weights or creates a new NAS model with pretrained weights if not provided."""
         import super_gradients
+
         suffix = Path(weights).suffix
-        if suffix == '.pt':
+        if suffix == ".pt":
             self.model = torch.load(weights)
-        elif suffix == '':
-            self.model = super_gradients.training.models.get(weights, pretrained_weights='coco')
+        elif suffix == "":
+            self.model = super_gradients.training.models.get(weights, pretrained_weights="coco")
         # Standardize model
         self.model.fuse = lambda verbose=True: self.model
         self.model.stride = torch.tensor([32])
         self.model.names = dict(enumerate(self.model._class_names))
         self.model.is_fused = lambda: False  # for info()
         self.model.yaml = {}  # for info()
         self.model.pt_path = weights  # for export()
-        self.model.task = 'detect'  # for export()
+        self.model.task = "detect"  # for export()
 
     def info(self, detailed=False, verbose=True):
         """
         Logs model info.
 
         Args:
             detailed (bool): Show detailed information about model.
             verbose (bool): Controls verbosity.
         """
         return model_info(self.model, detailed=detailed, verbose=verbose, imgsz=640)
 
     @property
     def task_map(self):
         """Returns a dictionary mapping tasks to respective predictor and validator classes."""
-        return {'detect': {'predictor': NASPredictor, 'validator': NASValidator}}
+        return {"detect": {"predictor": NASPredictor, "validator": NASValidator}}
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/nas/predict.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/nas/predict.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,20 +35,22 @@
     def postprocess(self, preds_in, img, orig_imgs):
         """Postprocess predictions and returns a list of Results objects."""
 
         # Cat boxes and class scores
         boxes = ops.xyxy2xywh(preds_in[0][0])
         preds = torch.cat((boxes, preds_in[0][1]), -1).permute(0, 2, 1)
 
-        preds = ops.non_max_suppression(preds,
-                                        self.args.conf,
-                                        self.args.iou,
-                                        agnostic=self.args.agnostic_nms,
-                                        max_det=self.args.max_det,
-                                        classes=self.args.classes)
+        preds = ops.non_max_suppression(
+            preds,
+            self.args.conf,
+            self.args.iou,
+            agnostic=self.args.agnostic_nms,
+            max_det=self.args.max_det,
+            classes=self.args.classes,
+        )
 
         if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list
             orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)
 
         results = []
         for i, pred in enumerate(preds):
             orig_img = orig_imgs[i]
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/nas/val.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/nas/val.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import torch
 
 from ultralytics.models.yolo.detect import DetectionValidator
 from ultralytics.utils import ops
 
-__all__ = ['NASValidator']
+__all__ = ["NASValidator"]
 
 
 class NASValidator(DetectionValidator):
     """
     Ultralytics YOLO NAS Validator for object detection.
 
     Extends `DetectionValidator` from the Ultralytics models package and is designed to post-process the raw predictions
@@ -34,15 +34,17 @@
         This class is generally not instantiated directly but is used internally within the `NAS` class.
     """
 
     def postprocess(self, preds_in):
         """Apply Non-maximum suppression to prediction outputs."""
         boxes = ops.xyxy2xywh(preds_in[0][0])
         preds = torch.cat((boxes, preds_in[0][1]), -1).permute(0, 2, 1)
-        return ops.non_max_suppression(preds,
-                                       self.args.conf,
-                                       self.args.iou,
-                                       labels=self.lb,
-                                       multi_label=False,
-                                       agnostic=self.args.single_cls,
-                                       max_det=self.args.max_det,
-                                       max_time_img=0.5)
+        return ops.non_max_suppression(
+            preds,
+            self.args.conf,
+            self.args.iou,
+            labels=self.lb,
+            multi_label=False,
+            agnostic=self.args.single_cls,
+            max_det=self.args.max_det,
+            max_time_img=0.5,
+        )
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/model.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/model.py`

 * *Files 12% similar despite different names*

```diff
@@ -20,35 +20,35 @@
     Interface for Baidu's RT-DETR model. This Vision Transformer-based object detector provides real-time performance
     with high accuracy. It supports efficient hybrid encoding, IoU-aware query selection, and adaptable inference speed.
 
     Attributes:
         model (str): Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.
     """
 
-    def __init__(self, model='rtdetr-l.pt') -> None:
+    def __init__(self, model="rtdetr-l.pt") -> None:
         """
         Initializes the RT-DETR model with the given pre-trained model file. Supports .pt and .yaml formats.
 
         Args:
             model (str): Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.
 
         Raises:
             NotImplementedError: If the model file extension is not 'pt', 'yaml', or 'yml'.
         """
-        if model and model.split('.')[-1] not in ('pt', 'yaml', 'yml'):
-            raise NotImplementedError('RT-DETR only supports creating from *.pt, *.yaml, or *.yml files.')
-        super().__init__(model=model, task='detect')
+        super().__init__(model=model, task="detect")
 
     @property
     def task_map(self) -> dict:
         """
         Returns a task map for RT-DETR, associating tasks with corresponding Ultralytics classes.
 
         Returns:
             dict: A dictionary mapping task names to Ultralytics task classes for the RT-DETR model.
         """
         return {
-            'detect': {
-                'predictor': RTDETRPredictor,
-                'validator': RTDETRValidator,
-                'trainer': RTDETRTrainer,
-                'model': RTDETRDetectionModel}}
+            "detect": {
+                "predictor": RTDETRPredictor,
+                "validator": RTDETRValidator,
+                "trainer": RTDETRTrainer,
+                "model": RTDETRDetectionModel,
+            }
+        }
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/predict.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/predict.py`

 * *Files 13% similar despite different names*

```diff
@@ -34,22 +34,25 @@
     def postprocess(self, preds, img, orig_imgs):
         """
         Postprocess the raw predictions from the model to generate bounding boxes and confidence scores.
 
         The method filters detections based on confidence and class if specified in `self.args`.
 
         Args:
-            preds (torch.Tensor): Raw predictions from the model.
+            preds (list): List of [predictions, extra] from the model.
             img (torch.Tensor): Processed input images.
             orig_imgs (list or torch.Tensor): Original, unprocessed images.
 
         Returns:
             (list[Results]): A list of Results objects containing the post-processed bounding boxes, confidence scores,
                 and class labels.
         """
+        if not isinstance(preds, (list, tuple)):  # list for PyTorch inference but list[0] Tensor for export inference
+            preds = [preds, None]
+
         nd = preds[0].shape[-1]
         bboxes, scores = preds[0].split((4, nd - 4), dim=-1)
 
         if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list
             orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)
 
         results = []
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/train.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/train.py`

 * *Files 7% similar despite different names*

```diff
@@ -39,62 +39,64 @@
             cfg (dict, optional): Model configuration. Defaults to None.
             weights (str, optional): Path to pre-trained model weights. Defaults to None.
             verbose (bool): Verbose logging if True. Defaults to True.
 
         Returns:
             (RTDETRDetectionModel): Initialized model.
         """
-        model = RTDETRDetectionModel(cfg, nc=self.data['nc'], verbose=verbose and RANK == -1)
+        model = RTDETRDetectionModel(cfg, nc=self.data["nc"], verbose=verbose and RANK == -1)
         if weights:
             model.load(weights)
         return model
 
-    def build_dataset(self, img_path, mode='val', batch=None):
+    def build_dataset(self, img_path, mode="val", batch=None):
         """
         Build and return an RT-DETR dataset for training or validation.
 
         Args:
             img_path (str): Path to the folder containing images.
             mode (str): Dataset mode, either 'train' or 'val'.
             batch (int, optional): Batch size for rectangle training. Defaults to None.
 
         Returns:
             (RTDETRDataset): Dataset object for the specific mode.
         """
-        return RTDETRDataset(img_path=img_path,
-                             imgsz=self.args.imgsz,
-                             batch_size=batch,
-                             augment=mode == 'train',
-                             hyp=self.args,
-                             rect=False,
-                             cache=self.args.cache or None,
-                             prefix=colorstr(f'{mode}: '),
-                             data=self.data)
+        return RTDETRDataset(
+            img_path=img_path,
+            imgsz=self.args.imgsz,
+            batch_size=batch,
+            augment=mode == "train",
+            hyp=self.args,
+            rect=False,
+            cache=self.args.cache or None,
+            prefix=colorstr(f"{mode}: "),
+            data=self.data,
+        )
 
     def get_validator(self):
         """
         Returns a DetectionValidator suitable for RT-DETR model validation.
 
         Returns:
             (RTDETRValidator): Validator object for model validation.
         """
-        self.loss_names = 'giou_loss', 'cls_loss', 'l1_loss'
+        self.loss_names = "giou_loss", "cls_loss", "l1_loss"
         return RTDETRValidator(self.test_loader, save_dir=self.save_dir, args=copy(self.args))
 
     def preprocess_batch(self, batch):
         """
         Preprocess a batch of images. Scales and converts the images to float format.
 
         Args:
             batch (dict): Dictionary containing a batch of images, bboxes, and labels.
 
         Returns:
             (dict): Preprocessed batch.
         """
         batch = super().preprocess_batch(batch)
-        bs = len(batch['img'])
-        batch_idx = batch['batch_idx']
+        bs = len(batch["img"])
+        batch_idx = batch["batch_idx"]
         gt_bbox, gt_class = [], []
         for i in range(bs):
-            gt_bbox.append(batch['bboxes'][batch_idx == i].to(batch_idx.device))
-            gt_class.append(batch['cls'][batch_idx == i].to(device=batch_idx.device, dtype=torch.long))
+            gt_bbox.append(batch["bboxes"][batch_idx == i].to(batch_idx.device))
+            gt_class.append(batch["cls"][batch_idx == i].to(device=batch_idx.device, dtype=torch.long))
         return batch
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/rtdetr/val.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/rtdetr/val.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,32 +1,30 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
-from pathlib import Path
-
 import torch
 
 from ultralytics.data import YOLODataset
 from ultralytics.data.augment import Compose, Format, v8_transforms
 from ultralytics.models.yolo.detect import DetectionValidator
 from ultralytics.utils import colorstr, ops
 
-__all__ = 'RTDETRValidator',  # tuple or list
+__all__ = ("RTDETRValidator",)  # tuple or list
 
 
 class RTDETRDataset(YOLODataset):
     """
     Real-Time DEtection and TRacking (RT-DETR) dataset class extending the base YOLODataset class.
 
     This specialized dataset class is designed for use with the RT-DETR object detection model and is optimized for
     real-time detection and tracking tasks.
     """
 
     def __init__(self, *args, data=None, **kwargs):
         """Initialize the RTDETRDataset class by inheriting from the YOLODataset class."""
-        super().__init__(*args, data=data, use_segments=False, use_keypoints=False, **kwargs)
+        super().__init__(*args, data=data, **kwargs)
 
     # NOTE: add stretch version load_image for RTDETR mosaic
     def load_image(self, i, rect_mode=False):
         """Loads 1 image from dataset index 'i', returns (im, resized hw)."""
         return super().load_image(i=i, rect_mode=rect_mode)
 
     def build_transforms(self, hyp=None):
@@ -35,21 +33,24 @@
             hyp.mosaic = hyp.mosaic if self.augment and not self.rect else 0.0
             hyp.mixup = hyp.mixup if self.augment and not self.rect else 0.0
             transforms = v8_transforms(self, self.imgsz, hyp, stretch=True)
         else:
             # transforms = Compose([LetterBox(new_shape=(self.imgsz, self.imgsz), auto=False, scaleFill=True)])
             transforms = Compose([])
         transforms.append(
-            Format(bbox_format='xywh',
-                   normalize=True,
-                   return_mask=self.use_segments,
-                   return_keypoint=self.use_keypoints,
-                   batch_idx=True,
-                   mask_ratio=hyp.mask_ratio,
-                   mask_overlap=hyp.overlap_mask))
+            Format(
+                bbox_format="xywh",
+                normalize=True,
+                return_mask=self.use_segments,
+                return_keypoint=self.use_keypoints,
+                batch_idx=True,
+                mask_ratio=hyp.mask_ratio,
+                mask_overlap=hyp.overlap_mask,
+            )
+        )
         return transforms
 
 
 class RTDETRValidator(DetectionValidator):
     """
     RTDETRValidator extends the DetectionValidator class to provide validation capabilities specifically tailored for
     the RT-DETR (Real-Time DETR) object detection model.
@@ -66,15 +67,15 @@
         validator()
         ```
 
     Note:
         For further details on the attributes and methods, refer to the parent DetectionValidator class.
     """
 
-    def build_dataset(self, img_path, mode='val', batch=None):
+    def build_dataset(self, img_path, mode="val", batch=None):
         """
         Build an RTDETR Dataset.
 
         Args:
             img_path (str): Path to the folder containing images.
             mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.
             batch (int, optional): Size of batches, this is for `rect`. Defaults to None.
@@ -83,19 +84,23 @@
             img_path=img_path,
             imgsz=self.args.imgsz,
             batch_size=batch,
             augment=False,  # no augmentation
             hyp=self.args,
             rect=False,  # no rect
             cache=self.args.cache or None,
-            prefix=colorstr(f'{mode}: '),
-            data=self.data)
+            prefix=colorstr(f"{mode}: "),
+            data=self.data,
+        )
 
     def postprocess(self, preds):
         """Apply Non-maximum suppression to prediction outputs."""
+        if not isinstance(preds, (list, tuple)):  # list for PyTorch inference but list[0] Tensor for export inference
+            preds = [preds, None]
+
         bs, _, nd = preds[0].shape
         bboxes, scores = preds[0].split((4, nd - 4), dim=-1)
         bboxes *= self.args.imgsz
         outputs = [torch.zeros((0, 6), device=bboxes.device)] * bs
         for i, bbox in enumerate(bboxes):  # (300, 4)
             bbox = ops.xywh2xyxy(bbox)
             score, cls = scores[i].max(-1)  # (300, )
@@ -104,51 +109,27 @@
             pred = torch.cat([bbox, score[..., None], cls[..., None]], dim=-1)  # filter
             # Sort by confidence to correctly get internal metrics
             pred = pred[score.argsort(descending=True)]
             outputs[i] = pred  # [idx]
 
         return outputs
 
-    def update_metrics(self, preds, batch):
-        """Metrics."""
-        for si, pred in enumerate(preds):
-            idx = batch['batch_idx'] == si
-            cls = batch['cls'][idx]
-            bbox = batch['bboxes'][idx]
-            nl, npr = cls.shape[0], pred.shape[0]  # number of labels, predictions
-            shape = batch['ori_shape'][si]
-            correct_bboxes = torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device)  # init
-            self.seen += 1
-
-            if npr == 0:
-                if nl:
-                    self.stats.append((correct_bboxes, *torch.zeros((2, 0), device=self.device), cls.squeeze(-1)))
-                    if self.args.plots:
-                        self.confusion_matrix.process_batch(detections=None, labels=cls.squeeze(-1))
-                continue
-
-            # Predictions
-            if self.args.single_cls:
-                pred[:, 5] = 0
-            predn = pred.clone()
-            predn[..., [0, 2]] *= shape[1] / self.args.imgsz  # native-space pred
-            predn[..., [1, 3]] *= shape[0] / self.args.imgsz  # native-space pred
-
-            # Evaluate
-            if nl:
-                tbox = ops.xywh2xyxy(bbox)  # target boxes
-                tbox[..., [0, 2]] *= shape[1]  # native-space pred
-                tbox[..., [1, 3]] *= shape[0]  # native-space pred
-                labelsn = torch.cat((cls, tbox), 1)  # native-space labels
-                # NOTE: To get correct metrics, the inputs of `_process_batch` should always be float32 type.
-                correct_bboxes = self._process_batch(predn.float(), labelsn)
-                # TODO: maybe remove these `self.` arguments as they already are member variable
-                if self.args.plots:
-                    self.confusion_matrix.process_batch(predn, labelsn)
-            self.stats.append((correct_bboxes, pred[:, 4], pred[:, 5], cls.squeeze(-1)))  # (conf, pcls, tcls)
-
-            # Save
-            if self.args.save_json:
-                self.pred_to_json(predn, batch['im_file'][si])
-            if self.args.save_txt:
-                file = self.save_dir / 'labels' / f'{Path(batch["im_file"][si]).stem}.txt'
-                self.save_one_txt(predn, self.args.save_conf, shape, file)
+    def _prepare_batch(self, si, batch):
+        """Prepares a batch for training or inference by applying transformations."""
+        idx = batch["batch_idx"] == si
+        cls = batch["cls"][idx].squeeze(-1)
+        bbox = batch["bboxes"][idx]
+        ori_shape = batch["ori_shape"][si]
+        imgsz = batch["img"].shape[2:]
+        ratio_pad = batch["ratio_pad"][si]
+        if len(cls):
+            bbox = ops.xywh2xyxy(bbox)  # target boxes
+            bbox[..., [0, 2]] *= ori_shape[1]  # native-space pred
+            bbox[..., [1, 3]] *= ori_shape[0]  # native-space pred
+        return {"cls": cls, "bbox": bbox, "ori_shape": ori_shape, "imgsz": imgsz, "ratio_pad": ratio_pad}
+
+    def _prepare_pred(self, pred, pbatch):
+        """Prepares and returns a batch with transformed bounding boxes and class labels."""
+        predn = pred.clone()
+        predn[..., [0, 2]] *= pbatch["ori_shape"][1] / self.args.imgsz  # native-space pred
+        predn[..., [1, 3]] *= pbatch["ori_shape"][0] / self.args.imgsz  # native-space pred
+        return predn.float()
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/amg.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/amg.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,67 +4,68 @@
 from itertools import product
 from typing import Any, Generator, List, Tuple
 
 import numpy as np
 import torch
 
 
-def is_box_near_crop_edge(boxes: torch.Tensor,
-                          crop_box: List[int],
-                          orig_box: List[int],
-                          atol: float = 20.0) -> torch.Tensor:
+def is_box_near_crop_edge(
+    boxes: torch.Tensor, crop_box: List[int], orig_box: List[int], atol: float = 20.0
+) -> torch.Tensor:
     """Return a boolean tensor indicating if boxes are near the crop edge."""
     crop_box_torch = torch.as_tensor(crop_box, dtype=torch.float, device=boxes.device)
     orig_box_torch = torch.as_tensor(orig_box, dtype=torch.float, device=boxes.device)
     boxes = uncrop_boxes_xyxy(boxes, crop_box).float()
     near_crop_edge = torch.isclose(boxes, crop_box_torch[None, :], atol=atol, rtol=0)
     near_image_edge = torch.isclose(boxes, orig_box_torch[None, :], atol=atol, rtol=0)
     near_crop_edge = torch.logical_and(near_crop_edge, ~near_image_edge)
     return torch.any(near_crop_edge, dim=1)
 
 
 def batch_iterator(batch_size: int, *args) -> Generator[List[Any], None, None]:
     """Yield batches of data from the input arguments."""
-    assert args and all(len(a) == len(args[0]) for a in args), 'Batched iteration must have same-size inputs.'
+    assert args and all(len(a) == len(args[0]) for a in args), "Batched iteration must have same-size inputs."
     n_batches = len(args[0]) // batch_size + int(len(args[0]) % batch_size != 0)
     for b in range(n_batches):
-        yield [arg[b * batch_size:(b + 1) * batch_size] for arg in args]
+        yield [arg[b * batch_size : (b + 1) * batch_size] for arg in args]
 
 
 def calculate_stability_score(masks: torch.Tensor, mask_threshold: float, threshold_offset: float) -> torch.Tensor:
     """
     Computes the stability score for a batch of masks.
 
     The stability score is the IoU between the binary masks obtained by thresholding the predicted mask logits at high
     and low values.
+
+    Notes:
+        - One mask is always contained inside the other.
+        - Save memory by preventing unnecessary cast to torch.int64
     """
-    # One mask is always contained inside the other.
-    # Save memory by preventing unnecessary cast to torch.int64
-    intersections = ((masks > (mask_threshold + threshold_offset)).sum(-1, dtype=torch.int16).sum(-1,
-                                                                                                  dtype=torch.int32))
-    unions = ((masks > (mask_threshold - threshold_offset)).sum(-1, dtype=torch.int16).sum(-1, dtype=torch.int32))
+    intersections = (masks > (mask_threshold + threshold_offset)).sum(-1, dtype=torch.int16).sum(-1, dtype=torch.int32)
+    unions = (masks > (mask_threshold - threshold_offset)).sum(-1, dtype=torch.int16).sum(-1, dtype=torch.int32)
     return intersections / unions
 
 
 def build_point_grid(n_per_side: int) -> np.ndarray:
     """Generate a 2D grid of evenly spaced points in the range [0,1]x[0,1]."""
     offset = 1 / (2 * n_per_side)
     points_one_side = np.linspace(offset, 1 - offset, n_per_side)
     points_x = np.tile(points_one_side[None, :], (n_per_side, 1))
     points_y = np.tile(points_one_side[:, None], (1, n_per_side))
     return np.stack([points_x, points_y], axis=-1).reshape(-1, 2)
 
 
 def build_all_layer_point_grids(n_per_side: int, n_layers: int, scale_per_layer: int) -> List[np.ndarray]:
     """Generate point grids for all crop layers."""
-    return [build_point_grid(int(n_per_side / (scale_per_layer ** i))) for i in range(n_layers + 1)]
+    return [build_point_grid(int(n_per_side / (scale_per_layer**i))) for i in range(n_layers + 1)]
 
 
-def generate_crop_boxes(im_size: Tuple[int, ...], n_layers: int,
-                        overlap_ratio: float) -> Tuple[List[List[int]], List[int]]:
+def generate_crop_boxes(
+    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float
+) -> Tuple[List[List[int]], List[int]]:
     """
     Generates a list of crop boxes of different sizes.
 
     Each layer has (2**i)**2 boxes for the ith layer.
     """
     crop_boxes, layer_idxs = [], []
     im_h, im_w = im_size
@@ -128,16 +129,16 @@
     return torch.nn.functional.pad(masks, pad, value=0)
 
 
 def remove_small_regions(mask: np.ndarray, area_thresh: float, mode: str) -> Tuple[np.ndarray, bool]:
     """Remove small disconnected regions or holes in a mask, returning the mask and a modification indicator."""
     import cv2  # type: ignore
 
-    assert mode in {'holes', 'islands'}
-    correct_holes = mode == 'holes'
+    assert mode in {"holes", "islands"}
+    correct_holes = mode == "holes"
     working_mask = (correct_holes ^ mask).astype(np.uint8)
     n_labels, regions, stats, _ = cv2.connectedComponentsWithStats(working_mask, 8)
     sizes = stats[:, -1][1:]  # Row 0 is background label
     small_regions = [i + 1 for i, s in enumerate(sizes) if s < area_thresh]
     if not small_regions:
         return mask, False
     fill_labels = [0] + small_regions
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/build.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/build.py`

 * *Files 3% similar despite different names*

```diff
@@ -60,54 +60,55 @@
         encoder_num_heads=[2, 4, 5, 10],
         encoder_global_attn_indexes=None,
         mobile_sam=True,
         checkpoint=checkpoint,
     )
 
 
-def _build_sam(encoder_embed_dim,
-               encoder_depth,
-               encoder_num_heads,
-               encoder_global_attn_indexes,
-               checkpoint=None,
-               mobile_sam=False):
+def _build_sam(
+    encoder_embed_dim, encoder_depth, encoder_num_heads, encoder_global_attn_indexes, checkpoint=None, mobile_sam=False
+):
     """Builds the selected SAM model architecture."""
     prompt_embed_dim = 256
     image_size = 1024
     vit_patch_size = 16
     image_embedding_size = image_size // vit_patch_size
-    image_encoder = (TinyViT(
-        img_size=1024,
-        in_chans=3,
-        num_classes=1000,
-        embed_dims=encoder_embed_dim,
-        depths=encoder_depth,
-        num_heads=encoder_num_heads,
-        window_sizes=[7, 7, 14, 7],
-        mlp_ratio=4.0,
-        drop_rate=0.0,
-        drop_path_rate=0.0,
-        use_checkpoint=False,
-        mbconv_expand_ratio=4.0,
-        local_conv_size=3,
-        layer_lr_decay=0.8,
-    ) if mobile_sam else ImageEncoderViT(
-        depth=encoder_depth,
-        embed_dim=encoder_embed_dim,
-        img_size=image_size,
-        mlp_ratio=4,
-        norm_layer=partial(torch.nn.LayerNorm, eps=1e-6),
-        num_heads=encoder_num_heads,
-        patch_size=vit_patch_size,
-        qkv_bias=True,
-        use_rel_pos=True,
-        global_attn_indexes=encoder_global_attn_indexes,
-        window_size=14,
-        out_chans=prompt_embed_dim,
-    ))
+    image_encoder = (
+        TinyViT(
+            img_size=1024,
+            in_chans=3,
+            num_classes=1000,
+            embed_dims=encoder_embed_dim,
+            depths=encoder_depth,
+            num_heads=encoder_num_heads,
+            window_sizes=[7, 7, 14, 7],
+            mlp_ratio=4.0,
+            drop_rate=0.0,
+            drop_path_rate=0.0,
+            use_checkpoint=False,
+            mbconv_expand_ratio=4.0,
+            local_conv_size=3,
+            layer_lr_decay=0.8,
+        )
+        if mobile_sam
+        else ImageEncoderViT(
+            depth=encoder_depth,
+            embed_dim=encoder_embed_dim,
+            img_size=image_size,
+            mlp_ratio=4,
+            norm_layer=partial(torch.nn.LayerNorm, eps=1e-6),
+            num_heads=encoder_num_heads,
+            patch_size=vit_patch_size,
+            qkv_bias=True,
+            use_rel_pos=True,
+            global_attn_indexes=encoder_global_attn_indexes,
+            window_size=14,
+            out_chans=prompt_embed_dim,
+        )
+    )
     sam = Sam(
         image_encoder=image_encoder,
         prompt_encoder=PromptEncoder(
             embed_dim=prompt_embed_dim,
             image_embedding_size=(image_embedding_size, image_embedding_size),
             input_image_size=(image_size, image_size),
             mask_in_chans=16,
@@ -125,35 +126,36 @@
             iou_head_hidden_dim=256,
         ),
         pixel_mean=[123.675, 116.28, 103.53],
         pixel_std=[58.395, 57.12, 57.375],
     )
     if checkpoint is not None:
         checkpoint = attempt_download_asset(checkpoint)
-        with open(checkpoint, 'rb') as f:
+        with open(checkpoint, "rb") as f:
             state_dict = torch.load(f)
         sam.load_state_dict(state_dict)
     sam.eval()
     # sam.load_state_dict(torch.load(checkpoint), strict=True)
     # sam.eval()
     return sam
 
 
 sam_model_map = {
-    'sam_h.pt': build_sam_vit_h,
-    'sam_l.pt': build_sam_vit_l,
-    'sam_b.pt': build_sam_vit_b,
-    'mobile_sam.pt': build_mobile_sam, }
+    "sam_h.pt": build_sam_vit_h,
+    "sam_l.pt": build_sam_vit_l,
+    "sam_b.pt": build_sam_vit_b,
+    "mobile_sam.pt": build_mobile_sam,
+}
 
 
-def build_sam(ckpt='sam_b.pt'):
+def build_sam(ckpt="sam_b.pt"):
     """Build a SAM model specified by ckpt."""
     model_builder = None
     ckpt = str(ckpt)  # to allow Path ckpt types
     for k in sam_model_map.keys():
         if ckpt.endswith(k):
             model_builder = sam_model_map.get(k)
 
     if not model_builder:
-        raise FileNotFoundError(f'{ckpt} is not a supported SAM model. Available models are: \n {sam_model_map.keys()}')
+        raise FileNotFoundError(f"{ckpt} is not a supported SAM model. Available models are: \n {sam_model_map.keys()}")
 
     return model_builder(ckpt)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/model.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/model.py`

 * *Files 5% similar despite different names*

```diff
@@ -28,27 +28,27 @@
     SAM (Segment Anything Model) interface class.
 
     SAM is designed for promptable real-time image segmentation. It can be used with a variety of prompts such as
     bounding boxes, points, or labels. The model has capabilities for zero-shot performance and is trained on the SA-1B
     dataset.
     """
 
-    def __init__(self, model='sam_b.pt') -> None:
+    def __init__(self, model="sam_b.pt") -> None:
         """
         Initializes the SAM model with a pre-trained model file.
 
         Args:
             model (str): Path to the pre-trained SAM model file. File should have a .pt or .pth extension.
 
         Raises:
             NotImplementedError: If the model file extension is not .pt or .pth.
         """
-        if model and Path(model).suffix not in ('.pt', '.pth'):
-            raise NotImplementedError('SAM prediction requires pre-trained *.pt or *.pth model.')
-        super().__init__(model=model, task='segment')
+        if model and Path(model).suffix not in {".pt", ".pth"}:
+            raise NotImplementedError("SAM prediction requires pre-trained *.pt or *.pth model.")
+        super().__init__(model=model, task="segment")
 
     def _load(self, weights: str, task=None):
         """
         Loads the specified weights into the SAM model.
 
         Args:
             weights (str): Path to the weights file.
@@ -66,15 +66,15 @@
             bboxes (list, optional): List of bounding box coordinates for prompted segmentation. Defaults to None.
             points (list, optional): List of points for prompted segmentation. Defaults to None.
             labels (list, optional): List of labels for prompted segmentation. Defaults to None.
 
         Returns:
             (list): The model predictions.
         """
-        overrides = dict(conf=0.25, task='segment', mode='predict', imgsz=1024)
+        overrides = dict(conf=0.25, task="segment", mode="predict", imgsz=1024)
         kwargs.update(overrides)
         prompts = dict(bboxes=bboxes, points=points, labels=labels)
         return super().predict(source, stream, prompts=prompts, **kwargs)
 
     def __call__(self, source=None, stream=False, bboxes=None, points=None, labels=None, **kwargs):
         """
         Alias for the 'predict' method.
@@ -108,8 +108,8 @@
     def task_map(self):
         """
         Provides a mapping from the 'segment' task to its corresponding 'Predictor'.
 
         Returns:
             (dict): A dictionary mapping the 'segment' task to its corresponding 'Predictor'.
         """
-        return {'segment': {'predictor': Predictor}}
+        return {"segment": {"predictor": Predictor}}
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/decoders.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/decoders.py`

 * *Files 1% similar despite different names*

```diff
@@ -60,16 +60,17 @@
         self.output_upscaling = nn.Sequential(
             nn.ConvTranspose2d(transformer_dim, transformer_dim // 4, kernel_size=2, stride=2),
             LayerNorm2d(transformer_dim // 4),
             activation(),
             nn.ConvTranspose2d(transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2),
             activation(),
         )
-        self.output_hypernetworks_mlps = nn.ModuleList([
-            MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3) for _ in range(self.num_mask_tokens)])
+        self.output_hypernetworks_mlps = nn.ModuleList(
+            [MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3) for _ in range(self.num_mask_tokens)]
+        )
 
         self.iou_prediction_head = MLP(transformer_dim, iou_head_hidden_dim, self.num_mask_tokens, iou_head_depth)
 
     def forward(
         self,
         image_embeddings: torch.Tensor,
         image_pe: torch.Tensor,
@@ -116,33 +117,34 @@
         """
         Predicts masks.
 
         See 'forward' for more details.
         """
         # Concatenate output tokens
         output_tokens = torch.cat([self.iou_token.weight, self.mask_tokens.weight], dim=0)
-        output_tokens = output_tokens.unsqueeze(0).expand(sparse_prompt_embeddings.size(0), -1, -1)
+        output_tokens = output_tokens.unsqueeze(0).expand(sparse_prompt_embeddings.shape[0], -1, -1)
         tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)
 
         # Expand per-image data in batch direction to be per-mask
         src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)
         src = src + dense_prompt_embeddings
         pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)
         b, c, h, w = src.shape
 
         # Run the transformer
         hs, src = self.transformer(src, pos_src, tokens)
         iou_token_out = hs[:, 0, :]
-        mask_tokens_out = hs[:, 1:(1 + self.num_mask_tokens), :]
+        mask_tokens_out = hs[:, 1 : (1 + self.num_mask_tokens), :]
 
         # Upscale mask embeddings and predict masks using the mask tokens
         src = src.transpose(1, 2).view(b, c, h, w)
         upscaled_embedding = self.output_upscaling(src)
         hyper_in_list: List[torch.Tensor] = [
-            self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :]) for i in range(self.num_mask_tokens)]
+            self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :]) for i in range(self.num_mask_tokens)
+        ]
         hyper_in = torch.stack(hyper_in_list, dim=1)
         b, c, h, w = upscaled_embedding.shape
         masks = (hyper_in @ upscaled_embedding.view(b, c, h * w)).view(b, -1, h, w)
 
         # Generate mask quality predictions
         iou_pred = self.iou_prediction_head(iou_token_out)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/encoders.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/encoders.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,31 +24,31 @@
         patch_embed (PatchEmbed): Module for patch embedding.
         pos_embed (nn.Parameter, optional): Absolute positional embedding for patches.
         blocks (nn.ModuleList): List of transformer blocks for processing patch embeddings.
         neck (nn.Sequential): Neck module to further process the output.
     """
 
     def __init__(
-            self,
-            img_size: int = 1024,
-            patch_size: int = 16,
-            in_chans: int = 3,
-            embed_dim: int = 768,
-            depth: int = 12,
-            num_heads: int = 12,
-            mlp_ratio: float = 4.0,
-            out_chans: int = 256,
-            qkv_bias: bool = True,
-            norm_layer: Type[nn.Module] = nn.LayerNorm,
-            act_layer: Type[nn.Module] = nn.GELU,
-            use_abs_pos: bool = True,
-            use_rel_pos: bool = False,
-            rel_pos_zero_init: bool = True,
-            window_size: int = 0,
-            global_attn_indexes: Tuple[int, ...] = (),
+        self,
+        img_size: int = 1024,
+        patch_size: int = 16,
+        in_chans: int = 3,
+        embed_dim: int = 768,
+        depth: int = 12,
+        num_heads: int = 12,
+        mlp_ratio: float = 4.0,
+        out_chans: int = 256,
+        qkv_bias: bool = True,
+        norm_layer: Type[nn.Module] = nn.LayerNorm,
+        act_layer: Type[nn.Module] = nn.GELU,
+        use_abs_pos: bool = True,
+        use_rel_pos: bool = False,
+        rel_pos_zero_init: bool = True,
+        window_size: int = 0,
+        global_attn_indexes: Tuple[int, ...] = (),
     ) -> None:
         """
         Args:
             img_size (int): Input image size.
             patch_size (int): Patch size.
             in_chans (int): Number of input image channels.
             embed_dim (int): Patch embedding dimension.
@@ -194,20 +194,15 @@
         image encoding.
 
         Returns:
           torch.Tensor: Positional encoding with shape 1x(embed_dim)x(embedding_h)x(embedding_w)
         """
         return self.pe_layer(self.image_embedding_size).unsqueeze(0)
 
-    def _embed_points(
-        self,
-        points: torch.Tensor,
-        labels: torch.Tensor,
-        pad: bool,
-    ) -> torch.Tensor:
+    def _embed_points(self, points: torch.Tensor, labels: torch.Tensor, pad: bool) -> torch.Tensor:
         """Embeds point prompts."""
         points = points + 0.5  # Shift to center of pixel
         if pad:
             padding_point = torch.zeros((points.shape[0], 1, 2), device=points.device)
             padding_label = -torch.ones((labels.shape[0], 1), device=labels.device)
             points = torch.cat([points, padding_point], dim=1)
             labels = torch.cat([labels, padding_label], dim=1)
@@ -279,30 +274,30 @@
         if boxes is not None:
             box_embeddings = self._embed_boxes(boxes)
             sparse_embeddings = torch.cat([sparse_embeddings, box_embeddings], dim=1)
 
         if masks is not None:
             dense_embeddings = self._embed_masks(masks)
         else:
-            dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1,
-                                                                 1).expand(bs, -1, self.image_embedding_size[0],
-                                                                           self.image_embedding_size[1])
+            dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1, 1).expand(
+                bs, -1, self.image_embedding_size[0], self.image_embedding_size[1]
+            )
 
         return sparse_embeddings, dense_embeddings
 
 
 class PositionEmbeddingRandom(nn.Module):
     """Positional encoding using random spatial frequencies."""
 
     def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -> None:
         """Initializes a position embedding using random spatial frequencies."""
         super().__init__()
         if scale is None or scale <= 0.0:
             scale = 1.0
-        self.register_buffer('positional_encoding_gaussian_matrix', scale * torch.randn((2, num_pos_feats)))
+        self.register_buffer("positional_encoding_gaussian_matrix", scale * torch.randn((2, num_pos_feats)))
 
         # Set non-deterministic for forward() error 'cumsum_cuda_kernel does not have a deterministic implementation'
         torch.use_deterministic_algorithms(False)
         torch.backends.cudnn.deterministic = False
 
     def _pe_encoding(self, coords: torch.Tensor) -> torch.Tensor:
         """Positionally encode points that are normalized to [0,1]."""
@@ -421,22 +416,22 @@
             rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.
             input_size (tuple(int, int), None): Input resolution for calculating the relative
                 positional parameter size.
         """
         super().__init__()
         self.num_heads = num_heads
         head_dim = dim // num_heads
-        self.scale = head_dim ** -0.5
+        self.scale = head_dim**-0.5
 
         self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)
         self.proj = nn.Linear(dim, dim)
 
         self.use_rel_pos = use_rel_pos
         if self.use_rel_pos:
-            assert (input_size is not None), 'Input size must be provided if using relative positional encoding.'
+            assert input_size is not None, "Input size must be provided if using relative positional encoding."
             # Initialize relative positional embeddings
             self.rel_pos_h = nn.Parameter(torch.zeros(2 * input_size[0] - 1, head_dim))
             self.rel_pos_w = nn.Parameter(torch.zeros(2 * input_size[1] - 1, head_dim))
 
     def forward(self, x: torch.Tensor) -> torch.Tensor:
         """Applies the forward operation including attention, normalization, MLP, and indexing within window limits."""
         B, H, W, _ = x.shape
@@ -475,16 +470,17 @@
     Hp, Wp = H + pad_h, W + pad_w
 
     x = x.view(B, Hp // window_size, window_size, Wp // window_size, window_size, C)
     windows = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(-1, window_size, window_size, C)
     return windows, (Hp, Wp)
 
 
-def window_unpartition(windows: torch.Tensor, window_size: int, pad_hw: Tuple[int, int],
-                       hw: Tuple[int, int]) -> torch.Tensor:
+def window_unpartition(
+    windows: torch.Tensor, window_size: int, pad_hw: Tuple[int, int], hw: Tuple[int, int]
+) -> torch.Tensor:
     """
     Window unpartition into original sequences and removing padding.
 
     Args:
         windows (tensor): input tokens with [B * num_windows, window_size, window_size, C].
         window_size (int): window size.
         pad_hw (Tuple): padded height and width (Hp, Wp).
@@ -519,15 +515,15 @@
     max_rel_dist = int(2 * max(q_size, k_size) - 1)
     # Interpolate rel pos if needed.
     if rel_pos.shape[0] != max_rel_dist:
         # Interpolate rel pos.
         rel_pos_resized = F.interpolate(
             rel_pos.reshape(1, rel_pos.shape[0], -1).permute(0, 2, 1),
             size=max_rel_dist,
-            mode='linear',
+            mode="linear",
         )
         rel_pos_resized = rel_pos_resized.reshape(-1, max_rel_dist).permute(1, 0)
     else:
         rel_pos_resized = rel_pos
 
     # Scale the coords with short length if shapes for q and k are different.
     q_coords = torch.arange(q_size)[:, None] * max(k_size / q_size, 1.0)
@@ -563,33 +559,34 @@
     q_h, q_w = q_size
     k_h, k_w = k_size
     Rh = get_rel_pos(q_h, k_h, rel_pos_h)
     Rw = get_rel_pos(q_w, k_w, rel_pos_w)
 
     B, _, dim = q.shape
     r_q = q.reshape(B, q_h, q_w, dim)
-    rel_h = torch.einsum('bhwc,hkc->bhwk', r_q, Rh)
-    rel_w = torch.einsum('bhwc,wkc->bhwk', r_q, Rw)
+    rel_h = torch.einsum("bhwc,hkc->bhwk", r_q, Rh)
+    rel_w = torch.einsum("bhwc,wkc->bhwk", r_q, Rw)
 
     attn = (attn.view(B, q_h, q_w, k_h, k_w) + rel_h[:, :, :, :, None] + rel_w[:, :, :, None, :]).view(
-        B, q_h * q_w, k_h * k_w)
+        B, q_h * q_w, k_h * k_w
+    )
 
     return attn
 
 
 class PatchEmbed(nn.Module):
     """Image to Patch Embedding."""
 
     def __init__(
-            self,
-            kernel_size: Tuple[int, int] = (16, 16),
-            stride: Tuple[int, int] = (16, 16),
-            padding: Tuple[int, int] = (0, 0),
-            in_chans: int = 3,
-            embed_dim: int = 768,
+        self,
+        kernel_size: Tuple[int, int] = (16, 16),
+        stride: Tuple[int, int] = (16, 16),
+        padding: Tuple[int, int] = (0, 0),
+        in_chans: int = 3,
+        embed_dim: int = 768,
     ) -> None:
         """
         Initialize PatchEmbed module.
 
         Args:
             kernel_size (Tuple): kernel size of the projection layer.
             stride (Tuple): stride of the projection layer.
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/sam.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/sam.py`

 * *Files 1% similar despite different names*

```diff
@@ -26,24 +26,25 @@
         image_format (str): Format of the input image, default is 'RGB'.
         image_encoder (ImageEncoderViT): The backbone used to encode the image into embeddings.
         prompt_encoder (PromptEncoder): Encodes various types of input prompts.
         mask_decoder (MaskDecoder): Predicts object masks from the image and prompt embeddings.
         pixel_mean (List[float]): Mean pixel values for image normalization.
         pixel_std (List[float]): Standard deviation values for image normalization.
     """
+
     mask_threshold: float = 0.0
-    image_format: str = 'RGB'
+    image_format: str = "RGB"
 
     def __init__(
         self,
         image_encoder: ImageEncoderViT,
         prompt_encoder: PromptEncoder,
         mask_decoder: MaskDecoder,
         pixel_mean: List[float] = (123.675, 116.28, 103.53),
-        pixel_std: List[float] = (58.395, 57.12, 57.375)
+        pixel_std: List[float] = (58.395, 57.12, 57.375),
     ) -> None:
         """
         Initialize the Sam class to predict object masks from an image and input prompts.
 
         Note:
             All forward() operations moved to SAMPredictor.
 
@@ -56,9 +57,9 @@
             pixel_std (List[float], optional): Std values for normalizing pixels in the input image. Defaults to
                 (58.395, 57.12, 57.375).
         """
         super().__init__()
         self.image_encoder = image_encoder
         self.prompt_encoder = prompt_encoder
         self.mask_decoder = mask_decoder
-        self.register_buffer('pixel_mean', torch.Tensor(pixel_mean).view(-1, 1, 1), False)
-        self.register_buffer('pixel_std', torch.Tensor(pixel_std).view(-1, 1, 1), False)
+        self.register_buffer("pixel_mean", torch.Tensor(pixel_mean).view(-1, 1, 1), False)
+        self.register_buffer("pixel_std", torch.Tensor(pixel_std).view(-1, 1, 1), False)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/tiny_encoder.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/tiny_encoder.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,19 +24,19 @@
     """A sequential container that performs 2D convolution followed by batch normalization."""
 
     def __init__(self, a, b, ks=1, stride=1, pad=0, dilation=1, groups=1, bn_weight_init=1):
         """Initializes the MBConv model with given input channels, output channels, expansion ratio, activation, and
         drop path.
         """
         super().__init__()
-        self.add_module('c', torch.nn.Conv2d(a, b, ks, stride, pad, dilation, groups, bias=False))
+        self.add_module("c", torch.nn.Conv2d(a, b, ks, stride, pad, dilation, groups, bias=False))
         bn = torch.nn.BatchNorm2d(b)
         torch.nn.init.constant_(bn.weight, bn_weight_init)
         torch.nn.init.constant_(bn.bias, 0)
-        self.add_module('bn', bn)
+        self.add_module("bn", bn)
 
 
 class PatchEmbed(nn.Module):
     """Embeds images into patches and projects them into a specified embedding dimension."""
 
     def __init__(self, in_chans, embed_dim, resolution, activation):
         """Initialize the PatchMerging class with specified input, output dimensions, resolution and activation
@@ -108,15 +108,15 @@
         super().__init__()
 
         self.input_resolution = input_resolution
         self.dim = dim
         self.out_dim = out_dim
         self.act = activation()
         self.conv1 = Conv2d_BN(dim, out_dim, 1, 1, 0)
-        stride_c = 1 if out_dim in [320, 448, 576] else 2
+        stride_c = 1 if out_dim in {320, 448, 576} else 2
         self.conv2 = Conv2d_BN(out_dim, out_dim, 3, stride_c, 1, groups=out_dim)
         self.conv3 = Conv2d_BN(out_dim, out_dim, 1, 1, 0)
 
     def forward(self, x):
         """Applies forward pass on the input utilizing convolution and activation layers, and returns the result."""
         if x.ndim == 3:
             H, W = self.input_resolution
@@ -142,19 +142,19 @@
 
     def __init__(
         self,
         dim,
         input_resolution,
         depth,
         activation,
-        drop_path=0.,
+        drop_path=0.0,
         downsample=None,
         use_checkpoint=False,
         out_dim=None,
-        conv_expand_ratio=4.,
+        conv_expand_ratio=4.0,
     ):
         """
         Initializes the ConvLayer with the given dimensions and settings.
 
         Args:
             dim (int): The dimensionality of the input and output.
             input_resolution (Tuple[int, int]): The resolution of the input image.
@@ -169,26 +169,33 @@
         super().__init__()
         self.dim = dim
         self.input_resolution = input_resolution
         self.depth = depth
         self.use_checkpoint = use_checkpoint
 
         # Build blocks
-        self.blocks = nn.ModuleList([
-            MBConv(
-                dim,
-                dim,
-                conv_expand_ratio,
-                activation,
-                drop_path[i] if isinstance(drop_path, list) else drop_path,
-            ) for i in range(depth)])
+        self.blocks = nn.ModuleList(
+            [
+                MBConv(
+                    dim,
+                    dim,
+                    conv_expand_ratio,
+                    activation,
+                    drop_path[i] if isinstance(drop_path, list) else drop_path,
+                )
+                for i in range(depth)
+            ]
+        )
 
         # Patch merging layer
-        self.downsample = None if downsample is None else downsample(
-            input_resolution, dim=dim, out_dim=out_dim, activation=activation)
+        self.downsample = (
+            None
+            if downsample is None
+            else downsample(input_resolution, dim=dim, out_dim=out_dim, activation=activation)
+        )
 
     def forward(self, x):
         """Processes the input through a series of convolutional layers and returns the activated output."""
         for blk in self.blocks:
             x = checkpoint.checkpoint(blk, x) if self.use_checkpoint else blk(x)
         return x if self.downsample is None else self.downsample(x)
 
@@ -196,15 +203,15 @@
 class Mlp(nn.Module):
     """
     Multi-layer Perceptron (MLP) for transformer architectures.
 
     This layer takes an input with in_features, applies layer normalization and two fully-connected layers.
     """
 
-    def __init__(self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.):
+    def __init__(self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.0):
         """Initializes Attention module with the given parameters including dimension, key_dim, number of heads, etc."""
         super().__init__()
         out_features = out_features or in_features
         hidden_features = hidden_features or in_features
         self.norm = nn.LayerNorm(in_features)
         self.fc1 = nn.Linear(in_features, hidden_features)
         self.fc2 = nn.Linear(hidden_features, out_features)
@@ -228,20 +235,20 @@
     grid.
 
     Attributes:
         ab (Tensor, optional): Cached attention biases for inference, deleted during training.
     """
 
     def __init__(
-            self,
-            dim,
-            key_dim,
-            num_heads=8,
-            attn_ratio=4,
-            resolution=(14, 14),
+        self,
+        dim,
+        key_dim,
+        num_heads=8,
+        attn_ratio=4,
+        resolution=(14, 14),
     ):
         """
         Initializes the Attention module.
 
         Args:
             dim (int): The dimensionality of the input and output.
             key_dim (int): The dimensionality of the keys and queries.
@@ -252,15 +259,15 @@
         Raises:
             AssertionError: If `resolution` is not a tuple of length 2.
         """
         super().__init__()
 
         assert isinstance(resolution, tuple) and len(resolution) == 2
         self.num_heads = num_heads
-        self.scale = key_dim ** -0.5
+        self.scale = key_dim**-0.5
         self.key_dim = key_dim
         self.nh_kd = nh_kd = key_dim * num_heads
         self.d = int(attn_ratio * key_dim)
         self.dh = int(attn_ratio * key_dim) * num_heads
         self.attn_ratio = attn_ratio
         h = self.dh + nh_kd * 2
 
@@ -275,21 +282,21 @@
         for p1 in points:
             for p2 in points:
                 offset = (abs(p1[0] - p2[0]), abs(p1[1] - p2[1]))
                 if offset not in attention_offsets:
                     attention_offsets[offset] = len(attention_offsets)
                 idxs.append(attention_offsets[offset])
         self.attention_biases = torch.nn.Parameter(torch.zeros(num_heads, len(attention_offsets)))
-        self.register_buffer('attention_bias_idxs', torch.LongTensor(idxs).view(N, N), persistent=False)
+        self.register_buffer("attention_bias_idxs", torch.LongTensor(idxs).view(N, N), persistent=False)
 
     @torch.no_grad()
     def train(self, mode=True):
         """Sets the module in training mode and handles attribute 'ab' based on the mode."""
         super().train(mode)
-        if mode and hasattr(self, 'ab'):
+        if mode and hasattr(self, "ab"):
             del self.ab
         else:
             self.ab = self.attention_biases[:, self.attention_bias_idxs]
 
     def forward(self, x):  # x
         """Performs forward pass over the input tensor 'x' by applying normalization and querying keys/values."""
         B, N, _ = x.shape  # B, N, C
@@ -302,33 +309,34 @@
         q, k, v = qkv.view(B, N, self.num_heads, -1).split([self.key_dim, self.key_dim, self.d], dim=3)
         # (B, num_heads, N, d)
         q = q.permute(0, 2, 1, 3)
         k = k.permute(0, 2, 1, 3)
         v = v.permute(0, 2, 1, 3)
         self.ab = self.ab.to(self.attention_biases.device)
 
-        attn = ((q @ k.transpose(-2, -1)) * self.scale +
-                (self.attention_biases[:, self.attention_bias_idxs] if self.training else self.ab))
+        attn = (q @ k.transpose(-2, -1)) * self.scale + (
+            self.attention_biases[:, self.attention_bias_idxs] if self.training else self.ab
+        )
         attn = attn.softmax(dim=-1)
         x = (attn @ v).transpose(1, 2).reshape(B, N, self.dh)
         return self.proj(x)
 
 
 class TinyViTBlock(nn.Module):
     """TinyViT Block that applies self-attention and a local convolution to the input."""
 
     def __init__(
         self,
         dim,
         input_resolution,
         num_heads,
         window_size=7,
-        mlp_ratio=4.,
-        drop=0.,
-        drop_path=0.,
+        mlp_ratio=4.0,
+        drop=0.0,
+        drop_path=0.0,
         local_conv_size=3,
         activation=nn.GELU,
     ):
         """
         Initializes the TinyViTBlock.
 
         Args:
@@ -346,23 +354,23 @@
             AssertionError: If `window_size` is not greater than 0.
             AssertionError: If `dim` is not divisible by `num_heads`.
         """
         super().__init__()
         self.dim = dim
         self.input_resolution = input_resolution
         self.num_heads = num_heads
-        assert window_size > 0, 'window_size must be greater than 0'
+        assert window_size > 0, "window_size must be greater than 0"
         self.window_size = window_size
         self.mlp_ratio = mlp_ratio
 
         # NOTE: `DropPath` is needed only for training.
         # self.drop_path = DropPath(drop_path) if drop_path > 0. else nn.Identity()
         self.drop_path = nn.Identity()
 
-        assert dim % num_heads == 0, 'dim must be divisible by num_heads'
+        assert dim % num_heads == 0, "dim must be divisible by num_heads"
         head_dim = dim // num_heads
 
         window_resolution = (window_size, window_size)
         self.attn = Attention(dim, head_dim, num_heads, attn_ratio=1, resolution=window_resolution)
 
         mlp_hidden_dim = int(dim * mlp_ratio)
         mlp_activation = activation
@@ -373,15 +381,15 @@
 
     def forward(self, x):
         """Applies attention-based transformation or padding to input 'x' before passing it through a local
         convolution.
         """
         H, W = self.input_resolution
         B, L, C = x.shape
-        assert L == H * W, 'input feature has wrong size'
+        assert L == H * W, "input feature has wrong size"
         res_x = x
         if H == self.window_size and W == self.window_size:
             x = self.attn(x)
         else:
             x = x.view(B, H, W, C)
             pad_b = (self.window_size - H % self.window_size) % self.window_size
             pad_r = (self.window_size - W % self.window_size) % self.window_size
@@ -390,16 +398,19 @@
             if padding:
                 x = F.pad(x, (0, 0, 0, pad_r, 0, pad_b))
 
             pH, pW = H + pad_b, W + pad_r
             nH = pH // self.window_size
             nW = pW // self.window_size
             # Window partition
-            x = x.view(B, nH, self.window_size, nW, self.window_size,
-                       C).transpose(2, 3).reshape(B * nH * nW, self.window_size * self.window_size, C)
+            x = (
+                x.view(B, nH, self.window_size, nW, self.window_size, C)
+                .transpose(2, 3)
+                .reshape(B * nH * nW, self.window_size * self.window_size, C)
+            )
             x = self.attn(x)
             # Window reverse
             x = x.view(B, nH, nW, self.window_size, self.window_size, C).transpose(2, 3).reshape(B, pH, pW, C)
 
             if padding:
                 x = x[:, :H, :W].contiguous()
 
@@ -413,31 +424,33 @@
 
         return x + self.drop_path(self.mlp(x))
 
     def extra_repr(self) -> str:
         """Returns a formatted string representing the TinyViTBlock's parameters: dimension, input resolution, number of
         attentions heads, window size, and MLP ratio.
         """
-        return f'dim={self.dim}, input_resolution={self.input_resolution}, num_heads={self.num_heads}, ' \
-               f'window_size={self.window_size}, mlp_ratio={self.mlp_ratio}'
+        return (
+            f"dim={self.dim}, input_resolution={self.input_resolution}, num_heads={self.num_heads}, "
+            f"window_size={self.window_size}, mlp_ratio={self.mlp_ratio}"
+        )
 
 
 class BasicLayer(nn.Module):
     """A basic TinyViT layer for one stage in a TinyViT architecture."""
 
     def __init__(
         self,
         dim,
         input_resolution,
         depth,
         num_heads,
         window_size,
-        mlp_ratio=4.,
-        drop=0.,
-        drop_path=0.,
+        mlp_ratio=4.0,
+        drop=0.0,
+        drop_path=0.0,
         downsample=None,
         use_checkpoint=False,
         local_conv_size=3,
         activation=nn.GELU,
         out_dim=None,
     ):
         """
@@ -464,40 +477,47 @@
         super().__init__()
         self.dim = dim
         self.input_resolution = input_resolution
         self.depth = depth
         self.use_checkpoint = use_checkpoint
 
         # Build blocks
-        self.blocks = nn.ModuleList([
-            TinyViTBlock(
-                dim=dim,
-                input_resolution=input_resolution,
-                num_heads=num_heads,
-                window_size=window_size,
-                mlp_ratio=mlp_ratio,
-                drop=drop,
-                drop_path=drop_path[i] if isinstance(drop_path, list) else drop_path,
-                local_conv_size=local_conv_size,
-                activation=activation,
-            ) for i in range(depth)])
+        self.blocks = nn.ModuleList(
+            [
+                TinyViTBlock(
+                    dim=dim,
+                    input_resolution=input_resolution,
+                    num_heads=num_heads,
+                    window_size=window_size,
+                    mlp_ratio=mlp_ratio,
+                    drop=drop,
+                    drop_path=drop_path[i] if isinstance(drop_path, list) else drop_path,
+                    local_conv_size=local_conv_size,
+                    activation=activation,
+                )
+                for i in range(depth)
+            ]
+        )
 
         # Patch merging layer
-        self.downsample = None if downsample is None else downsample(
-            input_resolution, dim=dim, out_dim=out_dim, activation=activation)
+        self.downsample = (
+            None
+            if downsample is None
+            else downsample(input_resolution, dim=dim, out_dim=out_dim, activation=activation)
+        )
 
     def forward(self, x):
         """Performs forward propagation on the input tensor and returns a normalized tensor."""
         for blk in self.blocks:
             x = checkpoint.checkpoint(blk, x) if self.use_checkpoint else blk(x)
         return x if self.downsample is None else self.downsample(x)
 
     def extra_repr(self) -> str:
         """Returns a string representation of the extra_repr function with the layer's parameters."""
-        return f'dim={self.dim}, input_resolution={self.input_resolution}, depth={self.depth}'
+        return f"dim={self.dim}, input_resolution={self.input_resolution}, depth={self.depth}"
 
 
 class LayerNorm2d(nn.Module):
     """A PyTorch implementation of Layer Normalization in 2D."""
 
     def __init__(self, num_channels: int, eps: float = 1e-6) -> None:
         """Initialize LayerNorm2d with the number of channels and an optional epsilon."""
@@ -545,32 +565,32 @@
         img_size=224,
         in_chans=3,
         num_classes=1000,
         embed_dims=[96, 192, 384, 768],
         depths=[2, 2, 6, 2],
         num_heads=[3, 6, 12, 24],
         window_sizes=[7, 7, 14, 7],
-        mlp_ratio=4.,
-        drop_rate=0.,
+        mlp_ratio=4.0,
+        drop_rate=0.0,
         drop_path_rate=0.1,
         use_checkpoint=False,
         mbconv_expand_ratio=4.0,
         local_conv_size=3,
         layer_lr_decay=1.0,
     ):
         """
         Initializes the TinyViT model.
 
         Args:
             img_size (int, optional): The input image size. Defaults to 224.
             in_chans (int, optional): Number of input channels. Defaults to 3.
             num_classes (int, optional): Number of classification classes. Defaults to 1000.
-            embed_dims (List[int], optional): List of embedding dimensions for each layer. Defaults to [96, 192, 384, 768].
+            embed_dims (List[int], optional): List of embedding dimensions per layer. Defaults to [96, 192, 384, 768].
             depths (List[int], optional): List of depths for each layer. Defaults to [2, 2, 6, 2].
-            num_heads (List[int], optional): List of number of attention heads for each layer. Defaults to [3, 6, 12, 24].
+            num_heads (List[int], optional): List of number of attention heads per layer. Defaults to [3, 6, 12, 24].
             window_sizes (List[int], optional): List of window sizes for each layer. Defaults to [7, 7, 14, 7].
             mlp_ratio (float, optional): Ratio of MLP hidden dimension to embedding dimension. Defaults to 4.
             drop_rate (float, optional): Dropout rate. Defaults to 0.
             drop_path_rate (float, optional): Drop path rate for stochastic depth. Defaults to 0.1.
             use_checkpoint (bool, optional): Whether to use checkpointing for efficient memory usage. Defaults to False.
             mbconv_expand_ratio (float, optional): Expansion ratio for MBConv layer. Defaults to 4.0.
             local_conv_size (int, optional): Local convolution kernel size. Defaults to 3.
@@ -581,51 +601,53 @@
         self.num_classes = num_classes
         self.depths = depths
         self.num_layers = len(depths)
         self.mlp_ratio = mlp_ratio
 
         activation = nn.GELU
 
-        self.patch_embed = PatchEmbed(in_chans=in_chans,
-                                      embed_dim=embed_dims[0],
-                                      resolution=img_size,
-                                      activation=activation)
+        self.patch_embed = PatchEmbed(
+            in_chans=in_chans, embed_dim=embed_dims[0], resolution=img_size, activation=activation
+        )
 
         patches_resolution = self.patch_embed.patches_resolution
         self.patches_resolution = patches_resolution
 
         # Stochastic depth
         dpr = [x.item() for x in torch.linspace(0, drop_path_rate, sum(depths))]  # stochastic depth decay rule
 
         # Build layers
         self.layers = nn.ModuleList()
         for i_layer in range(self.num_layers):
             kwargs = dict(
                 dim=embed_dims[i_layer],
-                input_resolution=(patches_resolution[0] // (2 ** (i_layer - 1 if i_layer == 3 else i_layer)),
-                                  patches_resolution[1] // (2 ** (i_layer - 1 if i_layer == 3 else i_layer))),
+                input_resolution=(
+                    patches_resolution[0] // (2 ** (i_layer - 1 if i_layer == 3 else i_layer)),
+                    patches_resolution[1] // (2 ** (i_layer - 1 if i_layer == 3 else i_layer)),
+                ),
                 #   input_resolution=(patches_resolution[0] // (2 ** i_layer),
                 #                     patches_resolution[1] // (2 ** i_layer)),
                 depth=depths[i_layer],
-                drop_path=dpr[sum(depths[:i_layer]):sum(depths[:i_layer + 1])],
+                drop_path=dpr[sum(depths[:i_layer]) : sum(depths[: i_layer + 1])],
                 downsample=PatchMerging if (i_layer < self.num_layers - 1) else None,
                 use_checkpoint=use_checkpoint,
-                out_dim=embed_dims[min(i_layer + 1,
-                                       len(embed_dims) - 1)],
+                out_dim=embed_dims[min(i_layer + 1, len(embed_dims) - 1)],
                 activation=activation,
             )
             if i_layer == 0:
                 layer = ConvLayer(conv_expand_ratio=mbconv_expand_ratio, **kwargs)
             else:
-                layer = BasicLayer(num_heads=num_heads[i_layer],
-                                   window_size=window_sizes[i_layer],
-                                   mlp_ratio=self.mlp_ratio,
-                                   drop=drop_rate,
-                                   local_conv_size=local_conv_size,
-                                   **kwargs)
+                layer = BasicLayer(
+                    num_heads=num_heads[i_layer],
+                    window_size=window_sizes[i_layer],
+                    mlp_ratio=self.mlp_ratio,
+                    drop=drop_rate,
+                    local_conv_size=local_conv_size,
+                    **kwargs,
+                )
             self.layers.append(layer)
 
         # Classifier head
         self.norm_head = nn.LayerNorm(embed_dims[-1])
         self.head = nn.Linear(embed_dims[-1], num_classes) if num_classes > 0 else torch.nn.Identity()
 
         # Init weights
@@ -676,15 +698,15 @@
 
         for k, p in self.named_parameters():
             p.param_name = k
 
         def _check_lr_scale(m):
             """Checks if the learning rate scale attribute is present in module's parameters."""
             for p in m.parameters():
-                assert hasattr(p, 'lr_scale'), p.param_name
+                assert hasattr(p, "lr_scale"), p.param_name
 
         self.apply(_check_lr_scale)
 
     def _init_weights(self, m):
         """Initializes weights for linear layers and layer normalization in the given module."""
         if isinstance(m, nn.Linear):
             # NOTE: This initialization is needed only for training.
@@ -694,27 +716,27 @@
         elif isinstance(m, nn.LayerNorm):
             nn.init.constant_(m.bias, 0)
             nn.init.constant_(m.weight, 1.0)
 
     @torch.jit.ignore
     def no_weight_decay_keywords(self):
         """Returns a dictionary of parameter names where weight decay should not be applied."""
-        return {'attention_biases'}
+        return {"attention_biases"}
 
     def forward_features(self, x):
         """Runs the input through the model layers and returns the transformed output."""
         x = self.patch_embed(x)  # x input is (N, C, H, W)
 
         x = self.layers[0](x)
         start_i = 1
 
         for i in range(start_i, len(self.layers)):
             layer = self.layers[i]
             x = layer(x)
-        B, _, C = x.size()
+        B, _, C = x.shape
         x = x.view(B, 64, 64, C)
         x = x.permute(0, 3, 1, 2)
         return self.neck(x)
 
     def forward(self, x):
         """Executes a forward pass on the input tensor through the constructed model layers."""
         return self.forward_features(x)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/modules/transformer.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/modules/transformer.py`

 * *Files 0% similar despite different names*

```diff
@@ -58,15 +58,16 @@
                 TwoWayAttentionBlock(
                     embedding_dim=embedding_dim,
                     num_heads=num_heads,
                     mlp_dim=mlp_dim,
                     activation=activation,
                     attention_downsample_rate=attention_downsample_rate,
                     skip_first_layer_pe=(i == 0),
-                ))
+                )
+            )
 
         self.final_attn_token_to_image = Attention(embedding_dim, num_heads, downsample_rate=attention_downsample_rate)
         self.norm_final_attn = nn.LayerNorm(embedding_dim)
 
     def forward(
         self,
         image_embedding: Tensor,
@@ -217,21 +218,21 @@
 
         Args:
             embedding_dim (int): The dimensionality of the input embeddings.
             num_heads (int): The number of attention heads.
             downsample_rate (int, optional): The factor by which the internal dimensions are downsampled. Defaults to 1.
 
         Raises:
-            AssertionError: If 'num_heads' does not evenly divide the internal dimension (embedding_dim / downsample_rate).
+            AssertionError: If 'num_heads' does not evenly divide the internal dim (embedding_dim / downsample_rate).
         """
         super().__init__()
         self.embedding_dim = embedding_dim
         self.internal_dim = embedding_dim // downsample_rate
         self.num_heads = num_heads
-        assert self.internal_dim % num_heads == 0, 'num_heads must divide embedding_dim.'
+        assert self.internal_dim % num_heads == 0, "num_heads must divide embedding_dim."
 
         self.q_proj = nn.Linear(embedding_dim, self.internal_dim)
         self.k_proj = nn.Linear(embedding_dim, self.internal_dim)
         self.v_proj = nn.Linear(embedding_dim, self.internal_dim)
         self.out_proj = nn.Linear(self.internal_dim, embedding_dim)
 
     @staticmethod
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/sam/predict.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/sam/predict.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,24 +7,32 @@
 using SAM. It forms an integral part of the Ultralytics framework and is designed for high-performance, real-time image
 segmentation tasks.
 """
 
 import numpy as np
 import torch
 import torch.nn.functional as F
-import torchvision
 
 from ultralytics.data.augment import LetterBox
 from ultralytics.engine.predictor import BasePredictor
 from ultralytics.engine.results import Results
 from ultralytics.utils import DEFAULT_CFG, ops
 from ultralytics.utils.torch_utils import select_device
 
-from .amg import (batch_iterator, batched_mask_to_box, build_all_layer_point_grids, calculate_stability_score,
-                  generate_crop_boxes, is_box_near_crop_edge, remove_small_regions, uncrop_boxes_xyxy, uncrop_masks)
+from .amg import (
+    batch_iterator,
+    batched_mask_to_box,
+    build_all_layer_point_grids,
+    calculate_stability_score,
+    generate_crop_boxes,
+    is_box_near_crop_edge,
+    remove_small_regions,
+    uncrop_boxes_xyxy,
+    uncrop_masks,
+)
 from .build import build_sam
 
 
 class Predictor(BasePredictor):
     """
     Predictor class for the Segment Anything Model (SAM), extending BasePredictor.
 
@@ -54,15 +62,15 @@
         Args:
             cfg (dict): Configuration dictionary.
             overrides (dict, optional): Dictionary of values to override default configuration.
             _callbacks (dict, optional): Dictionary of callback functions to customize behavior.
         """
         if overrides is None:
             overrides = {}
-        overrides.update(dict(task='segment', mode='predict', imgsz=1024))
+        overrides.update(dict(task="segment", mode="predict", imgsz=1024))
         super().__init__(cfg, overrides, _callbacks)
         self.args.retina_masks = True
         self.im = None
         self.features = None
         self.prompts = {}
         self.segment_all = False
 
@@ -103,60 +111,60 @@
 
         Args:
             im (List[np.ndarray]): List containing images in HWC numpy array format.
 
         Returns:
             (List[np.ndarray]): List of transformed images.
         """
-        assert len(im) == 1, 'SAM model does not currently support batched inference'
+        assert len(im) == 1, "SAM model does not currently support batched inference"
         letterbox = LetterBox(self.args.imgsz, auto=False, center=False)
         return [letterbox(image=x) for x in im]
 
     def inference(self, im, bboxes=None, points=None, labels=None, masks=None, multimask_output=False, *args, **kwargs):
         """
         Perform image segmentation inference based on the given input cues, using the currently loaded image. This
         method leverages SAM's (Segment Anything Model) architecture consisting of image encoder, prompt encoder, and
         mask decoder for real-time and promptable segmentation tasks.
 
         Args:
             im (torch.Tensor): The preprocessed input image in tensor format, with shape (N, C, H, W).
             bboxes (np.ndarray | List, optional): Bounding boxes with shape (N, 4), in XYXY format.
-            points (np.ndarray | List, optional): Points indicating object locations with shape (N, 2), in pixel coordinates.
-            labels (np.ndarray | List, optional): Labels for point prompts, shape (N, ). 1 for foreground and 0 for background.
-            masks (np.ndarray, optional): Low-resolution masks from previous predictions. Shape should be (N, H, W). For SAM, H=W=256.
-            multimask_output (bool, optional): Flag to return multiple masks. Helpful for ambiguous prompts. Defaults to False.
+            points (np.ndarray | List, optional): Points indicating object locations with shape (N, 2), in pixels.
+            labels (np.ndarray | List, optional): Labels for point prompts, shape (N, ). 1 = foreground, 0 = background.
+            masks (np.ndarray, optional): Low-resolution masks from previous predictions shape (N,H,W). For SAM H=W=256.
+            multimask_output (bool, optional): Flag to return multiple masks. Helpful for ambiguous prompts.
 
         Returns:
             (tuple): Contains the following three elements.
                 - np.ndarray: The output masks in shape CxHxW, where C is the number of generated masks.
                 - np.ndarray: An array of length C containing quality scores predicted by the model for each mask.
                 - np.ndarray: Low-resolution logits of shape CxHxW for subsequent inference, where H=W=256.
         """
         # Override prompts if any stored in self.prompts
-        bboxes = self.prompts.pop('bboxes', bboxes)
-        points = self.prompts.pop('points', points)
-        masks = self.prompts.pop('masks', masks)
+        bboxes = self.prompts.pop("bboxes", bboxes)
+        points = self.prompts.pop("points", points)
+        masks = self.prompts.pop("masks", masks)
 
         if all(i is None for i in [bboxes, points, masks]):
             return self.generate(im, *args, **kwargs)
 
         return self.prompt_inference(im, bboxes, points, labels, masks, multimask_output)
 
     def prompt_inference(self, im, bboxes=None, points=None, labels=None, masks=None, multimask_output=False):
         """
         Internal function for image segmentation inference based on cues like bounding boxes, points, and masks.
         Leverages SAM's specialized architecture for prompt-based, real-time segmentation.
 
         Args:
             im (torch.Tensor): The preprocessed input image in tensor format, with shape (N, C, H, W).
             bboxes (np.ndarray | List, optional): Bounding boxes with shape (N, 4), in XYXY format.
-            points (np.ndarray | List, optional): Points indicating object locations with shape (N, 2), in pixel coordinates.
-            labels (np.ndarray | List, optional): Labels for point prompts, shape (N, ). 1 for foreground and 0 for background.
-            masks (np.ndarray, optional): Low-resolution masks from previous predictions. Shape should be (N, H, W). For SAM, H=W=256.
-            multimask_output (bool, optional): Flag to return multiple masks. Helpful for ambiguous prompts. Defaults to False.
+            points (np.ndarray | List, optional): Points indicating object locations with shape (N, 2), in pixels.
+            labels (np.ndarray | List, optional): Labels for point prompts, shape (N, ). 1 = foreground, 0 = background.
+            masks (np.ndarray, optional): Low-resolution masks from previous predictions shape (N,H,W). For SAM H=W=256.
+            multimask_output (bool, optional): Flag to return multiple masks. Helpful for ambiguous prompts.
 
         Returns:
             (tuple): Contains the following three elements.
                 - np.ndarray: The output masks in shape CxHxW, where C is the number of generated masks.
                 - np.ndarray: An array of length C containing quality scores predicted by the model for each mask.
                 - np.ndarray: Low-resolution logits of shape CxHxW for subsequent inference, where H=W=256.
         """
@@ -195,76 +203,81 @@
             multimask_output=multimask_output,
         )
 
         # (N, d, H, W) --> (N*d, H, W), (N, d) --> (N*d, )
         # `d` could be 1 or 3 depends on `multimask_output`.
         return pred_masks.flatten(0, 1), pred_scores.flatten(0, 1)
 
-    def generate(self,
-                 im,
-                 crop_n_layers=0,
-                 crop_overlap_ratio=512 / 1500,
-                 crop_downscale_factor=1,
-                 point_grids=None,
-                 points_stride=32,
-                 points_batch_size=64,
-                 conf_thres=0.88,
-                 stability_score_thresh=0.95,
-                 stability_score_offset=0.95,
-                 crop_nms_thresh=0.7):
+    def generate(
+        self,
+        im,
+        crop_n_layers=0,
+        crop_overlap_ratio=512 / 1500,
+        crop_downscale_factor=1,
+        point_grids=None,
+        points_stride=32,
+        points_batch_size=64,
+        conf_thres=0.88,
+        stability_score_thresh=0.95,
+        stability_score_offset=0.95,
+        crop_nms_thresh=0.7,
+    ):
         """
         Perform image segmentation using the Segment Anything Model (SAM).
 
         This function segments an entire image into constituent parts by leveraging SAM's advanced architecture
         and real-time performance capabilities. It can optionally work on image crops for finer segmentation.
 
         Args:
             im (torch.Tensor): Input tensor representing the preprocessed image with dimensions (N, C, H, W).
             crop_n_layers (int): Specifies the number of layers for additional mask predictions on image crops.
                                  Each layer produces 2**i_layer number of image crops.
-            crop_overlap_ratio (float): Determines the extent of overlap between crops. Scaled down in subsequent layers.
+            crop_overlap_ratio (float): Determines the overlap between crops. Scaled down in subsequent layers.
             crop_downscale_factor (int): Scaling factor for the number of sampled points-per-side in each layer.
             point_grids (list[np.ndarray], optional): Custom grids for point sampling normalized to [0,1].
                                                       Used in the nth crop layer.
             points_stride (int, optional): Number of points to sample along each side of the image.
                                            Exclusive with 'point_grids'.
             points_batch_size (int): Batch size for the number of points processed simultaneously.
             conf_thres (float): Confidence threshold [0,1] for filtering based on the model's mask quality prediction.
             stability_score_thresh (float): Stability threshold [0,1] for mask filtering based on mask stability.
             stability_score_offset (float): Offset value for calculating stability score.
-            crop_nms_thresh (float): IoU cutoff for Non-Maximum Suppression (NMS) to remove duplicate masks between crops.
+            crop_nms_thresh (float): IoU cutoff for NMS to remove duplicate masks between crops.
 
         Returns:
             (tuple): A tuple containing segmented masks, confidence scores, and bounding boxes.
         """
+        import torchvision  # scope for faster 'import ultralytics'
+
         self.segment_all = True
         ih, iw = im.shape[2:]
         crop_regions, layer_idxs = generate_crop_boxes((ih, iw), crop_n_layers, crop_overlap_ratio)
         if point_grids is None:
             point_grids = build_all_layer_point_grids(points_stride, crop_n_layers, crop_downscale_factor)
         pred_masks, pred_scores, pred_bboxes, region_areas = [], [], [], []
         for crop_region, layer_idx in zip(crop_regions, layer_idxs):
             x1, y1, x2, y2 = crop_region
             w, h = x2 - x1, y2 - y1
             area = torch.tensor(w * h, device=im.device)
             points_scale = np.array([[w, h]])  # w, h
             # Crop image and interpolate to input size
-            crop_im = F.interpolate(im[..., y1:y2, x1:x2], (ih, iw), mode='bilinear', align_corners=False)
+            crop_im = F.interpolate(im[..., y1:y2, x1:x2], (ih, iw), mode="bilinear", align_corners=False)
             # (num_points, 2)
             points_for_image = point_grids[layer_idx] * points_scale
             crop_masks, crop_scores, crop_bboxes = [], [], []
-            for (points, ) in batch_iterator(points_batch_size, points_for_image):
+            for (points,) in batch_iterator(points_batch_size, points_for_image):
                 pred_mask, pred_score = self.prompt_inference(crop_im, points=points, multimask_output=True)
                 # Interpolate predicted masks to input size
-                pred_mask = F.interpolate(pred_mask[None], (h, w), mode='bilinear', align_corners=False)[0]
+                pred_mask = F.interpolate(pred_mask[None], (h, w), mode="bilinear", align_corners=False)[0]
                 idx = pred_score > conf_thres
                 pred_mask, pred_score = pred_mask[idx], pred_score[idx]
 
-                stability_score = calculate_stability_score(pred_mask, self.model.mask_threshold,
-                                                            stability_score_offset)
+                stability_score = calculate_stability_score(
+                    pred_mask, self.model.mask_threshold, stability_score_offset
+                )
                 idx = stability_score > stability_score_thresh
                 pred_mask, pred_score = pred_mask[idx], pred_score[idx]
                 # Bool type is much more memory-efficient.
                 pred_mask = pred_mask > self.model.mask_threshold
                 # (N, 4)
                 pred_bbox = batched_mask_to_box(pred_mask).float()
                 keep_mask = ~is_box_near_crop_edge(pred_bbox, crop_region, [0, 0, iw, ih])
@@ -335,16 +348,16 @@
         self.model.fp16 = False
         self.done_warmup = True
 
     def postprocess(self, preds, img, orig_imgs):
         """
         Post-processes SAM's inference outputs to generate object detection masks and bounding boxes.
 
-        The method scales masks and boxes to the original image size and applies a threshold to the mask predictions. The
-        SAM model uses advanced architecture and promptable segmentation tasks to achieve real-time performance.
+        The method scales masks and boxes to the original image size and applies a threshold to the mask predictions.
+        The SAM model uses advanced architecture and promptable segmentation tasks to achieve real-time performance.
 
         Args:
             preds (tuple): The output from SAM model inference, containing masks, scores, and optional bounding boxes.
             img (torch.Tensor): The processed input image tensor.
             orig_imgs (list | torch.Tensor): The original, unprocessed images.
 
         Returns:
@@ -400,15 +413,15 @@
         Raises:
             AssertionError: If more than one image is set.
         """
         if self.model is None:
             model = build_sam(self.args.model)
             self.setup_model(model)
         self.setup_source(image)
-        assert len(self.dataset) == 1, '`set_image` only supports setting one image!'
+        assert len(self.dataset) == 1, "`set_image` only supports setting one image!"
         for batch in self.dataset:
             im = self.preprocess(batch[1])
             self.features = self.model.image_encoder(im)
             self.im = im
             break
 
     def set_prompts(self, prompts):
@@ -434,25 +447,27 @@
             nms_thresh (float): The IoU threshold for the NMS algorithm. Defaults to 0.7.
 
         Returns:
             (tuple([torch.Tensor, List[int]])):
                 - new_masks (torch.Tensor): The processed masks with small regions removed. Shape is (N, H, W).
                 - keep (List[int]): The indices of the remaining masks post-NMS, which can be used to filter the boxes.
         """
+        import torchvision  # scope for faster 'import ultralytics'
+
         if len(masks) == 0:
             return masks
 
         # Filter small disconnected regions and holes
         new_masks = []
         scores = []
         for mask in masks:
             mask = mask.cpu().numpy().astype(np.uint8)
-            mask, changed = remove_small_regions(mask, min_area, mode='holes')
+            mask, changed = remove_small_regions(mask, min_area, mode="holes")
             unchanged = not changed
-            mask, changed = remove_small_regions(mask, min_area, mode='islands')
+            mask, changed = remove_small_regions(mask, min_area, mode="islands")
             unchanged = unchanged and not changed
 
             new_masks.append(torch.as_tensor(mask).unsqueeze(0))
             # Give score=0 to changed masks and 1 to unchanged masks so NMS prefers masks not needing postprocessing
             scores.append(float(unchanged))
 
         # Recalculate boxes and remove any new duplicates
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/utils/loss.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/utils/loss.py`

 * *Files 6% similar despite different names*

```diff
@@ -26,88 +26,83 @@
         uni_match_ind (int): The fixed indices of a layer to use if `use_uni_match` is True.
         matcher (HungarianMatcher): Object to compute matching cost and indices.
         fl (FocalLoss or None): Focal Loss object if `use_fl` is True, otherwise None.
         vfl (VarifocalLoss or None): Varifocal Loss object if `use_vfl` is True, otherwise None.
         device (torch.device): Device on which tensors are stored.
     """
 
-    def __init__(self,
-                 nc=80,
-                 loss_gain=None,
-                 aux_loss=True,
-                 use_fl=True,
-                 use_vfl=False,
-                 use_uni_match=False,
-                 uni_match_ind=0):
+    def __init__(
+        self, nc=80, loss_gain=None, aux_loss=True, use_fl=True, use_vfl=False, use_uni_match=False, uni_match_ind=0
+    ):
         """
         DETR loss function.
 
         Args:
             nc (int): The number of classes.
             loss_gain (dict): The coefficient of loss.
             aux_loss (bool): If 'aux_loss = True', loss at each decoder layer are to be used.
             use_vfl (bool): Use VarifocalLoss or not.
             use_uni_match (bool): Whether to use a fixed layer to assign labels for auxiliary branch.
             uni_match_ind (int): The fixed indices of a layer.
         """
         super().__init__()
 
         if loss_gain is None:
-            loss_gain = {'class': 1, 'bbox': 5, 'giou': 2, 'no_object': 0.1, 'mask': 1, 'dice': 1}
+            loss_gain = {"class": 1, "bbox": 5, "giou": 2, "no_object": 0.1, "mask": 1, "dice": 1}
         self.nc = nc
-        self.matcher = HungarianMatcher(cost_gain={'class': 2, 'bbox': 5, 'giou': 2})
+        self.matcher = HungarianMatcher(cost_gain={"class": 2, "bbox": 5, "giou": 2})
         self.loss_gain = loss_gain
         self.aux_loss = aux_loss
         self.fl = FocalLoss() if use_fl else None
         self.vfl = VarifocalLoss() if use_vfl else None
 
         self.use_uni_match = use_uni_match
         self.uni_match_ind = uni_match_ind
         self.device = None
 
-    def _get_loss_class(self, pred_scores, targets, gt_scores, num_gts, postfix=''):
+    def _get_loss_class(self, pred_scores, targets, gt_scores, num_gts, postfix=""):
         """Computes the classification loss based on predictions, target values, and ground truth scores."""
         # Logits: [b, query, num_classes], gt_class: list[[n, 1]]
-        name_class = f'loss_class{postfix}'
+        name_class = f"loss_class{postfix}"
         bs, nq = pred_scores.shape[:2]
         # one_hot = F.one_hot(targets, self.nc + 1)[..., :-1]  # (bs, num_queries, num_classes)
         one_hot = torch.zeros((bs, nq, self.nc + 1), dtype=torch.int64, device=targets.device)
         one_hot.scatter_(2, targets.unsqueeze(-1), 1)
         one_hot = one_hot[..., :-1]
         gt_scores = gt_scores.view(bs, nq, 1) * one_hot
 
         if self.fl:
             if num_gts and self.vfl:
                 loss_cls = self.vfl(pred_scores, gt_scores, one_hot)
             else:
                 loss_cls = self.fl(pred_scores, one_hot.float())
             loss_cls /= max(num_gts, 1) / nq
         else:
-            loss_cls = nn.BCEWithLogitsLoss(reduction='none')(pred_scores, gt_scores).mean(1).sum()  # YOLO CLS loss
+            loss_cls = nn.BCEWithLogitsLoss(reduction="none")(pred_scores, gt_scores).mean(1).sum()  # YOLO CLS loss
 
-        return {name_class: loss_cls.squeeze() * self.loss_gain['class']}
+        return {name_class: loss_cls.squeeze() * self.loss_gain["class"]}
 
-    def _get_loss_bbox(self, pred_bboxes, gt_bboxes, postfix=''):
+    def _get_loss_bbox(self, pred_bboxes, gt_bboxes, postfix=""):
         """Calculates and returns the bounding box loss and GIoU loss for the predicted and ground truth bounding
         boxes.
         """
         # Boxes: [b, query, 4], gt_bbox: list[[n, 4]]
-        name_bbox = f'loss_bbox{postfix}'
-        name_giou = f'loss_giou{postfix}'
+        name_bbox = f"loss_bbox{postfix}"
+        name_giou = f"loss_giou{postfix}"
 
         loss = {}
         if len(gt_bboxes) == 0:
-            loss[name_bbox] = torch.tensor(0., device=self.device)
-            loss[name_giou] = torch.tensor(0., device=self.device)
+            loss[name_bbox] = torch.tensor(0.0, device=self.device)
+            loss[name_giou] = torch.tensor(0.0, device=self.device)
             return loss
 
-        loss[name_bbox] = self.loss_gain['bbox'] * F.l1_loss(pred_bboxes, gt_bboxes, reduction='sum') / len(gt_bboxes)
+        loss[name_bbox] = self.loss_gain["bbox"] * F.l1_loss(pred_bboxes, gt_bboxes, reduction="sum") / len(gt_bboxes)
         loss[name_giou] = 1.0 - bbox_iou(pred_bboxes, gt_bboxes, xywh=True, GIoU=True)
         loss[name_giou] = loss[name_giou].sum() / len(gt_bboxes)
-        loss[name_giou] = self.loss_gain['giou'] * loss[name_giou]
+        loss[name_giou] = self.loss_gain["giou"] * loss[name_giou]
         return {k: v.squeeze() for k, v in loss.items()}
 
     # This function is for future RT-DETR Segment models
     # def _get_loss_mask(self, masks, gt_mask, match_indices, postfix=''):
     #     # masks: [b, query, h, w], gt_mask: list[[n, H, W]]
     #     name_mask = f'loss_mask{postfix}'
     #     name_dice = f'loss_dice{postfix}'
@@ -133,58 +128,65 @@
     #     inputs = F.sigmoid(inputs).flatten(1)
     #     targets = targets.flatten(1)
     #     numerator = 2 * (inputs * targets).sum(1)
     #     denominator = inputs.sum(-1) + targets.sum(-1)
     #     loss = 1 - (numerator + 1) / (denominator + 1)
     #     return loss.sum() / num_gts
 
-    def _get_loss_aux(self,
-                      pred_bboxes,
-                      pred_scores,
-                      gt_bboxes,
-                      gt_cls,
-                      gt_groups,
-                      match_indices=None,
-                      postfix='',
-                      masks=None,
-                      gt_mask=None):
+    def _get_loss_aux(
+        self,
+        pred_bboxes,
+        pred_scores,
+        gt_bboxes,
+        gt_cls,
+        gt_groups,
+        match_indices=None,
+        postfix="",
+        masks=None,
+        gt_mask=None,
+    ):
         """Get auxiliary losses."""
         # NOTE: loss class, bbox, giou, mask, dice
         loss = torch.zeros(5 if masks is not None else 3, device=pred_bboxes.device)
         if match_indices is None and self.use_uni_match:
-            match_indices = self.matcher(pred_bboxes[self.uni_match_ind],
-                                         pred_scores[self.uni_match_ind],
-                                         gt_bboxes,
-                                         gt_cls,
-                                         gt_groups,
-                                         masks=masks[self.uni_match_ind] if masks is not None else None,
-                                         gt_mask=gt_mask)
+            match_indices = self.matcher(
+                pred_bboxes[self.uni_match_ind],
+                pred_scores[self.uni_match_ind],
+                gt_bboxes,
+                gt_cls,
+                gt_groups,
+                masks=masks[self.uni_match_ind] if masks is not None else None,
+                gt_mask=gt_mask,
+            )
         for i, (aux_bboxes, aux_scores) in enumerate(zip(pred_bboxes, pred_scores)):
             aux_masks = masks[i] if masks is not None else None
-            loss_ = self._get_loss(aux_bboxes,
-                                   aux_scores,
-                                   gt_bboxes,
-                                   gt_cls,
-                                   gt_groups,
-                                   masks=aux_masks,
-                                   gt_mask=gt_mask,
-                                   postfix=postfix,
-                                   match_indices=match_indices)
-            loss[0] += loss_[f'loss_class{postfix}']
-            loss[1] += loss_[f'loss_bbox{postfix}']
-            loss[2] += loss_[f'loss_giou{postfix}']
+            loss_ = self._get_loss(
+                aux_bboxes,
+                aux_scores,
+                gt_bboxes,
+                gt_cls,
+                gt_groups,
+                masks=aux_masks,
+                gt_mask=gt_mask,
+                postfix=postfix,
+                match_indices=match_indices,
+            )
+            loss[0] += loss_[f"loss_class{postfix}"]
+            loss[1] += loss_[f"loss_bbox{postfix}"]
+            loss[2] += loss_[f"loss_giou{postfix}"]
             # if masks is not None and gt_mask is not None:
             #     loss_ = self._get_loss_mask(aux_masks, gt_mask, match_indices, postfix)
             #     loss[3] += loss_[f'loss_mask{postfix}']
             #     loss[4] += loss_[f'loss_dice{postfix}']
 
         loss = {
-            f'loss_class_aux{postfix}': loss[0],
-            f'loss_bbox_aux{postfix}': loss[1],
-            f'loss_giou_aux{postfix}': loss[2]}
+            f"loss_class_aux{postfix}": loss[0],
+            f"loss_bbox_aux{postfix}": loss[1],
+            f"loss_giou_aux{postfix}": loss[2],
+        }
         # if masks is not None and gt_mask is not None:
         #     loss[f'loss_mask_aux{postfix}'] = loss[3]
         #     loss[f'loss_dice_aux{postfix}'] = loss[4]
         return loss
 
     @staticmethod
     def _get_index(match_indices):
@@ -192,41 +194,45 @@
         batch_idx = torch.cat([torch.full_like(src, i) for i, (src, _) in enumerate(match_indices)])
         src_idx = torch.cat([src for (src, _) in match_indices])
         dst_idx = torch.cat([dst for (_, dst) in match_indices])
         return (batch_idx, src_idx), dst_idx
 
     def _get_assigned_bboxes(self, pred_bboxes, gt_bboxes, match_indices):
         """Assigns predicted bounding boxes to ground truth bounding boxes based on the match indices."""
-        pred_assigned = torch.cat([
-            t[I] if len(I) > 0 else torch.zeros(0, t.shape[-1], device=self.device)
-            for t, (I, _) in zip(pred_bboxes, match_indices)])
-        gt_assigned = torch.cat([
-            t[J] if len(J) > 0 else torch.zeros(0, t.shape[-1], device=self.device)
-            for t, (_, J) in zip(gt_bboxes, match_indices)])
+        pred_assigned = torch.cat(
+            [
+                t[i] if len(i) > 0 else torch.zeros(0, t.shape[-1], device=self.device)
+                for t, (i, _) in zip(pred_bboxes, match_indices)
+            ]
+        )
+        gt_assigned = torch.cat(
+            [
+                t[j] if len(j) > 0 else torch.zeros(0, t.shape[-1], device=self.device)
+                for t, (_, j) in zip(gt_bboxes, match_indices)
+            ]
+        )
         return pred_assigned, gt_assigned
 
-    def _get_loss(self,
-                  pred_bboxes,
-                  pred_scores,
-                  gt_bboxes,
-                  gt_cls,
-                  gt_groups,
-                  masks=None,
-                  gt_mask=None,
-                  postfix='',
-                  match_indices=None):
+    def _get_loss(
+        self,
+        pred_bboxes,
+        pred_scores,
+        gt_bboxes,
+        gt_cls,
+        gt_groups,
+        masks=None,
+        gt_mask=None,
+        postfix="",
+        match_indices=None,
+    ):
         """Get losses."""
         if match_indices is None:
-            match_indices = self.matcher(pred_bboxes,
-                                         pred_scores,
-                                         gt_bboxes,
-                                         gt_cls,
-                                         gt_groups,
-                                         masks=masks,
-                                         gt_mask=gt_mask)
+            match_indices = self.matcher(
+                pred_bboxes, pred_scores, gt_bboxes, gt_cls, gt_groups, masks=masks, gt_mask=gt_mask
+            )
 
         idx, gt_idx = self._get_index(match_indices)
         pred_bboxes, gt_bboxes = pred_bboxes[idx], gt_bboxes[gt_idx]
 
         bs, nq = pred_scores.shape[:2]
         targets = torch.full((bs, nq), self.nc, device=pred_scores.device, dtype=gt_cls.dtype)
         targets[idx] = gt_cls[gt_idx]
@@ -238,41 +244,39 @@
         loss = {}
         loss.update(self._get_loss_class(pred_scores, targets, gt_scores, len(gt_bboxes), postfix))
         loss.update(self._get_loss_bbox(pred_bboxes, gt_bboxes, postfix))
         # if masks is not None and gt_mask is not None:
         #     loss.update(self._get_loss_mask(masks, gt_mask, match_indices, postfix))
         return loss
 
-    def forward(self, pred_bboxes, pred_scores, batch, postfix='', **kwargs):
+    def forward(self, pred_bboxes, pred_scores, batch, postfix="", **kwargs):
         """
         Args:
             pred_bboxes (torch.Tensor): [l, b, query, 4]
             pred_scores (torch.Tensor): [l, b, query, num_classes]
             batch (dict): A dict includes:
                 gt_cls (torch.Tensor) with shape [num_gts, ],
                 gt_bboxes (torch.Tensor): [num_gts, 4],
                 gt_groups (List(int)): a list of batch size length includes the number of gts of each image.
             postfix (str): postfix of loss name.
         """
         self.device = pred_bboxes.device
-        match_indices = kwargs.get('match_indices', None)
-        gt_cls, gt_bboxes, gt_groups = batch['cls'], batch['bboxes'], batch['gt_groups']
+        match_indices = kwargs.get("match_indices", None)
+        gt_cls, gt_bboxes, gt_groups = batch["cls"], batch["bboxes"], batch["gt_groups"]
 
-        total_loss = self._get_loss(pred_bboxes[-1],
-                                    pred_scores[-1],
-                                    gt_bboxes,
-                                    gt_cls,
-                                    gt_groups,
-                                    postfix=postfix,
-                                    match_indices=match_indices)
+        total_loss = self._get_loss(
+            pred_bboxes[-1], pred_scores[-1], gt_bboxes, gt_cls, gt_groups, postfix=postfix, match_indices=match_indices
+        )
 
         if self.aux_loss:
             total_loss.update(
-                self._get_loss_aux(pred_bboxes[:-1], pred_scores[:-1], gt_bboxes, gt_cls, gt_groups, match_indices,
-                                   postfix))
+                self._get_loss_aux(
+                    pred_bboxes[:-1], pred_scores[:-1], gt_bboxes, gt_cls, gt_groups, match_indices, postfix
+                )
+            )
 
         return total_loss
 
 
 class RTDETRDetectionLoss(DETRLoss):
     """
     Real-Time DeepTracker (RT-DETR) Detection Loss class that extends the DETRLoss.
@@ -296,26 +300,26 @@
             (dict): Dictionary containing the total loss and, if applicable, the denoising loss.
         """
         pred_bboxes, pred_scores = preds
         total_loss = super().forward(pred_bboxes, pred_scores, batch)
 
         # Check for denoising metadata to compute denoising training loss
         if dn_meta is not None:
-            dn_pos_idx, dn_num_group = dn_meta['dn_pos_idx'], dn_meta['dn_num_group']
-            assert len(batch['gt_groups']) == len(dn_pos_idx)
+            dn_pos_idx, dn_num_group = dn_meta["dn_pos_idx"], dn_meta["dn_num_group"]
+            assert len(batch["gt_groups"]) == len(dn_pos_idx)
 
             # Get the match indices for denoising
-            match_indices = self.get_dn_match_indices(dn_pos_idx, dn_num_group, batch['gt_groups'])
+            match_indices = self.get_dn_match_indices(dn_pos_idx, dn_num_group, batch["gt_groups"])
 
             # Compute the denoising training loss
-            dn_loss = super().forward(dn_bboxes, dn_scores, batch, postfix='_dn', match_indices=match_indices)
+            dn_loss = super().forward(dn_bboxes, dn_scores, batch, postfix="_dn", match_indices=match_indices)
             total_loss.update(dn_loss)
         else:
             # If no denoising metadata is provided, set denoising loss to zero
-            total_loss.update({f'{k}_dn': torch.tensor(0., device=self.device) for k in total_loss.keys()})
+            total_loss.update({f"{k}_dn": torch.tensor(0.0, device=self.device) for k in total_loss.keys()})
 
         return total_loss
 
     @staticmethod
     def get_dn_match_indices(dn_pos_idx, dn_num_group, gt_groups):
         """
         Get the match indices for denoising.
@@ -330,13 +334,13 @@
         """
         dn_match_indices = []
         idx_groups = torch.as_tensor([0, *gt_groups[:-1]]).cumsum_(0)
         for i, num_gt in enumerate(gt_groups):
             if num_gt > 0:
                 gt_idx = torch.arange(end=num_gt, dtype=torch.long) + idx_groups[i]
                 gt_idx = gt_idx.repeat(dn_num_group)
-                assert len(dn_pos_idx[i]) == len(gt_idx), 'Expected the same length, '
-                f'but got {len(dn_pos_idx[i])} and {len(gt_idx)} respectively.'
+                assert len(dn_pos_idx[i]) == len(gt_idx), "Expected the same length, "
+                f"but got {len(dn_pos_idx[i])} and {len(gt_idx)} respectively."
                 dn_match_indices.append((dn_pos_idx[i], gt_idx))
             else:
                 dn_match_indices.append((torch.zeros([0], dtype=torch.long), torch.zeros([0], dtype=torch.long)))
         return dn_match_indices
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/utils/ops.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/utils/ops.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,15 +33,15 @@
 
     def __init__(self, cost_gain=None, use_fl=True, with_mask=False, num_sample_points=12544, alpha=0.25, gamma=2.0):
         """Initializes HungarianMatcher with cost coefficients, Focal Loss, mask prediction, sample points, and alpha
         gamma factors.
         """
         super().__init__()
         if cost_gain is None:
-            cost_gain = {'class': 1, 'bbox': 5, 'giou': 2, 'mask': 1, 'dice': 1}
+            cost_gain = {"class": 1, "bbox": 5, "giou": 2, "mask": 1, "dice": 1}
         self.cost_gain = cost_gain
         self.use_fl = use_fl
         self.with_mask = with_mask
         self.num_sample_points = num_sample_points
         self.alpha = alpha
         self.gamma = gamma
 
@@ -82,43 +82,46 @@
         pred_scores = F.sigmoid(pred_scores) if self.use_fl else F.softmax(pred_scores, dim=-1)
         # [batch_size * num_queries, 4]
         pred_bboxes = pred_bboxes.detach().view(-1, 4)
 
         # Compute the classification cost
         pred_scores = pred_scores[:, gt_cls]
         if self.use_fl:
-            neg_cost_class = (1 - self.alpha) * (pred_scores ** self.gamma) * (-(1 - pred_scores + 1e-8).log())
+            neg_cost_class = (1 - self.alpha) * (pred_scores**self.gamma) * (-(1 - pred_scores + 1e-8).log())
             pos_cost_class = self.alpha * ((1 - pred_scores) ** self.gamma) * (-(pred_scores + 1e-8).log())
             cost_class = pos_cost_class - neg_cost_class
         else:
             cost_class = -pred_scores
 
         # Compute the L1 cost between boxes
         cost_bbox = (pred_bboxes.unsqueeze(1) - gt_bboxes.unsqueeze(0)).abs().sum(-1)  # (bs*num_queries, num_gt)
 
         # Compute the GIoU cost between boxes, (bs*num_queries, num_gt)
         cost_giou = 1.0 - bbox_iou(pred_bboxes.unsqueeze(1), gt_bboxes.unsqueeze(0), xywh=True, GIoU=True).squeeze(-1)
 
         # Final cost matrix
-        C = self.cost_gain['class'] * cost_class + \
-            self.cost_gain['bbox'] * cost_bbox + \
-            self.cost_gain['giou'] * cost_giou
+        C = (
+            self.cost_gain["class"] * cost_class
+            + self.cost_gain["bbox"] * cost_bbox
+            + self.cost_gain["giou"] * cost_giou
+        )
         # Compute the mask cost and dice cost
         if self.with_mask:
             C += self._cost_mask(bs, gt_groups, masks, gt_mask)
 
         # Set invalid values (NaNs and infinities) to 0 (fixes ValueError: matrix contains invalid numeric entries)
         C[C.isnan() | C.isinf()] = 0.0
 
         C = C.view(bs, nq, -1).cpu()
         indices = [linear_sum_assignment(c[i]) for i, c in enumerate(C.split(gt_groups, -1))]
-        gt_groups = torch.as_tensor([0, *gt_groups[:-1]]).cumsum_(0)
-        # (idx for queries, idx for gt)
-        return [(torch.tensor(i, dtype=torch.long), torch.tensor(j, dtype=torch.long) + gt_groups[k])
-                for k, (i, j) in enumerate(indices)]
+        gt_groups = torch.as_tensor([0, *gt_groups[:-1]]).cumsum_(0)  # (idx for queries, idx for gt)
+        return [
+            (torch.tensor(i, dtype=torch.long), torch.tensor(j, dtype=torch.long) + gt_groups[k])
+            for k, (i, j) in enumerate(indices)
+        ]
 
     # This function is for future RT-DETR Segment models
     # def _cost_mask(self, bs, num_gts, masks=None, gt_mask=None):
     #     assert masks is not None and gt_mask is not None, 'Make sure the input has `mask` and `gt_mask`'
     #     # all masks share the same set of points for efficient matching
     #     sample_points = torch.rand([bs, 1, self.num_sample_points, 2])
     #     sample_points = 2.0 * sample_points - 1.0
@@ -143,22 +146,17 @@
     #         denominator = out_mask.sum(-1, keepdim=True) + tgt_mask.sum(-1).unsqueeze(0)
     #         cost_dice = 1 - (numerator + 1) / (denominator + 1)
     #
     #         C = self.cost_gain['mask'] * cost_mask + self.cost_gain['dice'] * cost_dice
     #     return C
 
 
-def get_cdn_group(batch,
-                  num_classes,
-                  num_queries,
-                  class_embed,
-                  num_dn=100,
-                  cls_noise_ratio=0.5,
-                  box_noise_scale=1.0,
-                  training=False):
+def get_cdn_group(
+    batch, num_classes, num_queries, class_embed, num_dn=100, cls_noise_ratio=0.5, box_noise_scale=1.0, training=False
+):
     """
     Get contrastive denoising training group. This function creates a contrastive denoising training group with positive
     and negative samples from the ground truths (gt). It applies noise to the class labels and bounding box coordinates,
     and returns the modified labels, bounding boxes, attention mask and meta information.
 
     Args:
         batch (dict): A dict that includes 'gt_cls' (torch.Tensor with shape [num_gts, ]), 'gt_bboxes'
@@ -176,27 +174,27 @@
         (Tuple[Optional[Tensor], Optional[Tensor], Optional[Tensor], Optional[Dict]]): The modified class embeddings,
             bounding boxes, attention mask and meta information for denoising. If not in training mode or 'num_dn'
             is less than or equal to 0, the function returns None for all elements in the tuple.
     """
 
     if (not training) or num_dn <= 0:
         return None, None, None, None
-    gt_groups = batch['gt_groups']
+    gt_groups = batch["gt_groups"]
     total_num = sum(gt_groups)
     max_nums = max(gt_groups)
     if max_nums == 0:
         return None, None, None, None
 
     num_group = num_dn // max_nums
     num_group = 1 if num_group == 0 else num_group
     # Pad gt to max_num of a batch
     bs = len(gt_groups)
-    gt_cls = batch['cls']  # (bs*num, )
-    gt_bbox = batch['bboxes']  # bs*num, 4
-    b_idx = batch['batch_idx']
+    gt_cls = batch["cls"]  # (bs*num, )
+    gt_bbox = batch["bboxes"]  # bs*num, 4
+    b_idx = batch["batch_idx"]
 
     # Each group has positive and negative queries.
     dn_cls = gt_cls.repeat(2 * num_group)  # (2*num_group*bs*num, )
     dn_bbox = gt_bbox.repeat(2 * num_group, 1)  # 2*num_group*bs*num, 4
     dn_b_idx = b_idx.repeat(2 * num_group).view(-1)  # (2*num_group*bs*num, )
 
     # Positive and negative mask
@@ -241,20 +239,25 @@
     tgt_size = num_dn + num_queries
     attn_mask = torch.zeros([tgt_size, tgt_size], dtype=torch.bool)
     # Match query cannot see the reconstruct
     attn_mask[num_dn:, :num_dn] = True
     # Reconstruct cannot see each other
     for i in range(num_group):
         if i == 0:
-            attn_mask[max_nums * 2 * i:max_nums * 2 * (i + 1), max_nums * 2 * (i + 1):num_dn] = True
+            attn_mask[max_nums * 2 * i : max_nums * 2 * (i + 1), max_nums * 2 * (i + 1) : num_dn] = True
         if i == num_group - 1:
-            attn_mask[max_nums * 2 * i:max_nums * 2 * (i + 1), :max_nums * i * 2] = True
+            attn_mask[max_nums * 2 * i : max_nums * 2 * (i + 1), : max_nums * i * 2] = True
         else:
-            attn_mask[max_nums * 2 * i:max_nums * 2 * (i + 1), max_nums * 2 * (i + 1):num_dn] = True
-            attn_mask[max_nums * 2 * i:max_nums * 2 * (i + 1), :max_nums * 2 * i] = True
+            attn_mask[max_nums * 2 * i : max_nums * 2 * (i + 1), max_nums * 2 * (i + 1) : num_dn] = True
+            attn_mask[max_nums * 2 * i : max_nums * 2 * (i + 1), : max_nums * 2 * i] = True
     dn_meta = {
-        'dn_pos_idx': [p.reshape(-1) for p in pos_idx.cpu().split(list(gt_groups), dim=1)],
-        'dn_num_group': num_group,
-        'dn_num_split': [num_dn, num_queries]}
-
-    return padding_cls.to(class_embed.device), padding_bbox.to(class_embed.device), attn_mask.to(
-        class_embed.device), dn_meta
+        "dn_pos_idx": [p.reshape(-1) for p in pos_idx.cpu().split(list(gt_groups), dim=1)],
+        "dn_num_group": num_group,
+        "dn_num_split": [num_dn, num_queries],
+    }
+
+    return (
+        padding_cls.to(class_embed.device),
+        padding_bbox.to(class_embed.device),
+        attn_mask.to(class_embed.device),
+        dn_meta,
+    )
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/classify/predict.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/pose/predict.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,50 +1,58 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
-import torch
-
-from ultralytics.engine.predictor import BasePredictor
 from ultralytics.engine.results import Results
-from ultralytics.utils import DEFAULT_CFG, ops
+from ultralytics.models.yolo.detect.predict import DetectionPredictor
+from ultralytics.utils import DEFAULT_CFG, LOGGER, ops
 
 
-class ClassificationPredictor(BasePredictor):
+class PosePredictor(DetectionPredictor):
     """
-    A class extending the BasePredictor class for prediction based on a classification model.
-
-    Notes:
-        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.
+    A class extending the DetectionPredictor class for prediction based on a pose model.
 
     Example:
         ```python
         from ultralytics.utils import ASSETS
-        from ultralytics.models.yolo.classify import ClassificationPredictor
+        from ultralytics.models.yolo.pose import PosePredictor
 
-        args = dict(model='yolov8n-cls.pt', source=ASSETS)
-        predictor = ClassificationPredictor(overrides=args)
+        args = dict(model='yolov8n-pose.pt', source=ASSETS)
+        predictor = PosePredictor(overrides=args)
         predictor.predict_cli()
         ```
     """
 
     def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):
-        """Initializes ClassificationPredictor setting the task to 'classify'."""
+        """Initializes PosePredictor, sets task to 'pose' and logs a warning for using 'mps' as device."""
         super().__init__(cfg, overrides, _callbacks)
-        self.args.task = 'classify'
-
-    def preprocess(self, img):
-        """Converts input image to model-compatible data type."""
-        if not isinstance(img, torch.Tensor):
-            img = torch.stack([self.transforms(im) for im in img], dim=0)
-        img = (img if isinstance(img, torch.Tensor) else torch.from_numpy(img)).to(self.model.device)
-        return img.half() if self.model.fp16 else img.float()  # uint8 to fp16/32
+        self.args.task = "pose"
+        if isinstance(self.args.device, str) and self.args.device.lower() == "mps":
+            LOGGER.warning(
+                "WARNING  Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. "
+                "See https://github.com/ultralytics/ultralytics/issues/4031."
+            )
 
     def postprocess(self, preds, img, orig_imgs):
-        """Post-processes predictions to return Results objects."""
+        """Return detection results for a given input image or list of images."""
+        preds = ops.non_max_suppression(
+            preds,
+            self.args.conf,
+            self.args.iou,
+            agnostic=self.args.agnostic_nms,
+            max_det=self.args.max_det,
+            classes=self.args.classes,
+            nc=len(self.model.names),
+        )
+
         if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list
             orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)
 
         results = []
         for i, pred in enumerate(preds):
             orig_img = orig_imgs[i]
+            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape).round()
+            pred_kpts = pred[:, 6:].view(len(pred), *self.model.kpt_shape) if len(pred) else pred[:, 6:]
+            pred_kpts = ops.scale_coords(img.shape[2:], pred_kpts, orig_img.shape)
             img_path = self.batch[0][i]
-            results.append(Results(orig_img, path=img_path, names=self.model.names, probs=pred))
+            results.append(
+                Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], keypoints=pred_kpts)
+            )
         return results
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/classify/train.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/classify/train.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,11 +1,10 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import torch
-import torchvision
 
 from ultralytics.data import ClassificationDataset, build_dataloader
 from ultralytics.engine.trainer import BaseTrainer
 from ultralytics.models import yolo
 from ultralytics.nn.tasks import ClassificationModel, attempt_load_one_weight
 from ultralytics.utils import DEFAULT_CFG, LOGGER, RANK, colorstr
 from ultralytics.utils.plotting import plot_images, plot_results
@@ -29,100 +28,107 @@
         ```
     """
 
     def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):
         """Initialize a ClassificationTrainer object with optional configuration overrides and callbacks."""
         if overrides is None:
             overrides = {}
-        overrides['task'] = 'classify'
-        if overrides.get('imgsz') is None:
-            overrides['imgsz'] = 224
+        overrides["task"] = "classify"
+        if overrides.get("imgsz") is None:
+            overrides["imgsz"] = 224
         super().__init__(cfg, overrides, _callbacks)
 
     def set_model_attributes(self):
         """Set the YOLO model's class names from the loaded dataset."""
-        self.model.names = self.data['names']
+        self.model.names = self.data["names"]
 
     def get_model(self, cfg=None, weights=None, verbose=True):
         """Returns a modified PyTorch model configured for training YOLO."""
-        model = ClassificationModel(cfg, nc=self.data['nc'], verbose=verbose and RANK == -1)
+        model = ClassificationModel(cfg, nc=self.data["nc"], verbose=verbose and RANK == -1)
         if weights:
             model.load(weights)
 
         for m in model.modules():
-            if not self.args.pretrained and hasattr(m, 'reset_parameters'):
+            if not self.args.pretrained and hasattr(m, "reset_parameters"):
                 m.reset_parameters()
             if isinstance(m, torch.nn.Dropout) and self.args.dropout:
                 m.p = self.args.dropout  # set dropout
         for p in model.parameters():
             p.requires_grad = True  # for training
         return model
 
     def setup_model(self):
         """Load, create or download model for any task."""
+        import torchvision  # scope for faster 'import ultralytics'
+
         if isinstance(self.model, torch.nn.Module):  # if model is loaded beforehand. No setup needed
             return
 
         model, ckpt = str(self.model), None
         # Load a YOLO model locally, from torchvision, or from Ultralytics assets
-        if model.endswith('.pt'):
-            self.model, ckpt = attempt_load_one_weight(model, device='cpu')
+        if model.endswith(".pt"):
+            self.model, ckpt = attempt_load_one_weight(model, device="cpu")
             for p in self.model.parameters():
                 p.requires_grad = True  # for training
-        elif model.split('.')[-1] in ('yaml', 'yml'):
+        elif model.split(".")[-1] in {"yaml", "yml"}:
             self.model = self.get_model(cfg=model)
         elif model in torchvision.models.__dict__:
-            self.model = torchvision.models.__dict__[model](weights='IMAGENET1K_V1' if self.args.pretrained else None)
+            self.model = torchvision.models.__dict__[model](weights="IMAGENET1K_V1" if self.args.pretrained else None)
         else:
-            FileNotFoundError(f'ERROR: model={model} not found locally or online. Please check model name.')
-        ClassificationModel.reshape_outputs(self.model, self.data['nc'])
+            raise FileNotFoundError(f"ERROR: model={model} not found locally or online. Please check model name.")
+        ClassificationModel.reshape_outputs(self.model, self.data["nc"])
 
         return ckpt
 
-    def build_dataset(self, img_path, mode='train', batch=None):
+    def build_dataset(self, img_path, mode="train", batch=None):
         """Creates a ClassificationDataset instance given an image path, and mode (train/test etc.)."""
-        return ClassificationDataset(root=img_path, args=self.args, augment=mode == 'train', prefix=mode)
+        return ClassificationDataset(root=img_path, args=self.args, augment=mode == "train", prefix=mode)
 
-    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode='train'):
+    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode="train"):
         """Returns PyTorch DataLoader with transforms to preprocess images for inference."""
         with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP
             dataset = self.build_dataset(dataset_path, mode)
 
         loader = build_dataloader(dataset, batch_size, self.args.workers, rank=rank)
         # Attach inference transforms
-        if mode != 'train':
+        if mode != "train":
             if is_parallel(self.model):
                 self.model.module.transforms = loader.dataset.torch_transforms
             else:
                 self.model.transforms = loader.dataset.torch_transforms
         return loader
 
     def preprocess_batch(self, batch):
         """Preprocesses a batch of images and classes."""
-        batch['img'] = batch['img'].to(self.device)
-        batch['cls'] = batch['cls'].to(self.device)
+        batch["img"] = batch["img"].to(self.device)
+        batch["cls"] = batch["cls"].to(self.device)
         return batch
 
     def progress_string(self):
         """Returns a formatted string showing training progress."""
-        return ('\n' + '%11s' * (4 + len(self.loss_names))) % \
-            ('Epoch', 'GPU_mem', *self.loss_names, 'Instances', 'Size')
+        return ("\n" + "%11s" * (4 + len(self.loss_names))) % (
+            "Epoch",
+            "GPU_mem",
+            *self.loss_names,
+            "Instances",
+            "Size",
+        )
 
     def get_validator(self):
         """Returns an instance of ClassificationValidator for validation."""
-        self.loss_names = ['loss']
-        return yolo.classify.ClassificationValidator(self.test_loader, self.save_dir)
+        self.loss_names = ["loss"]
+        return yolo.classify.ClassificationValidator(self.test_loader, self.save_dir, _callbacks=self.callbacks)
 
-    def label_loss_items(self, loss_items=None, prefix='train'):
+    def label_loss_items(self, loss_items=None, prefix="train"):
         """
         Returns a loss dict with labelled training loss items tensor.
 
         Not needed for classification but necessary for segmentation & detection
         """
-        keys = [f'{prefix}/{x}' for x in self.loss_names]
+        keys = [f"{prefix}/{x}" for x in self.loss_names]
         if loss_items is None:
             return keys
         loss_items = [round(float(loss_items), 5)]
         return dict(zip(keys, loss_items))
 
     def plot_metrics(self):
         """Plots metrics from a CSV file."""
@@ -130,23 +136,24 @@
 
     def final_eval(self):
         """Evaluate trained model and save validation results."""
         for f in self.last, self.best:
             if f.exists():
                 strip_optimizer(f)  # strip optimizers
                 if f is self.best:
-                    LOGGER.info(f'\nValidating {f}...')
+                    LOGGER.info(f"\nValidating {f}...")
                     self.validator.args.data = self.args.data
                     self.validator.args.plots = self.args.plots
                     self.metrics = self.validator(model=f)
-                    self.metrics.pop('fitness', None)
-                    self.run_callbacks('on_fit_epoch_end')
+                    self.metrics.pop("fitness", None)
+                    self.run_callbacks("on_fit_epoch_end")
         LOGGER.info(f"Results saved to {colorstr('bold', self.save_dir)}")
 
     def plot_training_samples(self, batch, ni):
         """Plots training samples with their annotations."""
         plot_images(
-            images=batch['img'],
-            batch_idx=torch.arange(len(batch['img'])),
-            cls=batch['cls'].view(-1),  # warning: use .view(), not .squeeze() for Classify models
-            fname=self.save_dir / f'train_batch{ni}.jpg',
-            on_plot=self.on_plot)
+            images=batch["img"],
+            batch_idx=torch.arange(len(batch["img"])),
+            cls=batch["cls"].view(-1),  # warning: use .view(), not .squeeze() for Classify models
+            fname=self.save_dir / f"train_batch{ni}.jpg",
+            on_plot=self.on_plot,
+        )
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/classify/val.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/classify/val.py`

 * *Files 18% similar despite different names*

```diff
@@ -27,51 +27,50 @@
     """
 
     def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):
         """Initializes ClassificationValidator instance with args, dataloader, save_dir, and progress bar."""
         super().__init__(dataloader, save_dir, pbar, args, _callbacks)
         self.targets = None
         self.pred = None
-        self.args.task = 'classify'
+        self.args.task = "classify"
         self.metrics = ClassifyMetrics()
 
     def get_desc(self):
         """Returns a formatted string summarizing classification metrics."""
-        return ('%22s' + '%11s' * 2) % ('classes', 'top1_acc', 'top5_acc')
+        return ("%22s" + "%11s" * 2) % ("classes", "top1_acc", "top5_acc")
 
     def init_metrics(self, model):
         """Initialize confusion matrix, class names, and top-1 and top-5 accuracy."""
         self.names = model.names
         self.nc = len(model.names)
-        self.confusion_matrix = ConfusionMatrix(nc=self.nc, conf=self.args.conf, task='classify')
+        self.confusion_matrix = ConfusionMatrix(nc=self.nc, conf=self.args.conf, task="classify")
         self.pred = []
         self.targets = []
 
     def preprocess(self, batch):
         """Preprocesses input batch and returns it."""
-        batch['img'] = batch['img'].to(self.device, non_blocking=True)
-        batch['img'] = batch['img'].half() if self.args.half else batch['img'].float()
-        batch['cls'] = batch['cls'].to(self.device)
+        batch["img"] = batch["img"].to(self.device, non_blocking=True)
+        batch["img"] = batch["img"].half() if self.args.half else batch["img"].float()
+        batch["cls"] = batch["cls"].to(self.device)
         return batch
 
     def update_metrics(self, preds, batch):
         """Updates running metrics with model predictions and batch targets."""
         n5 = min(len(self.names), 5)
         self.pred.append(preds.argsort(1, descending=True)[:, :n5])
-        self.targets.append(batch['cls'])
+        self.targets.append(batch["cls"])
 
     def finalize_metrics(self, *args, **kwargs):
         """Finalizes metrics of the model such as confusion_matrix and speed."""
         self.confusion_matrix.process_cls_preds(self.pred, self.targets)
         if self.args.plots:
             for normalize in True, False:
-                self.confusion_matrix.plot(save_dir=self.save_dir,
-                                           names=self.names.values(),
-                                           normalize=normalize,
-                                           on_plot=self.on_plot)
+                self.confusion_matrix.plot(
+                    save_dir=self.save_dir, names=self.names.values(), normalize=normalize, on_plot=self.on_plot
+                )
         self.metrics.speed = self.speed
         self.metrics.confusion_matrix = self.confusion_matrix
         self.metrics.save_dir = self.save_dir
 
     def get_stats(self):
         """Returns a dictionary of metrics obtained by processing targets and predictions."""
         self.metrics.process(self.targets, self.pred)
@@ -84,28 +83,31 @@
     def get_dataloader(self, dataset_path, batch_size):
         """Builds and returns a data loader for classification tasks with given parameters."""
         dataset = self.build_dataset(dataset_path)
         return build_dataloader(dataset, batch_size, self.args.workers, rank=-1)
 
     def print_results(self):
         """Prints evaluation metrics for YOLO object detection model."""
-        pf = '%22s' + '%11.3g' * len(self.metrics.keys)  # print format
-        LOGGER.info(pf % ('all', self.metrics.top1, self.metrics.top5))
+        pf = "%22s" + "%11.3g" * len(self.metrics.keys)  # print format
+        LOGGER.info(pf % ("all", self.metrics.top1, self.metrics.top5))
 
     def plot_val_samples(self, batch, ni):
         """Plot validation image samples."""
         plot_images(
-            images=batch['img'],
-            batch_idx=torch.arange(len(batch['img'])),
-            cls=batch['cls'].view(-1),  # warning: use .view(), not .squeeze() for Classify models
-            fname=self.save_dir / f'val_batch{ni}_labels.jpg',
+            images=batch["img"],
+            batch_idx=torch.arange(len(batch["img"])),
+            cls=batch["cls"].view(-1),  # warning: use .view(), not .squeeze() for Classify models
+            fname=self.save_dir / f"val_batch{ni}_labels.jpg",
             names=self.names,
-            on_plot=self.on_plot)
+            on_plot=self.on_plot,
+        )
 
     def plot_predictions(self, batch, preds, ni):
         """Plots predicted bounding boxes on input images and saves the result."""
-        plot_images(batch['img'],
-                    batch_idx=torch.arange(len(batch['img'])),
-                    cls=torch.argmax(preds, dim=1),
-                    fname=self.save_dir / f'val_batch{ni}_pred.jpg',
-                    names=self.names,
-                    on_plot=self.on_plot)  # pred
+        plot_images(
+            batch["img"],
+            batch_idx=torch.arange(len(batch["img"])),
+            cls=torch.argmax(preds, dim=1),
+            fname=self.save_dir / f"val_batch{ni}_pred.jpg",
+            names=self.names,
+            on_plot=self.on_plot,
+        )  # pred
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/detect/predict.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/detect/predict.py`

 * *Files 8% similar despite different names*

```diff
@@ -18,20 +18,22 @@
         predictor = DetectionPredictor(overrides=args)
         predictor.predict_cli()
         ```
     """
 
     def postprocess(self, preds, img, orig_imgs):
         """Post-processes predictions and returns a list of Results objects."""
-        preds = ops.non_max_suppression(preds,
-                                        self.args.conf,
-                                        self.args.iou,
-                                        agnostic=self.args.agnostic_nms,
-                                        max_det=self.args.max_det,
-                                        classes=self.args.classes)
+        preds = ops.non_max_suppression(
+            preds,
+            self.args.conf,
+            self.args.iou,
+            agnostic=self.args.agnostic_nms,
+            max_det=self.args.max_det,
+            classes=self.args.classes,
+        )
 
         if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list
             orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)
 
         results = []
         for i, pred in enumerate(preds):
             orig_img = orig_imgs[i]
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/detect/train.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/detect/train.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,12 +1,15 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
+import math
+import random
 from copy import copy
 
 import numpy as np
+import torch.nn as nn
 
 from ultralytics.data import build_dataloader, build_yolo_dataset
 from ultralytics.engine.trainer import BaseTrainer
 from ultralytics.models import yolo
 from ultralytics.nn.tasks import DetectionModel
 from ultralytics.utils import LOGGER, RANK
 from ultralytics.utils.plotting import plot_images, plot_labels, plot_results
@@ -23,95 +26,118 @@
 
         args = dict(model='yolov8n.pt', data='coco8.yaml', epochs=3)
         trainer = DetectionTrainer(overrides=args)
         trainer.train()
         ```
     """
 
-    def build_dataset(self, img_path, mode='train', batch=None):
+    def build_dataset(self, img_path, mode="train", batch=None):
         """
         Build YOLO Dataset.
 
         Args:
             img_path (str): Path to the folder containing images.
             mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.
             batch (int, optional): Size of batches, this is for `rect`. Defaults to None.
         """
         gs = max(int(de_parallel(self.model).stride.max() if self.model else 0), 32)
-        return build_yolo_dataset(self.args, img_path, batch, self.data, mode=mode, rect=mode == 'val', stride=gs)
+        return build_yolo_dataset(self.args, img_path, batch, self.data, mode=mode, rect=mode == "val", stride=gs)
 
-    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode='train'):
+    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode="train"):
         """Construct and return dataloader."""
-        assert mode in ['train', 'val']
+        assert mode in {"train", "val"}, f"Mode must be 'train' or 'val', not {mode}."
         with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP
             dataset = self.build_dataset(dataset_path, mode, batch_size)
-        shuffle = mode == 'train'
-        if getattr(dataset, 'rect', False) and shuffle:
+        shuffle = mode == "train"
+        if getattr(dataset, "rect", False) and shuffle:
             LOGGER.warning("WARNING  'rect=True' is incompatible with DataLoader shuffle, setting shuffle=False")
             shuffle = False
-        workers = self.args.workers if mode == 'train' else self.args.workers * 2
+        workers = self.args.workers if mode == "train" else self.args.workers * 2
         return build_dataloader(dataset, batch_size, workers, shuffle, rank)  # return dataloader
 
     def preprocess_batch(self, batch):
         """Preprocesses a batch of images by scaling and converting to float."""
-        batch['img'] = batch['img'].to(self.device, non_blocking=True).float() / 255
+        batch["img"] = batch["img"].to(self.device, non_blocking=True).float() / 255
+        if self.args.multi_scale:
+            imgs = batch["img"]
+            sz = (
+                random.randrange(self.args.imgsz * 0.5, self.args.imgsz * 1.5 + self.stride)
+                // self.stride
+                * self.stride
+            )  # size
+            sf = sz / max(imgs.shape[2:])  # scale factor
+            if sf != 1:
+                ns = [
+                    math.ceil(x * sf / self.stride) * self.stride for x in imgs.shape[2:]
+                ]  # new shape (stretched to gs-multiple)
+                imgs = nn.functional.interpolate(imgs, size=ns, mode="bilinear", align_corners=False)
+            batch["img"] = imgs
         return batch
 
     def set_model_attributes(self):
         """Nl = de_parallel(self.model).model[-1].nl  # number of detection layers (to scale hyps)."""
         # self.args.box *= 3 / nl  # scale to layers
         # self.args.cls *= self.data["nc"] / 80 * 3 / nl  # scale to classes and layers
         # self.args.cls *= (self.args.imgsz / 640) ** 2 * 3 / nl  # scale to image size and layers
-        self.model.nc = self.data['nc']  # attach number of classes to model
-        self.model.names = self.data['names']  # attach class names to model
+        self.model.nc = self.data["nc"]  # attach number of classes to model
+        self.model.names = self.data["names"]  # attach class names to model
         self.model.args = self.args  # attach hyperparameters to model
         # TODO: self.model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc
 
     def get_model(self, cfg=None, weights=None, verbose=True):
         """Return a YOLO detection model."""
-        model = DetectionModel(cfg, nc=self.data['nc'], verbose=verbose and RANK == -1)
+        model = DetectionModel(cfg, nc=self.data["nc"], verbose=verbose and RANK == -1)
         if weights:
             model.load(weights)
         return model
 
     def get_validator(self):
         """Returns a DetectionValidator for YOLO model validation."""
-        self.loss_names = 'box_loss', 'cls_loss', 'dfl_loss'
-        return yolo.detect.DetectionValidator(self.test_loader, save_dir=self.save_dir, args=copy(self.args))
+        self.loss_names = "box_loss", "cls_loss", "dfl_loss"
+        return yolo.detect.DetectionValidator(
+            self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks
+        )
 
-    def label_loss_items(self, loss_items=None, prefix='train'):
+    def label_loss_items(self, loss_items=None, prefix="train"):
         """
         Returns a loss dict with labelled training loss items tensor.
 
         Not needed for classification but necessary for segmentation & detection
         """
-        keys = [f'{prefix}/{x}' for x in self.loss_names]
+        keys = [f"{prefix}/{x}" for x in self.loss_names]
         if loss_items is not None:
             loss_items = [round(float(x), 5) for x in loss_items]  # convert tensors to 5 decimal place floats
             return dict(zip(keys, loss_items))
         else:
             return keys
 
     def progress_string(self):
         """Returns a formatted string of training progress with epoch, GPU memory, loss, instances and size."""
-        return ('\n' + '%11s' *
-                (4 + len(self.loss_names))) % ('Epoch', 'GPU_mem', *self.loss_names, 'Instances', 'Size')
+        return ("\n" + "%11s" * (4 + len(self.loss_names))) % (
+            "Epoch",
+            "GPU_mem",
+            *self.loss_names,
+            "Instances",
+            "Size",
+        )
 
     def plot_training_samples(self, batch, ni):
         """Plots training samples with their annotations."""
-        plot_images(images=batch['img'],
-                    batch_idx=batch['batch_idx'],
-                    cls=batch['cls'].squeeze(-1),
-                    bboxes=batch['bboxes'],
-                    paths=batch['im_file'],
-                    fname=self.save_dir / f'train_batch{ni}.jpg',
-                    on_plot=self.on_plot)
+        plot_images(
+            images=batch["img"],
+            batch_idx=batch["batch_idx"],
+            cls=batch["cls"].squeeze(-1),
+            bboxes=batch["bboxes"],
+            paths=batch["im_file"],
+            fname=self.save_dir / f"train_batch{ni}.jpg",
+            on_plot=self.on_plot,
+        )
 
     def plot_metrics(self):
         """Plots metrics from a CSV file."""
         plot_results(file=self.csv, on_plot=self.on_plot)  # save results.png
 
     def plot_training_labels(self):
         """Create a labeled training plot of the YOLO model."""
-        boxes = np.concatenate([lb['bboxes'] for lb in self.train_loader.dataset.labels], 0)
-        cls = np.concatenate([lb['cls'] for lb in self.train_loader.dataset.labels], 0)
-        plot_labels(boxes, cls.squeeze(), names=self.data['names'], save_dir=self.save_dir, on_plot=self.on_plot)
+        boxes = np.concatenate([lb["bboxes"] for lb in self.train_loader.dataset.labels], 0)
+        cls = np.concatenate([lb["cls"] for lb in self.train_loader.dataset.labels], 0)
+        plot_labels(boxes, cls.squeeze(), names=self.data["names"], save_dir=self.save_dir, on_plot=self.on_plot)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/detect/val.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/pose/val.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,266 +1,248 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
-import os
 from pathlib import Path
 
 import numpy as np
 import torch
 
-from ultralytics.data import build_dataloader, build_yolo_dataset, converter
-from ultralytics.engine.validator import BaseValidator
+from ultralytics.models.yolo.detect import DetectionValidator
 from ultralytics.utils import LOGGER, ops
 from ultralytics.utils.checks import check_requirements
-from ultralytics.utils.metrics import ConfusionMatrix, DetMetrics, box_iou
+from ultralytics.utils.metrics import OKS_SIGMA, PoseMetrics, box_iou, kpt_iou
 from ultralytics.utils.plotting import output_to_target, plot_images
 
 
-class DetectionValidator(BaseValidator):
+class PoseValidator(DetectionValidator):
     """
-    A class extending the BaseValidator class for validation based on a detection model.
+    A class extending the DetectionValidator class for validation based on a pose model.
 
     Example:
         ```python
-        from ultralytics.models.yolo.detect import DetectionValidator
+        from ultralytics.models.yolo.pose import PoseValidator
 
-        args = dict(model='yolov8n.pt', data='coco8.yaml')
-        validator = DetectionValidator(args=args)
+        args = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml')
+        validator = PoseValidator(args=args)
         validator()
         ```
     """
 
     def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):
-        """Initialize detection model with necessary variables and settings."""
+        """Initialize a 'PoseValidator' object with custom parameters and assigned attributes."""
         super().__init__(dataloader, save_dir, pbar, args, _callbacks)
-        self.nt_per_class = None
-        self.is_coco = False
-        self.class_map = None
-        self.args.task = 'detect'
-        self.metrics = DetMetrics(save_dir=self.save_dir, on_plot=self.on_plot)
-        self.iouv = torch.linspace(0.5, 0.95, 10)  # iou vector for mAP@0.5:0.95
-        self.niou = self.iouv.numel()
-        self.lb = []  # for autolabelling
+        self.sigma = None
+        self.kpt_shape = None
+        self.args.task = "pose"
+        self.metrics = PoseMetrics(save_dir=self.save_dir, on_plot=self.on_plot)
+        if isinstance(self.args.device, str) and self.args.device.lower() == "mps":
+            LOGGER.warning(
+                "WARNING  Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. "
+                "See https://github.com/ultralytics/ultralytics/issues/4031."
+            )
 
     def preprocess(self, batch):
-        """Preprocesses batch of images for YOLO training."""
-        batch['img'] = batch['img'].to(self.device, non_blocking=True)
-        batch['img'] = (batch['img'].half() if self.args.half else batch['img'].float()) / 255
-        for k in ['batch_idx', 'cls', 'bboxes']:
-            batch[k] = batch[k].to(self.device)
-
-        if self.args.save_hybrid:
-            height, width = batch['img'].shape[2:]
-            nb = len(batch['img'])
-            bboxes = batch['bboxes'] * torch.tensor((width, height, width, height), device=self.device)
-            self.lb = [
-                torch.cat([batch['cls'][batch['batch_idx'] == i], bboxes[batch['batch_idx'] == i]], dim=-1)
-                for i in range(nb)] if self.args.save_hybrid else []  # for autolabelling
-
+        """Preprocesses the batch by converting the 'keypoints' data into a float and moving it to the device."""
+        batch = super().preprocess(batch)
+        batch["keypoints"] = batch["keypoints"].to(self.device).float()
         return batch
 
-    def init_metrics(self, model):
-        """Initialize evaluation metrics for YOLO."""
-        val = self.data.get(self.args.split, '')  # validation path
-        self.is_coco = isinstance(val, str) and 'coco' in val and val.endswith(f'{os.sep}val2017.txt')  # is COCO
-        self.class_map = converter.coco80_to_coco91_class() if self.is_coco else list(range(1000))
-        self.args.save_json |= self.is_coco and not self.training  # run on final val if training COCO
-        self.names = model.names
-        self.nc = len(model.names)
-        self.metrics.names = self.names
-        self.metrics.plot = self.args.plots
-        self.confusion_matrix = ConfusionMatrix(nc=self.nc, conf=self.args.conf)
-        self.seen = 0
-        self.jdict = []
-        self.stats = []
-
     def get_desc(self):
-        """Return a formatted string summarizing class metrics of YOLO model."""
-        return ('%22s' + '%11s' * 6) % ('Class', 'Images', 'Instances', 'Box(P', 'R', 'mAP50', 'mAP50-95)')
+        """Returns description of evaluation metrics in string format."""
+        return ("%22s" + "%11s" * 10) % (
+            "Class",
+            "Images",
+            "Instances",
+            "Box(P",
+            "R",
+            "mAP50",
+            "mAP50-95)",
+            "Pose(P",
+            "R",
+            "mAP50",
+            "mAP50-95)",
+        )
 
     def postprocess(self, preds):
-        """Apply Non-maximum suppression to prediction outputs."""
-        return ops.non_max_suppression(preds,
-                                       self.args.conf,
-                                       self.args.iou,
-                                       labels=self.lb,
-                                       multi_label=True,
-                                       agnostic=self.args.single_cls,
-                                       max_det=self.args.max_det)
+        """Apply non-maximum suppression and return detections with high confidence scores."""
+        return ops.non_max_suppression(
+            preds,
+            self.args.conf,
+            self.args.iou,
+            labels=self.lb,
+            multi_label=True,
+            agnostic=self.args.single_cls,
+            max_det=self.args.max_det,
+            nc=self.nc,
+        )
+
+    def init_metrics(self, model):
+        """Initiate pose estimation metrics for YOLO model."""
+        super().init_metrics(model)
+        self.kpt_shape = self.data["kpt_shape"]
+        is_pose = self.kpt_shape == [17, 3]
+        nkpt = self.kpt_shape[0]
+        self.sigma = OKS_SIGMA if is_pose else np.ones(nkpt) / nkpt
+        self.stats = dict(tp_p=[], tp=[], conf=[], pred_cls=[], target_cls=[])
+
+    def _prepare_batch(self, si, batch):
+        """Prepares a batch for processing by converting keypoints to float and moving to device."""
+        pbatch = super()._prepare_batch(si, batch)
+        kpts = batch["keypoints"][batch["batch_idx"] == si]
+        h, w = pbatch["imgsz"]
+        kpts = kpts.clone()
+        kpts[..., 0] *= w
+        kpts[..., 1] *= h
+        kpts = ops.scale_coords(pbatch["imgsz"], kpts, pbatch["ori_shape"], ratio_pad=pbatch["ratio_pad"])
+        pbatch["kpts"] = kpts
+        return pbatch
+
+    def _prepare_pred(self, pred, pbatch):
+        """Prepares and scales keypoints in a batch for pose processing."""
+        predn = super()._prepare_pred(pred, pbatch)
+        nk = pbatch["kpts"].shape[1]
+        pred_kpts = predn[:, 6:].view(len(predn), nk, -1)
+        ops.scale_coords(pbatch["imgsz"], pred_kpts, pbatch["ori_shape"], ratio_pad=pbatch["ratio_pad"])
+        return predn, pred_kpts
 
     def update_metrics(self, preds, batch):
         """Metrics."""
         for si, pred in enumerate(preds):
-            idx = batch['batch_idx'] == si
-            cls = batch['cls'][idx]
-            bbox = batch['bboxes'][idx]
-            nl, npr = cls.shape[0], pred.shape[0]  # number of labels, predictions
-            shape = batch['ori_shape'][si]
-            correct_bboxes = torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device)  # init
             self.seen += 1
-
+            npr = len(pred)
+            stat = dict(
+                conf=torch.zeros(0, device=self.device),
+                pred_cls=torch.zeros(0, device=self.device),
+                tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),
+                tp_p=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),
+            )
+            pbatch = self._prepare_batch(si, batch)
+            cls, bbox = pbatch.pop("cls"), pbatch.pop("bbox")
+            nl = len(cls)
+            stat["target_cls"] = cls
             if npr == 0:
                 if nl:
-                    self.stats.append((correct_bboxes, *torch.zeros((2, 0), device=self.device), cls.squeeze(-1)))
+                    for k in self.stats.keys():
+                        self.stats[k].append(stat[k])
                     if self.args.plots:
-                        self.confusion_matrix.process_batch(detections=None, labels=cls.squeeze(-1))
+                        self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)
                 continue
 
             # Predictions
             if self.args.single_cls:
                 pred[:, 5] = 0
-            predn = pred.clone()
-            ops.scale_boxes(batch['img'][si].shape[1:], predn[:, :4], shape,
-                            ratio_pad=batch['ratio_pad'][si])  # native-space pred
+            predn, pred_kpts = self._prepare_pred(pred, pbatch)
+            stat["conf"] = predn[:, 4]
+            stat["pred_cls"] = predn[:, 5]
 
             # Evaluate
             if nl:
-                height, width = batch['img'].shape[2:]
-                tbox = ops.xywh2xyxy(bbox) * torch.tensor(
-                    (width, height, width, height), device=self.device)  # target boxes
-                ops.scale_boxes(batch['img'][si].shape[1:], tbox, shape,
-                                ratio_pad=batch['ratio_pad'][si])  # native-space labels
-                labelsn = torch.cat((cls, tbox), 1)  # native-space labels
-                correct_bboxes = self._process_batch(predn, labelsn)
-                # TODO: maybe remove these `self.` arguments as they already are member variable
+                stat["tp"] = self._process_batch(predn, bbox, cls)
+                stat["tp_p"] = self._process_batch(predn, bbox, cls, pred_kpts, pbatch["kpts"])
                 if self.args.plots:
-                    self.confusion_matrix.process_batch(predn, labelsn)
-            self.stats.append((correct_bboxes, pred[:, 4], pred[:, 5], cls.squeeze(-1)))  # (conf, pcls, tcls)
+                    self.confusion_matrix.process_batch(predn, bbox, cls)
+
+            for k in self.stats.keys():
+                self.stats[k].append(stat[k])
 
             # Save
             if self.args.save_json:
-                self.pred_to_json(predn, batch['im_file'][si])
-            if self.args.save_txt:
-                file = self.save_dir / 'labels' / f'{Path(batch["im_file"][si]).stem}.txt'
-                self.save_one_txt(predn, self.args.save_conf, shape, file)
-
-    def finalize_metrics(self, *args, **kwargs):
-        """Set final values for metrics speed and confusion matrix."""
-        self.metrics.speed = self.speed
-        self.metrics.confusion_matrix = self.confusion_matrix
-
-    def get_stats(self):
-        """Returns metrics statistics and results dictionary."""
-        stats = [torch.cat(x, 0).cpu().numpy() for x in zip(*self.stats)]  # to numpy
-        if len(stats) and stats[0].any():
-            self.metrics.process(*stats)
-        self.nt_per_class = np.bincount(stats[-1].astype(int), minlength=self.nc)  # number of targets per class
-        return self.metrics.results_dict
-
-    def print_results(self):
-        """Prints training/validation set metrics per class."""
-        pf = '%22s' + '%11i' * 2 + '%11.3g' * len(self.metrics.keys)  # print format
-        LOGGER.info(pf % ('all', self.seen, self.nt_per_class.sum(), *self.metrics.mean_results()))
-        if self.nt_per_class.sum() == 0:
-            LOGGER.warning(
-                f'WARNING  no labels found in {self.args.task} set, can not compute metrics without labels')
-
-        # Print results per class
-        if self.args.verbose and not self.training and self.nc > 1 and len(self.stats):
-            for i, c in enumerate(self.metrics.ap_class_index):
-                LOGGER.info(pf % (self.names[c], self.seen, self.nt_per_class[c], *self.metrics.class_result(i)))
-
-        if self.args.plots:
-            for normalize in True, False:
-                self.confusion_matrix.plot(save_dir=self.save_dir,
-                                           names=self.names.values(),
-                                           normalize=normalize,
-                                           on_plot=self.on_plot)
+                self.pred_to_json(predn, batch["im_file"][si])
+            # if self.args.save_txt:
+            #    save_one_txt(predn, save_conf, shape, file=save_dir / 'labels' / f'{path.stem}.txt')
 
-    def _process_batch(self, detections, labels):
+    def _process_batch(self, detections, gt_bboxes, gt_cls, pred_kpts=None, gt_kpts=None):
         """
         Return correct prediction matrix.
 
         Args:
             detections (torch.Tensor): Tensor of shape [N, 6] representing detections.
                 Each detection is of the format: x1, y1, x2, y2, conf, class.
             labels (torch.Tensor): Tensor of shape [M, 5] representing labels.
                 Each label is of the format: class, x1, y1, x2, y2.
+            pred_kpts (torch.Tensor, optional): Tensor of shape [N, 51] representing predicted keypoints.
+                51 corresponds to 17 keypoints each with 3 values.
+            gt_kpts (torch.Tensor, optional): Tensor of shape [N, 51] representing ground truth keypoints.
 
         Returns:
-            (torch.Tensor): Correct prediction matrix of shape [N, 10] for 10 IoU levels.
-        """
-        iou = box_iou(labels[:, 1:], detections[:, :4])
-        return self.match_predictions(detections[:, 5], labels[:, 0], iou)
-
-    def build_dataset(self, img_path, mode='val', batch=None):
-        """
-        Build YOLO Dataset.
-
-        Args:
-            img_path (str): Path to the folder containing images.
-            mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.
-            batch (int, optional): Size of batches, this is for `rect`. Defaults to None.
+            torch.Tensor: Correct prediction matrix of shape [N, 10] for 10 IoU levels.
         """
-        return build_yolo_dataset(self.args, img_path, batch, self.data, mode=mode, stride=self.stride)
+        if pred_kpts is not None and gt_kpts is not None:
+            # `0.53` is from https://github.com/jin-s13/xtcocoapi/blob/master/xtcocotools/cocoeval.py#L384
+            area = ops.xyxy2xywh(gt_bboxes)[:, 2:].prod(1) * 0.53
+            iou = kpt_iou(gt_kpts, pred_kpts, sigma=self.sigma, area=area)
+        else:  # boxes
+            iou = box_iou(gt_bboxes, detections[:, :4])
 
-    def get_dataloader(self, dataset_path, batch_size):
-        """Construct and return dataloader."""
-        dataset = self.build_dataset(dataset_path, batch=batch_size, mode='val')
-        return build_dataloader(dataset, batch_size, self.args.workers, shuffle=False, rank=-1)  # return dataloader
+        return self.match_predictions(detections[:, 5], gt_cls, iou)
 
     def plot_val_samples(self, batch, ni):
-        """Plot validation image samples."""
-        plot_images(batch['img'],
-                    batch['batch_idx'],
-                    batch['cls'].squeeze(-1),
-                    batch['bboxes'],
-                    paths=batch['im_file'],
-                    fname=self.save_dir / f'val_batch{ni}_labels.jpg',
-                    names=self.names,
-                    on_plot=self.on_plot)
+        """Plots and saves validation set samples with predicted bounding boxes and keypoints."""
+        plot_images(
+            batch["img"],
+            batch["batch_idx"],
+            batch["cls"].squeeze(-1),
+            batch["bboxes"],
+            kpts=batch["keypoints"],
+            paths=batch["im_file"],
+            fname=self.save_dir / f"val_batch{ni}_labels.jpg",
+            names=self.names,
+            on_plot=self.on_plot,
+        )
 
     def plot_predictions(self, batch, preds, ni):
-        """Plots predicted bounding boxes on input images and saves the result."""
-        plot_images(batch['img'],
-                    *output_to_target(preds, max_det=self.args.max_det),
-                    paths=batch['im_file'],
-                    fname=self.save_dir / f'val_batch{ni}_pred.jpg',
-                    names=self.names,
-                    on_plot=self.on_plot)  # pred
-
-    def save_one_txt(self, predn, save_conf, shape, file):
-        """Save YOLO detections to a txt file in normalized coordinates in a specific format."""
-        gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh
-        for *xyxy, conf, cls in predn.tolist():
-            xywh = (ops.xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh
-            line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format
-            with open(file, 'a') as f:
-                f.write(('%g ' * len(line)).rstrip() % line + '\n')
+        """Plots predictions for YOLO model."""
+        pred_kpts = torch.cat([p[:, 6:].view(-1, *self.kpt_shape) for p in preds], 0)
+        plot_images(
+            batch["img"],
+            *output_to_target(preds, max_det=self.args.max_det),
+            kpts=pred_kpts,
+            paths=batch["im_file"],
+            fname=self.save_dir / f"val_batch{ni}_pred.jpg",
+            names=self.names,
+            on_plot=self.on_plot,
+        )  # pred
 
     def pred_to_json(self, predn, filename):
-        """Serialize YOLO predictions to COCO json format."""
+        """Converts YOLO predictions to COCO JSON format."""
         stem = Path(filename).stem
         image_id = int(stem) if stem.isnumeric() else stem
         box = ops.xyxy2xywh(predn[:, :4])  # xywh
         box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner
         for p, b in zip(predn.tolist(), box.tolist()):
-            self.jdict.append({
-                'image_id': image_id,
-                'category_id': self.class_map[int(p[5])],
-                'bbox': [round(x, 3) for x in b],
-                'score': round(p[4], 5)})
+            self.jdict.append(
+                {
+                    "image_id": image_id,
+                    "category_id": self.class_map[int(p[5])],
+                    "bbox": [round(x, 3) for x in b],
+                    "keypoints": p[6:],
+                    "score": round(p[4], 5),
+                }
+            )
 
     def eval_json(self, stats):
-        """Evaluates YOLO output in JSON format and returns performance statistics."""
+        """Evaluates object detection model using COCO JSON format."""
         if self.args.save_json and self.is_coco and len(self.jdict):
-            anno_json = self.data['path'] / 'annotations/instances_val2017.json'  # annotations
-            pred_json = self.save_dir / 'predictions.json'  # predictions
-            LOGGER.info(f'\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...')
+            anno_json = self.data["path"] / "annotations/person_keypoints_val2017.json"  # annotations
+            pred_json = self.save_dir / "predictions.json"  # predictions
+            LOGGER.info(f"\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...")
             try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb
-                check_requirements('pycocotools>=2.0.6')
+                check_requirements("pycocotools>=2.0.6")
                 from pycocotools.coco import COCO  # noqa
                 from pycocotools.cocoeval import COCOeval  # noqa
 
                 for x in anno_json, pred_json:
-                    assert x.is_file(), f'{x} file not found'
+                    assert x.is_file(), f"{x} file not found"
                 anno = COCO(str(anno_json))  # init annotations api
                 pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)
-                eval = COCOeval(anno, pred, 'bbox')
-                if self.is_coco:
-                    eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # images to eval
-                eval.evaluate()
-                eval.accumulate()
-                eval.summarize()
-                stats[self.metrics.keys[-1]], stats[self.metrics.keys[-2]] = eval.stats[:2]  # update mAP50-95 and mAP50
+                for i, eval in enumerate([COCOeval(anno, pred, "bbox"), COCOeval(anno, pred, "keypoints")]):
+                    if self.is_coco:
+                        eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # im to eval
+                    eval.evaluate()
+                    eval.accumulate()
+                    eval.summarize()
+                    idx = i * 4 + 2
+                    stats[self.metrics.keys[idx + 1]], stats[self.metrics.keys[idx]] = eval.stats[
+                        :2
+                    ]  # update mAP50-95 and mAP50
             except Exception as e:
-                LOGGER.warning(f'pycocotools unable to run: {e}')
+                LOGGER.warning(f"pycocotools unable to run: {e}")
         return stats
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/pose/predict.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/segment/predict.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,53 +1,57 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 from ultralytics.engine.results import Results
 from ultralytics.models.yolo.detect.predict import DetectionPredictor
-from ultralytics.utils import DEFAULT_CFG, LOGGER, ops
+from ultralytics.utils import DEFAULT_CFG, ops
 
 
-class PosePredictor(DetectionPredictor):
+class SegmentationPredictor(DetectionPredictor):
     """
-    A class extending the DetectionPredictor class for prediction based on a pose model.
+    A class extending the DetectionPredictor class for prediction based on a segmentation model.
 
     Example:
         ```python
         from ultralytics.utils import ASSETS
-        from ultralytics.models.yolo.pose import PosePredictor
+        from ultralytics.models.yolo.segment import SegmentationPredictor
 
-        args = dict(model='yolov8n-pose.pt', source=ASSETS)
-        predictor = PosePredictor(overrides=args)
+        args = dict(model='yolov8n-seg.pt', source=ASSETS)
+        predictor = SegmentationPredictor(overrides=args)
         predictor.predict_cli()
         ```
     """
 
     def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):
-        """Initializes PosePredictor, sets task to 'pose' and logs a warning for using 'mps' as device."""
+        """Initializes the SegmentationPredictor with the provided configuration, overrides, and callbacks."""
         super().__init__(cfg, overrides, _callbacks)
-        self.args.task = 'pose'
-        if isinstance(self.args.device, str) and self.args.device.lower() == 'mps':
-            LOGGER.warning("WARNING  Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. "
-                           'See https://github.com/ultralytics/ultralytics/issues/4031.')
+        self.args.task = "segment"
 
     def postprocess(self, preds, img, orig_imgs):
-        """Return detection results for a given input image or list of images."""
-        preds = ops.non_max_suppression(preds,
-                                        self.args.conf,
-                                        self.args.iou,
-                                        agnostic=self.args.agnostic_nms,
-                                        max_det=self.args.max_det,
-                                        classes=self.args.classes,
-                                        nc=len(self.model.names))
+        """Applies non-max suppression and processes detections for each image in an input batch."""
+        p = ops.non_max_suppression(
+            preds[0],
+            self.args.conf,
+            self.args.iou,
+            agnostic=self.args.agnostic_nms,
+            max_det=self.args.max_det,
+            nc=len(self.model.names),
+            classes=self.args.classes,
+        )
 
         if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list
             orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)
 
         results = []
-        for i, pred in enumerate(preds):
+        proto = preds[1][-1] if isinstance(preds[1], tuple) else preds[1]  # tuple if PyTorch model or array if exported
+        for i, pred in enumerate(p):
             orig_img = orig_imgs[i]
-            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape).round()
-            pred_kpts = pred[:, 6:].view(len(pred), *self.model.kpt_shape) if len(pred) else pred[:, 6:]
-            pred_kpts = ops.scale_coords(img.shape[2:], pred_kpts, orig_img.shape)
             img_path = self.batch[0][i]
-            results.append(
-                Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], keypoints=pred_kpts))
+            if not len(pred):  # save empty boxes
+                masks = None
+            elif self.args.retina_masks:
+                pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)
+                masks = ops.process_mask_native(proto[i], pred[:, 6:], pred[:, :4], orig_img.shape[:2])  # HWC
+            else:
+                masks = ops.process_mask(proto[i], pred[:, 6:], pred[:, :4], img.shape[2:], upsample=True)  # HWC
+                pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)
+            results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], masks=masks))
         return results
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/pose/train.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/pose/train.py`

 * *Files 7% similar despite different names*

```diff
@@ -22,52 +22,58 @@
         ```
     """
 
     def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):
         """Initialize a PoseTrainer object with specified configurations and overrides."""
         if overrides is None:
             overrides = {}
-        overrides['task'] = 'pose'
+        overrides["task"] = "pose"
         super().__init__(cfg, overrides, _callbacks)
 
-        if isinstance(self.args.device, str) and self.args.device.lower() == 'mps':
-            LOGGER.warning("WARNING  Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. "
-                           'See https://github.com/ultralytics/ultralytics/issues/4031.')
+        if isinstance(self.args.device, str) and self.args.device.lower() == "mps":
+            LOGGER.warning(
+                "WARNING  Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. "
+                "See https://github.com/ultralytics/ultralytics/issues/4031."
+            )
 
     def get_model(self, cfg=None, weights=None, verbose=True):
         """Get pose estimation model with specified configuration and weights."""
-        model = PoseModel(cfg, ch=3, nc=self.data['nc'], data_kpt_shape=self.data['kpt_shape'], verbose=verbose)
+        model = PoseModel(cfg, ch=3, nc=self.data["nc"], data_kpt_shape=self.data["kpt_shape"], verbose=verbose)
         if weights:
             model.load(weights)
 
         return model
 
     def set_model_attributes(self):
         """Sets keypoints shape attribute of PoseModel."""
         super().set_model_attributes()
-        self.model.kpt_shape = self.data['kpt_shape']
+        self.model.kpt_shape = self.data["kpt_shape"]
 
     def get_validator(self):
         """Returns an instance of the PoseValidator class for validation."""
-        self.loss_names = 'box_loss', 'pose_loss', 'kobj_loss', 'cls_loss', 'dfl_loss'
-        return yolo.pose.PoseValidator(self.test_loader, save_dir=self.save_dir, args=copy(self.args))
+        self.loss_names = "box_loss", "pose_loss", "kobj_loss", "cls_loss", "dfl_loss"
+        return yolo.pose.PoseValidator(
+            self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks
+        )
 
     def plot_training_samples(self, batch, ni):
         """Plot a batch of training samples with annotated class labels, bounding boxes, and keypoints."""
-        images = batch['img']
-        kpts = batch['keypoints']
-        cls = batch['cls'].squeeze(-1)
-        bboxes = batch['bboxes']
-        paths = batch['im_file']
-        batch_idx = batch['batch_idx']
-        plot_images(images,
-                    batch_idx,
-                    cls,
-                    bboxes,
-                    kpts=kpts,
-                    paths=paths,
-                    fname=self.save_dir / f'train_batch{ni}.jpg',
-                    on_plot=self.on_plot)
+        images = batch["img"]
+        kpts = batch["keypoints"]
+        cls = batch["cls"].squeeze(-1)
+        bboxes = batch["bboxes"]
+        paths = batch["im_file"]
+        batch_idx = batch["batch_idx"]
+        plot_images(
+            images,
+            batch_idx,
+            cls,
+            bboxes,
+            kpts=kpts,
+            paths=paths,
+            fname=self.save_dir / f"train_batch{ni}.jpg",
+            on_plot=self.on_plot,
+        )
 
     def plot_metrics(self):
         """Plots training/val metrics."""
         plot_results(file=self.csv, pose=True, on_plot=self.on_plot)  # save results.png
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/pose/val.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/segment/val.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,215 +1,277 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
+from multiprocessing.pool import ThreadPool
 from pathlib import Path
 
 import numpy as np
 import torch
+import torch.nn.functional as F
 
 from ultralytics.models.yolo.detect import DetectionValidator
-from ultralytics.utils import LOGGER, ops
+from ultralytics.utils import LOGGER, NUM_THREADS, ops
 from ultralytics.utils.checks import check_requirements
-from ultralytics.utils.metrics import OKS_SIGMA, PoseMetrics, box_iou, kpt_iou
+from ultralytics.utils.metrics import SegmentMetrics, box_iou, mask_iou
 from ultralytics.utils.plotting import output_to_target, plot_images
 
 
-class PoseValidator(DetectionValidator):
+class SegmentationValidator(DetectionValidator):
     """
-    A class extending the DetectionValidator class for validation based on a pose model.
+    A class extending the DetectionValidator class for validation based on a segmentation model.
 
     Example:
         ```python
-        from ultralytics.models.yolo.pose import PoseValidator
+        from ultralytics.models.yolo.segment import SegmentationValidator
 
-        args = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml')
-        validator = PoseValidator(args=args)
+        args = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml')
+        validator = SegmentationValidator(args=args)
         validator()
         ```
     """
 
     def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):
-        """Initialize a 'PoseValidator' object with custom parameters and assigned attributes."""
+        """Initialize SegmentationValidator and set task to 'segment', metrics to SegmentMetrics."""
         super().__init__(dataloader, save_dir, pbar, args, _callbacks)
-        self.sigma = None
-        self.kpt_shape = None
-        self.args.task = 'pose'
-        self.metrics = PoseMetrics(save_dir=self.save_dir, on_plot=self.on_plot)
-        if isinstance(self.args.device, str) and self.args.device.lower() == 'mps':
-            LOGGER.warning("WARNING  Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. "
-                           'See https://github.com/ultralytics/ultralytics/issues/4031.')
+        self.plot_masks = None
+        self.process = None
+        self.args.task = "segment"
+        self.metrics = SegmentMetrics(save_dir=self.save_dir, on_plot=self.on_plot)
 
     def preprocess(self, batch):
-        """Preprocesses the batch by converting the 'keypoints' data into a float and moving it to the device."""
+        """Preprocesses batch by converting masks to float and sending to device."""
         batch = super().preprocess(batch)
-        batch['keypoints'] = batch['keypoints'].to(self.device).float()
+        batch["masks"] = batch["masks"].to(self.device).float()
         return batch
 
+    def init_metrics(self, model):
+        """Initialize metrics and select mask processing function based on save_json flag."""
+        super().init_metrics(model)
+        self.plot_masks = []
+        if self.args.save_json:
+            check_requirements("pycocotools>=2.0.6")
+            self.process = ops.process_mask_upsample  # more accurate
+        else:
+            self.process = ops.process_mask  # faster
+        self.stats = dict(tp_m=[], tp=[], conf=[], pred_cls=[], target_cls=[])
+
     def get_desc(self):
-        """Returns description of evaluation metrics in string format."""
-        return ('%22s' + '%11s' * 10) % ('Class', 'Images', 'Instances', 'Box(P', 'R', 'mAP50', 'mAP50-95)', 'Pose(P',
-                                         'R', 'mAP50', 'mAP50-95)')
+        """Return a formatted description of evaluation metrics."""
+        return ("%22s" + "%11s" * 10) % (
+            "Class",
+            "Images",
+            "Instances",
+            "Box(P",
+            "R",
+            "mAP50",
+            "mAP50-95)",
+            "Mask(P",
+            "R",
+            "mAP50",
+            "mAP50-95)",
+        )
 
     def postprocess(self, preds):
-        """Apply non-maximum suppression and return detections with high confidence scores."""
-        return ops.non_max_suppression(preds,
-                                       self.args.conf,
-                                       self.args.iou,
-                                       labels=self.lb,
-                                       multi_label=True,
-                                       agnostic=self.args.single_cls,
-                                       max_det=self.args.max_det,
-                                       nc=self.nc)
-
-    def init_metrics(self, model):
-        """Initiate pose estimation metrics for YOLO model."""
-        super().init_metrics(model)
-        self.kpt_shape = self.data['kpt_shape']
-        is_pose = self.kpt_shape == [17, 3]
-        nkpt = self.kpt_shape[0]
-        self.sigma = OKS_SIGMA if is_pose else np.ones(nkpt) / nkpt
+        """Post-processes YOLO predictions and returns output detections with proto."""
+        p = ops.non_max_suppression(
+            preds[0],
+            self.args.conf,
+            self.args.iou,
+            labels=self.lb,
+            multi_label=True,
+            agnostic=self.args.single_cls,
+            max_det=self.args.max_det,
+            nc=self.nc,
+        )
+        proto = preds[1][-1] if len(preds[1]) == 3 else preds[1]  # second output is len 3 if pt, but only 1 if exported
+        return p, proto
+
+    def _prepare_batch(self, si, batch):
+        """Prepares a batch for training or inference by processing images and targets."""
+        prepared_batch = super()._prepare_batch(si, batch)
+        midx = [si] if self.args.overlap_mask else batch["batch_idx"] == si
+        prepared_batch["masks"] = batch["masks"][midx]
+        return prepared_batch
+
+    def _prepare_pred(self, pred, pbatch, proto):
+        """Prepares a batch for training or inference by processing images and targets."""
+        predn = super()._prepare_pred(pred, pbatch)
+        pred_masks = self.process(proto, pred[:, 6:], pred[:, :4], shape=pbatch["imgsz"])
+        return predn, pred_masks
 
     def update_metrics(self, preds, batch):
         """Metrics."""
-        for si, pred in enumerate(preds):
-            idx = batch['batch_idx'] == si
-            cls = batch['cls'][idx]
-            bbox = batch['bboxes'][idx]
-            kpts = batch['keypoints'][idx]
-            nl, npr = cls.shape[0], pred.shape[0]  # number of labels, predictions
-            nk = kpts.shape[1]  # number of keypoints
-            shape = batch['ori_shape'][si]
-            correct_kpts = torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device)  # init
-            correct_bboxes = torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device)  # init
+        for si, (pred, proto) in enumerate(zip(preds[0], preds[1])):
             self.seen += 1
-
+            npr = len(pred)
+            stat = dict(
+                conf=torch.zeros(0, device=self.device),
+                pred_cls=torch.zeros(0, device=self.device),
+                tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),
+                tp_m=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),
+            )
+            pbatch = self._prepare_batch(si, batch)
+            cls, bbox = pbatch.pop("cls"), pbatch.pop("bbox")
+            nl = len(cls)
+            stat["target_cls"] = cls
             if npr == 0:
                 if nl:
-                    self.stats.append((correct_bboxes, correct_kpts, *torch.zeros(
-                        (2, 0), device=self.device), cls.squeeze(-1)))
+                    for k in self.stats.keys():
+                        self.stats[k].append(stat[k])
                     if self.args.plots:
-                        self.confusion_matrix.process_batch(detections=None, labels=cls.squeeze(-1))
+                        self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)
                 continue
 
+            # Masks
+            gt_masks = pbatch.pop("masks")
             # Predictions
             if self.args.single_cls:
                 pred[:, 5] = 0
-            predn = pred.clone()
-            ops.scale_boxes(batch['img'][si].shape[1:], predn[:, :4], shape,
-                            ratio_pad=batch['ratio_pad'][si])  # native-space pred
-            pred_kpts = predn[:, 6:].view(npr, nk, -1)
-            ops.scale_coords(batch['img'][si].shape[1:], pred_kpts, shape, ratio_pad=batch['ratio_pad'][si])
+            predn, pred_masks = self._prepare_pred(pred, pbatch, proto)
+            stat["conf"] = predn[:, 4]
+            stat["pred_cls"] = predn[:, 5]
 
             # Evaluate
             if nl:
-                height, width = batch['img'].shape[2:]
-                tbox = ops.xywh2xyxy(bbox) * torch.tensor(
-                    (width, height, width, height), device=self.device)  # target boxes
-                ops.scale_boxes(batch['img'][si].shape[1:], tbox, shape,
-                                ratio_pad=batch['ratio_pad'][si])  # native-space labels
-                tkpts = kpts.clone()
-                tkpts[..., 0] *= width
-                tkpts[..., 1] *= height
-                tkpts = ops.scale_coords(batch['img'][si].shape[1:], tkpts, shape, ratio_pad=batch['ratio_pad'][si])
-                labelsn = torch.cat((cls, tbox), 1)  # native-space labels
-                correct_bboxes = self._process_batch(predn[:, :6], labelsn)
-                correct_kpts = self._process_batch(predn[:, :6], labelsn, pred_kpts, tkpts)
+                stat["tp"] = self._process_batch(predn, bbox, cls)
+                stat["tp_m"] = self._process_batch(
+                    predn, bbox, cls, pred_masks, gt_masks, self.args.overlap_mask, masks=True
+                )
                 if self.args.plots:
-                    self.confusion_matrix.process_batch(predn, labelsn)
+                    self.confusion_matrix.process_batch(predn, bbox, cls)
 
-            # Append correct_masks, correct_boxes, pconf, pcls, tcls
-            self.stats.append((correct_bboxes, correct_kpts, pred[:, 4], pred[:, 5], cls.squeeze(-1)))
+            for k in self.stats.keys():
+                self.stats[k].append(stat[k])
+
+            pred_masks = torch.as_tensor(pred_masks, dtype=torch.uint8)
+            if self.args.plots and self.batch_i < 3:
+                self.plot_masks.append(pred_masks[:15].cpu())  # filter top 15 to plot
 
             # Save
             if self.args.save_json:
-                self.pred_to_json(predn, batch['im_file'][si])
+                pred_masks = ops.scale_image(
+                    pred_masks.permute(1, 2, 0).contiguous().cpu().numpy(),
+                    pbatch["ori_shape"],
+                    ratio_pad=batch["ratio_pad"][si],
+                )
+                self.pred_to_json(predn, batch["im_file"][si], pred_masks)
             # if self.args.save_txt:
             #    save_one_txt(predn, save_conf, shape, file=save_dir / 'labels' / f'{path.stem}.txt')
 
-    def _process_batch(self, detections, labels, pred_kpts=None, gt_kpts=None):
+    def finalize_metrics(self, *args, **kwargs):
+        """Sets speed and confusion matrix for evaluation metrics."""
+        self.metrics.speed = self.speed
+        self.metrics.confusion_matrix = self.confusion_matrix
+
+    def _process_batch(self, detections, gt_bboxes, gt_cls, pred_masks=None, gt_masks=None, overlap=False, masks=False):
         """
         Return correct prediction matrix.
 
         Args:
-            detections (torch.Tensor): Tensor of shape [N, 6] representing detections.
-                Each detection is of the format: x1, y1, x2, y2, conf, class.
-            labels (torch.Tensor): Tensor of shape [M, 5] representing labels.
-                Each label is of the format: class, x1, y1, x2, y2.
-            pred_kpts (torch.Tensor, optional): Tensor of shape [N, 51] representing predicted keypoints.
-                51 corresponds to 17 keypoints each with 3 values.
-            gt_kpts (torch.Tensor, optional): Tensor of shape [N, 51] representing ground truth keypoints.
+            detections (array[N, 6]), x1, y1, x2, y2, conf, class
+            labels (array[M, 5]), class, x1, y1, x2, y2
 
         Returns:
-            torch.Tensor: Correct prediction matrix of shape [N, 10] for 10 IoU levels.
+            correct (array[N, 10]), for 10 IoU levels
         """
-        if pred_kpts is not None and gt_kpts is not None:
-            # `0.53` is from https://github.com/jin-s13/xtcocoapi/blob/master/xtcocotools/cocoeval.py#L384
-            area = ops.xyxy2xywh(labels[:, 1:])[:, 2:].prod(1) * 0.53
-            iou = kpt_iou(gt_kpts, pred_kpts, sigma=self.sigma, area=area)
+        if masks:
+            if overlap:
+                nl = len(gt_cls)
+                index = torch.arange(nl, device=gt_masks.device).view(nl, 1, 1) + 1
+                gt_masks = gt_masks.repeat(nl, 1, 1)  # shape(1,640,640) -> (n,640,640)
+                gt_masks = torch.where(gt_masks == index, 1.0, 0.0)
+            if gt_masks.shape[1:] != pred_masks.shape[1:]:
+                gt_masks = F.interpolate(gt_masks[None], pred_masks.shape[1:], mode="bilinear", align_corners=False)[0]
+                gt_masks = gt_masks.gt_(0.5)
+            iou = mask_iou(gt_masks.view(gt_masks.shape[0], -1), pred_masks.view(pred_masks.shape[0], -1))
         else:  # boxes
-            iou = box_iou(labels[:, 1:], detections[:, :4])
+            iou = box_iou(gt_bboxes, detections[:, :4])
 
-        return self.match_predictions(detections[:, 5], labels[:, 0], iou)
+        return self.match_predictions(detections[:, 5], gt_cls, iou)
 
     def plot_val_samples(self, batch, ni):
-        """Plots and saves validation set samples with predicted bounding boxes and keypoints."""
-        plot_images(batch['img'],
-                    batch['batch_idx'],
-                    batch['cls'].squeeze(-1),
-                    batch['bboxes'],
-                    kpts=batch['keypoints'],
-                    paths=batch['im_file'],
-                    fname=self.save_dir / f'val_batch{ni}_labels.jpg',
-                    names=self.names,
-                    on_plot=self.on_plot)
+        """Plots validation samples with bounding box labels."""
+        plot_images(
+            batch["img"],
+            batch["batch_idx"],
+            batch["cls"].squeeze(-1),
+            batch["bboxes"],
+            masks=batch["masks"],
+            paths=batch["im_file"],
+            fname=self.save_dir / f"val_batch{ni}_labels.jpg",
+            names=self.names,
+            on_plot=self.on_plot,
+        )
 
     def plot_predictions(self, batch, preds, ni):
-        """Plots predictions for YOLO model."""
-        pred_kpts = torch.cat([p[:, 6:].view(-1, *self.kpt_shape) for p in preds], 0)
-        plot_images(batch['img'],
-                    *output_to_target(preds, max_det=self.args.max_det),
-                    kpts=pred_kpts,
-                    paths=batch['im_file'],
-                    fname=self.save_dir / f'val_batch{ni}_pred.jpg',
-                    names=self.names,
-                    on_plot=self.on_plot)  # pred
+        """Plots batch predictions with masks and bounding boxes."""
+        plot_images(
+            batch["img"],
+            *output_to_target(preds[0], max_det=15),  # not set to self.args.max_det due to slow plotting speed
+            torch.cat(self.plot_masks, dim=0) if len(self.plot_masks) else self.plot_masks,
+            paths=batch["im_file"],
+            fname=self.save_dir / f"val_batch{ni}_pred.jpg",
+            names=self.names,
+            on_plot=self.on_plot,
+        )  # pred
+        self.plot_masks.clear()
+
+    def pred_to_json(self, predn, filename, pred_masks):
+        """
+        Save one JSON result.
+
+        Examples:
+             >>> result = {"image_id": 42, "category_id": 18, "bbox": [258.15, 41.29, 348.26, 243.78], "score": 0.236}
+        """
+        from pycocotools.mask import encode  # noqa
+
+        def single_encode(x):
+            """Encode predicted masks as RLE and append results to jdict."""
+            rle = encode(np.asarray(x[:, :, None], order="F", dtype="uint8"))[0]
+            rle["counts"] = rle["counts"].decode("utf-8")
+            return rle
 
-    def pred_to_json(self, predn, filename):
-        """Converts YOLO predictions to COCO JSON format."""
         stem = Path(filename).stem
         image_id = int(stem) if stem.isnumeric() else stem
         box = ops.xyxy2xywh(predn[:, :4])  # xywh
         box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner
-        for p, b in zip(predn.tolist(), box.tolist()):
-            self.jdict.append({
-                'image_id': image_id,
-                'category_id': self.class_map[int(p[5])],
-                'bbox': [round(x, 3) for x in b],
-                'keypoints': p[6:],
-                'score': round(p[4], 5)})
+        pred_masks = np.transpose(pred_masks, (2, 0, 1))
+        with ThreadPool(NUM_THREADS) as pool:
+            rles = pool.map(single_encode, pred_masks)
+        for i, (p, b) in enumerate(zip(predn.tolist(), box.tolist())):
+            self.jdict.append(
+                {
+                    "image_id": image_id,
+                    "category_id": self.class_map[int(p[5])],
+                    "bbox": [round(x, 3) for x in b],
+                    "score": round(p[4], 5),
+                    "segmentation": rles[i],
+                }
+            )
 
     def eval_json(self, stats):
-        """Evaluates object detection model using COCO JSON format."""
+        """Return COCO-style object detection evaluation metrics."""
         if self.args.save_json and self.is_coco and len(self.jdict):
-            anno_json = self.data['path'] / 'annotations/person_keypoints_val2017.json'  # annotations
-            pred_json = self.save_dir / 'predictions.json'  # predictions
-            LOGGER.info(f'\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...')
+            anno_json = self.data["path"] / "annotations/instances_val2017.json"  # annotations
+            pred_json = self.save_dir / "predictions.json"  # predictions
+            LOGGER.info(f"\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...")
             try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb
-                check_requirements('pycocotools>=2.0.6')
+                check_requirements("pycocotools>=2.0.6")
                 from pycocotools.coco import COCO  # noqa
                 from pycocotools.cocoeval import COCOeval  # noqa
 
                 for x in anno_json, pred_json:
-                    assert x.is_file(), f'{x} file not found'
+                    assert x.is_file(), f"{x} file not found"
                 anno = COCO(str(anno_json))  # init annotations api
                 pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)
-                for i, eval in enumerate([COCOeval(anno, pred, 'bbox'), COCOeval(anno, pred, 'keypoints')]):
+                for i, eval in enumerate([COCOeval(anno, pred, "bbox"), COCOeval(anno, pred, "segm")]):
                     if self.is_coco:
                         eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # im to eval
                     eval.evaluate()
                     eval.accumulate()
                     eval.summarize()
                     idx = i * 4 + 2
-                    stats[self.metrics.keys[idx + 1]], stats[
-                        self.metrics.keys[idx]] = eval.stats[:2]  # update mAP50-95 and mAP50
+                    stats[self.metrics.keys[idx + 1]], stats[self.metrics.keys[idx]] = eval.stats[
+                        :2
+                    ]  # update mAP50-95 and mAP50
             except Exception as e:
-                LOGGER.warning(f'pycocotools unable to run: {e}')
+                LOGGER.warning(f"pycocotools unable to run: {e}")
         return stats
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/segment/predict.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/classify/predict.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,55 +1,61 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
+import cv2
+import torch
+from PIL import Image
+
+from ultralytics.engine.predictor import BasePredictor
 from ultralytics.engine.results import Results
-from ultralytics.models.yolo.detect.predict import DetectionPredictor
 from ultralytics.utils import DEFAULT_CFG, ops
 
 
-class SegmentationPredictor(DetectionPredictor):
+class ClassificationPredictor(BasePredictor):
     """
-    A class extending the DetectionPredictor class for prediction based on a segmentation model.
+    A class extending the BasePredictor class for prediction based on a classification model.
+
+    Notes:
+        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.
 
     Example:
         ```python
         from ultralytics.utils import ASSETS
-        from ultralytics.models.yolo.segment import SegmentationPredictor
+        from ultralytics.models.yolo.classify import ClassificationPredictor
 
-        args = dict(model='yolov8n-seg.pt', source=ASSETS)
-        predictor = SegmentationPredictor(overrides=args)
+        args = dict(model='yolov8n-cls.pt', source=ASSETS)
+        predictor = ClassificationPredictor(overrides=args)
         predictor.predict_cli()
         ```
     """
 
     def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):
-        """Initializes the SegmentationPredictor with the provided configuration, overrides, and callbacks."""
+        """Initializes ClassificationPredictor setting the task to 'classify'."""
         super().__init__(cfg, overrides, _callbacks)
-        self.args.task = 'segment'
+        self.args.task = "classify"
+        self._legacy_transform_name = "ultralytics.yolo.data.augment.ToTensor"
 
-    def postprocess(self, preds, img, orig_imgs):
-        """Applies non-max suppression and processes detections for each image in an input batch."""
-        p = ops.non_max_suppression(preds[0],
-                                    self.args.conf,
-                                    self.args.iou,
-                                    agnostic=self.args.agnostic_nms,
-                                    max_det=self.args.max_det,
-                                    nc=len(self.model.names),
-                                    classes=self.args.classes)
+    def preprocess(self, img):
+        """Converts input image to model-compatible data type."""
+        if not isinstance(img, torch.Tensor):
+            is_legacy_transform = any(
+                self._legacy_transform_name in str(transform) for transform in self.transforms.transforms
+            )
+            if is_legacy_transform:  # to handle legacy transforms
+                img = torch.stack([self.transforms(im) for im in img], dim=0)
+            else:
+                img = torch.stack(
+                    [self.transforms(Image.fromarray(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))) for im in img], dim=0
+                )
+        img = (img if isinstance(img, torch.Tensor) else torch.from_numpy(img)).to(self.model.device)
+        return img.half() if self.model.fp16 else img.float()  # uint8 to fp16/32
 
+    def postprocess(self, preds, img, orig_imgs):
+        """Post-processes predictions to return Results objects."""
         if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list
             orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)
 
         results = []
-        proto = preds[1][-1] if len(preds[1]) == 3 else preds[1]  # second output is len 3 if pt, but only 1 if exported
-        for i, pred in enumerate(p):
+        for i, pred in enumerate(preds):
             orig_img = orig_imgs[i]
             img_path = self.batch[0][i]
-            if not len(pred):  # save empty boxes
-                masks = None
-            elif self.args.retina_masks:
-                pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)
-                masks = ops.process_mask_native(proto[i], pred[:, 6:], pred[:, :4], orig_img.shape[:2])  # HWC
-            else:
-                masks = ops.process_mask(proto[i], pred[:, 6:], pred[:, :4], img.shape[2:], upsample=True)  # HWC
-                pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)
-            results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], masks=masks))
+            results.append(Results(orig_img, path=img_path, names=self.model.names, probs=pred))
         return results
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/models/yolo/segment/train.py` & `yolov8_pose_triton-8.2.0/ultralytics/models/yolo/segment/train.py`

 * *Files 10% similar despite different names*

```diff
@@ -22,37 +22,41 @@
         ```
     """
 
     def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):
         """Initialize a SegmentationTrainer object with given arguments."""
         if overrides is None:
             overrides = {}
-        overrides['task'] = 'segment'
+        overrides["task"] = "segment"
         super().__init__(cfg, overrides, _callbacks)
 
     def get_model(self, cfg=None, weights=None, verbose=True):
         """Return SegmentationModel initialized with specified config and weights."""
-        model = SegmentationModel(cfg, ch=3, nc=self.data['nc'], verbose=verbose and RANK == -1)
+        model = SegmentationModel(cfg, ch=3, nc=self.data["nc"], verbose=verbose and RANK == -1)
         if weights:
             model.load(weights)
 
         return model
 
     def get_validator(self):
         """Return an instance of SegmentationValidator for validation of YOLO model."""
-        self.loss_names = 'box_loss', 'seg_loss', 'cls_loss', 'dfl_loss'
-        return yolo.segment.SegmentationValidator(self.test_loader, save_dir=self.save_dir, args=copy(self.args))
+        self.loss_names = "box_loss", "seg_loss", "cls_loss", "dfl_loss"
+        return yolo.segment.SegmentationValidator(
+            self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks
+        )
 
     def plot_training_samples(self, batch, ni):
         """Creates a plot of training sample images with labels and box coordinates."""
-        plot_images(batch['img'],
-                    batch['batch_idx'],
-                    batch['cls'].squeeze(-1),
-                    batch['bboxes'],
-                    batch['masks'],
-                    paths=batch['im_file'],
-                    fname=self.save_dir / f'train_batch{ni}.jpg',
-                    on_plot=self.on_plot)
+        plot_images(
+            batch["img"],
+            batch["batch_idx"],
+            batch["cls"].squeeze(-1),
+            batch["bboxes"],
+            masks=batch["masks"],
+            paths=batch["im_file"],
+            fname=self.save_dir / f"train_batch{ni}.jpg",
+            on_plot=self.on_plot,
+        )
 
     def plot_metrics(self):
         """Plots training/val metrics."""
         plot_results(file=self.csv, segment=True, on_plot=self.on_plot)  # save results.png
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/nn/autobackend.py` & `yolov8_pose_triton-8.2.0/ultralytics/nn/autobackend.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 
 import cv2
 import numpy as np
 import torch
 import torch.nn as nn
 from PIL import Image
 
-from ultralytics.utils import ARM64, LINUX, LOGGER, ROOT, yaml_load
+from ultralytics.utils import ARM64, IS_JETSON, IS_RASPBERRYPI, LINUX, LOGGER, ROOT, yaml_load
 from ultralytics.utils.checks import check_requirements, check_suffix, check_version, check_yaml
 from ultralytics.utils.downloads import attempt_download_asset, is_url
 
 
 def check_class_names(names):
     """
     Check class names.
@@ -28,22 +28,32 @@
     if isinstance(names, list):  # names is a list
         names = dict(enumerate(names))  # convert to dict
     if isinstance(names, dict):
         # Convert 1) string keys to int, i.e. '0' to 0, and non-string values to strings, i.e. True to 'True'
         names = {int(k): str(v) for k, v in names.items()}
         n = len(names)
         if max(names.keys()) >= n:
-            raise KeyError(f'{n}-class dataset requires class indices 0-{n - 1}, but you have invalid class indices '
-                           f'{min(names.keys())}-{max(names.keys())} defined in your dataset YAML.')
-        if isinstance(names[0], str) and names[0].startswith('n0'):  # imagenet class codes, i.e. 'n01440764'
-            names_map = yaml_load(ROOT / 'cfg/datasets/ImageNet.yaml')['map']  # human-readable names
+            raise KeyError(
+                f"{n}-class dataset requires class indices 0-{n - 1}, but you have invalid class indices "
+                f"{min(names.keys())}-{max(names.keys())} defined in your dataset YAML."
+            )
+        if isinstance(names[0], str) and names[0].startswith("n0"):  # imagenet class codes, i.e. 'n01440764'
+            names_map = yaml_load(ROOT / "cfg/datasets/ImageNet.yaml")["map"]  # human-readable names
             names = {k: names_map[v] for k, v in names.items()}
     return names
 
 
+def default_class_names(data=None):
+    """Applies default class names to an input YAML file or returns numerical class names."""
+    if data:
+        with contextlib.suppress(Exception):
+            return yaml_load(check_yaml(data))["names"]
+    return {i: f"class{i}" for i in range(999)}  # return default if above errors
+
+
 class AutoBackend(nn.Module):
     """
     Handles dynamic backend selection for running inference using Ultralytics YOLO models.
 
     The AutoBackend class is designed to provide an abstraction layer for various inference engines. It supports a wide
     range of formats, each with specific naming conventions as outlined below:
 
@@ -58,388 +68,525 @@
             | CoreML                | *.mlpackage      |
             | TensorRT              | *.engine         |
             | TensorFlow SavedModel | *_saved_model    |
             | TensorFlow GraphDef   | *.pb             |
             | TensorFlow Lite       | *.tflite         |
             | TensorFlow Edge TPU   | *_edgetpu.tflite |
             | PaddlePaddle          | *_paddle_model   |
-            | ncnn                  | *_ncnn_model     |
+            | NCNN                  | *_ncnn_model     |
 
     This class offers dynamic backend switching capabilities based on the input model format, making it easier to deploy
     models across various platforms.
     """
 
     @torch.no_grad()
-    def __init__(self,
-                 weights='yolov8n.pt',
-                 device=torch.device('cpu'),
-                 dnn=False,
-                 data=None,
-                 fp16=False,
-                 fuse=True,
-                 verbose=True):
+    def __init__(
+        self,
+        weights="yolov8n.pt",
+        device=torch.device("cpu"),
+        dnn=False,
+        data=None,
+        fp16=False,
+        batch=1,
+        fuse=True,
+        verbose=True,
+    ):
         """
         Initialize the AutoBackend for inference.
 
         Args:
             weights (str): Path to the model weights file. Defaults to 'yolov8n.pt'.
             device (torch.device): Device to run the model on. Defaults to CPU.
             dnn (bool): Use OpenCV DNN module for ONNX inference. Defaults to False.
             data (str | Path | optional): Path to the additional data.yaml file containing class names. Optional.
             fp16 (bool): Enable half-precision inference. Supported only on specific backends. Defaults to False.
+            batch (int): Batch-size to assume for inference.
             fuse (bool): Fuse Conv2D + BatchNorm layers for optimization. Defaults to True.
             verbose (bool): Enable verbose logging. Defaults to True.
         """
         super().__init__()
         w = str(weights[0] if isinstance(weights, list) else weights)
         nn_module = isinstance(weights, torch.nn.Module)
-        pt, jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle, ncnn, triton = \
-            self._model_type(w)
+        (
+            pt,
+            jit,
+            onnx,
+            xml,
+            engine,
+            coreml,
+            saved_model,
+            pb,
+            tflite,
+            edgetpu,
+            tfjs,
+            paddle,
+            ncnn,
+            triton,
+        ) = self._model_type(w)
         fp16 &= pt or jit or onnx or xml or engine or nn_module or triton  # FP16
         nhwc = coreml or saved_model or pb or tflite or edgetpu  # BHWC formats (vs torch BCWH)
         stride = 32  # default stride
         model, metadata = None, None
 
         # Set device
-        cuda = torch.cuda.is_available() and device.type != 'cpu'  # use CUDA
-        if cuda and not any([nn_module, pt, jit, engine]):  # GPU dataloader formats
-            device = torch.device('cpu')
+        cuda = torch.cuda.is_available() and device.type != "cpu"  # use CUDA
+        if cuda and not any([nn_module, pt, jit, engine, onnx]):  # GPU dataloader formats
+            device = torch.device("cpu")
             cuda = False
 
         # Download if not local
         if not (pt or triton or nn_module):
             w = attempt_download_asset(w)
 
-        # Load model
-        if nn_module:  # in-memory PyTorch model
+        # In-memory PyTorch model
+        if nn_module:
             model = weights.to(device)
-            model = model.fuse(verbose=verbose) if fuse else model
-            if hasattr(model, 'kpt_shape'):
+            if fuse:
+                model = model.fuse(verbose=verbose)
+            if hasattr(model, "kpt_shape"):
                 kpt_shape = model.kpt_shape  # pose-only
             stride = max(int(model.stride.max()), 32)  # model stride
-            names = model.module.names if hasattr(model, 'module') else model.names  # get class names
+            names = model.module.names if hasattr(model, "module") else model.names  # get class names
             model.half() if fp16 else model.float()
             self.model = model  # explicitly assign for to(), cpu(), cuda(), half()
             pt = True
-        elif pt:  # PyTorch
+
+        # PyTorch
+        elif pt:
             from ultralytics.nn.tasks import attempt_load_weights
-            model = attempt_load_weights(weights if isinstance(weights, list) else w,
-                                         device=device,
-                                         inplace=True,
-                                         fuse=fuse)
-            if hasattr(model, 'kpt_shape'):
+
+            model = attempt_load_weights(
+                weights if isinstance(weights, list) else w, device=device, inplace=True, fuse=fuse
+            )
+            if hasattr(model, "kpt_shape"):
                 kpt_shape = model.kpt_shape  # pose-only
             stride = max(int(model.stride.max()), 32)  # model stride
-            names = model.module.names if hasattr(model, 'module') else model.names  # get class names
+            names = model.module.names if hasattr(model, "module") else model.names  # get class names
             model.half() if fp16 else model.float()
             self.model = model  # explicitly assign for to(), cpu(), cuda(), half()
-        elif jit:  # TorchScript
-            LOGGER.info(f'Loading {w} for TorchScript inference...')
-            extra_files = {'config.txt': ''}  # model metadata
+
+        # TorchScript
+        elif jit:
+            LOGGER.info(f"Loading {w} for TorchScript inference...")
+            extra_files = {"config.txt": ""}  # model metadata
             model = torch.jit.load(w, _extra_files=extra_files, map_location=device)
             model.half() if fp16 else model.float()
-            if extra_files['config.txt']:  # load metadata dict
-                metadata = json.loads(extra_files['config.txt'], object_hook=lambda x: dict(x.items()))
-        elif dnn:  # ONNX OpenCV DNN
-            LOGGER.info(f'Loading {w} for ONNX OpenCV DNN inference...')
-            check_requirements('opencv-python>=4.5.4')
+            if extra_files["config.txt"]:  # load metadata dict
+                metadata = json.loads(extra_files["config.txt"], object_hook=lambda x: dict(x.items()))
+
+        # ONNX OpenCV DNN
+        elif dnn:
+            LOGGER.info(f"Loading {w} for ONNX OpenCV DNN inference...")
+            check_requirements("opencv-python>=4.5.4")
             net = cv2.dnn.readNetFromONNX(w)
-        elif onnx:  # ONNX Runtime
-            LOGGER.info(f'Loading {w} for ONNX Runtime inference...')
-            check_requirements(('onnx', 'onnxruntime-gpu' if cuda else 'onnxruntime'))
+
+        # ONNX Runtime
+        elif onnx:
+            LOGGER.info(f"Loading {w} for ONNX Runtime inference...")
+            check_requirements(("onnx", "onnxruntime-gpu" if cuda else "onnxruntime"))
+            if IS_RASPBERRYPI or IS_JETSON:
+                # Fix error: module 'numpy.linalg._umath_linalg' has no attribute '_ilp64' when exporting to Tensorflow SavedModel on RPi and Jetson
+                check_requirements("numpy==1.23.5")
             import onnxruntime
-            providers = ['CUDAExecutionProvider', 'CPUExecutionProvider'] if cuda else ['CPUExecutionProvider']
+
+            providers = ["CUDAExecutionProvider", "CPUExecutionProvider"] if cuda else ["CPUExecutionProvider"]
             session = onnxruntime.InferenceSession(w, providers=providers)
             output_names = [x.name for x in session.get_outputs()]
-            metadata = session.get_modelmeta().custom_metadata_map  # metadata
-        elif xml:  # OpenVINO
-            LOGGER.info(f'Loading {w} for OpenVINO inference...')
-            check_requirements('openvino>=2023.0')  # requires openvino-dev: https://pypi.org/project/openvino-dev/
-            from openvino.runtime import Core, Layout, get_batch  # noqa
-            core = Core()
+            metadata = session.get_modelmeta().custom_metadata_map
+
+        # OpenVINO
+        elif xml:
+            LOGGER.info(f"Loading {w} for OpenVINO inference...")
+            check_requirements("openvino>=2024.0.0")
+            import openvino as ov
+
+            core = ov.Core()
             w = Path(w)
             if not w.is_file():  # if not *.xml
-                w = next(w.glob('*.xml'))  # get *.xml file from *_openvino_model dir
-            ov_model = core.read_model(model=str(w), weights=w.with_suffix('.bin'))
+                w = next(w.glob("*.xml"))  # get *.xml file from *_openvino_model dir
+            ov_model = core.read_model(model=str(w), weights=w.with_suffix(".bin"))
             if ov_model.get_parameters()[0].get_layout().empty:
-                ov_model.get_parameters()[0].set_layout(Layout('NCHW'))
-            batch_dim = get_batch(ov_model)
-            if batch_dim.is_static:
-                batch_size = batch_dim.get_length()
-            ov_compiled_model = core.compile_model(ov_model, device_name='AUTO')  # AUTO selects best available device
-            metadata = w.parent / 'metadata.yaml'
-        elif engine:  # TensorRT
-            LOGGER.info(f'Loading {w} for TensorRT inference...')
+                ov_model.get_parameters()[0].set_layout(ov.Layout("NCHW"))
+
+            # OpenVINO inference modes are 'LATENCY', 'THROUGHPUT' (not recommended), or 'CUMULATIVE_THROUGHPUT'
+            inference_mode = "CUMULATIVE_THROUGHPUT" if batch > 1 else "LATENCY"
+            LOGGER.info(f"Using OpenVINO {inference_mode} mode for batch={batch} inference...")
+            ov_compiled_model = core.compile_model(
+                ov_model,
+                device_name="AUTO",  # AUTO selects best available device, do not modify
+                config={"PERFORMANCE_HINT": inference_mode},
+            )
+            input_name = ov_compiled_model.input().get_any_name()
+            metadata = w.parent / "metadata.yaml"
+
+        # TensorRT
+        elif engine:
+            LOGGER.info(f"Loading {w} for TensorRT inference...")
             try:
                 import tensorrt as trt  # noqa https://developer.nvidia.com/nvidia-tensorrt-download
             except ImportError:
                 if LINUX:
-                    check_requirements('nvidia-tensorrt', cmds='-U --index-url https://pypi.ngc.nvidia.com')
+                    check_requirements("nvidia-tensorrt", cmds="-U --index-url https://pypi.ngc.nvidia.com")
                 import tensorrt as trt  # noqa
-            check_version(trt.__version__, '7.0.0', hard=True)  # require tensorrt>=7.0.0
-            if device.type == 'cpu':
-                device = torch.device('cuda:0')
-            Binding = namedtuple('Binding', ('name', 'dtype', 'shape', 'data', 'ptr'))
+            check_version(trt.__version__, "7.0.0", hard=True)  # require tensorrt>=7.0.0
+            if device.type == "cpu":
+                device = torch.device("cuda:0")
+            Binding = namedtuple("Binding", ("name", "dtype", "shape", "data", "ptr"))
             logger = trt.Logger(trt.Logger.INFO)
             # Read file
-            with open(w, 'rb') as f, trt.Runtime(logger) as runtime:
-                meta_len = int.from_bytes(f.read(4), byteorder='little')  # read metadata length
-                metadata = json.loads(f.read(meta_len).decode('utf-8'))  # read metadata
+            with open(w, "rb") as f, trt.Runtime(logger) as runtime:
+                meta_len = int.from_bytes(f.read(4), byteorder="little")  # read metadata length
+                metadata = json.loads(f.read(meta_len).decode("utf-8"))  # read metadata
                 model = runtime.deserialize_cuda_engine(f.read())  # read engine
-            context = model.create_execution_context()
+
+            # Model context
+            try:
+                context = model.create_execution_context()
+            except Exception as e:  # model is None
+                LOGGER.error(f"ERROR: TensorRT model exported with a different version than {trt.__version__}\n")
+                raise e
+
             bindings = OrderedDict()
             output_names = []
             fp16 = False  # default updated below
             dynamic = False
-            for i in range(model.num_bindings):
-                name = model.get_binding_name(i)
-                dtype = trt.nptype(model.get_binding_dtype(i))
-                if model.binding_is_input(i):
-                    if -1 in tuple(model.get_binding_shape(i)):  # dynamic
-                        dynamic = True
-                        context.set_binding_shape(i, tuple(model.get_profile_shape(0, i)[2]))
-                    if dtype == np.float16:
-                        fp16 = True
-                else:  # output
-                    output_names.append(name)
-                shape = tuple(context.get_binding_shape(i))
+            is_trt10 = not hasattr(model, "num_bindings")
+            num = range(model.num_io_tensors) if is_trt10 else range(model.num_bindings)
+            for i in num:
+                if is_trt10:
+                    name = model.get_tensor_name(i)
+                    dtype = trt.nptype(model.get_tensor_dtype(name))
+                    is_input = model.get_tensor_mode(name) == trt.TensorIOMode.INPUT
+                    if is_input:
+                        if -1 in tuple(model.get_tensor_shape(name)):
+                            dynamic = True
+                            context.set_input_shape(name, tuple(model.get_tensor_profile_shape(name, 0)[1]))
+                            if dtype == np.float16:
+                                fp16 = True
+                    else:
+                        output_names.append(name)
+                    shape = tuple(context.get_tensor_shape(name))
+                else:  # TensorRT < 10.0
+                    name = model.get_binding_name(i)
+                    dtype = trt.nptype(model.get_binding_dtype(i))
+                    is_input = model.binding_is_input(i)
+                    if model.binding_is_input(i):
+                        if -1 in tuple(model.get_binding_shape(i)):  # dynamic
+                            dynamic = True
+                            context.set_binding_shape(i, tuple(model.get_profile_shape(0, i)[1]))
+                        if dtype == np.float16:
+                            fp16 = True
+                    else:
+                        output_names.append(name)
+                    shape = tuple(context.get_binding_shape(i))
                 im = torch.from_numpy(np.empty(shape, dtype=dtype)).to(device)
                 bindings[name] = Binding(name, dtype, shape, im, int(im.data_ptr()))
             binding_addrs = OrderedDict((n, d.ptr) for n, d in bindings.items())
-            batch_size = bindings['images'].shape[0]  # if dynamic, this is instead max batch size
-        elif coreml:  # CoreML
-            LOGGER.info(f'Loading {w} for CoreML inference...')
+            batch_size = bindings["images"].shape[0]  # if dynamic, this is instead max batch size
+
+        # CoreML
+        elif coreml:
+            LOGGER.info(f"Loading {w} for CoreML inference...")
             import coremltools as ct
+
             model = ct.models.MLModel(w)
             metadata = dict(model.user_defined_metadata)
-        elif saved_model:  # TF SavedModel
-            LOGGER.info(f'Loading {w} for TensorFlow SavedModel inference...')
+
+        # TF SavedModel
+        elif saved_model:
+            LOGGER.info(f"Loading {w} for TensorFlow SavedModel inference...")
             import tensorflow as tf
+
             keras = False  # assume TF1 saved_model
             model = tf.keras.models.load_model(w) if keras else tf.saved_model.load(w)
-            metadata = Path(w) / 'metadata.yaml'
-        elif pb:  # GraphDef https://www.tensorflow.org/guide/migrate#a_graphpb_or_graphpbtxt
-            LOGGER.info(f'Loading {w} for TensorFlow GraphDef inference...')
+            metadata = Path(w) / "metadata.yaml"
+
+        # TF GraphDef
+        elif pb:  # https://www.tensorflow.org/guide/migrate#a_graphpb_or_graphpbtxt
+            LOGGER.info(f"Loading {w} for TensorFlow GraphDef inference...")
             import tensorflow as tf
 
             from ultralytics.engine.exporter import gd_outputs
 
             def wrap_frozen_graph(gd, inputs, outputs):
                 """Wrap frozen graphs for deployment."""
-                x = tf.compat.v1.wrap_function(lambda: tf.compat.v1.import_graph_def(gd, name=''), [])  # wrapped
+                x = tf.compat.v1.wrap_function(lambda: tf.compat.v1.import_graph_def(gd, name=""), [])  # wrapped
                 ge = x.graph.as_graph_element
                 return x.prune(tf.nest.map_structure(ge, inputs), tf.nest.map_structure(ge, outputs))
 
             gd = tf.Graph().as_graph_def()  # TF GraphDef
-            with open(w, 'rb') as f:
+            with open(w, "rb") as f:
                 gd.ParseFromString(f.read())
-            frozen_func = wrap_frozen_graph(gd, inputs='x:0', outputs=gd_outputs(gd))
+            frozen_func = wrap_frozen_graph(gd, inputs="x:0", outputs=gd_outputs(gd))
+
+        # TFLite or TFLite Edge TPU
         elif tflite or edgetpu:  # https://www.tensorflow.org/lite/guide/python#install_tensorflow_lite_for_python
             try:  # https://coral.ai/docs/edgetpu/tflite-python/#update-existing-tf-lite-code-for-the-edge-tpu
                 from tflite_runtime.interpreter import Interpreter, load_delegate
             except ImportError:
                 import tensorflow as tf
+
                 Interpreter, load_delegate = tf.lite.Interpreter, tf.lite.experimental.load_delegate
             if edgetpu:  # TF Edge TPU https://coral.ai/software/#edgetpu-runtime
-                LOGGER.info(f'Loading {w} for TensorFlow Lite Edge TPU inference...')
-                delegate = {
-                    'Linux': 'libedgetpu.so.1',
-                    'Darwin': 'libedgetpu.1.dylib',
-                    'Windows': 'edgetpu.dll'}[platform.system()]
+                LOGGER.info(f"Loading {w} for TensorFlow Lite Edge TPU inference...")
+                delegate = {"Linux": "libedgetpu.so.1", "Darwin": "libedgetpu.1.dylib", "Windows": "edgetpu.dll"}[
+                    platform.system()
+                ]
                 interpreter = Interpreter(model_path=w, experimental_delegates=[load_delegate(delegate)])
             else:  # TFLite
-                LOGGER.info(f'Loading {w} for TensorFlow Lite inference...')
+                LOGGER.info(f"Loading {w} for TensorFlow Lite inference...")
                 interpreter = Interpreter(model_path=w)  # load TFLite model
             interpreter.allocate_tensors()  # allocate
             input_details = interpreter.get_input_details()  # inputs
             output_details = interpreter.get_output_details()  # outputs
             # Load metadata
             with contextlib.suppress(zipfile.BadZipFile):
-                with zipfile.ZipFile(w, 'r') as model:
+                with zipfile.ZipFile(w, "r") as model:
                     meta_file = model.namelist()[0]
-                    metadata = ast.literal_eval(model.read(meta_file).decode('utf-8'))
-        elif tfjs:  # TF.js
-            raise NotImplementedError('YOLOv8 TF.js inference is not currently supported.')
-        elif paddle:  # PaddlePaddle
-            LOGGER.info(f'Loading {w} for PaddlePaddle inference...')
-            check_requirements('paddlepaddle-gpu' if cuda else 'paddlepaddle')
+                    metadata = ast.literal_eval(model.read(meta_file).decode("utf-8"))
+
+        # TF.js
+        elif tfjs:
+            raise NotImplementedError("YOLOv8 TF.js inference is not currently supported.")
+
+        # PaddlePaddle
+        elif paddle:
+            LOGGER.info(f"Loading {w} for PaddlePaddle inference...")
+            check_requirements("paddlepaddle-gpu" if cuda else "paddlepaddle")
             import paddle.inference as pdi  # noqa
+
             w = Path(w)
             if not w.is_file():  # if not *.pdmodel
-                w = next(w.rglob('*.pdmodel'))  # get *.pdmodel file from *_paddle_model dir
-            config = pdi.Config(str(w), str(w.with_suffix('.pdiparams')))
+                w = next(w.rglob("*.pdmodel"))  # get *.pdmodel file from *_paddle_model dir
+            config = pdi.Config(str(w), str(w.with_suffix(".pdiparams")))
             if cuda:
                 config.enable_use_gpu(memory_pool_init_size_mb=2048, device_id=0)
             predictor = pdi.create_predictor(config)
             input_handle = predictor.get_input_handle(predictor.get_input_names()[0])
             output_names = predictor.get_output_names()
-            metadata = w.parents[1] / 'metadata.yaml'
-        elif ncnn:  # ncnn
-            LOGGER.info(f'Loading {w} for ncnn inference...')
-            check_requirements('git+https://github.com/Tencent/ncnn.git' if ARM64 else 'ncnn')  # requires ncnn
+            metadata = w.parents[1] / "metadata.yaml"
+
+        # NCNN
+        elif ncnn:
+            LOGGER.info(f"Loading {w} for NCNN inference...")
+            check_requirements("git+https://github.com/Tencent/ncnn.git" if ARM64 else "ncnn")  # requires NCNN
             import ncnn as pyncnn
+
             net = pyncnn.Net()
             net.opt.use_vulkan_compute = cuda
             w = Path(w)
             if not w.is_file():  # if not *.param
-                w = next(w.glob('*.param'))  # get *.param file from *_ncnn_model dir
+                w = next(w.glob("*.param"))  # get *.param file from *_ncnn_model dir
             net.load_param(str(w))
-            net.load_model(str(w.with_suffix('.bin')))
-            metadata = w.parent / 'metadata.yaml'
-        elif triton:  # NVIDIA Triton Inference Server
-            check_requirements('tritonclient[all]')
+            net.load_model(str(w.with_suffix(".bin")))
+            metadata = w.parent / "metadata.yaml"
+
+        # NVIDIA Triton Inference Server
+        elif triton:
+            check_requirements("tritonclient[all]")
             from ultralytics.utils.triton import TritonRemoteModel
+
             model = TritonRemoteModel(w)
-            if hasattr(model, 'names'):  # pose-only
+            if hasattr(model, 'names'): # pose-only
                 names = model.names
-            if hasattr(model, 'kpt_shape'):  # pose-only
+            if hasattr(model, 'kpt_shape'): # pose-only
                 kpt_shape = model.kpt_shape
+
+        # Any other format (unsupported)
         else:
             from ultralytics.engine.exporter import export_formats
-            raise TypeError(f"model='{w}' is not a supported model format. "
-                            'See https://docs.ultralytics.com/modes/predict for help.'
-                            f'\n\n{export_formats()}')
+
+            raise TypeError(
+                f"model='{w}' is not a supported model format. "
+                f"See https://docs.ultralytics.com/modes/predict for help.\n\n{export_formats()}"
+            )
 
         # Load external metadata YAML
         if isinstance(metadata, (str, Path)) and Path(metadata).exists():
             metadata = yaml_load(metadata)
         if metadata:
             for k, v in metadata.items():
-                if k in ('stride', 'batch'):
+                if k in {"stride", "batch"}:
                     metadata[k] = int(v)
-                elif k in ('imgsz', 'names', 'kpt_shape') and isinstance(v, str):
+                elif k in {"imgsz", "names", "kpt_shape"} and isinstance(v, str):
                     metadata[k] = eval(v)
-            stride = metadata['stride']
-            task = metadata['task']
-            batch = metadata['batch']
-            imgsz = metadata['imgsz']
-            names = metadata['names']
-            kpt_shape = metadata.get('kpt_shape')
+            stride = metadata["stride"]
+            task = metadata["task"]
+            batch = metadata["batch"]
+            imgsz = metadata["imgsz"]
+            names = metadata["names"]
+            kpt_shape = metadata.get("kpt_shape")
         elif not (pt or triton or nn_module):
             LOGGER.warning(f"WARNING  Metadata not found for 'model={weights}'")
 
         # Check names
-        if 'names' not in locals():  # names missing
-            names = self._apply_default_class_names(data)
+        if "names" not in locals():  # names missing
+            names = default_class_names(data)
         names = check_class_names(names)
 
         # Disable gradients
         if pt:
             for p in model.parameters():
                 p.requires_grad = False
 
         self.__dict__.update(locals())  # assign all variables to self
 
-    def forward(self, im, augment=False, visualize=False):
+    def forward(self, im, augment=False, visualize=False, embed=None):
         """
         Runs inference on the YOLOv8 MultiBackend model.
 
         Args:
             im (torch.Tensor): The image tensor to perform inference on.
             augment (bool): whether to perform data augmentation during inference, defaults to False
             visualize (bool): whether to visualize the output predictions, defaults to False
+            embed (list, optional): A list of feature vectors/embeddings to return.
 
         Returns:
             (tuple): Tuple containing the raw output tensor, and processed output for visualization (if visualize=True)
         """
         b, ch, h, w = im.shape  # batch, channel, height, width
         if self.fp16 and im.dtype != torch.float16:
             im = im.half()  # to FP16
         if self.nhwc:
             im = im.permute(0, 2, 3, 1)  # torch BCHW to numpy BHWC shape(1,320,192,3)
 
-        if self.pt or self.nn_module:  # PyTorch
-            y = self.model(im, augment=augment, visualize=visualize) if augment or visualize else self.model(im)
-        elif self.jit:  # TorchScript
+        # PyTorch
+        if self.pt or self.nn_module:
+            y = self.model(im, augment=augment, visualize=visualize, embed=embed)
+
+        # TorchScript
+        elif self.jit:
             y = self.model(im)
-        elif self.dnn:  # ONNX OpenCV DNN
+
+        # ONNX OpenCV DNN
+        elif self.dnn:
             im = im.cpu().numpy()  # torch to numpy
             self.net.setInput(im)
             y = self.net.forward()
-        elif self.onnx:  # ONNX Runtime
+
+        # ONNX Runtime
+        elif self.onnx:
             im = im.cpu().numpy()  # torch to numpy
             y = self.session.run(self.output_names, {self.session.get_inputs()[0].name: im})
-        elif self.xml:  # OpenVINO
+
+        # OpenVINO
+        elif self.xml:
             im = im.cpu().numpy()  # FP32
-            y = list(self.ov_compiled_model(im).values())
-        elif self.engine:  # TensorRT
-            if self.dynamic and im.shape != self.bindings['images'].shape:
-                i = self.model.get_binding_index('images')
-                self.context.set_binding_shape(i, im.shape)  # reshape if dynamic
-                self.bindings['images'] = self.bindings['images']._replace(shape=im.shape)
-                for name in self.output_names:
-                    i = self.model.get_binding_index(name)
-                    self.bindings[name].data.resize_(tuple(self.context.get_binding_shape(i)))
-            s = self.bindings['images'].shape
+
+            if self.inference_mode in {"THROUGHPUT", "CUMULATIVE_THROUGHPUT"}:  # optimized for larger batch-sizes
+                n = im.shape[0]  # number of images in batch
+                results = [None] * n  # preallocate list with None to match the number of images
+
+                def callback(request, userdata):
+                    """Places result in preallocated list using userdata index."""
+                    results[userdata] = request.results
+
+                # Create AsyncInferQueue, set the callback and start asynchronous inference for each input image
+                async_queue = self.ov.runtime.AsyncInferQueue(self.ov_compiled_model)
+                async_queue.set_callback(callback)
+                for i in range(n):
+                    # Start async inference with userdata=i to specify the position in results list
+                    async_queue.start_async(inputs={self.input_name: im[i : i + 1]}, userdata=i)  # keep image as BCHW
+                async_queue.wait_all()  # wait for all inference requests to complete
+                y = np.concatenate([list(r.values())[0] for r in results])
+
+            else:  # inference_mode = "LATENCY", optimized for fastest first result at batch-size 1
+                y = list(self.ov_compiled_model(im).values())
+
+        # TensorRT
+        elif self.engine:
+            if self.dynamic or im.shape != self.bindings["images"].shape:
+                if self.is_trt10:
+                    self.context.set_input_shape("images", im.shape)
+                    self.bindings["images"] = self.bindings["images"]._replace(shape=im.shape)
+                    for name in self.output_names:
+                        self.bindings[name].data.resize_(tuple(self.context.get_tensor_shape(name)))
+                else:
+                    i = self.model.get_binding_index("images")
+                    self.context.set_binding_shape(i, im.shape)
+                    self.bindings["images"] = self.bindings["images"]._replace(shape=im.shape)
+                    for name in self.output_names:
+                        i = self.model.get_binding_index(name)
+                        self.bindings[name].data.resize_(tuple(self.context.get_binding_shape(i)))
+
+            s = self.bindings["images"].shape
             assert im.shape == s, f"input size {im.shape} {'>' if self.dynamic else 'not equal to'} max model size {s}"
-            self.binding_addrs['images'] = int(im.data_ptr())
+            self.binding_addrs["images"] = int(im.data_ptr())
             self.context.execute_v2(list(self.binding_addrs.values()))
             y = [self.bindings[x].data for x in sorted(self.output_names)]
-        elif self.coreml:  # CoreML
+
+        # CoreML
+        elif self.coreml:
             im = im[0].cpu().numpy()
-            im_pil = Image.fromarray((im * 255).astype('uint8'))
+            im_pil = Image.fromarray((im * 255).astype("uint8"))
             # im = im.resize((192, 320), Image.BILINEAR)
-            y = self.model.predict({'image': im_pil})  # coordinates are xywh normalized
-            if 'confidence' in y:
-                raise TypeError('Ultralytics only supports inference of non-pipelined CoreML models exported with '
-                                f"'nms=False', but 'model={w}' has an NMS pipeline created by an 'nms=True' export.")
+            y = self.model.predict({"image": im_pil})  # coordinates are xywh normalized
+            if "confidence" in y:
+                raise TypeError(
+                    "Ultralytics only supports inference of non-pipelined CoreML models exported with "
+                    f"'nms=False', but 'model={w}' has an NMS pipeline created by an 'nms=True' export."
+                )
                 # TODO: CoreML NMS inference handling
                 # from ultralytics.utils.ops import xywh2xyxy
                 # box = xywh2xyxy(y['coordinates'] * [[w, h, w, h]])  # xyxy pixels
                 # conf, cls = y['confidence'].max(1), y['confidence'].argmax(1).astype(np.float32)
                 # y = np.concatenate((box, conf.reshape(-1, 1), cls.reshape(-1, 1)), 1)
             elif len(y) == 1:  # classification model
                 y = list(y.values())
             elif len(y) == 2:  # segmentation model
                 y = list(reversed(y.values()))  # reversed for segmentation models (pred, proto)
-        elif self.paddle:  # PaddlePaddle
+
+        # PaddlePaddle
+        elif self.paddle:
             im = im.cpu().numpy().astype(np.float32)
             self.input_handle.copy_from_cpu(im)
             self.predictor.run()
             y = [self.predictor.get_output_handle(x).copy_to_cpu() for x in self.output_names]
-        elif self.ncnn:  # ncnn
+
+        # NCNN
+        elif self.ncnn:
             mat_in = self.pyncnn.Mat(im[0].cpu().numpy())
-            ex = self.net.create_extractor()
-            input_names, output_names = self.net.input_names(), self.net.output_names()
-            ex.input(input_names[0], mat_in)
-            y = []
-            for output_name in output_names:
-                mat_out = self.pyncnn.Mat()
-                ex.extract(output_name, mat_out)
-                y.append(np.array(mat_out)[None])
-        elif self.triton:  # NVIDIA Triton Inference Server
+            with self.net.create_extractor() as ex:
+                ex.input(self.net.input_names()[0], mat_in)
+                # WARNING: 'output_names' sorted as a temporary fix for https://github.com/pnnx/pnnx/issues/130
+                y = [np.array(ex.extract(x)[1])[None] for x in sorted(self.net.output_names())]
+
+        # NVIDIA Triton Inference Server
+        elif self.triton:
             im = im.cpu().numpy()  # torch to numpy
             y = self.model(im)
-        else:  # TensorFlow (SavedModel, GraphDef, Lite, Edge TPU)
+
+        # TensorFlow (SavedModel, GraphDef, Lite, Edge TPU)
+        else:
             im = im.cpu().numpy()
             if self.saved_model:  # SavedModel
                 y = self.model(im, training=False) if self.keras else self.model(im)
                 if not isinstance(y, list):
                     y = [y]
             elif self.pb:  # GraphDef
                 y = self.frozen_func(x=self.tf.constant(im))
                 if len(y) == 2 and len(self.names) == 999:  # segments and names not defined
                     ip, ib = (0, 1) if len(y[0].shape) == 4 else (1, 0)  # index of protos, boxes
                     nc = y[ib].shape[1] - y[ip].shape[3] - 4  # y = (1, 160, 160, 32), (1, 116, 8400)
-                    self.names = {i: f'class{i}' for i in range(nc)}
+                    self.names = {i: f"class{i}" for i in range(nc)}
             else:  # Lite or Edge TPU
                 details = self.input_details[0]
-                integer = details['dtype'] in (np.int8, np.int16)  # is TFLite quantized int8 or int16 model
-                if integer:
-                    scale, zero_point = details['quantization']
-                    im = (im / scale + zero_point).astype(details['dtype'])  # de-scale
-                self.interpreter.set_tensor(details['index'], im)
+                is_int = details["dtype"] in {np.int8, np.int16}  # is TFLite quantized int8 or int16 model
+                if is_int:
+                    scale, zero_point = details["quantization"]
+                    im = (im / scale + zero_point).astype(details["dtype"])  # de-scale
+                self.interpreter.set_tensor(details["index"], im)
                 self.interpreter.invoke()
                 y = []
                 for output in self.output_details:
-                    x = self.interpreter.get_tensor(output['index'])
-                    if integer:
-                        scale, zero_point = output['quantization']
+                    x = self.interpreter.get_tensor(output["index"])
+                    if is_int:
+                        scale, zero_point = output["quantization"]
                         x = (x.astype(np.float32) - zero_point) * scale  # re-scale
-                    if x.ndim > 2:  # if task is not classification
+                    if x.ndim == 3:  # if task is not classification, excluding masks (ndim=4) as well
                         # Denormalize xywh by image size. See https://github.com/ultralytics/ultralytics/pull/1695
                         # xywh are normalized in TFLite/EdgeTPU to mitigate quantization error of integer models
                         x[:, [0, 2]] *= w
                         x[:, [1, 3]] *= h
                     y.append(x)
             # TF segment fixes: export is reversed vs ONNX export and protos are transposed
             if len(y) == 2:  # segment with (det, proto) output order reversed
@@ -469,50 +616,45 @@
 
     def warmup(self, imgsz=(1, 3, 640, 640)):
         """
         Warm up the model by running one forward pass with a dummy input.
 
         Args:
             imgsz (tuple): The shape of the dummy input tensor in the format (batch_size, channels, height, width)
-
-        Returns:
-            (None): This method runs the forward pass and don't return any value
         """
         warmup_types = self.pt, self.jit, self.onnx, self.engine, self.saved_model, self.pb, self.triton, self.nn_module
-        if any(warmup_types) and (self.device.type != 'cpu' or self.triton):
+        if any(warmup_types) and (self.device.type != "cpu" or self.triton):
             im = torch.empty(*imgsz, dtype=torch.half if self.fp16 else torch.float, device=self.device)  # input
             for _ in range(2 if self.jit else 1):
                 self.forward(im)  # warmup
 
     @staticmethod
-    def _apply_default_class_names(data):
-        """Applies default class names to an input YAML file or returns numerical class names."""
-        with contextlib.suppress(Exception):
-            return yaml_load(check_yaml(data))['names']
-        return {i: f'class{i}' for i in range(999)}  # return default if above errors
-
-    @staticmethod
-    def _model_type(p='path/to/model.pt'):
+    def _model_type(p="path/to/model.pt"):
         """
-        This function takes a path to a model file and returns the model type.
+        This function takes a path to a model file and returns the model type. Possibles types are pt, jit, onnx, xml,
+        engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, ncnn or paddle.
 
         Args:
             p: path to the model file. Defaults to path/to/model.pt
+
+        Examples:
+            >>> model = AutoBackend(weights="path/to/model.onnx")
+            >>> model_type = model._model_type()  # returns "onnx"
         """
-        # Return model type from model path, i.e. path='path/to/model.onnx' -> type=onnx
-        # types = [pt, jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle]
         from ultralytics.engine.exporter import export_formats
+
         sf = list(export_formats().Suffix)  # export suffixes
-        if not is_url(p, check=False) and not isinstance(p, str):
+        if not is_url(p) and not isinstance(p, str):
             check_suffix(p, sf)  # checks
         name = Path(p).name
         types = [s in name for s in sf]
-        types[5] |= name.endswith('.mlmodel')  # retain support for older Apple CoreML *.mlmodel formats
+        types[5] |= name.endswith(".mlmodel")  # retain support for older Apple CoreML *.mlmodel formats
         types[8] &= not types[9]  # tflite &= not edgetpu
         if any(types):
             triton = False
         else:
             from urllib.parse import urlsplit
+
             url = urlsplit(p)
-            triton = url.netloc and url.path and url.scheme in {'http', 'grpc'}
+            triton = bool(url.netloc) and bool(url.path) and url.scheme in {"http", "grpc"}
 
         return types + [triton]
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/nn/modules/conv.py` & `yolov8_pose_triton-8.2.0/ultralytics/nn/modules/conv.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,29 +3,43 @@
 
 import math
 
 import numpy as np
 import torch
 import torch.nn as nn
 
-__all__ = ('Conv', 'Conv2', 'LightConv', 'DWConv', 'DWConvTranspose2d', 'ConvTranspose', 'Focus', 'GhostConv',
-           'ChannelAttention', 'SpatialAttention', 'CBAM', 'Concat', 'RepConv')
+__all__ = (
+    "Conv",
+    "Conv2",
+    "LightConv",
+    "DWConv",
+    "DWConvTranspose2d",
+    "ConvTranspose",
+    "Focus",
+    "GhostConv",
+    "ChannelAttention",
+    "SpatialAttention",
+    "CBAM",
+    "Concat",
+    "RepConv",
+)
 
 
 def autopad(k, p=None, d=1):  # kernel, padding, dilation
     """Pad to 'same' shape outputs."""
     if d > 1:
         k = d * (k - 1) + 1 if isinstance(k, int) else [d * (x - 1) + 1 for x in k]  # actual kernel-size
     if p is None:
         p = k // 2 if isinstance(k, int) else [x // 2 for x in k]  # auto-pad
     return p
 
 
 class Conv(nn.Module):
     """Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation)."""
+
     default_act = nn.SiLU()  # default activation
 
     def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True):
         """Initialize Conv layer with given arguments including activation."""
         super().__init__()
         self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False)
         self.bn = nn.BatchNorm2d(c2)
@@ -56,17 +70,17 @@
         """Apply fused convolution, batch normalization and activation to input tensor."""
         return self.act(self.bn(self.conv(x)))
 
     def fuse_convs(self):
         """Fuse parallel convolutions."""
         w = torch.zeros_like(self.conv.weight.data)
         i = [x // 2 for x in w.shape[2:]]
-        w[:, :, i[0]:i[0] + 1, i[1]:i[1] + 1] = self.cv2.weight.data.clone()
+        w[:, :, i[0] : i[0] + 1, i[1] : i[1] + 1] = self.cv2.weight.data.clone()
         self.conv.weight.data += w
-        self.__delattr__('cv2')
+        self.__delattr__("cv2")
         self.forward = self.forward_fuse
 
 
 class LightConv(nn.Module):
     """
     Light convolution with args(ch_in, ch_out, kernel).
 
@@ -98,14 +112,15 @@
     def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):  # ch_in, ch_out, kernel, stride, padding, padding_out
         """Initialize DWConvTranspose2d class with given parameters."""
         super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))
 
 
 class ConvTranspose(nn.Module):
     """Convolution transpose 2d layer."""
+
     default_act = nn.SiLU()  # default activation
 
     def __init__(self, c1, c2, k=2, s=2, p=0, bn=True, act=True):
         """Initialize ConvTranspose2d layer with batch normalization and activation function."""
         super().__init__()
         self.conv_transpose = nn.ConvTranspose2d(c1, c2, k, s, p, bias=not bn)
         self.bn = nn.BatchNorm2d(c2) if bn else nn.Identity()
@@ -160,14 +175,15 @@
 class RepConv(nn.Module):
     """
     RepConv is a basic rep-style block, including training and deploy status.
 
     This module is used in RT-DETR.
     Based on https://github.com/DingXiaoH/RepVGG/blob/main/repvgg.py
     """
+
     default_act = nn.SiLU()  # default activation
 
     def __init__(self, c1, c2, k=3, s=1, p=1, g=1, d=1, act=True, bn=False, deploy=False):
         """Initializes Light Convolution layer with inputs, outputs & optional activation function."""
         super().__init__()
         assert k == 3 and p == 1
         self.g = g
@@ -210,15 +226,15 @@
             kernel = branch.conv.weight
             running_mean = branch.bn.running_mean
             running_var = branch.bn.running_var
             gamma = branch.bn.weight
             beta = branch.bn.bias
             eps = branch.bn.eps
         elif isinstance(branch, nn.BatchNorm2d):
-            if not hasattr(self, 'id_tensor'):
+            if not hasattr(self, "id_tensor"):
                 input_dim = self.c1 // self.g
                 kernel_value = np.zeros((self.c1, input_dim, 3, 3), dtype=np.float32)
                 for i in range(self.c1):
                     kernel_value[i, i % input_dim, 1, 1] = 1
                 self.id_tensor = torch.from_numpy(kernel_value).to(branch.weight.device)
             kernel = self.id_tensor
             running_mean = branch.running_mean
@@ -228,37 +244,39 @@
             eps = branch.eps
         std = (running_var + eps).sqrt()
         t = (gamma / std).reshape(-1, 1, 1, 1)
         return kernel * t, beta - running_mean * gamma / std
 
     def fuse_convs(self):
         """Combines two convolution layers into a single layer and removes unused attributes from the class."""
-        if hasattr(self, 'conv'):
+        if hasattr(self, "conv"):
             return
         kernel, bias = self.get_equivalent_kernel_bias()
-        self.conv = nn.Conv2d(in_channels=self.conv1.conv.in_channels,
-                              out_channels=self.conv1.conv.out_channels,
-                              kernel_size=self.conv1.conv.kernel_size,
-                              stride=self.conv1.conv.stride,
-                              padding=self.conv1.conv.padding,
-                              dilation=self.conv1.conv.dilation,
-                              groups=self.conv1.conv.groups,
-                              bias=True).requires_grad_(False)
+        self.conv = nn.Conv2d(
+            in_channels=self.conv1.conv.in_channels,
+            out_channels=self.conv1.conv.out_channels,
+            kernel_size=self.conv1.conv.kernel_size,
+            stride=self.conv1.conv.stride,
+            padding=self.conv1.conv.padding,
+            dilation=self.conv1.conv.dilation,
+            groups=self.conv1.conv.groups,
+            bias=True,
+        ).requires_grad_(False)
         self.conv.weight.data = kernel
         self.conv.bias.data = bias
         for para in self.parameters():
             para.detach_()
-        self.__delattr__('conv1')
-        self.__delattr__('conv2')
-        if hasattr(self, 'nm'):
-            self.__delattr__('nm')
-        if hasattr(self, 'bn'):
-            self.__delattr__('bn')
-        if hasattr(self, 'id_tensor'):
-            self.__delattr__('id_tensor')
+        self.__delattr__("conv1")
+        self.__delattr__("conv2")
+        if hasattr(self, "nm"):
+            self.__delattr__("nm")
+        if hasattr(self, "bn"):
+            self.__delattr__("bn")
+        if hasattr(self, "id_tensor"):
+            self.__delattr__("id_tensor")
 
 
 class ChannelAttention(nn.Module):
     """Channel-attention module https://github.com/open-mmlab/mmdetection/tree/v3.0.0rc1/configs/rtmdet."""
 
     def __init__(self, channels: int) -> None:
         """Initializes the class and sets the basic configurations and instance variables required."""
@@ -274,15 +292,15 @@
 
 class SpatialAttention(nn.Module):
     """Spatial-attention module."""
 
     def __init__(self, kernel_size=7):
         """Initialize Spatial-attention module with kernel size argument."""
         super().__init__()
-        assert kernel_size in (3, 7), 'kernel size must be 3 or 7'
+        assert kernel_size in {3, 7}, "kernel size must be 3 or 7"
         padding = 3 if kernel_size == 7 else 1
         self.cv1 = nn.Conv2d(2, 1, kernel_size, padding=padding, bias=False)
         self.act = nn.Sigmoid()
 
     def forward(self, x):
         """Apply channel and spatial attention on input for feature recalibration."""
         return x * self.act(self.cv1(torch.cat([torch.mean(x, 1, keepdim=True), torch.max(x, 1, keepdim=True)[0]], 1)))
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/nn/modules/head.py` & `yolov8_pose_triton-8.2.0/ultralytics/nn/modules/head.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,26 +3,27 @@
 
 import math
 
 import torch
 import torch.nn as nn
 from torch.nn.init import constant_, xavier_uniform_
 
-from ultralytics.utils.tal import TORCH_1_10, dist2bbox, make_anchors
+from ultralytics.utils.tal import TORCH_1_10, dist2bbox, dist2rbox, make_anchors
 
-from .block import DFL, Proto
+from .block import DFL, BNContrastiveHead, ContrastiveHead, Proto
 from .conv import Conv
 from .transformer import MLP, DeformableTransformerDecoder, DeformableTransformerDecoderLayer
-from .utils import bias_init_with_prob, linear_init_
+from .utils import bias_init_with_prob, linear_init
 
-__all__ = 'Detect', 'Segment', 'Pose', 'Classify', 'RTDETRDecoder'
+__all__ = "Detect", "Segment", "Pose", "Classify", "OBB", "RTDETRDecoder"
 
 
 class Detect(nn.Module):
     """YOLOv8 Detect head for detection models."""
+
     dynamic = False  # force grid reconstruction
     export = False  # export mode
     shape = None
     anchors = torch.empty(0)  # init
     strides = torch.empty(0)  # init
 
     def __init__(self, nc=80, ch=()):
@@ -31,57 +32,65 @@
         self.nc = nc  # number of classes
         self.nl = len(ch)  # number of detection layers
         self.reg_max = 16  # DFL channels (ch[0] // 16 to scale 4/8/12/16/20 for n/s/m/l/x)
         self.no = nc + self.reg_max * 4  # number of outputs per anchor
         self.stride = torch.zeros(self.nl)  # strides computed during build
         c2, c3 = max((16, ch[0] // 4, self.reg_max * 4)), max(ch[0], min(self.nc, 100))  # channels
         self.cv2 = nn.ModuleList(
-            nn.Sequential(Conv(x, c2, 3), Conv(c2, c2, 3), nn.Conv2d(c2, 4 * self.reg_max, 1)) for x in ch)
+            nn.Sequential(Conv(x, c2, 3), Conv(c2, c2, 3), nn.Conv2d(c2, 4 * self.reg_max, 1)) for x in ch
+        )
         self.cv3 = nn.ModuleList(nn.Sequential(Conv(x, c3, 3), Conv(c3, c3, 3), nn.Conv2d(c3, self.nc, 1)) for x in ch)
         self.dfl = DFL(self.reg_max) if self.reg_max > 1 else nn.Identity()
 
     def forward(self, x):
         """Concatenates and returns predicted bounding boxes and class probabilities."""
-        shape = x[0].shape  # BCHW
         for i in range(self.nl):
             x[i] = torch.cat((self.cv2[i](x[i]), self.cv3[i](x[i])), 1)
-        if self.training:
+        if self.training:  # Training path
             return x
-        elif self.dynamic or self.shape != shape:
+
+        # Inference path
+        shape = x[0].shape  # BCHW
+        x_cat = torch.cat([xi.view(shape[0], self.no, -1) for xi in x], 2)
+        if self.dynamic or self.shape != shape:
             self.anchors, self.strides = (x.transpose(0, 1) for x in make_anchors(x, self.stride, 0.5))
             self.shape = shape
 
-        x_cat = torch.cat([xi.view(shape[0], self.no, -1) for xi in x], 2)
-        if self.export and self.format in ('saved_model', 'pb', 'tflite', 'edgetpu', 'tfjs'):  # avoid TF FlexSplitV ops
-            box = x_cat[:, :self.reg_max * 4]
-            cls = x_cat[:, self.reg_max * 4:]
+        if self.export and self.format in {"saved_model", "pb", "tflite", "edgetpu", "tfjs"}:  # avoid TF FlexSplitV ops
+            box = x_cat[:, : self.reg_max * 4]
+            cls = x_cat[:, self.reg_max * 4 :]
         else:
             box, cls = x_cat.split((self.reg_max * 4, self.nc), 1)
-        dbox = dist2bbox(self.dfl(box), self.anchors.unsqueeze(0), xywh=True, dim=1) * self.strides
 
-        if self.export and self.format in ('tflite', 'edgetpu'):
-            # Normalize xywh with image size to mitigate quantization error of TFLite integer models as done in YOLOv5:
-            # https://github.com/ultralytics/yolov5/blob/0c8de3fca4a702f8ff5c435e67f378d1fce70243/models/tf.py#L307-L309
-            # See this PR for details: https://github.com/ultralytics/ultralytics/pull/1695
-            img_h = shape[2] * self.stride[0]
-            img_w = shape[3] * self.stride[0]
-            img_size = torch.tensor([img_w, img_h, img_w, img_h], device=dbox.device).reshape(1, 4, 1)
-            dbox /= img_size
+        if self.export and self.format in {"tflite", "edgetpu"}:
+            # Precompute normalization factor to increase numerical stability
+            # See https://github.com/ultralytics/ultralytics/issues/7371
+            grid_h = shape[2]
+            grid_w = shape[3]
+            grid_size = torch.tensor([grid_w, grid_h, grid_w, grid_h], device=box.device).reshape(1, 4, 1)
+            norm = self.strides / (self.stride[0] * grid_size)
+            dbox = self.decode_bboxes(self.dfl(box) * norm, self.anchors.unsqueeze(0) * norm[:, :2])
+        else:
+            dbox = self.decode_bboxes(self.dfl(box), self.anchors.unsqueeze(0)) * self.strides
 
         y = torch.cat((dbox, cls.sigmoid()), 1)
         return y if self.export else (y, x)
 
     def bias_init(self):
         """Initialize Detect() biases, WARNING: requires stride availability."""
         m = self  # self.model[-1]  # Detect() module
         # cf = torch.bincount(torch.tensor(np.concatenate(dataset.labels, 0)[:, 0]).long(), minlength=nc) + 1
         # ncf = math.log(0.6 / (m.nc - 0.999999)) if cf is None else torch.log(cf / cf.sum())  # nominal class frequency
         for a, b, s in zip(m.cv2, m.cv3, m.stride):  # from
             a[-1].bias.data[:] = 1.0  # box
-            b[-1].bias.data[:m.nc] = math.log(5 / m.nc / (640 / s) ** 2)  # cls (.01 objects, 80 classes, 640 img)
+            b[-1].bias.data[: m.nc] = math.log(5 / m.nc / (640 / s) ** 2)  # cls (.01 objects, 80 classes, 640 img)
+
+    def decode_bboxes(self, bboxes, anchors):
+        """Decode bounding boxes."""
+        return dist2bbox(bboxes, anchors, xywh=True, dim=1)
 
 
 class Segment(Detect):
     """YOLOv8 Segment head for segmentation models."""
 
     def __init__(self, nc=80, nm=32, npr=256, ch=()):
         """Initialize the YOLO model attributes such as the number of masks, prototypes, and the convolution layers."""
@@ -102,14 +111,45 @@
         mc = torch.cat([self.cv4[i](x[i]).view(bs, self.nm, -1) for i in range(self.nl)], 2)  # mask coefficients
         x = self.detect(self, x)
         if self.training:
             return x, mc, p
         return (torch.cat([x, mc], 1), p) if self.export else (torch.cat([x[0], mc], 1), (x[1], mc, p))
 
 
+class OBB(Detect):
+    """YOLOv8 OBB detection head for detection with rotation models."""
+
+    def __init__(self, nc=80, ne=1, ch=()):
+        """Initialize OBB with number of classes `nc` and layer channels `ch`."""
+        super().__init__(nc, ch)
+        self.ne = ne  # number of extra parameters
+        self.detect = Detect.forward
+
+        c4 = max(ch[0] // 4, self.ne)
+        self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.ne, 1)) for x in ch)
+
+    def forward(self, x):
+        """Concatenates and returns predicted bounding boxes and class probabilities."""
+        bs = x[0].shape[0]  # batch size
+        angle = torch.cat([self.cv4[i](x[i]).view(bs, self.ne, -1) for i in range(self.nl)], 2)  # OBB theta logits
+        # NOTE: set `angle` as an attribute so that `decode_bboxes` could use it.
+        angle = (angle.sigmoid() - 0.25) * math.pi  # [-pi/4, 3pi/4]
+        # angle = angle.sigmoid() * math.pi / 2  # [0, pi/2]
+        if not self.training:
+            self.angle = angle
+        x = self.detect(self, x)
+        if self.training:
+            return x, angle
+        return torch.cat([x, angle], 1) if self.export else (torch.cat([x[0], angle], 1), (x[1], angle))
+
+    def decode_bboxes(self, bboxes, anchors):
+        """Decode rotated bounding boxes."""
+        return dist2rbox(bboxes, self.angle, anchors, dim=1)
+
+
 class Pose(Detect):
     """YOLOv8 Pose head for keypoints models."""
 
     def __init__(self, nc=80, kpt_shape=(17, 3), ch=()):
         """Initialize YOLO network with default parameters and Convolutional Layers."""
         super().__init__(nc, ch)
         self.kpt_shape = kpt_shape  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)
@@ -137,15 +177,15 @@
             a = (y[:, :, :2] * 2.0 + (self.anchors - 0.5)) * self.strides
             if ndim == 3:
                 a = torch.cat((a, y[:, :, 2:3].sigmoid()), 2)
             return a.view(bs, self.nk, -1)
         else:
             y = kpts.clone()
             if ndim == 3:
-                y[:, 2::3].sigmoid_()  # inplace sigmoid
+                y[:, 2::3] = y[:, 2::3].sigmoid()  # sigmoid (WARNING: inplace .sigmoid_() Apple MPS bug)
             y[:, 0::ndim] = (y[:, 0::ndim] * 2.0 + (self.anchors[0] - 0.5)) * self.strides
             y[:, 1::ndim] = (y[:, 1::ndim] * 2.0 + (self.anchors[1] - 0.5)) * self.strides
             return y
 
 
 class Classify(nn.Module):
     """YOLOv8 classification head, i.e. x(b,c1,20,20) to x(b,c2)."""
@@ -165,42 +205,96 @@
         """Performs a forward pass of the YOLO model on input image data."""
         if isinstance(x, list):
             x = torch.cat(x, 1)
         x = self.linear(self.drop(self.pool(self.conv(x)).flatten(1)))
         return x if self.training else x.softmax(1)
 
 
+class WorldDetect(Detect):
+    def __init__(self, nc=80, embed=512, with_bn=False, ch=()):
+        """Initialize YOLOv8 detection layer with nc classes and layer channels ch."""
+        super().__init__(nc, ch)
+        c3 = max(ch[0], min(self.nc, 100))
+        self.cv3 = nn.ModuleList(nn.Sequential(Conv(x, c3, 3), Conv(c3, c3, 3), nn.Conv2d(c3, embed, 1)) for x in ch)
+        self.cv4 = nn.ModuleList(BNContrastiveHead(embed) if with_bn else ContrastiveHead() for _ in ch)
+
+    def forward(self, x, text):
+        """Concatenates and returns predicted bounding boxes and class probabilities."""
+        for i in range(self.nl):
+            x[i] = torch.cat((self.cv2[i](x[i]), self.cv4[i](self.cv3[i](x[i]), text)), 1)
+        if self.training:
+            return x
+
+        # Inference path
+        shape = x[0].shape  # BCHW
+        x_cat = torch.cat([xi.view(shape[0], self.nc + self.reg_max * 4, -1) for xi in x], 2)
+        if self.dynamic or self.shape != shape:
+            self.anchors, self.strides = (x.transpose(0, 1) for x in make_anchors(x, self.stride, 0.5))
+            self.shape = shape
+
+        if self.export and self.format in {"saved_model", "pb", "tflite", "edgetpu", "tfjs"}:  # avoid TF FlexSplitV ops
+            box = x_cat[:, : self.reg_max * 4]
+            cls = x_cat[:, self.reg_max * 4 :]
+        else:
+            box, cls = x_cat.split((self.reg_max * 4, self.nc), 1)
+
+        if self.export and self.format in {"tflite", "edgetpu"}:
+            # Precompute normalization factor to increase numerical stability
+            # See https://github.com/ultralytics/ultralytics/issues/7371
+            grid_h = shape[2]
+            grid_w = shape[3]
+            grid_size = torch.tensor([grid_w, grid_h, grid_w, grid_h], device=box.device).reshape(1, 4, 1)
+            norm = self.strides / (self.stride[0] * grid_size)
+            dbox = self.decode_bboxes(self.dfl(box) * norm, self.anchors.unsqueeze(0) * norm[:, :2])
+        else:
+            dbox = self.decode_bboxes(self.dfl(box), self.anchors.unsqueeze(0)) * self.strides
+
+        y = torch.cat((dbox, cls.sigmoid()), 1)
+        return y if self.export else (y, x)
+
+    def bias_init(self):
+        """Initialize Detect() biases, WARNING: requires stride availability."""
+        m = self  # self.model[-1]  # Detect() module
+        # cf = torch.bincount(torch.tensor(np.concatenate(dataset.labels, 0)[:, 0]).long(), minlength=nc) + 1
+        # ncf = math.log(0.6 / (m.nc - 0.999999)) if cf is None else torch.log(cf / cf.sum())  # nominal class frequency
+        for a, b, s in zip(m.cv2, m.cv3, m.stride):  # from
+            a[-1].bias.data[:] = 1.0  # box
+            # b[-1].bias.data[:] = math.log(5 / m.nc / (640 / s) ** 2)  # cls (.01 objects, 80 classes, 640 img)
+
+
 class RTDETRDecoder(nn.Module):
     """
     Real-Time Deformable Transformer Decoder (RTDETRDecoder) module for object detection.
 
     This decoder module utilizes Transformer architecture along with deformable convolutions to predict bounding boxes
     and class labels for objects in an image. It integrates features from multiple layers and runs through a series of
     Transformer decoder layers to output the final predictions.
     """
+
     export = False  # export mode
 
     def __init__(
-            self,
-            nc=80,
-            ch=(512, 1024, 2048),
-            hd=256,  # hidden dim
-            nq=300,  # num queries
-            ndp=4,  # num decoder points
-            nh=8,  # num head
-            ndl=6,  # num decoder layers
-            d_ffn=1024,  # dim of feedforward
-            dropout=0.,
-            act=nn.ReLU(),
-            eval_idx=-1,
-            # Training args
-            nd=100,  # num denoising
-            label_noise_ratio=0.5,
-            box_noise_scale=1.0,
-            learnt_init_query=False):
+        self,
+        nc=80,
+        ch=(512, 1024, 2048),
+        hd=256,  # hidden dim
+        nq=300,  # num queries
+        ndp=4,  # num decoder points
+        nh=8,  # num head
+        ndl=6,  # num decoder layers
+        d_ffn=1024,  # dim of feedforward
+        dropout=0.0,
+        act=nn.ReLU(),
+        eval_idx=-1,
+        # Training args
+        nd=100,  # num denoising
+        label_noise_ratio=0.5,
+        box_noise_scale=1.0,
+        learnt_init_query=False,
+    ):
         """
         Initializes the RTDETRDecoder module with the given parameters.
 
         Args:
             nc (int): Number of classes. Default is 80.
             ch (tuple): Channels in the backbone feature maps. Default is (512, 1024, 2048).
             hd (int): Dimension of hidden layers. Default is 256.
@@ -261,61 +355,63 @@
         """Runs the forward pass of the module, returning bounding box and classification scores for the input."""
         from ultralytics.models.utils.ops import get_cdn_group
 
         # Input projection and embedding
         feats, shapes = self._get_encoder_input(x)
 
         # Prepare denoising training
-        dn_embed, dn_bbox, attn_mask, dn_meta = \
-            get_cdn_group(batch,
-                          self.nc,
-                          self.num_queries,
-                          self.denoising_class_embed.weight,
-                          self.num_denoising,
-                          self.label_noise_ratio,
-                          self.box_noise_scale,
-                          self.training)
+        dn_embed, dn_bbox, attn_mask, dn_meta = get_cdn_group(
+            batch,
+            self.nc,
+            self.num_queries,
+            self.denoising_class_embed.weight,
+            self.num_denoising,
+            self.label_noise_ratio,
+            self.box_noise_scale,
+            self.training,
+        )
 
-        embed, refer_bbox, enc_bboxes, enc_scores = \
-            self._get_decoder_input(feats, shapes, dn_embed, dn_bbox)
+        embed, refer_bbox, enc_bboxes, enc_scores = self._get_decoder_input(feats, shapes, dn_embed, dn_bbox)
 
         # Decoder
-        dec_bboxes, dec_scores = self.decoder(embed,
-                                              refer_bbox,
-                                              feats,
-                                              shapes,
-                                              self.dec_bbox_head,
-                                              self.dec_score_head,
-                                              self.query_pos_head,
-                                              attn_mask=attn_mask)
+        dec_bboxes, dec_scores = self.decoder(
+            embed,
+            refer_bbox,
+            feats,
+            shapes,
+            self.dec_bbox_head,
+            self.dec_score_head,
+            self.query_pos_head,
+            attn_mask=attn_mask,
+        )
         x = dec_bboxes, dec_scores, enc_bboxes, enc_scores, dn_meta
         if self.training:
             return x
         # (bs, 300, 4+nc)
         y = torch.cat((dec_bboxes.squeeze(0), dec_scores.squeeze(0).sigmoid()), -1)
         return y if self.export else (y, x)
 
-    def _generate_anchors(self, shapes, grid_size=0.05, dtype=torch.float32, device='cpu', eps=1e-2):
+    def _generate_anchors(self, shapes, grid_size=0.05, dtype=torch.float32, device="cpu", eps=1e-2):
         """Generates anchor bounding boxes for given shapes with specific grid size and validates them."""
         anchors = []
         for i, (h, w) in enumerate(shapes):
             sy = torch.arange(end=h, dtype=dtype, device=device)
             sx = torch.arange(end=w, dtype=dtype, device=device)
-            grid_y, grid_x = torch.meshgrid(sy, sx, indexing='ij') if TORCH_1_10 else torch.meshgrid(sy, sx)
+            grid_y, grid_x = torch.meshgrid(sy, sx, indexing="ij") if TORCH_1_10 else torch.meshgrid(sy, sx)
             grid_xy = torch.stack([grid_x, grid_y], -1)  # (h, w, 2)
 
-            valid_WH = torch.tensor([h, w], dtype=dtype, device=device)
+            valid_WH = torch.tensor([w, h], dtype=dtype, device=device)
             grid_xy = (grid_xy.unsqueeze(0) + 0.5) / valid_WH  # (1, h, w, 2)
-            wh = torch.ones_like(grid_xy, dtype=dtype, device=device) * grid_size * (2.0 ** i)
+            wh = torch.ones_like(grid_xy, dtype=dtype, device=device) * grid_size * (2.0**i)
             anchors.append(torch.cat([grid_xy, wh], -1).view(-1, h * w, 4))  # (1, h*w, 4)
 
         anchors = torch.cat(anchors, 1)  # (1, h*w*nl, 4)
-        valid_mask = ((anchors > eps) * (anchors < 1 - eps)).all(-1, keepdim=True)  # 1, h*w*nl, 1
+        valid_mask = ((anchors > eps) & (anchors < 1 - eps)).all(-1, keepdim=True)  # 1, h*w*nl, 1
         anchors = torch.log(anchors / (1 - anchors))
-        anchors = anchors.masked_fill(~valid_mask, float('inf'))
+        anchors = anchors.masked_fill(~valid_mask, float("inf"))
         return anchors, valid_mask
 
     def _get_encoder_input(self, x):
         """Processes and returns encoder inputs by getting projection features from input and concatenating them."""
         # Get projection features
         x = [self.input_proj[i](feat) for i, feat in enumerate(x)]
         # Get encoder inputs
@@ -330,15 +426,15 @@
 
         # [b, h*w, c]
         feats = torch.cat(feats, 1)
         return feats, shapes
 
     def _get_decoder_input(self, feats, shapes, dn_embed=None, dn_bbox=None):
         """Generates and prepares the input required for the decoder from the provided features and shapes."""
-        bs = len(feats)
+        bs = feats.shape[0]
         # Prepare input for decoder
         anchors, valid_mask = self._generate_anchors(shapes, dtype=feats.dtype, device=feats.device)
         features = self.enc_output(valid_mask * feats)  # bs, h*w, 256
 
         enc_outputs_scores = self.enc_score_head(features)  # (bs, h*w, nc)
 
         # Query selection
@@ -371,26 +467,26 @@
         return embeddings, refer_bbox, enc_bboxes, enc_scores
 
     # TODO
     def _reset_parameters(self):
         """Initializes or resets the parameters of the model's various components with predefined weights and biases."""
         # Class and bbox head init
         bias_cls = bias_init_with_prob(0.01) / 80 * self.nc
-        # NOTE: the weight initialization in `linear_init_` would cause NaN when training with custom datasets.
-        # linear_init_(self.enc_score_head)
+        # NOTE: the weight initialization in `linear_init` would cause NaN when training with custom datasets.
+        # linear_init(self.enc_score_head)
         constant_(self.enc_score_head.bias, bias_cls)
-        constant_(self.enc_bbox_head.layers[-1].weight, 0.)
-        constant_(self.enc_bbox_head.layers[-1].bias, 0.)
+        constant_(self.enc_bbox_head.layers[-1].weight, 0.0)
+        constant_(self.enc_bbox_head.layers[-1].bias, 0.0)
         for cls_, reg_ in zip(self.dec_score_head, self.dec_bbox_head):
-            # linear_init_(cls_)
+            # linear_init(cls_)
             constant_(cls_.bias, bias_cls)
-            constant_(reg_.layers[-1].weight, 0.)
-            constant_(reg_.layers[-1].bias, 0.)
+            constant_(reg_.layers[-1].weight, 0.0)
+            constant_(reg_.layers[-1].bias, 0.0)
 
-        linear_init_(self.enc_output[0])
+        linear_init(self.enc_output[0])
         xavier_uniform_(self.enc_output[0].weight)
         if self.learnt_init_query:
             xavier_uniform_(self.tgt_embed.weight)
         xavier_uniform_(self.query_pos_head.layers[0].weight)
         xavier_uniform_(self.query_pos_head.layers[1].weight)
         for layer in self.input_proj:
             xavier_uniform_(layer[0].weight)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/nn/modules/transformer.py` & `yolov8_pose_triton-8.2.0/ultralytics/nn/modules/transformer.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,28 +7,40 @@
 import torch.nn as nn
 import torch.nn.functional as F
 from torch.nn.init import constant_, xavier_uniform_
 
 from .conv import Conv
 from .utils import _get_clones, inverse_sigmoid, multi_scale_deformable_attn_pytorch
 
-__all__ = ('TransformerEncoderLayer', 'TransformerLayer', 'TransformerBlock', 'MLPBlock', 'LayerNorm2d', 'AIFI',
-           'DeformableTransformerDecoder', 'DeformableTransformerDecoderLayer', 'MSDeformAttn', 'MLP')
+__all__ = (
+    "TransformerEncoderLayer",
+    "TransformerLayer",
+    "TransformerBlock",
+    "MLPBlock",
+    "LayerNorm2d",
+    "AIFI",
+    "DeformableTransformerDecoder",
+    "DeformableTransformerDecoderLayer",
+    "MSDeformAttn",
+    "MLP",
+)
 
 
 class TransformerEncoderLayer(nn.Module):
     """Defines a single layer of the transformer encoder."""
 
     def __init__(self, c1, cm=2048, num_heads=8, dropout=0.0, act=nn.GELU(), normalize_before=False):
         """Initialize the TransformerEncoderLayer with specified parameters."""
         super().__init__()
         from ...utils.torch_utils import TORCH_1_9
+
         if not TORCH_1_9:
             raise ModuleNotFoundError(
-                'TransformerEncoderLayer() requires torch>=1.9 to use nn.MultiheadAttention(batch_first=True).')
+                "TransformerEncoderLayer() requires torch>=1.9 to use nn.MultiheadAttention(batch_first=True)."
+            )
         self.ma = nn.MultiheadAttention(c1, num_heads, dropout=dropout, batch_first=True)
         # Implementation of Feedforward model
         self.fc1 = nn.Linear(c1, cm)
         self.fc2 = nn.Linear(cm, c1)
 
         self.norm1 = nn.LayerNorm(c1)
         self.norm2 = nn.LayerNorm(c1)
@@ -85,22 +97,21 @@
         # Flatten [B, C, H, W] to [B, HxW, C]
         x = super().forward(x.flatten(2).permute(0, 2, 1), pos=pos_embed.to(device=x.device, dtype=x.dtype))
         return x.permute(0, 2, 1).view([-1, c, h, w]).contiguous()
 
     @staticmethod
     def build_2d_sincos_position_embedding(w, h, embed_dim=256, temperature=10000.0):
         """Builds 2D sine-cosine position embedding."""
-        grid_w = torch.arange(int(w), dtype=torch.float32)
-        grid_h = torch.arange(int(h), dtype=torch.float32)
-        grid_w, grid_h = torch.meshgrid(grid_w, grid_h, indexing='ij')
-        assert embed_dim % 4 == 0, \
-            'Embed dimension must be divisible by 4 for 2D sin-cos position embedding'
+        assert embed_dim % 4 == 0, "Embed dimension must be divisible by 4 for 2D sin-cos position embedding"
+        grid_w = torch.arange(w, dtype=torch.float32)
+        grid_h = torch.arange(h, dtype=torch.float32)
+        grid_w, grid_h = torch.meshgrid(grid_w, grid_h, indexing="ij")
         pos_dim = embed_dim // 4
         omega = torch.arange(pos_dim, dtype=torch.float32) / pos_dim
-        omega = 1. / (temperature ** omega)
+        omega = 1.0 / (temperature**omega)
 
         out_w = grid_w.flatten()[..., None] @ omega[None]
         out_h = grid_h.flatten()[..., None] @ omega[None]
 
         return torch.cat([torch.sin(out_w), torch.cos(out_w), torch.sin(out_h), torch.cos(out_h)], 1)[None]
 
 
@@ -200,27 +211,27 @@
         s = (x - u).pow(2).mean(1, keepdim=True)
         x = (x - u) / torch.sqrt(s + self.eps)
         return self.weight[:, None, None] * x + self.bias[:, None, None]
 
 
 class MSDeformAttn(nn.Module):
     """
-    Multi-Scale Deformable Attention Module based on Deformable-DETR and PaddleDetection implementations.
+    Multiscale Deformable Attention Module based on Deformable-DETR and PaddleDetection implementations.
 
     https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/ops/modules/ms_deform_attn.py
     """
 
     def __init__(self, d_model=256, n_levels=4, n_heads=8, n_points=4):
         """Initialize MSDeformAttn with the given parameters."""
         super().__init__()
         if d_model % n_heads != 0:
-            raise ValueError(f'd_model must be divisible by n_heads, but got {d_model} and {n_heads}')
+            raise ValueError(f"d_model must be divisible by n_heads, but got {d_model} and {n_heads}")
         _d_per_head = d_model // n_heads
         # Better to set _d_per_head to a power of 2 which is more efficient in a CUDA implementation
-        assert _d_per_head * n_heads == d_model, '`d_model` must be divisible by `n_heads`'
+        assert _d_per_head * n_heads == d_model, "`d_model` must be divisible by `n_heads`"
 
         self.im2col_step = 64
 
         self.d_model = d_model
         self.n_levels = n_levels
         self.n_heads = n_heads
         self.n_points = n_points
@@ -230,29 +241,32 @@
         self.value_proj = nn.Linear(d_model, d_model)
         self.output_proj = nn.Linear(d_model, d_model)
 
         self._reset_parameters()
 
     def _reset_parameters(self):
         """Reset module parameters."""
-        constant_(self.sampling_offsets.weight.data, 0.)
+        constant_(self.sampling_offsets.weight.data, 0.0)
         thetas = torch.arange(self.n_heads, dtype=torch.float32) * (2.0 * math.pi / self.n_heads)
         grid_init = torch.stack([thetas.cos(), thetas.sin()], -1)
-        grid_init = (grid_init / grid_init.abs().max(-1, keepdim=True)[0]).view(self.n_heads, 1, 1, 2).repeat(
-            1, self.n_levels, self.n_points, 1)
+        grid_init = (
+            (grid_init / grid_init.abs().max(-1, keepdim=True)[0])
+            .view(self.n_heads, 1, 1, 2)
+            .repeat(1, self.n_levels, self.n_points, 1)
+        )
         for i in range(self.n_points):
             grid_init[:, :, i, :] *= i + 1
         with torch.no_grad():
             self.sampling_offsets.bias = nn.Parameter(grid_init.view(-1))
-        constant_(self.attention_weights.weight.data, 0.)
-        constant_(self.attention_weights.bias.data, 0.)
+        constant_(self.attention_weights.weight.data, 0.0)
+        constant_(self.attention_weights.bias.data, 0.0)
         xavier_uniform_(self.value_proj.weight.data)
-        constant_(self.value_proj.bias.data, 0.)
+        constant_(self.value_proj.bias.data, 0.0)
         xavier_uniform_(self.output_proj.weight.data)
-        constant_(self.output_proj.bias.data, 0.)
+        constant_(self.output_proj.bias.data, 0.0)
 
     def forward(self, query, refer_bbox, value, value_shapes, value_mask=None):
         """
         Perform forward pass for multiscale deformable attention.
 
         https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py
 
@@ -284,28 +298,28 @@
             offset_normalizer = torch.as_tensor(value_shapes, dtype=query.dtype, device=query.device).flip(-1)
             add = sampling_offsets / offset_normalizer[None, None, None, :, None, :]
             sampling_locations = refer_bbox[:, :, None, :, None, :] + add
         elif num_points == 4:
             add = sampling_offsets / self.n_points * refer_bbox[:, :, None, :, None, 2:] * 0.5
             sampling_locations = refer_bbox[:, :, None, :, None, :2] + add
         else:
-            raise ValueError(f'Last dim of reference_points must be 2 or 4, but got {num_points}.')
+            raise ValueError(f"Last dim of reference_points must be 2 or 4, but got {num_points}.")
         output = multi_scale_deformable_attn_pytorch(value, value_shapes, sampling_locations, attention_weights)
         return self.output_proj(output)
 
 
 class DeformableTransformerDecoderLayer(nn.Module):
     """
     Deformable Transformer Decoder Layer inspired by PaddleDetection and Deformable-DETR implementations.
 
     https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py
     https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/deformable_transformer.py
     """
 
-    def __init__(self, d_model=256, n_heads=8, d_ffn=1024, dropout=0., act=nn.ReLU(), n_levels=4, n_points=4):
+    def __init__(self, d_model=256, n_heads=8, d_ffn=1024, dropout=0.0, act=nn.ReLU(), n_levels=4, n_points=4):
         """Initialize the DeformableTransformerDecoderLayer with the given parameters."""
         super().__init__()
 
         # Self attention
         self.self_attn = nn.MultiheadAttention(d_model, n_heads, dropout=dropout)
         self.dropout1 = nn.Dropout(dropout)
         self.norm1 = nn.LayerNorm(d_model)
@@ -335,22 +349,24 @@
         return self.norm3(tgt)
 
     def forward(self, embed, refer_bbox, feats, shapes, padding_mask=None, attn_mask=None, query_pos=None):
         """Perform the forward pass through the entire decoder layer."""
 
         # Self attention
         q = k = self.with_pos_embed(embed, query_pos)
-        tgt = self.self_attn(q.transpose(0, 1), k.transpose(0, 1), embed.transpose(0, 1),
-                             attn_mask=attn_mask)[0].transpose(0, 1)
+        tgt = self.self_attn(q.transpose(0, 1), k.transpose(0, 1), embed.transpose(0, 1), attn_mask=attn_mask)[
+            0
+        ].transpose(0, 1)
         embed = embed + self.dropout1(tgt)
         embed = self.norm1(embed)
 
         # Cross attention
-        tgt = self.cross_attn(self.with_pos_embed(embed, query_pos), refer_bbox.unsqueeze(2), feats, shapes,
-                              padding_mask)
+        tgt = self.cross_attn(
+            self.with_pos_embed(embed, query_pos), refer_bbox.unsqueeze(2), feats, shapes, padding_mask
+        )
         embed = embed + self.dropout2(tgt)
         embed = self.norm2(embed)
 
         # FFN
         return self.forward_ffn(embed)
 
 
@@ -366,24 +382,25 @@
         super().__init__()
         self.layers = _get_clones(decoder_layer, num_layers)
         self.num_layers = num_layers
         self.hidden_dim = hidden_dim
         self.eval_idx = eval_idx if eval_idx >= 0 else num_layers + eval_idx
 
     def forward(
-            self,
-            embed,  # decoder embeddings
-            refer_bbox,  # anchor
-            feats,  # image features
-            shapes,  # feature shapes
-            bbox_head,
-            score_head,
-            pos_mlp,
-            attn_mask=None,
-            padding_mask=None):
+        self,
+        embed,  # decoder embeddings
+        refer_bbox,  # anchor
+        feats,  # image features
+        shapes,  # feature shapes
+        bbox_head,
+        score_head,
+        pos_mlp,
+        attn_mask=None,
+        padding_mask=None,
+    ):
         """Perform the forward pass through the entire decoder."""
         output = embed
         dec_bboxes = []
         dec_cls = []
         last_refined_bbox = None
         refer_bbox = refer_bbox.sigmoid()
         for i, layer in enumerate(self.layers):
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/nn/modules/utils.py` & `yolov8_pose_triton-8.2.0/ultralytics/nn/modules/utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,75 +6,80 @@
 
 import numpy as np
 import torch
 import torch.nn as nn
 import torch.nn.functional as F
 from torch.nn.init import uniform_
 
-__all__ = 'multi_scale_deformable_attn_pytorch', 'inverse_sigmoid'
+__all__ = "multi_scale_deformable_attn_pytorch", "inverse_sigmoid"
 
 
 def _get_clones(module, n):
     """Create a list of cloned modules from the given module."""
     return nn.ModuleList([copy.deepcopy(module) for _ in range(n)])
 
 
 def bias_init_with_prob(prior_prob=0.01):
     """Initialize conv/fc bias value according to a given probability value."""
     return float(-np.log((1 - prior_prob) / prior_prob))  # return bias_init
 
 
-def linear_init_(module):
+def linear_init(module):
     """Initialize the weights and biases of a linear module."""
     bound = 1 / math.sqrt(module.weight.shape[0])
     uniform_(module.weight, -bound, bound)
-    if hasattr(module, 'bias') and module.bias is not None:
+    if hasattr(module, "bias") and module.bias is not None:
         uniform_(module.bias, -bound, bound)
 
 
 def inverse_sigmoid(x, eps=1e-5):
     """Calculate the inverse sigmoid function for a tensor."""
     x = x.clamp(min=0, max=1)
     x1 = x.clamp(min=eps)
     x2 = (1 - x).clamp(min=eps)
     return torch.log(x1 / x2)
 
 
-def multi_scale_deformable_attn_pytorch(value: torch.Tensor, value_spatial_shapes: torch.Tensor,
-                                        sampling_locations: torch.Tensor,
-                                        attention_weights: torch.Tensor) -> torch.Tensor:
+def multi_scale_deformable_attn_pytorch(
+    value: torch.Tensor,
+    value_spatial_shapes: torch.Tensor,
+    sampling_locations: torch.Tensor,
+    attention_weights: torch.Tensor,
+) -> torch.Tensor:
     """
-    Multi-scale deformable attention.
+    Multiscale deformable attention.
 
     https://github.com/IDEA-Research/detrex/blob/main/detrex/layers/multi_scale_deform_attn.py
     """
 
     bs, _, num_heads, embed_dims = value.shape
     _, num_queries, num_heads, num_levels, num_points, _ = sampling_locations.shape
     value_list = value.split([H_ * W_ for H_, W_ in value_spatial_shapes], dim=1)
     sampling_grids = 2 * sampling_locations - 1
     sampling_value_list = []
     for level, (H_, W_) in enumerate(value_spatial_shapes):
         # bs, H_*W_, num_heads, embed_dims ->
         # bs, H_*W_, num_heads*embed_dims ->
         # bs, num_heads*embed_dims, H_*W_ ->
         # bs*num_heads, embed_dims, H_, W_
-        value_l_ = (value_list[level].flatten(2).transpose(1, 2).reshape(bs * num_heads, embed_dims, H_, W_))
+        value_l_ = value_list[level].flatten(2).transpose(1, 2).reshape(bs * num_heads, embed_dims, H_, W_)
         # bs, num_queries, num_heads, num_points, 2 ->
         # bs, num_heads, num_queries, num_points, 2 ->
         # bs*num_heads, num_queries, num_points, 2
         sampling_grid_l_ = sampling_grids[:, :, :, level].transpose(1, 2).flatten(0, 1)
         # bs*num_heads, embed_dims, num_queries, num_points
-        sampling_value_l_ = F.grid_sample(value_l_,
-                                          sampling_grid_l_,
-                                          mode='bilinear',
-                                          padding_mode='zeros',
-                                          align_corners=False)
+        sampling_value_l_ = F.grid_sample(
+            value_l_, sampling_grid_l_, mode="bilinear", padding_mode="zeros", align_corners=False
+        )
         sampling_value_list.append(sampling_value_l_)
     # (bs, num_queries, num_heads, num_levels, num_points) ->
     # (bs, num_heads, num_queries, num_levels, num_points) ->
     # (bs, num_heads, 1, num_queries, num_levels*num_points)
-    attention_weights = attention_weights.transpose(1, 2).reshape(bs * num_heads, 1, num_queries,
-                                                                  num_levels * num_points)
-    output = ((torch.stack(sampling_value_list, dim=-2).flatten(-2) * attention_weights).sum(-1).view(
-        bs, num_heads * embed_dims, num_queries))
+    attention_weights = attention_weights.transpose(1, 2).reshape(
+        bs * num_heads, 1, num_queries, num_levels * num_points
+    )
+    output = (
+        (torch.stack(sampling_value_list, dim=-2).flatten(-2) * attention_weights)
+        .sum(-1)
+        .view(bs, num_heads * embed_dims, num_queries)
+    )
     return output.transpose(1, 2).contiguous()
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/nn/tasks.py` & `yolov8_pose_triton-8.2.0/ultralytics/nn/tasks.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,24 +3,71 @@
 import contextlib
 from copy import deepcopy
 from pathlib import Path
 
 import torch
 import torch.nn as nn
 
-from ultralytics.nn.modules import (AIFI, C1, C2, C3, C3TR, SPP, SPPF, Bottleneck, BottleneckCSP, C2f, C3Ghost, C3x,
-                                    Classify, Concat, Conv, Conv2, ConvTranspose, Detect, DWConv, DWConvTranspose2d,
-                                    Focus, GhostBottleneck, GhostConv, HGBlock, HGStem, Pose, RepC3, RepConv,
-                                    RTDETRDecoder, Segment)
+from ultralytics.nn.modules import (
+    AIFI,
+    C1,
+    C2,
+    C3,
+    C3TR,
+    OBB,
+    SPP,
+    SPPELAN,
+    SPPF,
+    ADown,
+    Bottleneck,
+    BottleneckCSP,
+    C2f,
+    C2fAttn,
+    C3Ghost,
+    C3x,
+    CBFuse,
+    CBLinear,
+    Classify,
+    Concat,
+    Conv,
+    Conv2,
+    ConvTranspose,
+    Detect,
+    DWConv,
+    DWConvTranspose2d,
+    Focus,
+    GhostBottleneck,
+    GhostConv,
+    HGBlock,
+    HGStem,
+    ImagePoolingAttn,
+    Pose,
+    RepC3,
+    RepConv,
+    RepNCSPELAN4,
+    ResNetLayer,
+    RTDETRDecoder,
+    Segment,
+    Silence,
+    WorldDetect,
+)
 from ultralytics.utils import DEFAULT_CFG_DICT, DEFAULT_CFG_KEYS, LOGGER, colorstr, emojis, yaml_load
 from ultralytics.utils.checks import check_requirements, check_suffix, check_yaml
-from ultralytics.utils.loss import v8ClassificationLoss, v8DetectionLoss, v8PoseLoss, v8SegmentationLoss
+from ultralytics.utils.loss import v8ClassificationLoss, v8DetectionLoss, v8OBBLoss, v8PoseLoss, v8SegmentationLoss
 from ultralytics.utils.plotting import feature_visualization
-from ultralytics.utils.torch_utils import (fuse_conv_and_bn, fuse_deconv_and_bn, initialize_weights, intersect_dicts,
-                                           make_divisible, model_info, scale_img, time_sync)
+from ultralytics.utils.torch_utils import (
+    fuse_conv_and_bn,
+    fuse_deconv_and_bn,
+    initialize_weights,
+    intersect_dicts,
+    make_divisible,
+    model_info,
+    scale_img,
+    time_sync,
+)
 
 try:
     import thop
 except ImportError:
     thop = None
 
 
@@ -37,59 +84,67 @@
         Returns:
             (torch.Tensor): The output of the network.
         """
         if isinstance(x, dict):  # for cases of training and validating while training.
             return self.loss(x, *args, **kwargs)
         return self.predict(x, *args, **kwargs)
 
-    def predict(self, x, profile=False, visualize=False, augment=False):
+    def predict(self, x, profile=False, visualize=False, augment=False, embed=None):
         """
         Perform a forward pass through the network.
 
         Args:
             x (torch.Tensor): The input tensor to the model.
             profile (bool):  Print the computation time of each layer if True, defaults to False.
             visualize (bool): Save the feature maps of the model if True, defaults to False.
             augment (bool): Augment image during prediction, defaults to False.
+            embed (list, optional): A list of feature vectors/embeddings to return.
 
         Returns:
             (torch.Tensor): The last output of the model.
         """
         if augment:
             return self._predict_augment(x)
-        return self._predict_once(x, profile, visualize)
+        return self._predict_once(x, profile, visualize, embed)
 
-    def _predict_once(self, x, profile=False, visualize=False):
+    def _predict_once(self, x, profile=False, visualize=False, embed=None):
         """
         Perform a forward pass through the network.
 
         Args:
             x (torch.Tensor): The input tensor to the model.
             profile (bool):  Print the computation time of each layer if True, defaults to False.
             visualize (bool): Save the feature maps of the model if True, defaults to False.
+            embed (list, optional): A list of feature vectors/embeddings to return.
 
         Returns:
             (torch.Tensor): The last output of the model.
         """
-        y, dt = [], []  # outputs
+        y, dt, embeddings = [], [], []  # outputs
         for m in self.model:
             if m.f != -1:  # if not from previous layer
                 x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers
             if profile:
                 self._profile_one_layer(m, x, dt)
             x = m(x)  # run
             y.append(x if m.i in self.save else None)  # save output
             if visualize:
                 feature_visualization(x, m.type, m.i, save_dir=visualize)
+            if embed and m.i in embed:
+                embeddings.append(nn.functional.adaptive_avg_pool2d(x, (1, 1)).squeeze(-1).squeeze(-1))  # flatten
+                if m.i == max(embed):
+                    return torch.unbind(torch.cat(embeddings, 1), dim=0)
         return x
 
     def _predict_augment(self, x):
         """Perform augmentations on input image x and return augmented inference."""
-        LOGGER.warning(f'WARNING  {self.__class__.__name__} does not support augmented inference yet. '
-                       f'Reverting to single-scale inference instead.')
+        LOGGER.warning(
+            f"WARNING  {self.__class__.__name__} does not support augmented inference yet. "
+            f"Reverting to single-scale inference instead."
+        )
         return self._predict_once(x)
 
     def _profile_one_layer(self, m, x, dt):
         """
         Profile the computation time and FLOPs of a single layer of the model on a given input. Appends the results to
         the provided list.
 
@@ -98,44 +153,44 @@
             x (torch.Tensor): The input data to the layer.
             dt (list): A list to store the computation time of the layer.
 
         Returns:
             None
         """
         c = m == self.model[-1] and isinstance(x, list)  # is final layer list, copy input as inplace fix
-        flops = thop.profile(m, inputs=[x.copy() if c else x], verbose=False)[0] / 1E9 * 2 if thop else 0  # FLOPs
+        flops = thop.profile(m, inputs=[x.copy() if c else x], verbose=False)[0] / 1e9 * 2 if thop else 0  # FLOPs
         t = time_sync()
         for _ in range(10):
             m(x.copy() if c else x)
         dt.append((time_sync() - t) * 100)
         if m == self.model[0]:
             LOGGER.info(f"{'time (ms)':>10s} {'GFLOPs':>10s} {'params':>10s}  module")
-        LOGGER.info(f'{dt[-1]:10.2f} {flops:10.2f} {m.np:10.0f}  {m.type}')
+        LOGGER.info(f"{dt[-1]:10.2f} {flops:10.2f} {m.np:10.0f}  {m.type}")
         if c:
             LOGGER.info(f"{sum(dt):10.2f} {'-':>10s} {'-':>10s}  Total")
 
     def fuse(self, verbose=True):
         """
         Fuse the `Conv2d()` and `BatchNorm2d()` layers of the model into a single layer, in order to improve the
         computation efficiency.
 
         Returns:
             (nn.Module): The fused model is returned.
         """
         if not self.is_fused():
             for m in self.model.modules():
-                if isinstance(m, (Conv, Conv2, DWConv)) and hasattr(m, 'bn'):
+                if isinstance(m, (Conv, Conv2, DWConv)) and hasattr(m, "bn"):
                     if isinstance(m, Conv2):
                         m.fuse_convs()
                     m.conv = fuse_conv_and_bn(m.conv, m.bn)  # update conv
-                    delattr(m, 'bn')  # remove batchnorm
+                    delattr(m, "bn")  # remove batchnorm
                     m.forward = m.forward_fuse  # update forward
-                if isinstance(m, ConvTranspose) and hasattr(m, 'bn'):
+                if isinstance(m, ConvTranspose) and hasattr(m, "bn"):
                     m.conv_transpose = fuse_deconv_and_bn(m.conv_transpose, m.bn)
-                    delattr(m, 'bn')  # remove batchnorm
+                    delattr(m, "bn")  # remove batchnorm
                     m.forward = m.forward_fuse  # update forward
                 if isinstance(m, RepConv):
                     m.fuse_convs()
                     m.forward = m.forward_fuse  # update forward
             self.info(verbose=verbose)
 
         return self
@@ -146,15 +201,15 @@
 
         Args:
             thresh (int, optional): The threshold number of BatchNorm layers. Default is 10.
 
         Returns:
             (bool): True if the number of BatchNorm layers in the model is less than the threshold, False otherwise.
         """
-        bn = tuple(v for k, v in nn.__dict__.items() if 'Norm' in k)  # normalization layers, i.e. BatchNorm2d()
+        bn = tuple(v for k, v in nn.__dict__.items() if "Norm" in k)  # normalization layers, i.e. BatchNorm2d()
         return sum(isinstance(v, bn) for v in self.modules()) < thresh  # True if < 'thresh' BatchNorm layers in model
 
     def info(self, detailed=False, verbose=True, imgsz=640):
         """
         Prints model information.
 
         Args:
@@ -172,88 +227,88 @@
             fn (function): the function to apply to the model
 
         Returns:
             (BaseModel): An updated BaseModel object.
         """
         self = super()._apply(fn)
         m = self.model[-1]  # Detect()
-        if isinstance(m, (Detect, Segment)):
+        if isinstance(m, Detect):  # includes all Detect subclasses like Segment, Pose, OBB, WorldDetect
             m.stride = fn(m.stride)
             m.anchors = fn(m.anchors)
             m.strides = fn(m.strides)
         return self
 
     def load(self, weights, verbose=True):
         """
         Load the weights into the model.
 
         Args:
             weights (dict | torch.nn.Module): The pre-trained weights to be loaded.
             verbose (bool, optional): Whether to log the transfer progress. Defaults to True.
         """
-        model = weights['model'] if isinstance(weights, dict) else weights  # torchvision models are not dicts
+        model = weights["model"] if isinstance(weights, dict) else weights  # torchvision models are not dicts
         csd = model.float().state_dict()  # checkpoint state_dict as FP32
         csd = intersect_dicts(csd, self.state_dict())  # intersect
         self.load_state_dict(csd, strict=False)  # load
         if verbose:
-            LOGGER.info(f'Transferred {len(csd)}/{len(self.model.state_dict())} items from pretrained weights')
+            LOGGER.info(f"Transferred {len(csd)}/{len(self.model.state_dict())} items from pretrained weights")
 
     def loss(self, batch, preds=None):
         """
         Compute loss.
 
         Args:
             batch (dict): Batch to compute loss on
             preds (torch.Tensor | List[torch.Tensor]): Predictions.
         """
-        if not hasattr(self, 'criterion'):
+        if not hasattr(self, "criterion"):
             self.criterion = self.init_criterion()
 
-        preds = self.forward(batch['img']) if preds is None else preds
+        preds = self.forward(batch["img"]) if preds is None else preds
         return self.criterion(preds, batch)
 
     def init_criterion(self):
         """Initialize the loss criterion for the BaseModel."""
-        raise NotImplementedError('compute_loss() needs to be implemented by task heads')
+        raise NotImplementedError("compute_loss() needs to be implemented by task heads")
 
 
 class DetectionModel(BaseModel):
     """YOLOv8 detection model."""
 
-    def __init__(self, cfg='yolov8n.yaml', ch=3, nc=None, verbose=True):  # model, input channels, number of classes
+    def __init__(self, cfg="yolov8n.yaml", ch=3, nc=None, verbose=True):  # model, input channels, number of classes
         """Initialize the YOLOv8 detection model with the given config and parameters."""
         super().__init__()
         self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict
 
         # Define model
-        ch = self.yaml['ch'] = self.yaml.get('ch', ch)  # input channels
-        if nc and nc != self.yaml['nc']:
+        ch = self.yaml["ch"] = self.yaml.get("ch", ch)  # input channels
+        if nc and nc != self.yaml["nc"]:
             LOGGER.info(f"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}")
-            self.yaml['nc'] = nc  # override YAML value
+            self.yaml["nc"] = nc  # override YAML value
         self.model, self.save = parse_model(deepcopy(self.yaml), ch=ch, verbose=verbose)  # model, savelist
-        self.names = {i: f'{i}' for i in range(self.yaml['nc'])}  # default names dict
-        self.inplace = self.yaml.get('inplace', True)
+        self.names = {i: f"{i}" for i in range(self.yaml["nc"])}  # default names dict
+        self.inplace = self.yaml.get("inplace", True)
 
         # Build strides
         m = self.model[-1]  # Detect()
-        if isinstance(m, (Detect, Segment, Pose)):
+        if isinstance(m, Detect):  # includes all Detect subclasses like Segment, Pose, OBB, WorldDetect
             s = 256  # 2x min stride
             m.inplace = self.inplace
-            forward = lambda x: self.forward(x)[0] if isinstance(m, (Segment, Pose)) else self.forward(x)
+            forward = lambda x: self.forward(x)[0] if isinstance(m, (Segment, Pose, OBB)) else self.forward(x)
             m.stride = torch.tensor([s / x.shape[-2] for x in forward(torch.zeros(1, ch, s, s))])  # forward
             self.stride = m.stride
             m.bias_init()  # only run once
         else:
             self.stride = torch.Tensor([32])  # default stride for i.e. RTDETR
 
         # Init weights, biases
         initialize_weights(self)
         if verbose:
             self.info()
-            LOGGER.info('')
+            LOGGER.info("")
 
     def _predict_augment(self, x):
         """Perform augmentations on input image x and return augmented inference and train outputs."""
         img_size = x.shape[-2:]  # height, width
         s = [1, 0.83, 0.67]  # scales
         f = [None, 3, None]  # flips (2-ud, 3-lr)
         y = []  # outputs
@@ -275,84 +330,96 @@
         elif flips == 3:
             x = img_size[1] - x  # de-flip lr
         return torch.cat((x, y, wh, cls), dim)
 
     def _clip_augmented(self, y):
         """Clip YOLO augmented inference tails."""
         nl = self.model[-1].nl  # number of detection layers (P3-P5)
-        g = sum(4 ** x for x in range(nl))  # grid points
+        g = sum(4**x for x in range(nl))  # grid points
         e = 1  # exclude layer count
-        i = (y[0].shape[-1] // g) * sum(4 ** x for x in range(e))  # indices
+        i = (y[0].shape[-1] // g) * sum(4**x for x in range(e))  # indices
         y[0] = y[0][..., :-i]  # large
         i = (y[-1].shape[-1] // g) * sum(4 ** (nl - 1 - x) for x in range(e))  # indices
         y[-1] = y[-1][..., i:]  # small
         return y
 
     def init_criterion(self):
         """Initialize the loss criterion for the DetectionModel."""
         return v8DetectionLoss(self)
 
 
+class OBBModel(DetectionModel):
+    """YOLOv8 Oriented Bounding Box (OBB) model."""
+
+    def __init__(self, cfg="yolov8n-obb.yaml", ch=3, nc=None, verbose=True):
+        """Initialize YOLOv8 OBB model with given config and parameters."""
+        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)
+
+    def init_criterion(self):
+        """Initialize the loss criterion for the model."""
+        return v8OBBLoss(self)
+
+
 class SegmentationModel(DetectionModel):
     """YOLOv8 segmentation model."""
 
-    def __init__(self, cfg='yolov8n-seg.yaml', ch=3, nc=None, verbose=True):
+    def __init__(self, cfg="yolov8n-seg.yaml", ch=3, nc=None, verbose=True):
         """Initialize YOLOv8 segmentation model with given config and parameters."""
         super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)
 
     def init_criterion(self):
         """Initialize the loss criterion for the SegmentationModel."""
         return v8SegmentationLoss(self)
 
 
 class PoseModel(DetectionModel):
     """YOLOv8 pose model."""
 
-    def __init__(self, cfg='yolov8n-pose.yaml', ch=3, nc=None, data_kpt_shape=(None, None), verbose=True):
+    def __init__(self, cfg="yolov8n-pose.yaml", ch=3, nc=None, data_kpt_shape=(None, None), verbose=True):
         """Initialize YOLOv8 Pose model."""
         if not isinstance(cfg, dict):
             cfg = yaml_model_load(cfg)  # load model YAML
-        if any(data_kpt_shape) and list(data_kpt_shape) != list(cfg['kpt_shape']):
+        if any(data_kpt_shape) and list(data_kpt_shape) != list(cfg["kpt_shape"]):
             LOGGER.info(f"Overriding model.yaml kpt_shape={cfg['kpt_shape']} with kpt_shape={data_kpt_shape}")
-            cfg['kpt_shape'] = data_kpt_shape
+            cfg["kpt_shape"] = data_kpt_shape
         super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)
 
     def init_criterion(self):
         """Initialize the loss criterion for the PoseModel."""
         return v8PoseLoss(self)
 
 
 class ClassificationModel(BaseModel):
     """YOLOv8 classification model."""
 
-    def __init__(self, cfg='yolov8n-cls.yaml', ch=3, nc=None, verbose=True):
+    def __init__(self, cfg="yolov8n-cls.yaml", ch=3, nc=None, verbose=True):
         """Init ClassificationModel with YAML, channels, number of classes, verbose flag."""
         super().__init__()
         self._from_yaml(cfg, ch, nc, verbose)
 
     def _from_yaml(self, cfg, ch, nc, verbose):
         """Set YOLOv8 model configurations and define the model architecture."""
         self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict
 
         # Define model
-        ch = self.yaml['ch'] = self.yaml.get('ch', ch)  # input channels
-        if nc and nc != self.yaml['nc']:
+        ch = self.yaml["ch"] = self.yaml.get("ch", ch)  # input channels
+        if nc and nc != self.yaml["nc"]:
             LOGGER.info(f"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}")
-            self.yaml['nc'] = nc  # override YAML value
-        elif not nc and not self.yaml.get('nc', None):
-            raise ValueError('nc not specified. Must specify nc in model.yaml or function arguments.')
+            self.yaml["nc"] = nc  # override YAML value
+        elif not nc and not self.yaml.get("nc", None):
+            raise ValueError("nc not specified. Must specify nc in model.yaml or function arguments.")
         self.model, self.save = parse_model(deepcopy(self.yaml), ch=ch, verbose=verbose)  # model, savelist
         self.stride = torch.Tensor([1])  # no stride constraints
-        self.names = {i: f'{i}' for i in range(self.yaml['nc'])}  # default names dict
+        self.names = {i: f"{i}" for i in range(self.yaml["nc"])}  # default names dict
         self.info()
 
     @staticmethod
     def reshape_outputs(model, nc):
         """Update a TorchVision classification model to class count 'n' if required."""
-        name, m = list((model.model if hasattr(model, 'model') else model).named_children())[-1]  # last module
+        name, m = list((model.model if hasattr(model, "model") else model).named_children())[-1]  # last module
         if isinstance(m, Classify):  # YOLO Classify() head
             if m.linear.out_features != nc:
                 m.linear = nn.Linear(m.linear.in_features, nc)
         elif isinstance(m, nn.Linear):  # ResNet, EfficientNet
             if m.out_features != nc:
                 setattr(model, name, nn.Linear(m.in_features, nc))
         elif isinstance(m, nn.Sequential):
@@ -387,15 +454,15 @@
 
     Methods:
         init_criterion: Initializes the criterion used for loss calculation.
         loss: Computes and returns the loss during training.
         predict: Performs a forward pass through the network and returns the output.
     """
 
-    def __init__(self, cfg='rtdetr-l.yaml', ch=3, nc=None, verbose=True):
+    def __init__(self, cfg="rtdetr-l.yaml", ch=3, nc=None, verbose=True):
         """
         Initialize the RTDETRDetectionModel.
 
         Args:
             cfg (str): Configuration file name or path.
             ch (int): Number of input channels.
             nc (int, optional): Number of classes. Defaults to None.
@@ -416,77 +483,171 @@
         Args:
             batch (dict): Dictionary containing image and label data.
             preds (torch.Tensor, optional): Precomputed model predictions. Defaults to None.
 
         Returns:
             (tuple): A tuple containing the total loss and main three losses in a tensor.
         """
-        if not hasattr(self, 'criterion'):
+        if not hasattr(self, "criterion"):
             self.criterion = self.init_criterion()
 
-        img = batch['img']
+        img = batch["img"]
         # NOTE: preprocess gt_bbox and gt_labels to list.
         bs = len(img)
-        batch_idx = batch['batch_idx']
+        batch_idx = batch["batch_idx"]
         gt_groups = [(batch_idx == i).sum().item() for i in range(bs)]
         targets = {
-            'cls': batch['cls'].to(img.device, dtype=torch.long).view(-1),
-            'bboxes': batch['bboxes'].to(device=img.device),
-            'batch_idx': batch_idx.to(img.device, dtype=torch.long).view(-1),
-            'gt_groups': gt_groups}
+            "cls": batch["cls"].to(img.device, dtype=torch.long).view(-1),
+            "bboxes": batch["bboxes"].to(device=img.device),
+            "batch_idx": batch_idx.to(img.device, dtype=torch.long).view(-1),
+            "gt_groups": gt_groups,
+        }
 
         preds = self.predict(img, batch=targets) if preds is None else preds
         dec_bboxes, dec_scores, enc_bboxes, enc_scores, dn_meta = preds if self.training else preds[1]
         if dn_meta is None:
             dn_bboxes, dn_scores = None, None
         else:
-            dn_bboxes, dec_bboxes = torch.split(dec_bboxes, dn_meta['dn_num_split'], dim=2)
-            dn_scores, dec_scores = torch.split(dec_scores, dn_meta['dn_num_split'], dim=2)
+            dn_bboxes, dec_bboxes = torch.split(dec_bboxes, dn_meta["dn_num_split"], dim=2)
+            dn_scores, dec_scores = torch.split(dec_scores, dn_meta["dn_num_split"], dim=2)
 
         dec_bboxes = torch.cat([enc_bboxes.unsqueeze(0), dec_bboxes])  # (7, bs, 300, 4)
         dec_scores = torch.cat([enc_scores.unsqueeze(0), dec_scores])
 
-        loss = self.criterion((dec_bboxes, dec_scores),
-                              targets,
-                              dn_bboxes=dn_bboxes,
-                              dn_scores=dn_scores,
-                              dn_meta=dn_meta)
+        loss = self.criterion(
+            (dec_bboxes, dec_scores), targets, dn_bboxes=dn_bboxes, dn_scores=dn_scores, dn_meta=dn_meta
+        )
         # NOTE: There are like 12 losses in RTDETR, backward with all losses but only show the main three losses.
-        return sum(loss.values()), torch.as_tensor([loss[k].detach() for k in ['loss_giou', 'loss_class', 'loss_bbox']],
-                                                   device=img.device)
+        return sum(loss.values()), torch.as_tensor(
+            [loss[k].detach() for k in ["loss_giou", "loss_class", "loss_bbox"]], device=img.device
+        )
 
-    def predict(self, x, profile=False, visualize=False, batch=None, augment=False):
+    def predict(self, x, profile=False, visualize=False, batch=None, augment=False, embed=None):
         """
         Perform a forward pass through the model.
 
         Args:
             x (torch.Tensor): The input tensor.
             profile (bool, optional): If True, profile the computation time for each layer. Defaults to False.
             visualize (bool, optional): If True, save feature maps for visualization. Defaults to False.
             batch (dict, optional): Ground truth data for evaluation. Defaults to None.
             augment (bool, optional): If True, perform data augmentation during inference. Defaults to False.
+            embed (list, optional): A list of feature vectors/embeddings to return.
 
         Returns:
             (torch.Tensor): Model's output tensor.
         """
-        y, dt = [], []  # outputs
+        y, dt, embeddings = [], [], []  # outputs
         for m in self.model[:-1]:  # except the head part
             if m.f != -1:  # if not from previous layer
                 x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers
             if profile:
                 self._profile_one_layer(m, x, dt)
             x = m(x)  # run
             y.append(x if m.i in self.save else None)  # save output
             if visualize:
                 feature_visualization(x, m.type, m.i, save_dir=visualize)
+            if embed and m.i in embed:
+                embeddings.append(nn.functional.adaptive_avg_pool2d(x, (1, 1)).squeeze(-1).squeeze(-1))  # flatten
+                if m.i == max(embed):
+                    return torch.unbind(torch.cat(embeddings, 1), dim=0)
         head = self.model[-1]
         x = head([y[j] for j in head.f], batch)  # head inference
         return x
 
 
+class WorldModel(DetectionModel):
+    """YOLOv8 World Model."""
+
+    def __init__(self, cfg="yolov8s-world.yaml", ch=3, nc=None, verbose=True):
+        """Initialize YOLOv8 world model with given config and parameters."""
+        self.txt_feats = torch.randn(1, nc or 80, 512)  # features placeholder
+        self.clip_model = None  # CLIP model placeholder
+        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)
+
+    def set_classes(self, text, batch=80, cache_clip_model=True):
+        """Set classes in advance so that model could do offline-inference without clip model."""
+        try:
+            import clip
+        except ImportError:
+            check_requirements("git+https://github.com/ultralytics/CLIP.git")
+            import clip
+
+        if (
+            not getattr(self, "clip_model", None) and cache_clip_model
+        ):  # for backwards compatibility of models lacking clip_model attribute
+            self.clip_model = clip.load("ViT-B/32")[0]
+        model = self.clip_model if cache_clip_model else clip.load("ViT-B/32")[0]
+        device = next(model.parameters()).device
+        text_token = clip.tokenize(text).to(device)
+        txt_feats = [model.encode_text(token).detach() for token in text_token.split(batch)]
+        txt_feats = txt_feats[0] if len(txt_feats) == 1 else torch.cat(txt_feats, dim=0)
+        txt_feats = txt_feats / txt_feats.norm(p=2, dim=-1, keepdim=True)
+        self.txt_feats = txt_feats.reshape(-1, len(text), txt_feats.shape[-1])
+        self.model[-1].nc = len(text)
+
+    def predict(self, x, profile=False, visualize=False, txt_feats=None, augment=False, embed=None):
+        """
+        Perform a forward pass through the model.
+
+        Args:
+            x (torch.Tensor): The input tensor.
+            profile (bool, optional): If True, profile the computation time for each layer. Defaults to False.
+            visualize (bool, optional): If True, save feature maps for visualization. Defaults to False.
+            txt_feats (torch.Tensor): The text features, use it if it's given. Defaults to None.
+            augment (bool, optional): If True, perform data augmentation during inference. Defaults to False.
+            embed (list, optional): A list of feature vectors/embeddings to return.
+
+        Returns:
+            (torch.Tensor): Model's output tensor.
+        """
+        txt_feats = (self.txt_feats if txt_feats is None else txt_feats).to(device=x.device, dtype=x.dtype)
+        if len(txt_feats) != len(x):
+            txt_feats = txt_feats.repeat(len(x), 1, 1)
+        ori_txt_feats = txt_feats.clone()
+        y, dt, embeddings = [], [], []  # outputs
+        for m in self.model:  # except the head part
+            if m.f != -1:  # if not from previous layer
+                x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers
+            if profile:
+                self._profile_one_layer(m, x, dt)
+            if isinstance(m, C2fAttn):
+                x = m(x, txt_feats)
+            elif isinstance(m, WorldDetect):
+                x = m(x, ori_txt_feats)
+            elif isinstance(m, ImagePoolingAttn):
+                txt_feats = m(x, txt_feats)
+            else:
+                x = m(x)  # run
+
+            y.append(x if m.i in self.save else None)  # save output
+            if visualize:
+                feature_visualization(x, m.type, m.i, save_dir=visualize)
+            if embed and m.i in embed:
+                embeddings.append(nn.functional.adaptive_avg_pool2d(x, (1, 1)).squeeze(-1).squeeze(-1))  # flatten
+                if m.i == max(embed):
+                    return torch.unbind(torch.cat(embeddings, 1), dim=0)
+        return x
+
+    def loss(self, batch, preds=None):
+        """
+        Compute loss.
+
+        Args:
+            batch (dict): Batch to compute loss on.
+            preds (torch.Tensor | List[torch.Tensor]): Predictions.
+        """
+        if not hasattr(self, "criterion"):
+            self.criterion = self.init_criterion()
+
+        if preds is None:
+            preds = self.forward(batch["img"], txt_feats=batch["txt_feats"])
+        return self.criterion(preds, batch)
+
+
 class Ensemble(nn.ModuleList):
     """Ensemble of models."""
 
     def __init__(self):
         """Initialize an ensemble of models."""
         super().__init__()
 
@@ -526,14 +687,15 @@
         applications or libraries. Use this function with caution.
     """
     if not modules:
         modules = {}
 
     import importlib
     import sys
+
     try:
         # Set modules in sys.modules under their old name
         for old, new in modules.items():
             sys.modules[old] = importlib.import_module(new)
 
         yield
     finally:
@@ -553,200 +715,252 @@
         weight (str): The file path of the PyTorch model.
 
     Returns:
         (dict): The loaded PyTorch model.
     """
     from ultralytics.utils.downloads import attempt_download_asset
 
-    check_suffix(file=weight, suffix='.pt')
+    check_suffix(file=weight, suffix=".pt")
     file = attempt_download_asset(weight)  # search online if missing locally
     try:
-        with temporary_modules({
-                'ultralytics.yolo.utils': 'ultralytics.utils',
-                'ultralytics.yolo.v8': 'ultralytics.models.yolo',
-                'ultralytics.yolo.data': 'ultralytics.data'}):  # for legacy 8.0 Classify and Pose models
-            return torch.load(file, map_location='cpu'), file  # load
+        with temporary_modules(
+            {
+                "ultralytics.yolo.utils": "ultralytics.utils",
+                "ultralytics.yolo.v8": "ultralytics.models.yolo",
+                "ultralytics.yolo.data": "ultralytics.data",
+            }
+        ):  # for legacy 8.0 Classify and Pose models
+            ckpt = torch.load(file, map_location="cpu")
 
     except ModuleNotFoundError as e:  # e.name is missing module name
-        if e.name == 'models':
+        if e.name == "models":
             raise TypeError(
-                emojis(f'ERROR  {weight} appears to be an Ultralytics YOLOv5 model originally trained '
-                       f'with https://github.com/ultralytics/yolov5.\nThis model is NOT forwards compatible with '
-                       f'YOLOv8 at https://github.com/ultralytics/ultralytics.'
-                       f"\nRecommend fixes are to train a new model using the latest 'ultralytics' package or to "
-                       f"run a command with an official YOLOv8 model, i.e. 'yolo predict model=yolov8n.pt'")) from e
-        LOGGER.warning(f"WARNING  {weight} appears to require '{e.name}', which is not in ultralytics requirements."
-                       f"\nAutoInstall will run now for '{e.name}' but this feature will be removed in the future."
-                       f"\nRecommend fixes are to train a new model using the latest 'ultralytics' package or to "
-                       f"run a command with an official YOLOv8 model, i.e. 'yolo predict model=yolov8n.pt'")
+                emojis(
+                    f"ERROR  {weight} appears to be an Ultralytics YOLOv5 model originally trained "
+                    f"with https://github.com/ultralytics/yolov5.\nThis model is NOT forwards compatible with "
+                    f"YOLOv8 at https://github.com/ultralytics/ultralytics."
+                    f"\nRecommend fixes are to train a new model using the latest 'ultralytics' package or to "
+                    f"run a command with an official YOLOv8 model, i.e. 'yolo predict model=yolov8n.pt'"
+                )
+            ) from e
+        LOGGER.warning(
+            f"WARNING  {weight} appears to require '{e.name}', which is not in ultralytics requirements."
+            f"\nAutoInstall will run now for '{e.name}' but this feature will be removed in the future."
+            f"\nRecommend fixes are to train a new model using the latest 'ultralytics' package or to "
+            f"run a command with an official YOLOv8 model, i.e. 'yolo predict model=yolov8n.pt'"
+        )
         check_requirements(e.name)  # install missing module
+        ckpt = torch.load(file, map_location="cpu")
+
+    if not isinstance(ckpt, dict):
+        # File is likely a YOLO instance saved with i.e. torch.save(model, "saved_model.pt")
+        LOGGER.warning(
+            f"WARNING  The file '{weight}' appears to be improperly saved or formatted. "
+            f"For optimal results, use model.save('filename.pt') to correctly save YOLO models."
+        )
+        ckpt = {"model": ckpt.model}
 
-        return torch.load(file, map_location='cpu'), file  # load
+    return ckpt, file  # load
 
 
 def attempt_load_weights(weights, device=None, inplace=True, fuse=False):
     """Loads an ensemble of models weights=[a,b,c] or a single model weights=[a] or weights=a."""
 
     ensemble = Ensemble()
     for w in weights if isinstance(weights, list) else [weights]:
         ckpt, w = torch_safe_load(w)  # load ckpt
-        args = {**DEFAULT_CFG_DICT, **ckpt['train_args']} if 'train_args' in ckpt else None  # combined args
-        model = (ckpt.get('ema') or ckpt['model']).to(device).float()  # FP32 model
+        args = {**DEFAULT_CFG_DICT, **ckpt["train_args"]} if "train_args" in ckpt else None  # combined args
+        model = (ckpt.get("ema") or ckpt["model"]).to(device).float()  # FP32 model
 
         # Model compatibility updates
         model.args = args  # attach args to model
         model.pt_path = w  # attach *.pt file path to model
         model.task = guess_model_task(model)
-        if not hasattr(model, 'stride'):
-            model.stride = torch.tensor([32.])
+        if not hasattr(model, "stride"):
+            model.stride = torch.tensor([32.0])
 
         # Append
-        ensemble.append(model.fuse().eval() if fuse and hasattr(model, 'fuse') else model.eval())  # model in eval mode
+        ensemble.append(model.fuse().eval() if fuse and hasattr(model, "fuse") else model.eval())  # model in eval mode
 
     # Module updates
     for m in ensemble.modules():
-        t = type(m)
-        if t in (nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU, Detect, Segment):
+        if hasattr(m, "inplace"):
             m.inplace = inplace
-        elif t is nn.Upsample and not hasattr(m, 'recompute_scale_factor'):
+        elif isinstance(m, nn.Upsample) and not hasattr(m, "recompute_scale_factor"):
             m.recompute_scale_factor = None  # torch 1.11.0 compatibility
 
     # Return model
     if len(ensemble) == 1:
         return ensemble[-1]
 
     # Return ensemble
-    LOGGER.info(f'Ensemble created with {weights}\n')
-    for k in 'names', 'nc', 'yaml':
+    LOGGER.info(f"Ensemble created with {weights}\n")
+    for k in "names", "nc", "yaml":
         setattr(ensemble, k, getattr(ensemble[0], k))
-    ensemble.stride = ensemble[torch.argmax(torch.tensor([m.stride.max() for m in ensemble])).int()].stride
-    assert all(ensemble[0].nc == m.nc for m in ensemble), f'Models differ in class counts {[m.nc for m in ensemble]}'
+    ensemble.stride = ensemble[int(torch.argmax(torch.tensor([m.stride.max() for m in ensemble])))].stride
+    assert all(ensemble[0].nc == m.nc for m in ensemble), f"Models differ in class counts {[m.nc for m in ensemble]}"
     return ensemble
 
 
 def attempt_load_one_weight(weight, device=None, inplace=True, fuse=False):
     """Loads a single model weights."""
     ckpt, weight = torch_safe_load(weight)  # load ckpt
-    args = {**DEFAULT_CFG_DICT, **(ckpt.get('train_args', {}))}  # combine model and default args, preferring model args
-    model = (ckpt.get('ema') or ckpt['model']).to(device).float()  # FP32 model
+    args = {**DEFAULT_CFG_DICT, **(ckpt.get("train_args", {}))}  # combine model and default args, preferring model args
+    model = (ckpt.get("ema") or ckpt["model"]).to(device).float()  # FP32 model
 
     # Model compatibility updates
     model.args = {k: v for k, v in args.items() if k in DEFAULT_CFG_KEYS}  # attach args to model
     model.pt_path = weight  # attach *.pt file path to model
     model.task = guess_model_task(model)
-    if not hasattr(model, 'stride'):
-        model.stride = torch.tensor([32.])
+    if not hasattr(model, "stride"):
+        model.stride = torch.tensor([32.0])
 
-    model = model.fuse().eval() if fuse and hasattr(model, 'fuse') else model.eval()  # model in eval mode
+    model = model.fuse().eval() if fuse and hasattr(model, "fuse") else model.eval()  # model in eval mode
 
     # Module updates
     for m in model.modules():
-        t = type(m)
-        if t in (nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU, Detect, Segment):
+        if hasattr(m, "inplace"):
             m.inplace = inplace
-        elif t is nn.Upsample and not hasattr(m, 'recompute_scale_factor'):
+        elif isinstance(m, nn.Upsample) and not hasattr(m, "recompute_scale_factor"):
             m.recompute_scale_factor = None  # torch 1.11.0 compatibility
 
     # Return model and ckpt
     return model, ckpt
 
 
 def parse_model(d, ch, verbose=True):  # model_dict, input_channels(3)
     """Parse a YOLO model.yaml dictionary into a PyTorch model."""
     import ast
 
     # Args
-    max_channels = float('inf')
-    nc, act, scales = (d.get(x) for x in ('nc', 'activation', 'scales'))
-    depth, width, kpt_shape = (d.get(x, 1.0) for x in ('depth_multiple', 'width_multiple', 'kpt_shape'))
+    max_channels = float("inf")
+    nc, act, scales = (d.get(x) for x in ("nc", "activation", "scales"))
+    depth, width, kpt_shape = (d.get(x, 1.0) for x in ("depth_multiple", "width_multiple", "kpt_shape"))
     if scales:
-        scale = d.get('scale')
+        scale = d.get("scale")
         if not scale:
             scale = tuple(scales.keys())[0]
             LOGGER.warning(f"WARNING  no model scale passed. Assuming scale='{scale}'.")
         depth, width, max_channels = scales[scale]
 
     if act:
         Conv.default_act = eval(act)  # redefine default activation, i.e. Conv.default_act = nn.SiLU()
         if verbose:
             LOGGER.info(f"{colorstr('activation:')} {act}")  # print
 
     if verbose:
         LOGGER.info(f"\n{'':>3}{'from':>20}{'n':>3}{'params':>10}  {'module':<45}{'arguments':<30}")
     ch = [ch]
     layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out
-    for i, (f, n, m, args) in enumerate(d['backbone'] + d['head']):  # from, number, module, args
-        m = getattr(torch.nn, m[3:]) if 'nn.' in m else globals()[m]  # get module
+    for i, (f, n, m, args) in enumerate(d["backbone"] + d["head"]):  # from, number, module, args
+        m = getattr(torch.nn, m[3:]) if "nn." in m else globals()[m]  # get module
         for j, a in enumerate(args):
             if isinstance(a, str):
                 with contextlib.suppress(ValueError):
                     args[j] = locals()[a] if a in locals() else ast.literal_eval(a)
 
         n = n_ = max(round(n * depth), 1) if n > 1 else n  # depth gain
-        if m in (Classify, Conv, ConvTranspose, GhostConv, Bottleneck, GhostBottleneck, SPP, SPPF, DWConv, Focus,
-                 BottleneckCSP, C1, C2, C2f, C3, C3TR, C3Ghost, nn.ConvTranspose2d, DWConvTranspose2d, C3x, RepC3):
+        if m in {
+            Classify,
+            Conv,
+            ConvTranspose,
+            GhostConv,
+            Bottleneck,
+            GhostBottleneck,
+            SPP,
+            SPPF,
+            DWConv,
+            Focus,
+            BottleneckCSP,
+            C1,
+            C2,
+            C2f,
+            RepNCSPELAN4,
+            ADown,
+            SPPELAN,
+            C2fAttn,
+            C3,
+            C3TR,
+            C3Ghost,
+            nn.ConvTranspose2d,
+            DWConvTranspose2d,
+            C3x,
+            RepC3,
+        }:
             c1, c2 = ch[f], args[0]
             if c2 != nc:  # if c2 not equal to number of classes (i.e. for Classify() output)
                 c2 = make_divisible(min(c2, max_channels) * width, 8)
+            if m is C2fAttn:
+                args[1] = make_divisible(min(args[1], max_channels // 2) * width, 8)  # embed channels
+                args[2] = int(
+                    max(round(min(args[2], max_channels // 2 // 32)) * width, 1) if args[2] > 1 else args[2]
+                )  # num heads
 
             args = [c1, c2, *args[1:]]
-            if m in (BottleneckCSP, C1, C2, C2f, C3, C3TR, C3Ghost, C3x, RepC3):
+            if m in {BottleneckCSP, C1, C2, C2f, C2fAttn, C3, C3TR, C3Ghost, C3x, RepC3}:
                 args.insert(2, n)  # number of repeats
                 n = 1
         elif m is AIFI:
             args = [ch[f], *args]
-        elif m in (HGStem, HGBlock):
+        elif m in {HGStem, HGBlock}:
             c1, cm, c2 = ch[f], args[0], args[1]
             args = [c1, cm, c2, *args[2:]]
             if m is HGBlock:
                 args.insert(4, n)  # number of repeats
                 n = 1
-
+        elif m is ResNetLayer:
+            c2 = args[1] if args[3] else args[1] * 4
         elif m is nn.BatchNorm2d:
             args = [ch[f]]
         elif m is Concat:
             c2 = sum(ch[x] for x in f)
-        elif m in (Detect, Segment, Pose):
+        elif m in {Detect, WorldDetect, Segment, Pose, OBB, ImagePoolingAttn}:
             args.append([ch[x] for x in f])
             if m is Segment:
                 args[2] = make_divisible(min(args[2], max_channels) * width, 8)
         elif m is RTDETRDecoder:  # special case, channels arg must be passed in index 1
             args.insert(1, [ch[x] for x in f])
+        elif m is CBLinear:
+            c2 = args[0]
+            c1 = ch[f]
+            args = [c1, c2, *args[1:]]
+        elif m is CBFuse:
+            c2 = ch[f[-1]]
         else:
             c2 = ch[f]
 
         m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n > 1 else m(*args)  # module
-        t = str(m)[8:-2].replace('__main__.', '')  # module type
+        t = str(m)[8:-2].replace("__main__.", "")  # module type
         m.np = sum(x.numel() for x in m_.parameters())  # number params
         m_.i, m_.f, m_.type = i, f, t  # attach index, 'from' index, type
         if verbose:
-            LOGGER.info(f'{i:>3}{str(f):>20}{n_:>3}{m.np:10.0f}  {t:<45}{str(args):<30}')  # print
+            LOGGER.info(f"{i:>3}{str(f):>20}{n_:>3}{m.np:10.0f}  {t:<45}{str(args):<30}")  # print
         save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist
         layers.append(m_)
         if i == 0:
             ch = []
         ch.append(c2)
     return nn.Sequential(*layers), sorted(save)
 
 
 def yaml_model_load(path):
     """Load a YOLOv8 model from a YAML file."""
     import re
 
     path = Path(path)
-    if path.stem in (f'yolov{d}{x}6' for x in 'nsmlx' for d in (5, 8)):
-        new_stem = re.sub(r'(\d+)([nslmx])6(.+)?$', r'\1\2-p6\3', path.stem)
-        LOGGER.warning(f'WARNING  Ultralytics YOLO P6 models now use -p6 suffix. Renaming {path.stem} to {new_stem}.')
+    if path.stem in (f"yolov{d}{x}6" for x in "nsmlx" for d in (5, 8)):
+        new_stem = re.sub(r"(\d+)([nslmx])6(.+)?$", r"\1\2-p6\3", path.stem)
+        LOGGER.warning(f"WARNING  Ultralytics YOLO P6 models now use -p6 suffix. Renaming {path.stem} to {new_stem}.")
         path = path.with_name(new_stem + path.suffix)
 
-    unified_path = re.sub(r'(\d+)([nslmx])(.+)?$', r'\1\3', str(path))  # i.e. yolov8x.yaml -> yolov8.yaml
+    unified_path = re.sub(r"(\d+)([nslmx])(.+)?$", r"\1\3", str(path))  # i.e. yolov8x.yaml -> yolov8.yaml
     yaml_file = check_yaml(unified_path, hard=False) or check_yaml(path)
     d = yaml_load(yaml_file)  # model dict
-    d['scale'] = guess_model_scale(path)
-    d['yaml_file'] = str(path)
+    d["scale"] = guess_model_scale(path)
+    d["yaml_file"] = str(path)
     return d
 
 
 def guess_model_scale(model_path):
     """
     Takes a path to a YOLO model's YAML file as input and extracts the size character of the model's scale. The function
     uses regular expression matching to find the pattern of the model scale in the YAML file name, which is denoted by
@@ -756,16 +970,17 @@
         model_path (str | Path): The path to the YOLO model's YAML file.
 
     Returns:
         (str): The size character of the model's scale, which can be n, s, m, l, or x.
     """
     with contextlib.suppress(AttributeError):
         import re
-        return re.search(r'yolov\d+([nslmx])', Path(model_path).stem).group(1)  # n, s, m, l, or x
-    return ''
+
+        return re.search(r"yolov\d+([nslmx])", Path(model_path).stem).group(1)  # n, s, m, l, or x
+    return ""
 
 
 def guess_model_task(model):
     """
     Guess the task of a PyTorch model from its architecture or configuration.
 
     Args:
@@ -776,57 +991,65 @@
 
     Raises:
         SyntaxError: If the task of the model could not be determined.
     """
 
     def cfg2task(cfg):
         """Guess from YAML dictionary."""
-        m = cfg['head'][-1][-2].lower()  # output module name
-        if m in ('classify', 'classifier', 'cls', 'fc'):
-            return 'classify'
-        if m == 'detect':
-            return 'detect'
-        if m == 'segment':
-            return 'segment'
-        if m == 'pose':
-            return 'pose'
+        m = cfg["head"][-1][-2].lower()  # output module name
+        if m in {"classify", "classifier", "cls", "fc"}:
+            return "classify"
+        if m == "detect":
+            return "detect"
+        if m == "segment":
+            return "segment"
+        if m == "pose":
+            return "pose"
+        if m == "obb":
+            return "obb"
 
     # Guess from model cfg
     if isinstance(model, dict):
         with contextlib.suppress(Exception):
             return cfg2task(model)
 
     # Guess from PyTorch model
     if isinstance(model, nn.Module):  # PyTorch model
-        for x in 'model.args', 'model.model.args', 'model.model.model.args':
+        for x in "model.args", "model.model.args", "model.model.model.args":
             with contextlib.suppress(Exception):
-                return eval(x)['task']
-        for x in 'model.yaml', 'model.model.yaml', 'model.model.model.yaml':
+                return eval(x)["task"]
+        for x in "model.yaml", "model.model.yaml", "model.model.model.yaml":
             with contextlib.suppress(Exception):
                 return cfg2task(eval(x))
 
         for m in model.modules():
-            if isinstance(m, Detect):
-                return 'detect'
-            elif isinstance(m, Segment):
-                return 'segment'
+            if isinstance(m, Segment):
+                return "segment"
             elif isinstance(m, Classify):
-                return 'classify'
+                return "classify"
             elif isinstance(m, Pose):
-                return 'pose'
+                return "pose"
+            elif isinstance(m, OBB):
+                return "obb"
+            elif isinstance(m, (Detect, WorldDetect)):
+                return "detect"
 
     # Guess from model filename
     if isinstance(model, (str, Path)):
         model = Path(model)
-        if '-seg' in model.stem or 'segment' in model.parts:
-            return 'segment'
-        elif '-cls' in model.stem or 'classify' in model.parts:
-            return 'classify'
-        elif '-pose' in model.stem or 'pose' in model.parts:
-            return 'pose'
-        elif 'detect' in model.parts:
-            return 'detect'
+        if "-seg" in model.stem or "segment" in model.parts:
+            return "segment"
+        elif "-cls" in model.stem or "classify" in model.parts:
+            return "classify"
+        elif "-pose" in model.stem or "pose" in model.parts:
+            return "pose"
+        elif "-obb" in model.stem or "obb" in model.parts:
+            return "obb"
+        elif "detect" in model.parts:
+            return "detect"
 
     # Unable to determine task from model
-    LOGGER.warning("WARNING  Unable to automatically guess model task, assuming 'task=detect'. "
-                   "Explicitly define task for your model, i.e. 'task=detect', 'segment', 'classify', or 'pose'.")
-    return 'detect'  # assume detect
+    LOGGER.warning(
+        "WARNING  Unable to automatically guess model task, assuming 'task=detect'. "
+        "Explicitly define task for your model, i.e. 'task=detect', 'segment', 'classify','pose' or 'obb'."
+    )
+    return "detect"  # assume detect
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/trackers/bot_sort.py` & `yolov8_pose_triton-8.2.0/ultralytics/trackers/bot_sort.py`

 * *Files 0% similar despite different names*

```diff
@@ -35,14 +35,15 @@
         tlwh_to_xywh(tlwh): Convert bounding box to xywh format `(center x, center y, width, height)`.
 
     Usage:
         bo_track = BOTrack(tlwh, score, cls, feat)
         bo_track.predict()
         bo_track.update(new_track, frame_id)
     """
+
     shared_kalman = KalmanFilterXYWH()
 
     def __init__(self, tlwh, score, cls, feat=None, feat_history=50):
         """Initialize YOLOv8 object with temporal parameters, such as feature history, alpha and current features."""
         super().__init__(tlwh, score, cls)
 
         self.smooth_feat = None
@@ -172,15 +173,15 @@
             return [BOTrack(xyxy, s, c, f) for (xyxy, s, c, f) in zip(dets, scores, cls, features_keep)]  # detections
         else:
             return [BOTrack(xyxy, s, c) for (xyxy, s, c) in zip(dets, scores, cls)]  # detections
 
     def get_dists(self, tracks, detections):
         """Get distances between tracks and detections using IoU and (optionally) ReID embeddings."""
         dists = matching.iou_distance(tracks, detections)
-        dists_mask = (dists > self.proximity_thresh)
+        dists_mask = dists > self.proximity_thresh
 
         # TODO: mot20
         # if not self.args.mot20:
         dists = matching.fuse_score(dists, detections)
 
         if self.args.with_reid and self.encoder is not None:
             emb_dists = matching.embedding_distance(tracks, detections) / 2.0
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/trackers/byte_tracker.py` & `yolov8_pose_triton-8.2.0/ultralytics/trackers/byte_tracker.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import numpy as np
 
+from ..utils import LOGGER
+from ..utils.ops import xywh2ltwh
 from .basetrack import BaseTrack, TrackState
 from .utils import matching
 from .utils.kalman_filter import KalmanFilterXYAH
 
 
 class STrack(BaseTrack):
     """
@@ -31,33 +33,35 @@
     Methods:
         predict(): Predict the next state of the object using Kalman filter.
         multi_predict(stracks): Predict the next states for multiple tracks.
         multi_gmc(stracks, H): Update multiple track states using a homography matrix.
         activate(kalman_filter, frame_id): Activate a new tracklet.
         re_activate(new_track, frame_id, new_id): Reactivate a previously lost tracklet.
         update(new_track, frame_id): Update the state of a matched track.
-        convert_coords(tlwh): Convert bounding box to x-y-angle-height format.
+        convert_coords(tlwh): Convert bounding box to x-y-aspect-height format.
         tlwh_to_xyah(tlwh): Convert tlwh bounding box to xyah format.
-        tlbr_to_tlwh(tlbr): Convert tlbr bounding box to tlwh format.
-        tlwh_to_tlbr(tlwh): Convert tlwh bounding box to tlbr format.
     """
 
     shared_kalman = KalmanFilterXYAH()
 
-    def __init__(self, tlwh, score, cls):
+    def __init__(self, xywh, score, cls):
         """Initialize new STrack instance."""
-        self._tlwh = np.asarray(self.tlbr_to_tlwh(tlwh[:-1]), dtype=np.float32)
+        super().__init__()
+        # xywh+idx or xywha+idx
+        assert len(xywh) in {5, 6}, f"expected 5 or 6 values but got {len(xywh)}"
+        self._tlwh = np.asarray(xywh2ltwh(xywh[:4]), dtype=np.float32)
         self.kalman_filter = None
         self.mean, self.covariance = None, None
         self.is_activated = False
 
         self.score = score
         self.tracklet_len = 0
         self.cls = cls
-        self.idx = tlwh[-1]
+        self.idx = xywh[-1]
+        self.angle = xywh[4] if len(xywh) == 6 else None
 
     def predict(self):
         """Predicts mean and covariance using Kalman filter."""
         mean_state = self.mean.copy()
         if self.state != TrackState.Tracked:
             mean_state[7] = 0
         self.mean, self.covariance = self.kalman_filter.predict(mean_state, self.covariance)
@@ -107,63 +111,67 @@
         if frame_id == 1:
             self.is_activated = True
         self.frame_id = frame_id
         self.start_frame = frame_id
 
     def re_activate(self, new_track, frame_id, new_id=False):
         """Reactivates a previously lost track with a new detection."""
-        self.mean, self.covariance = self.kalman_filter.update(self.mean, self.covariance,
-                                                               self.convert_coords(new_track.tlwh))
+        self.mean, self.covariance = self.kalman_filter.update(
+            self.mean, self.covariance, self.convert_coords(new_track.tlwh)
+        )
         self.tracklet_len = 0
         self.state = TrackState.Tracked
         self.is_activated = True
         self.frame_id = frame_id
         if new_id:
             self.track_id = self.next_id()
         self.score = new_track.score
         self.cls = new_track.cls
+        self.angle = new_track.angle
         self.idx = new_track.idx
 
     def update(self, new_track, frame_id):
         """
         Update the state of a matched track.
 
         Args:
             new_track (STrack): The new track containing updated information.
             frame_id (int): The ID of the current frame.
         """
         self.frame_id = frame_id
         self.tracklet_len += 1
 
         new_tlwh = new_track.tlwh
-        self.mean, self.covariance = self.kalman_filter.update(self.mean, self.covariance,
-                                                               self.convert_coords(new_tlwh))
+        self.mean, self.covariance = self.kalman_filter.update(
+            self.mean, self.covariance, self.convert_coords(new_tlwh)
+        )
         self.state = TrackState.Tracked
         self.is_activated = True
 
         self.score = new_track.score
         self.cls = new_track.cls
+        self.angle = new_track.angle
         self.idx = new_track.idx
 
     def convert_coords(self, tlwh):
-        """Convert a bounding box's top-left-width-height format to its x-y-angle-height equivalent."""
+        """Convert a bounding box's top-left-width-height format to its x-y-aspect-height equivalent."""
         return self.tlwh_to_xyah(tlwh)
 
     @property
     def tlwh(self):
         """Get current position in bounding box format (top left x, top left y, width, height)."""
         if self.mean is None:
             return self._tlwh.copy()
         ret = self.mean[:4].copy()
         ret[2] *= ret[3]
         ret[:2] -= ret[2:] / 2
         return ret
 
     @property
-    def tlbr(self):
+    def xyxy(self):
         """Convert bounding box to format (min x, min y, max x, max y), i.e., (top left, bottom right)."""
         ret = self.tlwh.copy()
         ret[2:] += ret[:2]
         return ret
 
     @staticmethod
     def tlwh_to_xyah(tlwh):
@@ -171,31 +179,38 @@
         height.
         """
         ret = np.asarray(tlwh).copy()
         ret[:2] += ret[2:] / 2
         ret[2] /= ret[3]
         return ret
 
-    @staticmethod
-    def tlbr_to_tlwh(tlbr):
-        """Converts top-left bottom-right format to top-left width height format."""
-        ret = np.asarray(tlbr).copy()
-        ret[2:] -= ret[:2]
+    @property
+    def xywh(self):
+        """Get current position in bounding box format (center x, center y, width, height)."""
+        ret = np.asarray(self.tlwh).copy()
+        ret[:2] += ret[2:] / 2
         return ret
 
-    @staticmethod
-    def tlwh_to_tlbr(tlwh):
-        """Converts tlwh bounding box format to tlbr format."""
-        ret = np.asarray(tlwh).copy()
-        ret[2:] += ret[:2]
-        return ret
+    @property
+    def xywha(self):
+        """Get current position in bounding box format (center x, center y, width, height, angle)."""
+        if self.angle is None:
+            LOGGER.warning("WARNING  `angle` attr not found, returning `xywh` instead.")
+            return self.xywh
+        return np.concatenate([self.xywh, self.angle[None]])
+
+    @property
+    def result(self):
+        """Get current tracking results."""
+        coords = self.xyxy if self.angle is None else self.xywha
+        return coords.tolist() + [self.track_id, self.score, self.cls, self.idx]
 
     def __repr__(self):
         """Return a string representation of the BYTETracker object with start and end frames and track ID."""
-        return f'OT_{self.track_id}_({self.start_frame}-{self.end_frame})'
+        return f"OT_{self.track_id}_({self.start_frame}-{self.end_frame})"
 
 
 class BYTETracker:
     """
     BYTETracker: A tracking algorithm built on top of YOLOv8 for object detection and tracking.
 
     The class is responsible for initializing, updating, and managing the tracks for detected objects in a video
@@ -216,15 +231,15 @@
         get_kalmanfilter(): Returns a Kalman filter object for tracking bounding boxes.
         init_track(dets, scores, cls, img=None): Initialize object tracking with detections.
         get_dists(tracks, detections): Calculates the distance between tracks and detections.
         multi_predict(tracks): Predicts the location of tracks.
         reset_id(): Resets the ID counter of STrack.
         joint_stracks(tlista, tlistb): Combines two lists of stracks.
         sub_stracks(tlista, tlistb): Filters out the stracks present in the second list from the first list.
-        remove_duplicate_stracks(stracksa, stracksb): Removes duplicate stracks based on IOU.
+        remove_duplicate_stracks(stracksa, stracksb): Removes duplicate stracks based on IoU.
     """
 
     def __init__(self, args, frame_rate=30):
         """Initialize a YOLOv8 object to track objects with given arguments and frame rate."""
         self.tracked_stracks = []  # type: list[STrack]
         self.lost_stracks = []  # type: list[STrack]
         self.removed_stracks = []  # type: list[STrack]
@@ -240,15 +255,15 @@
         self.frame_id += 1
         activated_stracks = []
         refind_stracks = []
         lost_stracks = []
         removed_stracks = []
 
         scores = results.conf
-        bboxes = results.xyxy
+        bboxes = results.xywhr if hasattr(results, "xywhr") else results.xywh
         # Add index
         bboxes = np.concatenate([bboxes, np.arange(len(bboxes)).reshape(-1, 1)], axis=-1)
         cls = results.cls
 
         remain_inds = scores > self.args.track_high_thresh
         inds_low = scores > self.args.track_low_thresh
         inds_high = scores < self.args.track_high_thresh
@@ -270,15 +285,15 @@
                 unconfirmed.append(track)
             else:
                 tracked_stracks.append(track)
         # Step 2: First association, with high score detection boxes
         strack_pool = self.joint_stracks(tracked_stracks, self.lost_stracks)
         # Predict the current location with KF
         self.multi_predict(strack_pool)
-        if hasattr(self, 'gmc') and img is not None:
+        if hasattr(self, "gmc") and img is not None:
             warp = self.gmc.apply(img, dets)
             STrack.multi_gmc(strack_pool, warp)
             STrack.multi_gmc(unconfirmed, warp)
 
         dists = self.get_dists(strack_pool, detections)
         matches, u_track, u_detection = matching.linear_assignment(dists, thresh=self.args.match_thresh)
 
@@ -342,39 +357,39 @@
         self.lost_stracks = self.sub_stracks(self.lost_stracks, self.tracked_stracks)
         self.lost_stracks.extend(lost_stracks)
         self.lost_stracks = self.sub_stracks(self.lost_stracks, self.removed_stracks)
         self.tracked_stracks, self.lost_stracks = self.remove_duplicate_stracks(self.tracked_stracks, self.lost_stracks)
         self.removed_stracks.extend(removed_stracks)
         if len(self.removed_stracks) > 1000:
             self.removed_stracks = self.removed_stracks[-999:]  # clip remove stracks to 1000 maximum
-        return np.asarray(
-            [x.tlbr.tolist() + [x.track_id, x.score, x.cls, x.idx] for x in self.tracked_stracks if x.is_activated],
-            dtype=np.float32)
+
+        return np.asarray([x.result for x in self.tracked_stracks if x.is_activated], dtype=np.float32)
 
     def get_kalmanfilter(self):
         """Returns a Kalman filter object for tracking bounding boxes."""
         return KalmanFilterXYAH()
 
     def init_track(self, dets, scores, cls, img=None):
         """Initialize object tracking with detections and scores using STrack algorithm."""
         return [STrack(xyxy, s, c) for (xyxy, s, c) in zip(dets, scores, cls)] if len(dets) else []  # detections
 
     def get_dists(self, tracks, detections):
-        """Calculates the distance between tracks and detections using IOU and fuses scores."""
+        """Calculates the distance between tracks and detections using IoU and fuses scores."""
         dists = matching.iou_distance(tracks, detections)
         # TODO: mot20
         # if not self.args.mot20:
         dists = matching.fuse_score(dists, detections)
         return dists
 
     def multi_predict(self, tracks):
         """Returns the predicted tracks using the YOLOv8 network."""
         STrack.multi_predict(tracks)
 
-    def reset_id(self):
+    @staticmethod
+    def reset_id():
         """Resets the ID counter of STrack."""
         STrack.reset_id()
 
     def reset(self):
         """Reset tracker."""
         self.tracked_stracks = []  # type: list[STrack]
         self.lost_stracks = []  # type: list[STrack]
@@ -409,15 +424,15 @@
         return list(stracks.values())
         """
         track_ids_b = {t.track_id for t in tlistb}
         return [t for t in tlista if t.track_id not in track_ids_b]
 
     @staticmethod
     def remove_duplicate_stracks(stracksa, stracksb):
-        """Remove duplicate stracks with non-maximum IOU distance."""
+        """Remove duplicate stracks with non-maximum IoU distance."""
         pdist = matching.iou_distance(stracksa, stracksb)
         pairs = np.where(pdist < 0.15)
         dupa, dupb = [], []
         for p, q in zip(*pairs):
             timep = stracksa[p].frame_id - stracksa[p].start_frame
             timeq = stracksb[q].frame_id - stracksb[q].start_frame
             if timep > timeq:
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/trackers/track.py` & `yolov8_pose_triton-8.2.0/ultralytics/trackers/track.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,64 +7,84 @@
 
 from ultralytics.utils import IterableSimpleNamespace, yaml_load
 from ultralytics.utils.checks import check_yaml
 
 from .bot_sort import BOTSORT
 from .byte_tracker import BYTETracker
 
-TRACKER_MAP = {'bytetrack': BYTETracker, 'botsort': BOTSORT}
+# A mapping of tracker types to corresponding tracker classes
+TRACKER_MAP = {"bytetrack": BYTETracker, "botsort": BOTSORT}
 
 
-def on_predict_start(predictor, persist=False):
+def on_predict_start(predictor: object, persist: bool = False) -> None:
     """
     Initialize trackers for object tracking during prediction.
 
     Args:
         predictor (object): The predictor object to initialize trackers for.
         persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.
 
     Raises:
         AssertionError: If the tracker_type is not 'bytetrack' or 'botsort'.
     """
-    if hasattr(predictor, 'trackers') and persist:
+    if hasattr(predictor, "trackers") and persist:
         return
+
     tracker = check_yaml(predictor.args.tracker)
     cfg = IterableSimpleNamespace(**yaml_load(tracker))
-    assert cfg.tracker_type in ['bytetrack', 'botsort'], \
-        f"Only support 'bytetrack' and 'botsort' for now, but got '{cfg.tracker_type}'"
+
+    if cfg.tracker_type not in {"bytetrack", "botsort"}:
+        raise AssertionError(f"Only 'bytetrack' and 'botsort' are supported for now, but got '{cfg.tracker_type}'")
+
     trackers = []
     for _ in range(predictor.dataset.bs):
         tracker = TRACKER_MAP[cfg.tracker_type](args=cfg, frame_rate=30)
         trackers.append(tracker)
+        if predictor.dataset.mode != "stream":  # only need one tracker for other modes.
+            break
     predictor.trackers = trackers
+    predictor.vid_path = [None] * predictor.dataset.bs  # for determining when to reset tracker on new video
 
 
-def on_predict_postprocess_end(predictor, persist=False):
-    """Postprocess detected boxes and update with object tracking."""
-    bs = predictor.dataset.bs
+def on_predict_postprocess_end(predictor: object, persist: bool = False) -> None:
+    """
+    Postprocess detected boxes and update with object tracking.
+
+    Args:
+        predictor (object): The predictor object containing the predictions.
+        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.
+    """
     path, im0s = predictor.batch[:2]
 
-    for i in range(bs):
-        if not persist and predictor.vid_path[i] != str(predictor.save_dir / Path(path[i]).name):  # new video
-            predictor.trackers[i].reset()
+    is_obb = predictor.args.task == "obb"
+    is_stream = predictor.dataset.mode == "stream"
+    for i in range(len(im0s)):
+        tracker = predictor.trackers[i if is_stream else 0]
+        vid_path = predictor.save_dir / Path(path[i]).name
+        if not persist and predictor.vid_path[i if is_stream else 0] != vid_path:
+            tracker.reset()
+            predictor.vid_path[i if is_stream else 0] = vid_path
 
-        det = predictor.results[i].boxes.cpu().numpy()
+        det = (predictor.results[i].obb if is_obb else predictor.results[i].boxes).cpu().numpy()
         if len(det) == 0:
             continue
-        tracks = predictor.trackers[i].update(det, im0s[i])
+        tracks = tracker.update(det, im0s[i])
         if len(tracks) == 0:
             continue
         idx = tracks[:, -1].astype(int)
         predictor.results[i] = predictor.results[i][idx]
-        predictor.results[i].update(boxes=torch.as_tensor(tracks[:, :-1]))
+
+        update_args = dict()
+        update_args["obb" if is_obb else "boxes"] = torch.as_tensor(tracks[:, :-1])
+        predictor.results[i].update(**update_args)
 
 
-def register_tracker(model, persist):
+def register_tracker(model: object, persist: bool) -> None:
     """
     Register tracking callbacks to the model for object tracking during prediction.
 
     Args:
         model (object): The model object to register tracking callbacks for.
         persist (bool): Whether to persist the trackers if they already exist.
     """
-    model.add_callback('on_predict_start', partial(on_predict_start, persist=persist))
-    model.add_callback('on_predict_postprocess_end', partial(on_predict_postprocess_end, persist=persist))
+    model.add_callback("on_predict_start", partial(on_predict_start, persist=persist))
+    model.add_callback("on_predict_postprocess_end", partial(on_predict_postprocess_end, persist=persist))
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/trackers/utils/gmc.py` & `yolov8_pose_triton-8.2.0/ultralytics/trackers/utils/gmc.py`

 * *Files 15% similar despite different names*

```diff
@@ -9,94 +9,125 @@
 
 
 class GMC:
     """
     Generalized Motion Compensation (GMC) class for tracking and object detection in video frames.
 
     This class provides methods for tracking and detecting objects based on several tracking algorithms including ORB,
-    SIFT, ECC, and Sparse Optical Flow. It also supports downscaling of  frames for computational efficiency.
+    SIFT, ECC, and Sparse Optical Flow. It also supports downscaling of frames for computational efficiency.
 
     Attributes:
         method (str): The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.
         downscale (int): Factor by which to downscale the frames for processing.
-        prevFrame (np.array): Stores the previous frame for tracking.
+        prevFrame (np.ndarray): Stores the previous frame for tracking.
         prevKeyPoints (list): Stores the keypoints from the previous frame.
-        prevDescriptors (np.array): Stores the descriptors from the previous frame.
+        prevDescriptors (np.ndarray): Stores the descriptors from the previous frame.
         initializedFirstFrame (bool): Flag to indicate if the first frame has been processed.
 
     Methods:
         __init__(self, method='sparseOptFlow', downscale=2): Initializes a GMC object with the specified method
                                                               and downscale factor.
         apply(self, raw_frame, detections=None): Applies the chosen method to a raw frame and optionally uses
                                                  provided detections.
         applyEcc(self, raw_frame, detections=None): Applies the ECC algorithm to a raw frame.
         applyFeatures(self, raw_frame, detections=None): Applies feature-based methods like ORB or SIFT to a raw frame.
         applySparseOptFlow(self, raw_frame, detections=None): Applies the Sparse Optical Flow method to a raw frame.
     """
 
-    def __init__(self, method='sparseOptFlow', downscale=2):
-        """Initialize a video tracker with specified parameters."""
+    def __init__(self, method: str = "sparseOptFlow", downscale: int = 2) -> None:
+        """
+        Initialize a video tracker with specified parameters.
+
+        Args:
+            method (str): The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.
+            downscale (int): Downscale factor for processing frames.
+        """
         super().__init__()
 
         self.method = method
         self.downscale = max(1, int(downscale))
 
-        if self.method == 'orb':
+        if self.method == "orb":
             self.detector = cv2.FastFeatureDetector_create(20)
             self.extractor = cv2.ORB_create()
             self.matcher = cv2.BFMatcher(cv2.NORM_HAMMING)
 
-        elif self.method == 'sift':
+        elif self.method == "sift":
             self.detector = cv2.SIFT_create(nOctaveLayers=3, contrastThreshold=0.02, edgeThreshold=20)
             self.extractor = cv2.SIFT_create(nOctaveLayers=3, contrastThreshold=0.02, edgeThreshold=20)
             self.matcher = cv2.BFMatcher(cv2.NORM_L2)
 
-        elif self.method == 'ecc':
+        elif self.method == "ecc":
             number_of_iterations = 5000
             termination_eps = 1e-6
             self.warp_mode = cv2.MOTION_EUCLIDEAN
             self.criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, number_of_iterations, termination_eps)
 
-        elif self.method == 'sparseOptFlow':
-            self.feature_params = dict(maxCorners=1000,
-                                       qualityLevel=0.01,
-                                       minDistance=1,
-                                       blockSize=3,
-                                       useHarrisDetector=False,
-                                       k=0.04)
+        elif self.method == "sparseOptFlow":
+            self.feature_params = dict(
+                maxCorners=1000, qualityLevel=0.01, minDistance=1, blockSize=3, useHarrisDetector=False, k=0.04
+            )
 
-        elif self.method in ['none', 'None', None]:
+        elif self.method in {"none", "None", None}:
             self.method = None
         else:
-            raise ValueError(f'Error: Unknown GMC method:{method}')
+            raise ValueError(f"Error: Unknown GMC method:{method}")
 
         self.prevFrame = None
         self.prevKeyPoints = None
         self.prevDescriptors = None
-
         self.initializedFirstFrame = False
 
-    def apply(self, raw_frame, detections=None):
-        """Apply object detection on a raw frame using specified method."""
-        if self.method in ['orb', 'sift']:
+    def apply(self, raw_frame: np.array, detections: list = None) -> np.array:
+        """
+        Apply object detection on a raw frame using specified method.
+
+        Args:
+            raw_frame (np.ndarray): The raw frame to be processed.
+            detections (list): List of detections to be used in the processing.
+
+        Returns:
+            (np.ndarray): Processed frame.
+
+        Examples:
+            >>> gmc = GMC()
+            >>> gmc.apply(np.array([[1, 2, 3], [4, 5, 6]]))
+            array([[1, 2, 3],
+                   [4, 5, 6]])
+        """
+        if self.method in {"orb", "sift"}:
             return self.applyFeatures(raw_frame, detections)
-        elif self.method == 'ecc':
-            return self.applyEcc(raw_frame, detections)
-        elif self.method == 'sparseOptFlow':
-            return self.applySparseOptFlow(raw_frame, detections)
+        elif self.method == "ecc":
+            return self.applyEcc(raw_frame)
+        elif self.method == "sparseOptFlow":
+            return self.applySparseOptFlow(raw_frame)
         else:
             return np.eye(2, 3)
 
-    def applyEcc(self, raw_frame, detections=None):
-        """Initialize."""
+    def applyEcc(self, raw_frame: np.array) -> np.array:
+        """
+        Apply ECC algorithm to a raw frame.
+
+        Args:
+            raw_frame (np.ndarray): The raw frame to be processed.
+
+        Returns:
+            (np.ndarray): Processed frame.
+
+        Examples:
+            >>> gmc = GMC()
+            >>> gmc.applyEcc(np.array([[1, 2, 3], [4, 5, 6]]))
+            array([[1, 2, 3],
+                   [4, 5, 6]])
+        """
         height, width, _ = raw_frame.shape
         frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)
         H = np.eye(2, 3, dtype=np.float32)
 
-        # Downscale image (TODO: consider using pyramids)
+        # Downscale image
         if self.downscale > 1.0:
             frame = cv2.GaussianBlur(frame, (3, 3), 1.5)
             frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))
             width = width // self.downscale
             height = height // self.downscale
 
         # Handle first frame
@@ -108,41 +139,54 @@
             self.initializedFirstFrame = True
 
             return H
 
         # Run the ECC algorithm. The results are stored in warp_matrix.
         # (cc, H) = cv2.findTransformECC(self.prevFrame, frame, H, self.warp_mode, self.criteria)
         try:
-            (cc, H) = cv2.findTransformECC(self.prevFrame, frame, H, self.warp_mode, self.criteria, None, 1)
+            (_, H) = cv2.findTransformECC(self.prevFrame, frame, H, self.warp_mode, self.criteria, None, 1)
         except Exception as e:
-            LOGGER.warning(f'WARNING: find transform failed. Set warp as identity {e}')
+            LOGGER.warning(f"WARNING: find transform failed. Set warp as identity {e}")
 
         return H
 
-    def applyFeatures(self, raw_frame, detections=None):
-        """Initialize."""
+    def applyFeatures(self, raw_frame: np.array, detections: list = None) -> np.array:
+        """
+        Apply feature-based methods like ORB or SIFT to a raw frame.
+
+        Args:
+            raw_frame (np.ndarray): The raw frame to be processed.
+            detections (list): List of detections to be used in the processing.
+
+        Returns:
+            (np.ndarray): Processed frame.
+
+        Examples:
+            >>> gmc = GMC()
+            >>> gmc.applyFeatures(np.array([[1, 2, 3], [4, 5, 6]]))
+            array([[1, 2, 3],
+                   [4, 5, 6]])
+        """
         height, width, _ = raw_frame.shape
         frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)
         H = np.eye(2, 3)
 
-        # Downscale image (TODO: consider using pyramids)
+        # Downscale image
         if self.downscale > 1.0:
-            # frame = cv2.GaussianBlur(frame, (3, 3), 1.5)
             frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))
             width = width // self.downscale
             height = height // self.downscale
 
         # Find the keypoints
         mask = np.zeros_like(frame)
-        # mask[int(0.05 * height): int(0.95 * height), int(0.05 * width): int(0.95 * width)] = 255
-        mask[int(0.02 * height):int(0.98 * height), int(0.02 * width):int(0.98 * width)] = 255
+        mask[int(0.02 * height) : int(0.98 * height), int(0.02 * width) : int(0.98 * width)] = 255
         if detections is not None:
             for det in detections:
                 tlbr = (det[:4] / self.downscale).astype(np.int_)
-                mask[tlbr[1]:tlbr[3], tlbr[0]:tlbr[2]] = 0
+                mask[tlbr[1] : tlbr[3], tlbr[0] : tlbr[2]] = 0
 
         keypoints = self.detector.detect(frame, mask)
 
         # Compute the descriptors
         keypoints, descriptors = self.extractor.compute(frame, keypoints)
 
         # Handle first frame
@@ -153,18 +197,18 @@
             self.prevDescriptors = copy.copy(descriptors)
 
             # Initialization done
             self.initializedFirstFrame = True
 
             return H
 
-        # Match descriptors.
+        # Match descriptors
         knnMatches = self.matcher.knnMatch(self.prevDescriptors, descriptors, 2)
 
-        # Filtered matches based on smallest spatial distance
+        # Filter matches based on smallest spatial distance
         matches = []
         spatialDistances = []
 
         maxSpatialDistance = 0.25 * np.array([width, height])
 
         # Handle empty matches case
         if len(knnMatches) == 0:
@@ -176,19 +220,22 @@
             return H
 
         for m, n in knnMatches:
             if m.distance < 0.9 * n.distance:
                 prevKeyPointLocation = self.prevKeyPoints[m.queryIdx].pt
                 currKeyPointLocation = keypoints[m.trainIdx].pt
 
-                spatialDistance = (prevKeyPointLocation[0] - currKeyPointLocation[0],
-                                   prevKeyPointLocation[1] - currKeyPointLocation[1])
-
-                if (np.abs(spatialDistance[0]) < maxSpatialDistance[0]) and \
-                        (np.abs(spatialDistance[1]) < maxSpatialDistance[1]):
+                spatialDistance = (
+                    prevKeyPointLocation[0] - currKeyPointLocation[0],
+                    prevKeyPointLocation[1] - currKeyPointLocation[1],
+                )
+
+                if (np.abs(spatialDistance[0]) < maxSpatialDistance[0]) and (
+                    np.abs(spatialDistance[1]) < maxSpatialDistance[1]
+                ):
                     spatialDistances.append(spatialDistance)
                     matches.append(m)
 
         meanSpatialDistances = np.mean(spatialDistances, 0)
         stdSpatialDistances = np.std(spatialDistances, 0)
 
         inliers = (spatialDistances - meanSpatialDistances) < 2.5 * stdSpatialDistances
@@ -206,15 +253,15 @@
         currPoints = np.array(currPoints)
 
         # Draw the keypoint matches on the output image
         # if False:
         #     import matplotlib.pyplot as plt
         #     matches_img = np.hstack((self.prevFrame, frame))
         #     matches_img = cv2.cvtColor(matches_img, cv2.COLOR_GRAY2BGR)
-        #     W = np.size(self.prevFrame, 1)
+        #     W = self.prevFrame.shape[1]
         #     for m in goodMatches:
         #         prev_pt = np.array(self.prevKeyPoints[m.queryIdx].pt, dtype=np.int_)
         #         curr_pt = np.array(keypoints[m.trainIdx].pt, dtype=np.int_)
         #         curr_pt[0] += W
         #         color = np.random.randint(0, 255, 3)
         #         color = (int(color[0]), int(color[1]), int(color[2]))
         #
@@ -223,87 +270,94 @@
         #         matches_img = cv2.circle(matches_img, curr_pt, 2, tuple(color), -1)
         #
         #     plt.figure()
         #     plt.imshow(matches_img)
         #     plt.show()
 
         # Find rigid matrix
-        if (np.size(prevPoints, 0) > 4) and (np.size(prevPoints, 0) == np.size(prevPoints, 0)):
+        if prevPoints.shape[0] > 4:
             H, inliers = cv2.estimateAffinePartial2D(prevPoints, currPoints, cv2.RANSAC)
 
             # Handle downscale
             if self.downscale > 1.0:
                 H[0, 2] *= self.downscale
                 H[1, 2] *= self.downscale
         else:
-            LOGGER.warning('WARNING: not enough matching points')
+            LOGGER.warning("WARNING: not enough matching points")
 
         # Store to next iteration
         self.prevFrame = frame.copy()
         self.prevKeyPoints = copy.copy(keypoints)
         self.prevDescriptors = copy.copy(descriptors)
 
         return H
 
-    def applySparseOptFlow(self, raw_frame, detections=None):
-        """Initialize."""
+    def applySparseOptFlow(self, raw_frame: np.array) -> np.array:
+        """
+        Apply Sparse Optical Flow method to a raw frame.
+
+        Args:
+            raw_frame (np.ndarray): The raw frame to be processed.
+
+        Returns:
+            (np.ndarray): Processed frame.
+
+        Examples:
+            >>> gmc = GMC()
+            >>> gmc.applySparseOptFlow(np.array([[1, 2, 3], [4, 5, 6]]))
+            array([[1, 2, 3],
+                   [4, 5, 6]])
+        """
         height, width, _ = raw_frame.shape
         frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)
         H = np.eye(2, 3)
 
         # Downscale image
         if self.downscale > 1.0:
-            # frame = cv2.GaussianBlur(frame, (3, 3), 1.5)
             frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))
 
         # Find the keypoints
         keypoints = cv2.goodFeaturesToTrack(frame, mask=None, **self.feature_params)
 
         # Handle first frame
-        if not self.initializedFirstFrame:
-            # Initialize data
+        if not self.initializedFirstFrame or self.prevKeyPoints is None:
             self.prevFrame = frame.copy()
             self.prevKeyPoints = copy.copy(keypoints)
-
-            # Initialization done
             self.initializedFirstFrame = True
-
             return H
 
         # Find correspondences
-        matchedKeypoints, status, err = cv2.calcOpticalFlowPyrLK(self.prevFrame, frame, self.prevKeyPoints, None)
+        matchedKeypoints, status, _ = cv2.calcOpticalFlowPyrLK(self.prevFrame, frame, self.prevKeyPoints, None)
 
         # Leave good correspondences only
         prevPoints = []
         currPoints = []
 
         for i in range(len(status)):
             if status[i]:
                 prevPoints.append(self.prevKeyPoints[i])
                 currPoints.append(matchedKeypoints[i])
 
         prevPoints = np.array(prevPoints)
         currPoints = np.array(currPoints)
 
         # Find rigid matrix
-        if (np.size(prevPoints, 0) > 4) and (np.size(prevPoints, 0) == np.size(prevPoints, 0)):
-            H, inliers = cv2.estimateAffinePartial2D(prevPoints, currPoints, cv2.RANSAC)
+        if (prevPoints.shape[0] > 4) and (prevPoints.shape[0] == prevPoints.shape[0]):
+            H, _ = cv2.estimateAffinePartial2D(prevPoints, currPoints, cv2.RANSAC)
 
-            # Handle downscale
             if self.downscale > 1.0:
                 H[0, 2] *= self.downscale
                 H[1, 2] *= self.downscale
         else:
-            LOGGER.warning('WARNING: not enough matching points')
+            LOGGER.warning("WARNING: not enough matching points")
 
-        # Store to next iteration
         self.prevFrame = frame.copy()
         self.prevKeyPoints = copy.copy(keypoints)
 
         return H
 
-    def reset_params(self):
+    def reset_params(self) -> None:
         """Reset parameters."""
         self.prevFrame = None
         self.prevKeyPoints = None
         self.prevDescriptors = None
         self.initializedFirstFrame = False
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/trackers/utils/kalman_filter.py` & `yolov8_pose_triton-8.2.0/ultralytics/trackers/utils/kalman_filter.py`

 * *Files 18% similar despite different names*

```diff
@@ -13,356 +13,348 @@
 
     Object motion follows a constant velocity model. The bounding box location (x, y, a, h) is taken as direct
     observation of the state space (linear observation model).
     """
 
     def __init__(self):
         """Initialize Kalman filter model matrices with motion and observation uncertainty weights."""
-        ndim, dt = 4, 1.
+        ndim, dt = 4, 1.0
 
-        # Create Kalman filter model matrices.
+        # Create Kalman filter model matrices
         self._motion_mat = np.eye(2 * ndim, 2 * ndim)
         for i in range(ndim):
             self._motion_mat[i, ndim + i] = dt
         self._update_mat = np.eye(ndim, 2 * ndim)
 
         # Motion and observation uncertainty are chosen relative to the current state estimate. These weights control
-        # the amount of uncertainty in the model. This is a bit hacky.
-        self._std_weight_position = 1. / 20
-        self._std_weight_velocity = 1. / 160
+        # the amount of uncertainty in the model.
+        self._std_weight_position = 1.0 / 20
+        self._std_weight_velocity = 1.0 / 160
 
-    def initiate(self, measurement):
+    def initiate(self, measurement: np.ndarray) -> tuple:
         """
         Create track from unassociated measurement.
 
-        Parameters
-        ----------
-        measurement : ndarray
-            Bounding box coordinates (x, y, a, h) with center position (x, y),
-            aspect ratio a, and height h.
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the mean vector (8 dimensional) and covariance matrix (8x8
-            dimensional) of the new track. Unobserved velocities are initialized
-            to 0 mean.
+        Args:
+            measurement (ndarray): Bounding box coordinates (x, y, a, h) with center position (x, y), aspect ratio a,
+                and height h.
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional)
+                of the new track. Unobserved velocities are initialized to 0 mean.
         """
         mean_pos = measurement
         mean_vel = np.zeros_like(mean_pos)
         mean = np.r_[mean_pos, mean_vel]
 
         std = [
-            2 * self._std_weight_position * measurement[3], 2 * self._std_weight_position * measurement[3], 1e-2,
-            2 * self._std_weight_position * measurement[3], 10 * self._std_weight_velocity * measurement[3],
-            10 * self._std_weight_velocity * measurement[3], 1e-5, 10 * self._std_weight_velocity * measurement[3]]
+            2 * self._std_weight_position * measurement[3],
+            2 * self._std_weight_position * measurement[3],
+            1e-2,
+            2 * self._std_weight_position * measurement[3],
+            10 * self._std_weight_velocity * measurement[3],
+            10 * self._std_weight_velocity * measurement[3],
+            1e-5,
+            10 * self._std_weight_velocity * measurement[3],
+        ]
         covariance = np.diag(np.square(std))
         return mean, covariance
 
-    def predict(self, mean, covariance):
+    def predict(self, mean: np.ndarray, covariance: np.ndarray) -> tuple:
         """
         Run Kalman filter prediction step.
 
-        Parameters
-        ----------
-        mean : ndarray
-            The 8 dimensional mean vector of the object state at the previous time step.
-        covariance : ndarray
-            The 8x8 dimensional covariance matrix of the object state at the previous time step.
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the mean vector and covariance matrix of the predicted state. Unobserved velocities are
-            initialized to 0 mean.
+        Args:
+            mean (ndarray): The 8 dimensional mean vector of the object state at the previous time step.
+            covariance (ndarray): The 8x8 dimensional covariance matrix of the object state at the previous time step.
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved
+                velocities are initialized to 0 mean.
         """
         std_pos = [
-            self._std_weight_position * mean[3], self._std_weight_position * mean[3], 1e-2,
-            self._std_weight_position * mean[3]]
+            self._std_weight_position * mean[3],
+            self._std_weight_position * mean[3],
+            1e-2,
+            self._std_weight_position * mean[3],
+        ]
         std_vel = [
-            self._std_weight_velocity * mean[3], self._std_weight_velocity * mean[3], 1e-5,
-            self._std_weight_velocity * mean[3]]
+            self._std_weight_velocity * mean[3],
+            self._std_weight_velocity * mean[3],
+            1e-5,
+            self._std_weight_velocity * mean[3],
+        ]
         motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))
 
-        # mean = np.dot(self._motion_mat, mean)
         mean = np.dot(mean, self._motion_mat.T)
         covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov
 
         return mean, covariance
 
-    def project(self, mean, covariance):
+    def project(self, mean: np.ndarray, covariance: np.ndarray) -> tuple:
         """
         Project state distribution to measurement space.
 
-        Parameters
-        ----------
-        mean : ndarray
-            The state's mean vector (8 dimensional array).
-        covariance : ndarray
-            The state's covariance matrix (8x8 dimensional).
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the projected mean and covariance matrix of the given state estimate.
+        Args:
+            mean (ndarray): The state's mean vector (8 dimensional array).
+            covariance (ndarray): The state's covariance matrix (8x8 dimensional).
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the projected mean and covariance matrix of the given state estimate.
         """
         std = [
-            self._std_weight_position * mean[3], self._std_weight_position * mean[3], 1e-1,
-            self._std_weight_position * mean[3]]
+            self._std_weight_position * mean[3],
+            self._std_weight_position * mean[3],
+            1e-1,
+            self._std_weight_position * mean[3],
+        ]
         innovation_cov = np.diag(np.square(std))
 
         mean = np.dot(self._update_mat, mean)
         covariance = np.linalg.multi_dot((self._update_mat, covariance, self._update_mat.T))
         return mean, covariance + innovation_cov
 
-    def multi_predict(self, mean, covariance):
+    def multi_predict(self, mean: np.ndarray, covariance: np.ndarray) -> tuple:
         """
         Run Kalman filter prediction step (Vectorized version).
 
-        Parameters
-        ----------
-        mean : ndarray
-            The Nx8 dimensional mean matrix of the object states at the previous time step.
-        covariance : ndarray
-            The Nx8x8 dimensional covariance matrix of the object states at the previous time step.
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the mean vector and covariance matrix of the predicted state. Unobserved velocities are
-            initialized to 0 mean.
+        Args:
+            mean (ndarray): The Nx8 dimensional mean matrix of the object states at the previous time step.
+            covariance (ndarray): The Nx8x8 covariance matrix of the object states at the previous time step.
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved
+                velocities are initialized to 0 mean.
         """
         std_pos = [
-            self._std_weight_position * mean[:, 3], self._std_weight_position * mean[:, 3],
-            1e-2 * np.ones_like(mean[:, 3]), self._std_weight_position * mean[:, 3]]
+            self._std_weight_position * mean[:, 3],
+            self._std_weight_position * mean[:, 3],
+            1e-2 * np.ones_like(mean[:, 3]),
+            self._std_weight_position * mean[:, 3],
+        ]
         std_vel = [
-            self._std_weight_velocity * mean[:, 3], self._std_weight_velocity * mean[:, 3],
-            1e-5 * np.ones_like(mean[:, 3]), self._std_weight_velocity * mean[:, 3]]
+            self._std_weight_velocity * mean[:, 3],
+            self._std_weight_velocity * mean[:, 3],
+            1e-5 * np.ones_like(mean[:, 3]),
+            self._std_weight_velocity * mean[:, 3],
+        ]
         sqr = np.square(np.r_[std_pos, std_vel]).T
 
         motion_cov = [np.diag(sqr[i]) for i in range(len(mean))]
         motion_cov = np.asarray(motion_cov)
 
         mean = np.dot(mean, self._motion_mat.T)
         left = np.dot(self._motion_mat, covariance).transpose((1, 0, 2))
         covariance = np.dot(left, self._motion_mat.T) + motion_cov
 
         return mean, covariance
 
-    def update(self, mean, covariance, measurement):
+    def update(self, mean: np.ndarray, covariance: np.ndarray, measurement: np.ndarray) -> tuple:
         """
         Run Kalman filter correction step.
 
-        Parameters
-        ----------
-        mean : ndarray
-            The predicted state's mean vector (8 dimensional).
-        covariance : ndarray
-            The state's covariance matrix (8x8 dimensional).
-        measurement : ndarray
-            The 4 dimensional measurement vector (x, y, a, h), where (x, y) is the center position, a the aspect
-            ratio, and h the height of the bounding box.
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the measurement-corrected state distribution.
+        Args:
+            mean (ndarray): The predicted state's mean vector (8 dimensional).
+            covariance (ndarray): The state's covariance matrix (8x8 dimensional).
+            measurement (ndarray): The 4 dimensional measurement vector (x, y, a, h), where (x, y) is the center
+                position, a the aspect ratio, and h the height of the bounding box.
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the measurement-corrected state distribution.
         """
         projected_mean, projected_cov = self.project(mean, covariance)
 
         chol_factor, lower = scipy.linalg.cho_factor(projected_cov, lower=True, check_finite=False)
-        kalman_gain = scipy.linalg.cho_solve((chol_factor, lower),
-                                             np.dot(covariance, self._update_mat.T).T,
-                                             check_finite=False).T
+        kalman_gain = scipy.linalg.cho_solve(
+            (chol_factor, lower), np.dot(covariance, self._update_mat.T).T, check_finite=False
+        ).T
         innovation = measurement - projected_mean
 
         new_mean = mean + np.dot(innovation, kalman_gain.T)
         new_covariance = covariance - np.linalg.multi_dot((kalman_gain, projected_cov, kalman_gain.T))
         return new_mean, new_covariance
 
-    def gating_distance(self, mean, covariance, measurements, only_position=False, metric='maha'):
+    def gating_distance(
+        self,
+        mean: np.ndarray,
+        covariance: np.ndarray,
+        measurements: np.ndarray,
+        only_position: bool = False,
+        metric: str = "maha",
+    ) -> np.ndarray:
         """
         Compute gating distance between state distribution and measurements. A suitable distance threshold can be
         obtained from `chi2inv95`. If `only_position` is False, the chi-square distribution has 4 degrees of freedom,
         otherwise 2.
 
-        Parameters
-        ----------
-        mean : ndarray
-            Mean vector over the state distribution (8 dimensional).
-        covariance : ndarray
-            Covariance of the state distribution (8x8 dimensional).
-        measurements : ndarray
-            An Nx4 dimensional matrix of N measurements, each in format (x, y, a, h) where (x, y) is the bounding box
-            center position, a the aspect ratio, and h the height.
-        only_position : Optional[bool]
-            If True, distance computation is done with respect to the bounding box center position only.
-
-        Returns
-        -------
-        ndarray
-            Returns an array of length N, where the i-th element contains the squared Mahalanobis distance between
-            (mean, covariance) and `measurements[i]`.
+        Args:
+            mean (ndarray): Mean vector over the state distribution (8 dimensional).
+            covariance (ndarray): Covariance of the state distribution (8x8 dimensional).
+            measurements (ndarray): An Nx4 matrix of N measurements, each in format (x, y, a, h) where (x, y)
+                is the bounding box center position, a the aspect ratio, and h the height.
+            only_position (bool, optional): If True, distance computation is done with respect to the bounding box
+                center position only. Defaults to False.
+            metric (str, optional): The metric to use for calculating the distance. Options are 'gaussian' for the
+                squared Euclidean distance and 'maha' for the squared Mahalanobis distance. Defaults to 'maha'.
+
+        Returns:
+            (np.ndarray): Returns an array of length N, where the i-th element contains the squared distance between
+                (mean, covariance) and `measurements[i]`.
         """
         mean, covariance = self.project(mean, covariance)
         if only_position:
             mean, covariance = mean[:2], covariance[:2, :2]
             measurements = measurements[:, :2]
 
         d = measurements - mean
-        if metric == 'gaussian':
+        if metric == "gaussian":
             return np.sum(d * d, axis=1)
-        elif metric == 'maha':
+        elif metric == "maha":
             cholesky_factor = np.linalg.cholesky(covariance)
             z = scipy.linalg.solve_triangular(cholesky_factor, d.T, lower=True, check_finite=False, overwrite_b=True)
             return np.sum(z * z, axis=0)  # square maha
         else:
-            raise ValueError('invalid distance metric')
+            raise ValueError("Invalid distance metric")
 
 
 class KalmanFilterXYWH(KalmanFilterXYAH):
     """
     For BoT-SORT. A simple Kalman filter for tracking bounding boxes in image space.
 
     The 8-dimensional state space (x, y, w, h, vx, vy, vw, vh) contains the bounding box center position (x, y), width
     w, height h, and their respective velocities.
 
     Object motion follows a constant velocity model. The bounding box location (x, y, w, h) is taken as direct
     observation of the state space (linear observation model).
     """
 
-    def initiate(self, measurement):
+    def initiate(self, measurement: np.ndarray) -> tuple:
         """
         Create track from unassociated measurement.
 
-        Parameters
-        ----------
-        measurement : ndarray
-            Bounding box coordinates (x, y, w, h) with center position (x, y), width w, and height h.
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional) of the new track.
-            Unobserved velocities are initialized to 0 mean.
+        Args:
+            measurement (ndarray): Bounding box coordinates (x, y, w, h) with center position (x, y), width, and height.
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional)
+                of the new track. Unobserved velocities are initialized to 0 mean.
         """
         mean_pos = measurement
         mean_vel = np.zeros_like(mean_pos)
         mean = np.r_[mean_pos, mean_vel]
 
         std = [
-            2 * self._std_weight_position * measurement[2], 2 * self._std_weight_position * measurement[3],
-            2 * self._std_weight_position * measurement[2], 2 * self._std_weight_position * measurement[3],
-            10 * self._std_weight_velocity * measurement[2], 10 * self._std_weight_velocity * measurement[3],
-            10 * self._std_weight_velocity * measurement[2], 10 * self._std_weight_velocity * measurement[3]]
+            2 * self._std_weight_position * measurement[2],
+            2 * self._std_weight_position * measurement[3],
+            2 * self._std_weight_position * measurement[2],
+            2 * self._std_weight_position * measurement[3],
+            10 * self._std_weight_velocity * measurement[2],
+            10 * self._std_weight_velocity * measurement[3],
+            10 * self._std_weight_velocity * measurement[2],
+            10 * self._std_weight_velocity * measurement[3],
+        ]
         covariance = np.diag(np.square(std))
         return mean, covariance
 
-    def predict(self, mean, covariance):
+    def predict(self, mean, covariance) -> tuple:
         """
         Run Kalman filter prediction step.
 
-        Parameters
-        ----------
-        mean : ndarray
-            The 8 dimensional mean vector of the object state at the previous time step.
-        covariance : ndarray
-            The 8x8 dimensional covariance matrix of the object state at the previous time step.
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the mean vector and covariance matrix of the predicted state. Unobserved velocities are
-            initialized to 0 mean.
+        Args:
+            mean (ndarray): The 8 dimensional mean vector of the object state at the previous time step.
+            covariance (ndarray): The 8x8 dimensional covariance matrix of the object state at the previous time step.
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved
+                velocities are initialized to 0 mean.
         """
         std_pos = [
-            self._std_weight_position * mean[2], self._std_weight_position * mean[3],
-            self._std_weight_position * mean[2], self._std_weight_position * mean[3]]
+            self._std_weight_position * mean[2],
+            self._std_weight_position * mean[3],
+            self._std_weight_position * mean[2],
+            self._std_weight_position * mean[3],
+        ]
         std_vel = [
-            self._std_weight_velocity * mean[2], self._std_weight_velocity * mean[3],
-            self._std_weight_velocity * mean[2], self._std_weight_velocity * mean[3]]
+            self._std_weight_velocity * mean[2],
+            self._std_weight_velocity * mean[3],
+            self._std_weight_velocity * mean[2],
+            self._std_weight_velocity * mean[3],
+        ]
         motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))
 
         mean = np.dot(mean, self._motion_mat.T)
         covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov
 
         return mean, covariance
 
-    def project(self, mean, covariance):
+    def project(self, mean, covariance) -> tuple:
         """
         Project state distribution to measurement space.
 
-        Parameters
-        ----------
-        mean : ndarray
-            The state's mean vector (8 dimensional array).
-        covariance : ndarray
-            The state's covariance matrix (8x8 dimensional).
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the projected mean and covariance matrix of the given state estimate.
+        Args:
+            mean (ndarray): The state's mean vector (8 dimensional array).
+            covariance (ndarray): The state's covariance matrix (8x8 dimensional).
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the projected mean and covariance matrix of the given state estimate.
         """
         std = [
-            self._std_weight_position * mean[2], self._std_weight_position * mean[3],
-            self._std_weight_position * mean[2], self._std_weight_position * mean[3]]
+            self._std_weight_position * mean[2],
+            self._std_weight_position * mean[3],
+            self._std_weight_position * mean[2],
+            self._std_weight_position * mean[3],
+        ]
         innovation_cov = np.diag(np.square(std))
 
         mean = np.dot(self._update_mat, mean)
         covariance = np.linalg.multi_dot((self._update_mat, covariance, self._update_mat.T))
         return mean, covariance + innovation_cov
 
-    def multi_predict(self, mean, covariance):
+    def multi_predict(self, mean, covariance) -> tuple:
         """
         Run Kalman filter prediction step (Vectorized version).
 
-        Parameters
-        ----------
-        mean : ndarray
-            The Nx8 dimensional mean matrix of the object states at the previous time step.
-        covariance : ndarray
-            The Nx8x8 dimensional covariance matrix of the object states at the previous time step.
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the mean vector and covariance matrix of the predicted state. Unobserved velocities are
-            initialized to 0 mean.
+        Args:
+            mean (ndarray): The Nx8 dimensional mean matrix of the object states at the previous time step.
+            covariance (ndarray): The Nx8x8 covariance matrix of the object states at the previous time step.
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved
+                velocities are initialized to 0 mean.
         """
         std_pos = [
-            self._std_weight_position * mean[:, 2], self._std_weight_position * mean[:, 3],
-            self._std_weight_position * mean[:, 2], self._std_weight_position * mean[:, 3]]
+            self._std_weight_position * mean[:, 2],
+            self._std_weight_position * mean[:, 3],
+            self._std_weight_position * mean[:, 2],
+            self._std_weight_position * mean[:, 3],
+        ]
         std_vel = [
-            self._std_weight_velocity * mean[:, 2], self._std_weight_velocity * mean[:, 3],
-            self._std_weight_velocity * mean[:, 2], self._std_weight_velocity * mean[:, 3]]
+            self._std_weight_velocity * mean[:, 2],
+            self._std_weight_velocity * mean[:, 3],
+            self._std_weight_velocity * mean[:, 2],
+            self._std_weight_velocity * mean[:, 3],
+        ]
         sqr = np.square(np.r_[std_pos, std_vel]).T
 
         motion_cov = [np.diag(sqr[i]) for i in range(len(mean))]
         motion_cov = np.asarray(motion_cov)
 
         mean = np.dot(mean, self._motion_mat.T)
         left = np.dot(self._motion_mat, covariance).transpose((1, 0, 2))
         covariance = np.dot(left, self._motion_mat.T) + motion_cov
 
         return mean, covariance
 
-    def update(self, mean, covariance, measurement):
+    def update(self, mean, covariance, measurement) -> tuple:
         """
         Run Kalman filter correction step.
 
-        Parameters
-        ----------
-        mean : ndarray
-            The predicted state's mean vector (8 dimensional).
-        covariance : ndarray
-            The state's covariance matrix (8x8 dimensional).
-        measurement : ndarray
-            The 4 dimensional measurement vector (x, y, w, h), where (x, y) is the center position, w the width,
-            and h the height of the bounding box.
-
-        Returns
-        -------
-        (ndarray, ndarray)
-            Returns the measurement-corrected state distribution.
+        Args:
+            mean (ndarray): The predicted state's mean vector (8 dimensional).
+            covariance (ndarray): The state's covariance matrix (8x8 dimensional).
+            measurement (ndarray): The 4 dimensional measurement vector (x, y, w, h), where (x, y) is the center
+                position, w the width, and h the height of the bounding box.
+
+        Returns:
+            (tuple[ndarray, ndarray]): Returns the measurement-corrected state distribution.
         """
         return super().update(mean, covariance, measurement)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/trackers/utils/matching.py` & `yolov8_pose_triton-8.2.0/ultralytics/trackers/utils/matching.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,91 +1,103 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import numpy as np
 import scipy
 from scipy.spatial.distance import cdist
 
-from ultralytics.utils.metrics import bbox_ioa
+from ultralytics.utils.metrics import batch_probiou, bbox_ioa
 
 try:
     import lap  # for linear_assignment
 
     assert lap.__version__  # verify package is not directory
 except (ImportError, AssertionError, AttributeError):
     from ultralytics.utils.checks import check_requirements
 
-    check_requirements('lapx>=0.5.2')  # update to lap package from https://github.com/rathaROG/lapx
+    check_requirements("lapx>=0.5.2")  # update to lap package from https://github.com/rathaROG/lapx
     import lap
 
 
-def linear_assignment(cost_matrix, thresh, use_lap=True):
+def linear_assignment(cost_matrix: np.ndarray, thresh: float, use_lap: bool = True) -> tuple:
     """
     Perform linear assignment using scipy or lap.lapjv.
 
     Args:
         cost_matrix (np.ndarray): The matrix containing cost values for assignments.
         thresh (float): Threshold for considering an assignment valid.
         use_lap (bool, optional): Whether to use lap.lapjv. Defaults to True.
 
     Returns:
-        (tuple): Tuple containing matched indices, unmatched indices from 'a', and unmatched indices from 'b'.
+        Tuple with:
+            - matched indices
+            - unmatched indices from 'a'
+            - unmatched indices from 'b'
     """
 
     if cost_matrix.size == 0:
         return np.empty((0, 2), dtype=int), tuple(range(cost_matrix.shape[0])), tuple(range(cost_matrix.shape[1]))
 
     if use_lap:
+        # Use lap.lapjv
         # https://github.com/gatagat/lap
         _, x, y = lap.lapjv(cost_matrix, extend_cost=True, cost_limit=thresh)
         matches = [[ix, mx] for ix, mx in enumerate(x) if mx >= 0]
         unmatched_a = np.where(x < 0)[0]
         unmatched_b = np.where(y < 0)[0]
     else:
+        # Use scipy.optimize.linear_sum_assignment
         # https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linear_sum_assignment.html
         x, y = scipy.optimize.linear_sum_assignment(cost_matrix)  # row x, col y
         matches = np.asarray([[x[i], y[i]] for i in range(len(x)) if cost_matrix[x[i], y[i]] <= thresh])
         if len(matches) == 0:
             unmatched_a = list(np.arange(cost_matrix.shape[0]))
             unmatched_b = list(np.arange(cost_matrix.shape[1]))
         else:
             unmatched_a = list(set(np.arange(cost_matrix.shape[0])) - set(matches[:, 0]))
             unmatched_b = list(set(np.arange(cost_matrix.shape[1])) - set(matches[:, 1]))
 
     return matches, unmatched_a, unmatched_b
 
 
-def iou_distance(atracks, btracks):
+def iou_distance(atracks: list, btracks: list) -> np.ndarray:
     """
     Compute cost based on Intersection over Union (IoU) between tracks.
 
     Args:
         atracks (list[STrack] | list[np.ndarray]): List of tracks 'a' or bounding boxes.
         btracks (list[STrack] | list[np.ndarray]): List of tracks 'b' or bounding boxes.
 
     Returns:
         (np.ndarray): Cost matrix computed based on IoU.
     """
 
-    if (len(atracks) > 0 and isinstance(atracks[0], np.ndarray)) \
-            or (len(btracks) > 0 and isinstance(btracks[0], np.ndarray)):
+    if atracks and isinstance(atracks[0], np.ndarray) or btracks and isinstance(btracks[0], np.ndarray):
         atlbrs = atracks
         btlbrs = btracks
     else:
-        atlbrs = [track.tlbr for track in atracks]
-        btlbrs = [track.tlbr for track in btracks]
+        atlbrs = [track.xywha if track.angle is not None else track.xyxy for track in atracks]
+        btlbrs = [track.xywha if track.angle is not None else track.xyxy for track in btracks]
 
     ious = np.zeros((len(atlbrs), len(btlbrs)), dtype=np.float32)
     if len(atlbrs) and len(btlbrs):
-        ious = bbox_ioa(np.ascontiguousarray(atlbrs, dtype=np.float32),
-                        np.ascontiguousarray(btlbrs, dtype=np.float32),
-                        iou=True)
+        if len(atlbrs[0]) == 5 and len(btlbrs[0]) == 5:
+            ious = batch_probiou(
+                np.ascontiguousarray(atlbrs, dtype=np.float32),
+                np.ascontiguousarray(btlbrs, dtype=np.float32),
+            ).numpy()
+        else:
+            ious = bbox_ioa(
+                np.ascontiguousarray(atlbrs, dtype=np.float32),
+                np.ascontiguousarray(btlbrs, dtype=np.float32),
+                iou=True,
+            )
     return 1 - ious  # cost matrix
 
 
-def embedding_distance(tracks, detections, metric='cosine'):
+def embedding_distance(tracks: list, detections: list, metric: str = "cosine") -> np.ndarray:
     """
     Compute distance between tracks and detections based on embeddings.
 
     Args:
         tracks (list[STrack]): List of tracks.
         detections (list[BaseTrack]): List of detections.
         metric (str, optional): Metric for distance computation. Defaults to 'cosine'.
@@ -101,15 +113,15 @@
     # for i, track in enumerate(tracks):
     # cost_matrix[i, :] = np.maximum(0.0, cdist(track.smooth_feat.reshape(1,-1), det_features, metric))
     track_features = np.asarray([track.smooth_feat for track in tracks], dtype=np.float32)
     cost_matrix = np.maximum(0.0, cdist(track_features, det_features, metric))  # Normalized features
     return cost_matrix
 
 
-def fuse_score(cost_matrix, detections):
+def fuse_score(cost_matrix: np.ndarray, detections: list) -> np.ndarray:
     """
     Fuses cost matrix with detection scores to produce a single similarity matrix.
 
     Args:
         cost_matrix (np.ndarray): The matrix containing cost values for assignments.
         detections (list[BaseTrack]): List of detections with scores.
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/__init__.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import contextlib
+import importlib.metadata
 import inspect
 import logging.config
 import os
 import platform
 import re
 import subprocess
 import sys
 import threading
+import time
 import urllib
 import uuid
 from pathlib import Path
 from types import SimpleNamespace
 from typing import Union
 
 import cv2
@@ -21,31 +23,33 @@
 import torch
 import yaml
 from tqdm import tqdm as tqdm_original
 
 from ultralytics import __version__
 
 # PyTorch Multi-GPU DDP Constants
-RANK = int(os.getenv('RANK', -1))
-LOCAL_RANK = int(os.getenv('LOCAL_RANK', -1))  # https://pytorch.org/docs/stable/elastic/run.html
+RANK = int(os.getenv("RANK", -1))
+LOCAL_RANK = int(os.getenv("LOCAL_RANK", -1))  # https://pytorch.org/docs/stable/elastic/run.html
 
 # Other Constants
+ARGV = sys.argv or ["", ""]  # sometimes sys.argv = []
 FILE = Path(__file__).resolve()
 ROOT = FILE.parents[1]  # YOLO
-ASSETS = ROOT / 'assets'  # default images
-DEFAULT_CFG_PATH = ROOT / 'cfg/default.yaml'
+ASSETS = ROOT / "assets"  # default images
+DEFAULT_CFG_PATH = ROOT / "cfg/default.yaml"
 NUM_THREADS = min(8, max(1, os.cpu_count() - 1))  # number of YOLOv5 multiprocessing threads
-AUTOINSTALL = str(os.getenv('YOLO_AUTOINSTALL', True)).lower() == 'true'  # global auto-install mode
-VERBOSE = str(os.getenv('YOLO_VERBOSE', True)).lower() == 'true'  # global verbose mode
-TQDM_BAR_FORMAT = '{l_bar}{bar:10}{r_bar}' if VERBOSE else None  # tqdm bar format
-LOGGING_NAME = 'ultralytics'
-MACOS, LINUX, WINDOWS = (platform.system() == x for x in ['Darwin', 'Linux', 'Windows'])  # environment booleans
-ARM64 = platform.machine() in ('arm64', 'aarch64')  # ARM64 booleans
-HELP_MSG = \
-    """
+AUTOINSTALL = str(os.getenv("YOLO_AUTOINSTALL", True)).lower() == "true"  # global auto-install mode
+VERBOSE = str(os.getenv("YOLO_VERBOSE", True)).lower() == "true"  # global verbose mode
+TQDM_BAR_FORMAT = "{l_bar}{bar:10}{r_bar}" if VERBOSE else None  # tqdm bar format
+LOGGING_NAME = "ultralytics"
+MACOS, LINUX, WINDOWS = (platform.system() == x for x in ["Darwin", "Linux", "Windows"])  # environment booleans
+ARM64 = platform.machine() in {"arm64", "aarch64"}  # ARM64 booleans
+PYTHON_VERSION = platform.python_version()
+TORCHVISION_VERSION = importlib.metadata.version("torchvision")  # faster than importing torchvision
+HELP_MSG = """
     Usage examples for running YOLOv8:
 
     1. Install the ultralytics package:
 
         pip install ultralytics
 
     2. Use the Python SDK:
@@ -95,57 +99,60 @@
 
     Docs: https://docs.ultralytics.com
     Community: https://community.ultralytics.com
     GitHub: https://github.com/ultralytics/ultralytics
     """
 
 # Settings
-torch.set_printoptions(linewidth=320, precision=4, profile='default')
-np.set_printoptions(linewidth=320, formatter={'float_kind': '{:11.5g}'.format})  # format short g, %precision=5
+torch.set_printoptions(linewidth=320, precision=4, profile="default")
+np.set_printoptions(linewidth=320, formatter={"float_kind": "{:11.5g}".format})  # format short g, %precision=5
 cv2.setNumThreads(0)  # prevent OpenCV from multithreading (incompatible with PyTorch DataLoader)
-os.environ['NUMEXPR_MAX_THREADS'] = str(NUM_THREADS)  # NumExpr max threads
-os.environ['CUBLAS_WORKSPACE_CONFIG'] = ':4096:8'  # for deterministic training
-os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'  # suppress verbose TF compiler warnings in Colab
+os.environ["NUMEXPR_MAX_THREADS"] = str(NUM_THREADS)  # NumExpr max threads
+os.environ["CUBLAS_WORKSPACE_CONFIG"] = ":4096:8"  # for deterministic training
+os.environ["TF_CPP_MIN_LOG_LEVEL"] = "2"  # suppress verbose TF compiler warnings in Colab
 
 
 class TQDM(tqdm_original):
     """
     Custom Ultralytics tqdm class with different default arguments.
 
     Args:
         *args (list): Positional arguments passed to original tqdm.
-        **kwargs (dict): Keyword arguments, with custom defaults applied.
+        **kwargs (any): Keyword arguments, with custom defaults applied.
     """
 
     def __init__(self, *args, **kwargs):
-        """Initialize custom Ultralytics tqdm class with different default arguments."""
-        # Set new default values (these can still be overridden when calling TQDM)
-        kwargs['disable'] = not VERBOSE or kwargs.get('disable', False)  # logical 'and' with default value if passed
-        kwargs.setdefault('bar_format', TQDM_BAR_FORMAT)  # override default value if passed
+        """
+        Initialize custom Ultralytics tqdm class with different default arguments.
+
+        Note these can still be overridden when calling TQDM.
+        """
+        kwargs["disable"] = not VERBOSE or kwargs.get("disable", False)  # logical 'and' with default value if passed
+        kwargs.setdefault("bar_format", TQDM_BAR_FORMAT)  # override default value if passed
         super().__init__(*args, **kwargs)
 
 
 class SimpleClass:
     """Ultralytics SimpleClass is a base class providing helpful string representation, error reporting, and attribute
     access methods for easier debugging and usage.
     """
 
     def __str__(self):
         """Return a human-readable string representation of the object."""
         attr = []
         for a in dir(self):
             v = getattr(self, a)
-            if not callable(v) and not a.startswith('_'):
+            if not callable(v) and not a.startswith("_"):
                 if isinstance(v, SimpleClass):
                     # Display only the module and class name for subclasses
-                    s = f'{a}: {v.__module__}.{v.__class__.__name__} object'
+                    s = f"{a}: {v.__module__}.{v.__class__.__name__} object"
                 else:
-                    s = f'{a}: {repr(v)}'
+                    s = f"{a}: {repr(v)}"
                 attr.append(s)
-        return f'{self.__module__}.{self.__class__.__name__} object with attributes:\n\n' + '\n'.join(attr)
+        return f"{self.__module__}.{self.__class__.__name__} object with attributes:\n\n" + "\n".join(attr)
 
     def __repr__(self):
         """Return a machine-readable string representation of the object."""
         return self.__str__()
 
     def __getattr__(self, attr):
         """Custom attribute access error message with helpful information."""
@@ -160,32 +167,34 @@
 
     def __iter__(self):
         """Return an iterator of key-value pairs from the namespace's attributes."""
         return iter(vars(self).items())
 
     def __str__(self):
         """Return a human-readable string representation of the object."""
-        return '\n'.join(f'{k}={v}' for k, v in vars(self).items())
+        return "\n".join(f"{k}={v}" for k, v in vars(self).items())
 
     def __getattr__(self, attr):
         """Custom attribute access error message with helpful information."""
         name = self.__class__.__name__
-        raise AttributeError(f"""
+        raise AttributeError(
+            f"""
             '{name}' object has no attribute '{attr}'. This may be caused by a modified or out of date ultralytics
             'default.yaml' file.\nPlease update your code with 'pip install -U ultralytics' and if necessary replace
             {DEFAULT_CFG_PATH} with the latest version from
             https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/default.yaml
-            """)
+            """
+        )
 
     def get(self, key, default=None):
         """Return the value of the specified key if it exists; otherwise, return the default value."""
         return getattr(self, key, default)
 
 
-def plt_settings(rcparams=None, backend='Agg'):
+def plt_settings(rcparams=None, backend="Agg"):
     """
     Decorator to temporarily set rc parameters and the backend for a plotting function.
 
     Example:
         decorator: @plt_settings({"font.size": 12})
         context manager: with plt_settings({"font.size": 12}):
 
@@ -195,85 +204,91 @@
 
     Returns:
         (Callable): Decorated function with temporarily set rc parameters and backend. This decorator can be
             applied to any function that needs to have specific matplotlib rc parameters and backend for its execution.
     """
 
     if rcparams is None:
-        rcparams = {'font.size': 11}
+        rcparams = {"font.size": 11}
 
     def decorator(func):
         """Decorator to apply temporary rc parameters and backend to a function."""
 
         def wrapper(*args, **kwargs):
             """Sets rc parameters and backend, calls the original function, and restores the settings."""
             original_backend = plt.get_backend()
-            if backend != original_backend:
-                plt.close('all')  # auto-close()ing of figures upon backend switching is deprecated since 3.8
+            if backend.lower() != original_backend.lower():
+                plt.close("all")  # auto-close()ing of figures upon backend switching is deprecated since 3.8
                 plt.switch_backend(backend)
 
             with plt.rc_context(rcparams):
                 result = func(*args, **kwargs)
 
             if backend != original_backend:
-                plt.close('all')
+                plt.close("all")
                 plt.switch_backend(original_backend)
             return result
 
         return wrapper
 
     return decorator
 
 
-def set_logging(name=LOGGING_NAME, verbose=True):
-    """Sets up logging for the given name with UTF-8 encoding support."""
+def set_logging(name="LOGGING_NAME", verbose=True):
+    """Sets up logging for the given name with UTF-8 encoding support, ensuring compatibility across different
+    environments.
+    """
     level = logging.INFO if verbose and RANK in {-1, 0} else logging.ERROR  # rank in world for Multi-GPU trainings
 
-    # Configure the console (stdout) encoding to UTF-8
-    formatter = logging.Formatter('%(message)s')  # Default formatter
-    if WINDOWS and sys.stdout.encoding != 'utf-8':
+    # Configure the console (stdout) encoding to UTF-8, with checks for compatibility
+    formatter = logging.Formatter("%(message)s")  # Default formatter
+    if WINDOWS and hasattr(sys.stdout, "encoding") and sys.stdout.encoding != "utf-8":
+
+        class CustomFormatter(logging.Formatter):
+            def format(self, record):
+                """Sets up logging with UTF-8 encoding and configurable verbosity."""
+                return emojis(super().format(record))
+
         try:
-            if hasattr(sys.stdout, 'reconfigure'):
-                sys.stdout.reconfigure(encoding='utf-8')
-            elif hasattr(sys.stdout, 'buffer'):
+            # Attempt to reconfigure stdout to use UTF-8 encoding if possible
+            if hasattr(sys.stdout, "reconfigure"):
+                sys.stdout.reconfigure(encoding="utf-8")
+            # For environments where reconfigure is not available, wrap stdout in a TextIOWrapper
+            elif hasattr(sys.stdout, "buffer"):
                 import io
-                sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
+
+                sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8")
             else:
-                sys.stdout.encoding = 'utf-8'
+                formatter = CustomFormatter("%(message)s")
         except Exception as e:
-            print(f'Creating custom formatter for non UTF-8 environments due to {e}')
-
-            class CustomFormatter(logging.Formatter):
-
-                def format(self, record):
-                    return emojis(super().format(record))
+            print(f"Creating custom formatter for non UTF-8 environments due to {e}")
+            formatter = CustomFormatter("%(message)s")
 
-            formatter = CustomFormatter('%(message)s')  # Use CustomFormatter to eliminate UTF-8 output as last recourse
-
-    # Create and configure the StreamHandler
+    # Create and configure the StreamHandler with the appropriate formatter and level
     stream_handler = logging.StreamHandler(sys.stdout)
     stream_handler.setFormatter(formatter)
     stream_handler.setLevel(level)
 
+    # Set up the logger
     logger = logging.getLogger(name)
     logger.setLevel(level)
     logger.addHandler(stream_handler)
     logger.propagate = False
     return logger
 
 
 # Set logger
 LOGGER = set_logging(LOGGING_NAME, verbose=VERBOSE)  # define globally (used in train.py, val.py, predict.py, etc.)
-for logger in 'sentry_sdk', 'urllib3.connectionpool':
+for logger in "sentry_sdk", "urllib3.connectionpool":
     logging.getLogger(logger).setLevel(logging.CRITICAL + 1)
 
 
-def emojis(string=''):
+def emojis(string=""):
     """Return platform-dependent emoji-safe version of string."""
-    return string.encode().decode('ascii', 'ignore') if WINDOWS else string
+    return string.encode().decode("ascii", "ignore") if WINDOWS else string
 
 
 class ThreadingLocked:
     """
     A decorator class for ensuring thread-safe execution of a function or method. This class can be used as a decorator
     to make sure that if the decorated function is called from multiple threads, only one thread at a time will be able
     to execute the function.
@@ -305,15 +320,15 @@
             """Applies thread-safety to the decorated function or method."""
             with self.lock:
                 return f(*args, **kwargs)
 
         return decorated
 
 
-def yaml_save(file='data.yaml', data=None, header=''):
+def yaml_save(file="data.yaml", data=None, header=""):
     """
     Save YAML data to a file.
 
     Args:
         file (str, optional): File name. Default is 'data.yaml'.
         data (dict): Data to save in YAML format.
         header (str, optional): YAML header to add.
@@ -331,155 +346,182 @@
     # Convert Path objects to strings
     valid_types = int, float, str, bool, list, tuple, dict, type(None)
     for k, v in data.items():
         if not isinstance(v, valid_types):
             data[k] = str(v)
 
     # Dump data to file in YAML format
-    with open(file, 'w', errors='ignore', encoding='utf-8') as f:
+    with open(file, "w", errors="ignore", encoding="utf-8") as f:
         if header:
             f.write(header)
         yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)
 
 
-def yaml_load(file='data.yaml', append_filename=False):
+def yaml_load(file="data.yaml", append_filename=False):
     """
     Load YAML data from a file.
 
     Args:
         file (str, optional): File name. Default is 'data.yaml'.
         append_filename (bool): Add the YAML filename to the YAML dictionary. Default is False.
 
     Returns:
         (dict): YAML data and file name.
     """
-    assert Path(file).suffix in ('.yaml', '.yml'), f'Attempting to load non-YAML file {file} with yaml_load()'
-    with open(file, errors='ignore', encoding='utf-8') as f:
+    assert Path(file).suffix in {".yaml", ".yml"}, f"Attempting to load non-YAML file {file} with yaml_load()"
+    with open(file, errors="ignore", encoding="utf-8") as f:
         s = f.read()  # string
 
         # Remove special characters
         if not s.isprintable():
-            s = re.sub(r'[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD\U00010000-\U0010ffff]+', '', s)
+            s = re.sub(r"[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD\U00010000-\U0010ffff]+", "", s)
 
         # Add YAML filename to dict and return
         data = yaml.safe_load(s) or {}  # always return a dict (yaml.safe_load() may return None for empty files)
         if append_filename:
-            data['yaml_file'] = str(file)
+            data["yaml_file"] = str(file)
         return data
 
 
 def yaml_print(yaml_file: Union[str, Path, dict]) -> None:
     """
     Pretty prints a YAML file or a YAML-formatted dictionary.
 
     Args:
         yaml_file: The file path of the YAML file or a YAML-formatted dictionary.
 
     Returns:
-        None
+        (None)
     """
     yaml_dict = yaml_load(yaml_file) if isinstance(yaml_file, (str, Path)) else yaml_file
     dump = yaml.dump(yaml_dict, sort_keys=False, allow_unicode=True)
     LOGGER.info(f"Printing '{colorstr('bold', 'black', yaml_file)}'\n\n{dump}")
 
 
 # Default configuration
 DEFAULT_CFG_DICT = yaml_load(DEFAULT_CFG_PATH)
 for k, v in DEFAULT_CFG_DICT.items():
-    if isinstance(v, str) and v.lower() == 'none':
+    if isinstance(v, str) and v.lower() == "none":
         DEFAULT_CFG_DICT[k] = None
 DEFAULT_CFG_KEYS = DEFAULT_CFG_DICT.keys()
 DEFAULT_CFG = IterableSimpleNamespace(**DEFAULT_CFG_DICT)
 
 
+def read_device_model() -> str:
+    """
+    Reads the device model information from the system and caches it for quick access. Used by is_jetson() and
+    is_raspberrypi().
+
+    Returns:
+        (str): Model file contents if read successfully or empty string otherwise.
+    """
+    with contextlib.suppress(Exception):
+        with open("/proc/device-tree/model") as f:
+            return f.read()
+    return ""
+
+
 def is_ubuntu() -> bool:
     """
     Check if the OS is Ubuntu.
 
     Returns:
         (bool): True if OS is Ubuntu, False otherwise.
     """
     with contextlib.suppress(FileNotFoundError):
-        with open('/etc/os-release') as f:
-            return 'ID=ubuntu' in f.read()
+        with open("/etc/os-release") as f:
+            return "ID=ubuntu" in f.read()
     return False
 
 
 def is_colab():
     """
     Check if the current script is running inside a Google Colab notebook.
 
     Returns:
         (bool): True if running inside a Colab notebook, False otherwise.
     """
-    return 'COLAB_RELEASE_TAG' in os.environ or 'COLAB_BACKEND_VERSION' in os.environ
+    return "COLAB_RELEASE_TAG" in os.environ or "COLAB_BACKEND_VERSION" in os.environ
 
 
 def is_kaggle():
     """
     Check if the current script is running inside a Kaggle kernel.
 
     Returns:
         (bool): True if running inside a Kaggle kernel, False otherwise.
     """
-    return os.environ.get('PWD') == '/kaggle/working' and os.environ.get('KAGGLE_URL_BASE') == 'https://www.kaggle.com'
+    return os.environ.get("PWD") == "/kaggle/working" and os.environ.get("KAGGLE_URL_BASE") == "https://www.kaggle.com"
 
 
 def is_jupyter():
     """
     Check if the current script is running inside a Jupyter Notebook. Verified on Colab, Jupyterlab, Kaggle, Paperspace.
 
     Returns:
         (bool): True if running inside a Jupyter Notebook, False otherwise.
     """
     with contextlib.suppress(Exception):
         from IPython import get_ipython
+
         return get_ipython() is not None
     return False
 
 
 def is_docker() -> bool:
     """
     Determine if the script is running inside a Docker container.
 
     Returns:
         (bool): True if the script is running inside a Docker container, False otherwise.
     """
-    file = Path('/proc/self/cgroup')
-    if file.exists():
-        with open(file) as f:
-            return 'docker' in f.read()
-    else:
-        return False
+    with contextlib.suppress(Exception):
+        with open("/proc/self/cgroup") as f:
+            return "docker" in f.read()
+    return False
+
+
+def is_raspberrypi() -> bool:
+    """
+    Determines if the Python environment is running on a Raspberry Pi by checking the device model information.
+
+    Returns:
+        (bool): True if running on a Raspberry Pi, False otherwise.
+    """
+    return "Raspberry Pi" in PROC_DEVICE_MODEL
+
+
+def is_jetson() -> bool:
+    """
+    Determines if the Python environment is running on a Jetson Nano or Jetson Orin device by checking the device model
+    information.
+
+    Returns:
+        (bool): True if running on a Jetson Nano or Jetson Orin, False otherwise.
+    """
+    return "NVIDIA" in PROC_DEVICE_MODEL  # i.e. "NVIDIA Jetson Nano" or "NVIDIA Orin NX"
 
 
 def is_online() -> bool:
     """
     Check internet connectivity by attempting to connect to a known online host.
 
     Returns:
         (bool): True if connection is successful, False otherwise.
     """
-    import socket
+    with contextlib.suppress(Exception):
+        assert str(os.getenv("YOLO_OFFLINE", "")).lower() != "true"  # check if ENV var YOLO_OFFLINE="True"
+        import socket
 
-    for host in '1.1.1.1', '8.8.8.8', '223.5.5.5':  # Cloudflare, Google, AliDNS:
-        try:
-            test_connection = socket.create_connection(address=(host, 53), timeout=2)
-        except (socket.timeout, socket.gaierror, OSError):
-            continue
-        else:
-            # If the connection was successful, close it to avoid a ResourceWarning
-            test_connection.close()
+        for dns in ("1.1.1.1", "8.8.8.8"):  # check Cloudflare and Google DNS
+            socket.create_connection(address=(dns, 80), timeout=1.0).close()
             return True
     return False
 
 
-ONLINE = is_online()
-
-
 def is_pip_package(filepath: str = __name__) -> bool:
     """
     Determines if the file at the given filepath is part of a pip package.
 
     Args:
         filepath (str): The filepath to check.
 
@@ -511,74 +553,74 @@
 def is_pytest_running():
     """
     Determines whether pytest is currently running or not.
 
     Returns:
         (bool): True if pytest is running, False otherwise.
     """
-    return ('PYTEST_CURRENT_TEST' in os.environ) or ('pytest' in sys.modules) or ('pytest' in Path(sys.argv[0]).stem)
+    return ("PYTEST_CURRENT_TEST" in os.environ) or ("pytest" in sys.modules) or ("pytest" in Path(ARGV[0]).stem)
 
 
 def is_github_action_running() -> bool:
     """
     Determine if the current environment is a GitHub Actions runner.
 
     Returns:
         (bool): True if the current environment is a GitHub Actions runner, False otherwise.
     """
-    return 'GITHUB_ACTIONS' in os.environ and 'GITHUB_WORKFLOW' in os.environ and 'RUNNER_OS' in os.environ
-
-
-def is_git_dir():
-    """
-    Determines whether the current file is part of a git repository. If the current file is not part of a git
-    repository, returns None.
-
-    Returns:
-        (bool): True if current file is part of a git repository.
-    """
-    return get_git_dir() is not None
+    return "GITHUB_ACTIONS" in os.environ and "GITHUB_WORKFLOW" in os.environ and "RUNNER_OS" in os.environ
 
 
 def get_git_dir():
     """
     Determines whether the current file is part of a git repository and if so, returns the repository root directory. If
     the current file is not part of a git repository, returns None.
 
     Returns:
         (Path | None): Git root directory if found or None if not found.
     """
     for d in Path(__file__).parents:
-        if (d / '.git').is_dir():
+        if (d / ".git").is_dir():
             return d
 
 
+def is_git_dir():
+    """
+    Determines whether the current file is part of a git repository. If the current file is not part of a git
+    repository, returns None.
+
+    Returns:
+        (bool): True if current file is part of a git repository.
+    """
+    return GIT_DIR is not None
+
+
 def get_git_origin_url():
     """
     Retrieves the origin URL of a git repository.
 
     Returns:
         (str | None): The origin URL of the git repository or None if not git directory.
     """
-    if is_git_dir():
+    if IS_GIT_DIR:
         with contextlib.suppress(subprocess.CalledProcessError):
-            origin = subprocess.check_output(['git', 'config', '--get', 'remote.origin.url'])
+            origin = subprocess.check_output(["git", "config", "--get", "remote.origin.url"])
             return origin.decode().strip()
 
 
 def get_git_branch():
     """
     Returns the current git branch name. If not in a git repository, returns None.
 
     Returns:
         (str | None): The current git branch name or None if not a git directory.
     """
-    if is_git_dir():
+    if IS_GIT_DIR:
         with contextlib.suppress(subprocess.CalledProcessError):
-            origin = subprocess.check_output(['git', 'rev-parse', '--abbrev-ref', 'HEAD'])
+            origin = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"])
             return origin.decode().strip()
 
 
 def get_default_args(func):
     """
     Returns a dictionary of default arguments for a function.
 
@@ -597,52 +639,65 @@
     Retrieve the Ubuntu version if the OS is Ubuntu.
 
     Returns:
         (str): Ubuntu version or None if not an Ubuntu OS.
     """
     if is_ubuntu():
         with contextlib.suppress(FileNotFoundError, AttributeError):
-            with open('/etc/os-release') as f:
+            with open("/etc/os-release") as f:
                 return re.search(r'VERSION_ID="(\d+\.\d+)"', f.read())[1]
 
 
-def get_user_config_dir(sub_dir='Ultralytics'):
+def get_user_config_dir(sub_dir="Ultralytics"):
     """
-    Get the user config directory.
+    Return the appropriate config directory based on the environment operating system.
 
     Args:
         sub_dir (str): The name of the subdirectory to create.
 
     Returns:
         (Path): The path to the user config directory.
     """
-    # Return the appropriate config directory for each operating system
     if WINDOWS:
-        path = Path.home() / 'AppData' / 'Roaming' / sub_dir
+        path = Path.home() / "AppData" / "Roaming" / sub_dir
     elif MACOS:  # macOS
-        path = Path.home() / 'Library' / 'Application Support' / sub_dir
+        path = Path.home() / "Library" / "Application Support" / sub_dir
     elif LINUX:
-        path = Path.home() / '.config' / sub_dir
+        path = Path.home() / ".config" / sub_dir
     else:
-        raise ValueError(f'Unsupported operating system: {platform.system()}')
+        raise ValueError(f"Unsupported operating system: {platform.system()}")
 
     # GCP and AWS lambda fix, only /tmp is writeable
     if not is_dir_writeable(path.parent):
-        LOGGER.warning(f"WARNING  user config directory '{path}' is not writeable, defaulting to '/tmp' or CWD."
-                       'Alternatively you can define a YOLO_CONFIG_DIR environment variable for this path.')
-        path = Path('/tmp') / sub_dir if is_dir_writeable('/tmp') else Path().cwd() / sub_dir
+        LOGGER.warning(
+            f"WARNING  user config directory '{path}' is not writeable, defaulting to '/tmp' or CWD."
+            "Alternatively you can define a YOLO_CONFIG_DIR environment variable for this path."
+        )
+        path = Path("/tmp") / sub_dir if is_dir_writeable("/tmp") else Path().cwd() / sub_dir
 
     # Create the subdirectory if it does not exist
     path.mkdir(parents=True, exist_ok=True)
 
     return path
 
 
-USER_CONFIG_DIR = Path(os.getenv('YOLO_CONFIG_DIR') or get_user_config_dir())  # Ultralytics settings dir
-SETTINGS_YAML = USER_CONFIG_DIR / 'settings.yaml'
+# Define constants (required below)
+PROC_DEVICE_MODEL = read_device_model()  # is_jetson() and is_raspberrypi() depend on this constant
+ONLINE = is_online()
+IS_COLAB = is_colab()
+IS_DOCKER = is_docker()
+IS_JETSON = is_jetson()
+IS_JUPYTER = is_jupyter()
+IS_KAGGLE = is_kaggle()
+IS_PIP_PACKAGE = is_pip_package()
+IS_RASPBERRYPI = is_raspberrypi()
+GIT_DIR = get_git_dir()
+IS_GIT_DIR = is_git_dir()
+USER_CONFIG_DIR = Path(os.getenv("YOLO_CONFIG_DIR") or get_user_config_dir())  # Ultralytics settings dir
+SETTINGS_YAML = USER_CONFIG_DIR / "settings.yaml"
 
 
 def colorstr(*input):
     """
     Colors a string based on the provided color and style arguments. Utilizes ANSI escape codes.
     See https://en.wikipedia.org/wiki/ANSI_escape_code for more details.
 
@@ -662,39 +717,40 @@
                        'bright_blue', 'bright_magenta', 'bright_cyan', 'bright_white'
         Misc: 'end', 'bold', 'underline'
 
     Returns:
         (str): The input string wrapped with ANSI escape codes for the specified color and style.
 
     Examples:
-        >>> colorstr('blue', 'bold', 'hello world')
-        >>> '\033[34m\033[1mhello world\033[0m'
+        >>> colorstr("blue", "bold", "hello world")
+        >>> "\033[34m\033[1mhello world\033[0m"
     """
-    *args, string = input if len(input) > 1 else ('blue', 'bold', input[0])  # color arguments, string
+    *args, string = input if len(input) > 1 else ("blue", "bold", input[0])  # color arguments, string
     colors = {
-        'black': '\033[30m',  # basic colors
-        'red': '\033[31m',
-        'green': '\033[32m',
-        'yellow': '\033[33m',
-        'blue': '\033[34m',
-        'magenta': '\033[35m',
-        'cyan': '\033[36m',
-        'white': '\033[37m',
-        'bright_black': '\033[90m',  # bright colors
-        'bright_red': '\033[91m',
-        'bright_green': '\033[92m',
-        'bright_yellow': '\033[93m',
-        'bright_blue': '\033[94m',
-        'bright_magenta': '\033[95m',
-        'bright_cyan': '\033[96m',
-        'bright_white': '\033[97m',
-        'end': '\033[0m',  # misc
-        'bold': '\033[1m',
-        'underline': '\033[4m'}
-    return ''.join(colors[x] for x in args) + f'{string}' + colors['end']
+        "black": "\033[30m",  # basic colors
+        "red": "\033[31m",
+        "green": "\033[32m",
+        "yellow": "\033[33m",
+        "blue": "\033[34m",
+        "magenta": "\033[35m",
+        "cyan": "\033[36m",
+        "white": "\033[37m",
+        "bright_black": "\033[90m",  # bright colors
+        "bright_red": "\033[91m",
+        "bright_green": "\033[92m",
+        "bright_yellow": "\033[93m",
+        "bright_blue": "\033[94m",
+        "bright_magenta": "\033[95m",
+        "bright_cyan": "\033[96m",
+        "bright_white": "\033[97m",
+        "end": "\033[0m",  # misc
+        "bold": "\033[1m",
+        "underline": "\033[4m",
+    }
+    return "".join(colors[x] for x in args) + f"{string}" + colors["end"]
 
 
 def remove_colorstr(input_string):
     """
     Removes ANSI escape codes from a string, effectively un-coloring it.
 
     Args:
@@ -703,26 +759,36 @@
     Returns:
         (str): A new string with all ANSI escape codes removed.
 
     Examples:
         >>> remove_colorstr(colorstr('blue', 'bold', 'hello world'))
         >>> 'hello world'
     """
-    ansi_escape = re.compile(r'\x1B\[[0-9;]*[A-Za-z]')
-    return ansi_escape.sub('', input_string)
+    ansi_escape = re.compile(r"\x1B\[[0-9;]*[A-Za-z]")
+    return ansi_escape.sub("", input_string)
 
 
 class TryExcept(contextlib.ContextDecorator):
     """
-    YOLOv8 TryExcept class.
+    Ultralytics TryExcept class. Use as @TryExcept() decorator or 'with TryExcept():' context manager.
 
-    Use as @TryExcept() decorator or 'with TryExcept():' context manager.
+    Examples:
+        As a decorator:
+        >>> @TryExcept(msg="Error occurred in func", verbose=True)
+        >>> def func():
+        >>>    # Function logic here
+        >>>     pass
+
+        As a context manager:
+        >>> with TryExcept(msg="Error occurred in block", verbose=True):
+        >>>     # Code block here
+        >>>     pass
     """
 
-    def __init__(self, msg='', verbose=True):
+    def __init__(self, msg="", verbose=True):
         """Initialize TryExcept class with optional message and verbosity settings."""
         self.msg = msg
         self.verbose = verbose
 
     def __enter__(self):
         """Executes when entering TryExcept context, initializes instance."""
         pass
@@ -730,26 +796,88 @@
     def __exit__(self, exc_type, value, traceback):
         """Defines behavior when exiting a 'with' block, prints error message if necessary."""
         if self.verbose and value:
             print(emojis(f"{self.msg}{': ' if self.msg else ''}{value}"))
         return True
 
 
+class Retry(contextlib.ContextDecorator):
+    """
+    Retry class for function execution with exponential backoff.
+
+    Can be used as a decorator or a context manager to retry a function or block of code on exceptions, up to a
+    specified number of times with an exponentially increasing delay between retries.
+
+    Examples:
+        Example usage as a decorator:
+        >>> @Retry(times=3, delay=2)
+        >>> def test_func():
+        >>>     # Replace with function logic that may raise exceptions
+        >>>     return True
+
+        Example usage as a context manager:
+        >>> with Retry(times=3, delay=2):
+        >>>     # Replace with code block that may raise exceptions
+        >>>     pass
+    """
+
+    def __init__(self, times=3, delay=2):
+        """Initialize Retry class with specified number of retries and delay."""
+        self.times = times
+        self.delay = delay
+        self._attempts = 0
+
+    def __call__(self, func):
+        """Decorator implementation for Retry with exponential backoff."""
+
+        def wrapped_func(*args, **kwargs):
+            """Applies retries to the decorated function or method."""
+            self._attempts = 0
+            while self._attempts < self.times:
+                try:
+                    return func(*args, **kwargs)
+                except Exception as e:
+                    self._attempts += 1
+                    print(f"Retry {self._attempts}/{self.times} failed: {e}")
+                    if self._attempts >= self.times:
+                        raise e
+                    time.sleep(self.delay * (2**self._attempts))  # exponential backoff delay
+
+        return wrapped_func
+
+    def __enter__(self):
+        """Enter the runtime context related to this object."""
+        self._attempts = 0
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        """Exit the runtime context related to this object with exponential backoff."""
+        if exc_type is not None:
+            self._attempts += 1
+            if self._attempts < self.times:
+                print(f"Retry {self._attempts}/{self.times} failed: {exc_value}")
+                time.sleep(self.delay * (2**self._attempts))  # exponential backoff delay
+                return True  # Suppresses the exception and retries
+        return False  # Re-raises the exception if retries are exhausted
+
+
 def threaded(func):
     """
-    Multi-threads a target function and returns thread.
+    Multi-threads a target function by default and returns the thread or function result.
 
-    Use as @threaded decorator.
+    Use as @threaded decorator. The function runs in a separate thread unless 'threaded=False' is passed.
     """
 
     def wrapper(*args, **kwargs):
-        """Multi-threads a given function and returns the thread."""
-        thread = threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True)
-        thread.start()
-        return thread
+        """Multi-threads a given function based on 'threaded' kwarg and returns the thread or function result."""
+        if kwargs.pop("threaded", True):  # run in thread
+            thread = threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True)
+            thread.start()
+            return thread
+        else:
+            return func(*args, **kwargs)
 
     return wrapper
 
 
 def set_sentry():
     """
     Initialize the Sentry SDK for error tracking and reporting. Only used if sentry_sdk package is installed and
@@ -778,113 +906,127 @@
         Args:
             event (dict): The event dictionary containing information about the error.
             hint (dict): A dictionary containing additional information about the error.
 
         Returns:
             dict: The modified event or None if the event should not be sent to Sentry.
         """
-        if 'exc_info' in hint:
-            exc_type, exc_value, tb = hint['exc_info']
-            if exc_type in (KeyboardInterrupt, FileNotFoundError) \
-                    or 'out of memory' in str(exc_value):
+        if "exc_info" in hint:
+            exc_type, exc_value, tb = hint["exc_info"]
+            if exc_type in {KeyboardInterrupt, FileNotFoundError} or "out of memory" in str(exc_value):
                 return None  # do not send event
 
-        event['tags'] = {
-            'sys_argv': sys.argv[0],
-            'sys_argv_name': Path(sys.argv[0]).name,
-            'install': 'git' if is_git_dir() else 'pip' if is_pip_package() else 'other',
-            'os': ENVIRONMENT}
+        event["tags"] = {
+            "sys_argv": ARGV[0],
+            "sys_argv_name": Path(ARGV[0]).name,
+            "install": "git" if IS_GIT_DIR else "pip" if IS_PIP_PACKAGE else "other",
+            "os": ENVIRONMENT,
+        }
         return event
 
-    if SETTINGS['sync'] and \
-            RANK in (-1, 0) and \
-            Path(sys.argv[0]).name == 'yolo' and \
-            not TESTS_RUNNING and \
-            ONLINE and \
-            is_pip_package() and \
-            not is_git_dir():
-
+    if (
+        SETTINGS["sync"]
+        and RANK in {-1, 0}
+        and Path(ARGV[0]).name == "yolo"
+        and not TESTS_RUNNING
+        and ONLINE
+        and IS_PIP_PACKAGE
+        and not IS_GIT_DIR
+    ):
         # If sentry_sdk package is not installed then return and do not use Sentry
         try:
             import sentry_sdk  # noqa
         except ImportError:
             return
 
         sentry_sdk.init(
-            dsn='https://5ff1556b71594bfea135ff0203a0d290@o4504521589325824.ingest.sentry.io/4504521592406016',
+            dsn="https://5ff1556b71594bfea135ff0203a0d290@o4504521589325824.ingest.sentry.io/4504521592406016",
             debug=False,
             traces_sample_rate=1.0,
             release=__version__,
-            environment='production',  # 'dev' or 'production'
+            environment="production",  # 'dev' or 'production'
             before_send=before_send,
-            ignore_errors=[KeyboardInterrupt, FileNotFoundError])
-        sentry_sdk.set_user({'id': SETTINGS['uuid']})  # SHA-256 anonymized UUID hash
+            ignore_errors=[KeyboardInterrupt, FileNotFoundError],
+        )
+        sentry_sdk.set_user({"id": SETTINGS["uuid"]})  # SHA-256 anonymized UUID hash
 
 
 class SettingsManager(dict):
     """
     Manages Ultralytics settings stored in a YAML file.
 
     Args:
         file (str | Path): Path to the Ultralytics settings YAML file. Default is USER_CONFIG_DIR / 'settings.yaml'.
         version (str): Settings version. In case of local version mismatch, new default settings will be saved.
     """
 
-    def __init__(self, file=SETTINGS_YAML, version='0.0.4'):
+    def __init__(self, file=SETTINGS_YAML, version="0.0.4"):
         """Initialize the SettingsManager with default settings, load and validate current settings from the YAML
         file.
         """
         import copy
         import hashlib
 
         from ultralytics.utils.checks import check_version
         from ultralytics.utils.torch_utils import torch_distributed_zero_first
 
-        git_dir = get_git_dir()
-        root = git_dir or Path()
-        datasets_root = (root.parent if git_dir and is_dir_writeable(root.parent) else root).resolve()
+        root = GIT_DIR or Path()
+        datasets_root = (root.parent if GIT_DIR and is_dir_writeable(root.parent) else root).resolve()
 
         self.file = Path(file)
         self.version = version
         self.defaults = {
-            'settings_version': version,
-            'datasets_dir': str(datasets_root / 'datasets'),
-            'weights_dir': str(root / 'weights'),
-            'runs_dir': str(root / 'runs'),
-            'uuid': hashlib.sha256(str(uuid.getnode()).encode()).hexdigest(),
-            'sync': True,
-            'api_key': '',
-            'clearml': True,  # integrations
-            'comet': True,
-            'dvc': True,
-            'hub': True,
-            'mlflow': True,
-            'neptune': True,
-            'raytune': True,
-            'tensorboard': True,
-            'wandb': True}
+            "settings_version": version,
+            "datasets_dir": str(datasets_root / "datasets"),
+            "weights_dir": str(root / "weights"),
+            "runs_dir": str(root / "runs"),
+            "uuid": hashlib.sha256(str(uuid.getnode()).encode()).hexdigest(),
+            "sync": True,
+            "api_key": "",
+            "openai_api_key": "",
+            "clearml": True,  # integrations
+            "comet": True,
+            "dvc": True,
+            "hub": True,
+            "mlflow": True,
+            "neptune": True,
+            "raytune": True,
+            "tensorboard": True,
+            "wandb": True,
+        }
 
         super().__init__(copy.deepcopy(self.defaults))
 
         with torch_distributed_zero_first(RANK):
             if not self.file.exists():
                 self.save()
 
             self.load()
             correct_keys = self.keys() == self.defaults.keys()
             correct_types = all(type(a) is type(b) for a, b in zip(self.values(), self.defaults.values()))
-            correct_version = check_version(self['settings_version'], self.version)
+            correct_version = check_version(self["settings_version"], self.version)
+            help_msg = (
+                f"\nView settings with 'yolo settings' or at '{self.file}'"
+                "\nUpdate settings with 'yolo settings key=value', i.e. 'yolo settings runs_dir=path/to/dir'. "
+                "For help see https://docs.ultralytics.com/quickstart/#ultralytics-settings."
+            )
             if not (correct_keys and correct_types and correct_version):
                 LOGGER.warning(
-                    'WARNING  Ultralytics settings reset to default values. This may be due to a possible problem '
-                    'with your settings or a recent ultralytics package update. '
-                    f"\nView settings with 'yolo settings' or at '{self.file}'"
-                    "\nUpdate settings with 'yolo settings key=value', i.e. 'yolo settings runs_dir=path/to/dir'.")
+                    "WARNING  Ultralytics settings reset to default values. This may be due to a possible problem "
+                    f"with your settings or a recent ultralytics package update. {help_msg}"
+                )
                 self.reset()
 
+            if self.get("datasets_dir") == self.get("runs_dir"):
+                LOGGER.warning(
+                    f"WARNING  Ultralytics setting 'datasets_dir: {self.get('datasets_dir')}' "
+                    f"must be different than 'runs_dir: {self.get('runs_dir')}'. "
+                    f"Please change one to avoid possible issues during training. {help_msg}"
+                )
+
     def load(self):
         """Loads settings from the YAML file."""
         super().update(yaml_load(self.file))
 
     def save(self):
         """Saves the current settings to the YAML file."""
         yaml_save(self.file, dict(self))
@@ -901,39 +1043,50 @@
         self.save()
 
 
 def deprecation_warn(arg, new_arg, version=None):
     """Issue a deprecation warning when a deprecated argument is used, suggesting an updated argument."""
     if not version:
         version = float(__version__[:3]) + 0.2  # deprecate after 2nd major release
-    LOGGER.warning(f"WARNING  '{arg}' is deprecated and will be removed in 'ultralytics {version}' in the future. "
-                   f"Please use '{new_arg}' instead.")
+    LOGGER.warning(
+        f"WARNING  '{arg}' is deprecated and will be removed in 'ultralytics {version}' in the future. "
+        f"Please use '{new_arg}' instead."
+    )
 
 
 def clean_url(url):
     """Strip auth from URL, i.e. https://url.com/file.txt?auth -> https://url.com/file.txt."""
-    url = Path(url).as_posix().replace(':/', '://')  # Pathlib turns :// -> :/, as_posix() for Windows
-    return urllib.parse.unquote(url).split('?')[0]  # '%2F' to '/', split https://url.com/file.txt?auth
+    url = Path(url).as_posix().replace(":/", "://")  # Pathlib turns :// -> :/, as_posix() for Windows
+    return urllib.parse.unquote(url).split("?")[0]  # '%2F' to '/', split https://url.com/file.txt?auth
 
 
 def url2file(url):
     """Convert URL to filename, i.e. https://url.com/file.txt?auth -> file.txt."""
     return Path(clean_url(url)).name
 
 
 # Run below code on utils init ------------------------------------------------------------------------------------
 
 # Check first-install steps
-PREFIX = colorstr('Ultralytics: ')
+PREFIX = colorstr("Ultralytics: ")
 SETTINGS = SettingsManager()  # initialize settings
-DATASETS_DIR = Path(SETTINGS['datasets_dir'])  # global datasets directory
-WEIGHTS_DIR = Path(SETTINGS['weights_dir'])  # global weights directory
-RUNS_DIR = Path(SETTINGS['runs_dir'])  # global runs directory
-ENVIRONMENT = 'Colab' if is_colab() else 'Kaggle' if is_kaggle() else 'Jupyter' if is_jupyter() else \
-    'Docker' if is_docker() else platform.system()
+DATASETS_DIR = Path(SETTINGS["datasets_dir"])  # global datasets directory
+WEIGHTS_DIR = Path(SETTINGS["weights_dir"])  # global weights directory
+RUNS_DIR = Path(SETTINGS["runs_dir"])  # global runs directory
+ENVIRONMENT = (
+    "Colab"
+    if IS_COLAB
+    else "Kaggle"
+    if IS_KAGGLE
+    else "Jupyter"
+    if IS_JUPYTER
+    else "Docker"
+    if IS_DOCKER
+    else platform.system()
+)
 TESTS_RUNNING = is_pytest_running() or is_github_action_running()
 set_sentry()
 
 # Apply monkey patches
 from .patches import imread, imshow, imwrite, torch_save
 
 torch.save = torch_save
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/autobatch.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/autobatch.py`

 * *Files 7% similar despite different names*

```diff
@@ -38,51 +38,51 @@
         batch_size (int, optional): The default batch size to use if an error is detected. Defaults to 16.
 
     Returns:
         (int): The optimal batch size.
     """
 
     # Check device
-    prefix = colorstr('AutoBatch: ')
-    LOGGER.info(f'{prefix}Computing optimal batch size for imgsz={imgsz}')
+    prefix = colorstr("AutoBatch: ")
+    LOGGER.info(f"{prefix}Computing optimal batch size for imgsz={imgsz}")
     device = next(model.parameters()).device  # get model device
-    if device.type == 'cpu':
-        LOGGER.info(f'{prefix}CUDA not detected, using default CPU batch-size {batch_size}')
+    if device.type == "cpu":
+        LOGGER.info(f"{prefix}CUDA not detected, using default CPU batch-size {batch_size}")
         return batch_size
     if torch.backends.cudnn.benchmark:
-        LOGGER.info(f'{prefix}  Requires torch.backends.cudnn.benchmark=False, using default batch-size {batch_size}')
+        LOGGER.info(f"{prefix}  Requires torch.backends.cudnn.benchmark=False, using default batch-size {batch_size}")
         return batch_size
 
     # Inspect CUDA memory
     gb = 1 << 30  # bytes to GiB (1024 ** 3)
     d = str(device).upper()  # 'CUDA:0'
     properties = torch.cuda.get_device_properties(device)  # device properties
     t = properties.total_memory / gb  # GiB total
     r = torch.cuda.memory_reserved(device) / gb  # GiB reserved
     a = torch.cuda.memory_allocated(device) / gb  # GiB allocated
     f = t - (r + a)  # GiB free
-    LOGGER.info(f'{prefix}{d} ({properties.name}) {t:.2f}G total, {r:.2f}G reserved, {a:.2f}G allocated, {f:.2f}G free')
+    LOGGER.info(f"{prefix}{d} ({properties.name}) {t:.2f}G total, {r:.2f}G reserved, {a:.2f}G allocated, {f:.2f}G free")
 
     # Profile batch sizes
     batch_sizes = [1, 2, 4, 8, 16]
     try:
         img = [torch.empty(b, 3, imgsz, imgsz) for b in batch_sizes]
         results = profile(img, model, n=3, device=device)
 
         # Fit a solution
         y = [x[2] for x in results if x]  # memory [2]
-        p = np.polyfit(batch_sizes[:len(y)], y, deg=1)  # first degree polynomial fit
+        p = np.polyfit(batch_sizes[: len(y)], y, deg=1)  # first degree polynomial fit
         b = int((f * fraction - p[1]) / p[0])  # y intercept (optimal batch size)
         if None in results:  # some sizes failed
             i = results.index(None)  # first fail index
             if b >= batch_sizes[i]:  # y intercept above failure point
                 b = batch_sizes[max(i - 1, 0)]  # select prior safe point
         if b < 1 or b > 1024:  # b outside of safe range
             b = batch_size
-            LOGGER.info(f'{prefix}WARNING  CUDA anomaly detected, using default batch-size {batch_size}.')
+            LOGGER.info(f"{prefix}WARNING  CUDA anomaly detected, using default batch-size {batch_size}.")
 
         fraction = (np.polyval(p, b) + r + a) / t  # actual fraction predicted
-        LOGGER.info(f'{prefix}Using batch-size {b} for {d} {t * fraction:.2f}G/{t:.2f}G ({fraction * 100:.0f}%) ')
+        LOGGER.info(f"{prefix}Using batch-size {b} for {d} {t * fraction:.2f}G/{t:.2f}G ({fraction * 100:.0f}%) ")
         return b
     except Exception as e:
-        LOGGER.warning(f'{prefix}WARNING  error detected: {e},  using default batch-size {batch_size}.')
+        LOGGER.warning(f"{prefix}WARNING  error detected: {e},  using default batch-size {batch_size}.")
         return batch_size
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/benchmarks.py` & `yolov8_pose_triton-8.2.0/ultralytics/data/explorer/explorer.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,393 +1,472 @@
 # Ultralytics YOLO , AGPL-3.0 license
-"""
-Benchmark a YOLO model formats for speed and accuracy.
 
-Usage:
-    from ultralytics.utils.benchmarks import ProfileModels, benchmark
-    ProfileModels(['yolov8n.yaml', 'yolov8s.yaml']).profile()
-    benchmark(model='yolov8n.pt', imgsz=160)
-
-Format                  | `format=argument`         | Model
----                     | ---                       | ---
-PyTorch                 | -                         | yolov8n.pt
-TorchScript             | `torchscript`             | yolov8n.torchscript
-ONNX                    | `onnx`                    | yolov8n.onnx
-OpenVINO                | `openvino`                | yolov8n_openvino_model/
-TensorRT                | `engine`                  | yolov8n.engine
-CoreML                  | `coreml`                  | yolov8n.mlpackage
-TensorFlow SavedModel   | `saved_model`             | yolov8n_saved_model/
-TensorFlow GraphDef     | `pb`                      | yolov8n.pb
-TensorFlow Lite         | `tflite`                  | yolov8n.tflite
-TensorFlow Edge TPU     | `edgetpu`                 | yolov8n_edgetpu.tflite
-TensorFlow.js           | `tfjs`                    | yolov8n_web_model/
-PaddlePaddle            | `paddle`                  | yolov8n_paddle_model/
-ncnn                    | `ncnn`                    | yolov8n_ncnn_model/
-"""
-
-import glob
-import platform
-import sys
-import time
+from io import BytesIO
 from pathlib import Path
+from typing import Any, List, Tuple, Union
 
+import cv2
 import numpy as np
-import torch.cuda
+import torch
+from matplotlib import pyplot as plt
+from PIL import Image
+from tqdm import tqdm
+
+from ultralytics.data.augment import Format
+from ultralytics.data.dataset import YOLODataset
+from ultralytics.data.utils import check_det_dataset
+from ultralytics.models.yolo.model import YOLO
+from ultralytics.utils import LOGGER, USER_CONFIG_DIR, IterableSimpleNamespace, checks
+
+from .utils import get_sim_index_schema, get_table_schema, plot_query_result, prompt_sql_query, sanitize_batch
+
+
+class ExplorerDataset(YOLODataset):
+    def __init__(self, *args, data: dict = None, **kwargs) -> None:
+        super().__init__(*args, data=data, **kwargs)
+
+    def load_image(self, i: int) -> Union[Tuple[np.ndarray, Tuple[int, int], Tuple[int, int]], Tuple[None, None, None]]:
+        """Loads 1 image from dataset index 'i' without any resize ops."""
+        im, f, fn = self.ims[i], self.im_files[i], self.npy_files[i]
+        if im is None:  # not cached in RAM
+            if fn.exists():  # load npy
+                im = np.load(fn)
+            else:  # read image
+                im = cv2.imread(f)  # BGR
+                if im is None:
+                    raise FileNotFoundError(f"Image Not Found {f}")
+            h0, w0 = im.shape[:2]  # orig hw
+            return im, (h0, w0), im.shape[:2]
+
+        return self.ims[i], self.im_hw0[i], self.im_hw[i]
+
+    def build_transforms(self, hyp: IterableSimpleNamespace = None):
+        """Creates transforms for dataset images without resizing."""
+        return Format(
+            bbox_format="xyxy",
+            normalize=False,
+            return_mask=self.use_segments,
+            return_keypoint=self.use_keypoints,
+            batch_idx=True,
+            mask_ratio=hyp.mask_ratio,
+            mask_overlap=hyp.overlap_mask,
+        )
+
+
+class Explorer:
+    def __init__(
+        self,
+        data: Union[str, Path] = "coco128.yaml",
+        model: str = "yolov8n.pt",
+        uri: str = USER_CONFIG_DIR / "explorer",
+    ) -> None:
+        # Note duckdb==0.10.0 bug https://github.com/ultralytics/ultralytics/pull/8181
+        checks.check_requirements(["lancedb>=0.4.3", "duckdb<=0.9.2"])
+        import lancedb
+
+        self.connection = lancedb.connect(uri)
+        self.table_name = Path(data).name.lower() + "_" + model.lower()
+        self.sim_idx_base_name = (
+            f"{self.table_name}_sim_idx".lower()
+        )  # Use this name and append thres and top_k to reuse the table
+        self.model = YOLO(model)
+        self.data = data  # None
+        self.choice_set = None
 
-from ultralytics import YOLO
-from ultralytics.cfg import TASK2DATA, TASK2METRIC
-from ultralytics.engine.exporter import export_formats
-from ultralytics.utils import ASSETS, LINUX, LOGGER, MACOS, TQDM, WEIGHTS_DIR
-from ultralytics.utils.checks import check_requirements, check_yolo
-from ultralytics.utils.files import file_size
-from ultralytics.utils.torch_utils import select_device
-
-
-def benchmark(model=WEIGHTS_DIR / 'yolov8n.pt',
-              data=None,
-              imgsz=160,
-              half=False,
-              int8=False,
-              device='cpu',
-              verbose=False):
-    """
-    Benchmark a YOLO model across different formats for speed and accuracy.
-
-    Args:
-        model (str | Path | optional): Path to the model file or directory. Default is
-            Path(SETTINGS['weights_dir']) / 'yolov8n.pt'.
-        data (str, optional): Dataset to evaluate on, inherited from TASK2DATA if not passed. Default is None.
-        imgsz (int, optional): Image size for the benchmark. Default is 160.
-        half (bool, optional): Use half-precision for the model if True. Default is False.
-        int8 (bool, optional): Use int8-precision for the model if True. Default is False.
-        device (str, optional): Device to run the benchmark on, either 'cpu' or 'cuda'. Default is 'cpu'.
-        verbose (bool | float | optional): If True or a float, assert benchmarks pass with given metric.
-            Default is False.
-
-    Returns:
-        df (pandas.DataFrame): A pandas DataFrame with benchmark results for each format, including file size,
-            metric, and inference time.
-
-    Example:
-        ```python
-        from ultralytics.utils.benchmarks import benchmark
-
-        benchmark(model='yolov8n.pt', imgsz=640)
-        ```
-    """
-
-    import pandas as pd
-    pd.options.display.max_columns = 10
-    pd.options.display.width = 120
-    device = select_device(device, verbose=False)
-    if isinstance(model, (str, Path)):
-        model = YOLO(model)
-
-    y = []
-    t0 = time.time()
-    for i, (name, format, suffix, cpu, gpu) in export_formats().iterrows():  # index, (name, format, suffix, CPU, GPU)
-        emoji, filename = '', None  # export defaults
+        self.table = None
+        self.progress = 0
+
+    def create_embeddings_table(self, force: bool = False, split: str = "train") -> None:
+        """
+        Create LanceDB table containing the embeddings of the images in the dataset. The table will be reused if it
+        already exists. Pass force=True to overwrite the existing table.
+
+        Args:
+            force (bool): Whether to overwrite the existing table or not. Defaults to False.
+            split (str): Split of the dataset to use. Defaults to 'train'.
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+            ```
+        """
+        if self.table is not None and not force:
+            LOGGER.info("Table already exists. Reusing it. Pass force=True to overwrite it.")
+            return
+        if self.table_name in self.connection.table_names() and not force:
+            LOGGER.info(f"Table {self.table_name} already exists. Reusing it. Pass force=True to overwrite it.")
+            self.table = self.connection.open_table(self.table_name)
+            self.progress = 1
+            return
+        if self.data is None:
+            raise ValueError("Data must be provided to create embeddings table")
+
+        data_info = check_det_dataset(self.data)
+        if split not in data_info:
+            raise ValueError(
+                f"Split {split} is not found in the dataset. Available keys in the dataset are {list(data_info.keys())}"
+            )
+
+        choice_set = data_info[split]
+        choice_set = choice_set if isinstance(choice_set, list) else [choice_set]
+        self.choice_set = choice_set
+        dataset = ExplorerDataset(img_path=choice_set, data=data_info, augment=False, cache=False, task=self.model.task)
+
+        # Create the table schema
+        batch = dataset[0]
+        vector_size = self.model.embed(batch["im_file"], verbose=False)[0].shape[0]
+        table = self.connection.create_table(self.table_name, schema=get_table_schema(vector_size), mode="overwrite")
+        table.add(
+            self._yield_batches(
+                dataset,
+                data_info,
+                self.model,
+                exclude_keys=["img", "ratio_pad", "resized_shape", "ori_shape", "batch_idx"],
+            )
+        )
+
+        self.table = table
+
+    def _yield_batches(self, dataset: ExplorerDataset, data_info: dict, model: YOLO, exclude_keys: List[str]):
+        """Generates batches of data for embedding, excluding specified keys."""
+        for i in tqdm(range(len(dataset))):
+            self.progress = float(i + 1) / len(dataset)
+            batch = dataset[i]
+            for k in exclude_keys:
+                batch.pop(k, None)
+            batch = sanitize_batch(batch, data_info)
+            batch["vector"] = model.embed(batch["im_file"], verbose=False)[0].detach().tolist()
+            yield [batch]
+
+    def query(
+        self, imgs: Union[str, np.ndarray, List[str], List[np.ndarray]] = None, limit: int = 25
+    ) -> Any:  # pyarrow.Table
+        """
+        Query the table for similar images. Accepts a single image or a list of images.
+
+        Args:
+            imgs (str or list): Path to the image or a list of paths to the images.
+            limit (int): Number of results to return.
+
+        Returns:
+            (pyarrow.Table): An arrow table containing the results. Supports converting to:
+                - pandas dataframe: `result.to_pandas()`
+                - dict of lists: `result.to_pydict()`
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+            similar = exp.query(img='https://ultralytics.com/images/zidane.jpg')
+            ```
+        """
+        if self.table is None:
+            raise ValueError("Table is not created. Please create the table first.")
+        if isinstance(imgs, str):
+            imgs = [imgs]
+        assert isinstance(imgs, list), f"img must be a string or a list of strings. Got {type(imgs)}"
+        embeds = self.model.embed(imgs)
+        # Get avg if multiple images are passed (len > 1)
+        embeds = torch.mean(torch.stack(embeds), 0).cpu().numpy() if len(embeds) > 1 else embeds[0].cpu().numpy()
+        return self.table.search(embeds).limit(limit).to_arrow()
+
+    def sql_query(
+        self, query: str, return_type: str = "pandas"
+    ) -> Union[Any, None]:  # pandas.DataFrame or pyarrow.Table
+        """
+        Run a SQL-Like query on the table. Utilizes LanceDB predicate pushdown.
+
+        Args:
+            query (str): SQL query to run.
+            return_type (str): Type of the result to return. Can be either 'pandas' or 'arrow'. Defaults to 'pandas'.
+
+        Returns:
+            (pyarrow.Table): An arrow table containing the results.
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+            query = "SELECT * FROM 'table' WHERE labels LIKE '%person%'"
+            result = exp.sql_query(query)
+            ```
+        """
+        assert return_type in {
+            "pandas",
+            "arrow",
+        }, f"Return type should be either `pandas` or `arrow`, but got {return_type}"
+        import duckdb
+
+        if self.table is None:
+            raise ValueError("Table is not created. Please create the table first.")
+
+        # Note: using filter pushdown would be a better long term solution. Temporarily using duckdb for this.
+        table = self.table.to_arrow()  # noqa NOTE: Don't comment this. This line is used by DuckDB
+        if not query.startswith("SELECT") and not query.startswith("WHERE"):
+            raise ValueError(
+                f"Query must start with SELECT or WHERE. You can either pass the entire query or just the WHERE "
+                f"clause. found {query}"
+            )
+        if query.startswith("WHERE"):
+            query = f"SELECT * FROM 'table' {query}"
+        LOGGER.info(f"Running query: {query}")
+
+        rs = duckdb.sql(query)
+        if return_type == "arrow":
+            return rs.arrow()
+        elif return_type == "pandas":
+            return rs.df()
+
+    def plot_sql_query(self, query: str, labels: bool = True) -> Image.Image:
+        """
+        Plot the results of a SQL-Like query on the table.
+        Args:
+            query (str): SQL query to run.
+            labels (bool): Whether to plot the labels or not.
+
+        Returns:
+            (PIL.Image): Image containing the plot.
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+            query = "SELECT * FROM 'table' WHERE labels LIKE '%person%'"
+            result = exp.plot_sql_query(query)
+            ```
+        """
+        result = self.sql_query(query, return_type="arrow")
+        if len(result) == 0:
+            LOGGER.info("No results found.")
+            return None
+        img = plot_query_result(result, plot_labels=labels)
+        return Image.fromarray(img)
+
+    def get_similar(
+        self,
+        img: Union[str, np.ndarray, List[str], List[np.ndarray]] = None,
+        idx: Union[int, List[int]] = None,
+        limit: int = 25,
+        return_type: str = "pandas",
+    ) -> Any:  # pandas.DataFrame or pyarrow.Table
+        """
+        Query the table for similar images. Accepts a single image or a list of images.
+
+        Args:
+            img (str or list): Path to the image or a list of paths to the images.
+            idx (int or list): Index of the image in the table or a list of indexes.
+            limit (int): Number of results to return. Defaults to 25.
+            return_type (str): Type of the result to return. Can be either 'pandas' or 'arrow'. Defaults to 'pandas'.
+
+        Returns:
+            (pandas.DataFrame): A dataframe containing the results.
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+            similar = exp.get_similar(img='https://ultralytics.com/images/zidane.jpg')
+            ```
+        """
+        assert return_type in {
+            "pandas",
+            "arrow",
+        }, f"Return type should be either `pandas` or `arrow`, but got {return_type}"
+        img = self._check_imgs_or_idxs(img, idx)
+        similar = self.query(img, limit=limit)
+
+        if return_type == "arrow":
+            return similar
+        elif return_type == "pandas":
+            return similar.to_pandas()
+
+    def plot_similar(
+        self,
+        img: Union[str, np.ndarray, List[str], List[np.ndarray]] = None,
+        idx: Union[int, List[int]] = None,
+        limit: int = 25,
+        labels: bool = True,
+    ) -> Image.Image:
+        """
+        Plot the similar images. Accepts images or indexes.
+
+        Args:
+            img (str or list): Path to the image or a list of paths to the images.
+            idx (int or list): Index of the image in the table or a list of indexes.
+            labels (bool): Whether to plot the labels or not.
+            limit (int): Number of results to return. Defaults to 25.
+
+        Returns:
+            (PIL.Image): Image containing the plot.
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+            similar = exp.plot_similar(img='https://ultralytics.com/images/zidane.jpg')
+            ```
+        """
+        similar = self.get_similar(img, idx, limit, return_type="arrow")
+        if len(similar) == 0:
+            LOGGER.info("No results found.")
+            return None
+        img = plot_query_result(similar, plot_labels=labels)
+        return Image.fromarray(img)
+
+    def similarity_index(self, max_dist: float = 0.2, top_k: float = None, force: bool = False) -> Any:  # pd.DataFrame
+        """
+        Calculate the similarity index of all the images in the table. Here, the index will contain the data points that
+        are max_dist or closer to the image in the embedding space at a given index.
+
+        Args:
+            max_dist (float): maximum L2 distance between the embeddings to consider. Defaults to 0.2.
+            top_k (float): Percentage of the closest data points to consider when counting. Used to apply limit.
+                           vector search. Defaults: None.
+            force (bool): Whether to overwrite the existing similarity index or not. Defaults to True.
+
+        Returns:
+            (pandas.DataFrame): A dataframe containing the similarity index. Each row corresponds to an image,
+                and columns include indices of similar images and their respective distances.
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+            sim_idx = exp.similarity_index()
+            ```
+        """
+        if self.table is None:
+            raise ValueError("Table is not created. Please create the table first.")
+        sim_idx_table_name = f"{self.sim_idx_base_name}_thres_{max_dist}_top_{top_k}".lower()
+        if sim_idx_table_name in self.connection.table_names() and not force:
+            LOGGER.info("Similarity matrix already exists. Reusing it. Pass force=True to overwrite it.")
+            return self.connection.open_table(sim_idx_table_name).to_pandas()
+
+        if top_k and not (1.0 >= top_k >= 0.0):
+            raise ValueError(f"top_k must be between 0.0 and 1.0. Got {top_k}")
+        if max_dist < 0.0:
+            raise ValueError(f"max_dist must be greater than 0. Got {max_dist}")
+
+        top_k = int(top_k * len(self.table)) if top_k else len(self.table)
+        top_k = max(top_k, 1)
+        features = self.table.to_lance().to_table(columns=["vector", "im_file"]).to_pydict()
+        im_files = features["im_file"]
+        embeddings = features["vector"]
+
+        sim_table = self.connection.create_table(sim_idx_table_name, schema=get_sim_index_schema(), mode="overwrite")
+
+        def _yield_sim_idx():
+            """Generates a dataframe with similarity indices and distances for images."""
+            for i in tqdm(range(len(embeddings))):
+                sim_idx = self.table.search(embeddings[i]).limit(top_k).to_pandas().query(f"_distance <= {max_dist}")
+                yield [
+                    {
+                        "idx": i,
+                        "im_file": im_files[i],
+                        "count": len(sim_idx),
+                        "sim_im_files": sim_idx["im_file"].tolist(),
+                    }
+                ]
+
+        sim_table.add(_yield_sim_idx())
+        self.sim_index = sim_table
+        return sim_table.to_pandas()
+
+    def plot_similarity_index(self, max_dist: float = 0.2, top_k: float = None, force: bool = False) -> Image:
+        """
+        Plot the similarity index of all the images in the table. Here, the index will contain the data points that are
+        max_dist or closer to the image in the embedding space at a given index.
+
+        Args:
+            max_dist (float): maximum L2 distance between the embeddings to consider. Defaults to 0.2.
+            top_k (float): Percentage of closest data points to consider when counting. Used to apply limit when
+                running vector search. Defaults to 0.01.
+            force (bool): Whether to overwrite the existing similarity index or not. Defaults to True.
+
+        Returns:
+            (PIL.Image): Image containing the plot.
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+
+            similarity_idx_plot = exp.plot_similarity_index()
+            similarity_idx_plot.show() # view image preview
+            similarity_idx_plot.save('path/to/save/similarity_index_plot.png') # save contents to file
+            ```
+        """
+        sim_idx = self.similarity_index(max_dist=max_dist, top_k=top_k, force=force)
+        sim_count = sim_idx["count"].tolist()
+        sim_count = np.array(sim_count)
+
+        indices = np.arange(len(sim_count))
+
+        # Create the bar plot
+        plt.bar(indices, sim_count)
+
+        # Customize the plot (optional)
+        plt.xlabel("data idx")
+        plt.ylabel("Count")
+        plt.title("Similarity Count")
+        buffer = BytesIO()
+        plt.savefig(buffer, format="png")
+        buffer.seek(0)
+
+        # Use Pillow to open the image from the buffer
+        return Image.fromarray(np.array(Image.open(buffer)))
+
+    def _check_imgs_or_idxs(
+        self, img: Union[str, np.ndarray, List[str], List[np.ndarray], None], idx: Union[None, int, List[int]]
+    ) -> List[np.ndarray]:
+        if img is None and idx is None:
+            raise ValueError("Either img or idx must be provided.")
+        if img is not None and idx is not None:
+            raise ValueError("Only one of img or idx must be provided.")
+        if idx is not None:
+            idx = idx if isinstance(idx, list) else [idx]
+            img = self.table.to_lance().take(idx, columns=["im_file"]).to_pydict()["im_file"]
+
+        return img if isinstance(img, list) else [img]
+
+    def ask_ai(self, query):
+        """
+        Ask AI a question.
+
+        Args:
+            query (str): Question to ask.
+
+        Returns:
+            (pandas.DataFrame): A dataframe containing filtered results to the SQL query.
+
+        Example:
+            ```python
+            exp = Explorer()
+            exp.create_embeddings_table()
+            answer = exp.ask_ai('Show images with 1 person and 2 dogs')
+            ```
+        """
+        result = prompt_sql_query(query)
         try:
-            assert i != 9 or LINUX, 'Edge TPU export only supported on Linux'
-            if i == 10:
-                assert MACOS or LINUX, 'TF.js export only supported on macOS and Linux'
-            elif i == 11:
-                assert sys.version_info < (3, 11), 'PaddlePaddle export only supported on Python<=3.10'
-            if 'cpu' in device.type:
-                assert cpu, 'inference not supported on CPU'
-            if 'cuda' in device.type:
-                assert gpu, 'inference not supported on GPU'
-
-            # Export
-            if format == '-':
-                filename = model.ckpt_path or model.cfg
-                exported_model = model  # PyTorch format
-            else:
-                filename = model.export(imgsz=imgsz, format=format, half=half, int8=int8, device=device, verbose=False)
-                exported_model = YOLO(filename, task=model.task)
-                assert suffix in str(filename), 'export failed'
-            emoji = ''  # indicates export succeeded
-
-            # Predict
-            assert model.task != 'pose' or i != 7, 'GraphDef Pose inference is not supported'
-            assert i not in (9, 10), 'inference not supported'  # Edge TPU and TF.js are unsupported
-            assert i != 5 or platform.system() == 'Darwin', 'inference only supported on macOS>=10.13'  # CoreML
-            exported_model.predict(ASSETS / 'bus.jpg', imgsz=imgsz, device=device, half=half)
-
-            # Validate
-            data = data or TASK2DATA[model.task]  # task to dataset, i.e. coco8.yaml for task=detect
-            key = TASK2METRIC[model.task]  # task to metric, i.e. metrics/mAP50-95(B) for task=detect
-            results = exported_model.val(data=data,
-                                         batch=1,
-                                         imgsz=imgsz,
-                                         plots=False,
-                                         device=device,
-                                         half=half,
-                                         int8=int8,
-                                         verbose=False)
-            metric, speed = results.results_dict[key], results.speed['inference']
-            y.append([name, '', round(file_size(filename), 1), round(metric, 4), round(speed, 2)])
+            return self.sql_query(result)
         except Exception as e:
-            if verbose:
-                assert type(e) is AssertionError, f'Benchmark failure for {name}: {e}'
-            LOGGER.warning(f'ERROR  Benchmark failure for {name}: {e}')
-            y.append([name, emoji, round(file_size(filename), 1), None, None])  # mAP, t_inference
-
-    # Print results
-    check_yolo(device=device)  # print system info
-    df = pd.DataFrame(y, columns=['Format', 'Status', 'Size (MB)', key, 'Inference time (ms/im)'])
-
-    name = Path(model.ckpt_path).name
-    s = f'\nBenchmarks complete for {name} on {data} at imgsz={imgsz} ({time.time() - t0:.2f}s)\n{df}\n'
-    LOGGER.info(s)
-    with open('benchmarks.log', 'a', errors='ignore', encoding='utf-8') as f:
-        f.write(s)
-
-    if verbose and isinstance(verbose, float):
-        metrics = df[key].array  # values to compare to floor
-        floor = verbose  # minimum metric floor to pass, i.e. = 0.29 mAP for YOLOv5n
-        assert all(x > floor for x in metrics if pd.notna(x)), f'Benchmark failure: metric(s) < floor {floor}'
-
-    return df
-
-
-class ProfileModels:
-    """
-    ProfileModels class for profiling different models on ONNX and TensorRT.
-
-    This class profiles the performance of different models, provided their paths. The profiling includes parameters such as
-    model speed and FLOPs.
-
-    Attributes:
-        paths (list): Paths of the models to profile.
-        num_timed_runs (int): Number of timed runs for the profiling. Default is 100.
-        num_warmup_runs (int): Number of warmup runs before profiling. Default is 10.
-        min_time (float): Minimum number of seconds to profile for. Default is 60.
-        imgsz (int): Image size used in the models. Default is 640.
-
-    Methods:
-        profile(): Profiles the models and prints the result.
-
-    Example:
-        ```python
-        from ultralytics.utils.benchmarks import ProfileModels
-
-        ProfileModels(['yolov8n.yaml', 'yolov8s.yaml'], imgsz=640).profile()
-        ```
-    """
-
-    def __init__(self,
-                 paths: list,
-                 num_timed_runs=100,
-                 num_warmup_runs=10,
-                 min_time=60,
-                 imgsz=640,
-                 half=True,
-                 trt=True,
-                 device=None):
+            LOGGER.error("AI generated query is not valid. Please try again with a different prompt")
+            LOGGER.error(e)
+            return None
+
+    def visualize(self, result):
         """
-        Initialize the ProfileModels class for profiling models.
+        Visualize the results of a query. TODO.
 
         Args:
-            paths (list): List of paths of the models to be profiled.
-            num_timed_runs (int, optional): Number of timed runs for the profiling. Default is 100.
-            num_warmup_runs (int, optional): Number of warmup runs before the actual profiling starts. Default is 10.
-            min_time (float, optional): Minimum time in seconds for profiling a model. Default is 60.
-            imgsz (int, optional): Size of the image used during profiling. Default is 640.
-            half (bool, optional): Flag to indicate whether to use half-precision floating point for profiling. Default is True.
-            trt (bool, optional): Flag to indicate whether to profile using TensorRT. Default is True.
-            device (torch.device, optional): Device used for profiling. If None, it is determined automatically. Default is None.
-        """
-        self.paths = paths
-        self.num_timed_runs = num_timed_runs
-        self.num_warmup_runs = num_warmup_runs
-        self.min_time = min_time
-        self.imgsz = imgsz
-        self.half = half
-        self.trt = trt  # run TensorRT profiling
-        self.device = device or torch.device(0 if torch.cuda.is_available() else 'cpu')
-
-    def profile(self):
-        """Logs the benchmarking results of a model, checks metrics against floor and returns the results."""
-        files = self.get_files()
+            result (pyarrow.Table): Table containing the results of a query.
+        """
+        pass
 
-        if not files:
-            print('No matching *.pt or *.onnx files found.')
-            return
+    def generate_report(self, result):
+        """
+        Generate a report of the dataset.
 
-        table_rows = []
-        output = []
-        for file in files:
-            engine_file = file.with_suffix('.engine')
-            if file.suffix in ('.pt', '.yaml', '.yml'):
-                model = YOLO(str(file))
-                model.fuse()  # to report correct params and GFLOPs in model.info()
-                model_info = model.info()
-                if self.trt and self.device.type != 'cpu' and not engine_file.is_file():
-                    engine_file = model.export(format='engine',
-                                               half=self.half,
-                                               imgsz=self.imgsz,
-                                               device=self.device,
-                                               verbose=False)
-                onnx_file = model.export(format='onnx',
-                                         half=self.half,
-                                         imgsz=self.imgsz,
-                                         simplify=True,
-                                         device=self.device,
-                                         verbose=False)
-            elif file.suffix == '.onnx':
-                model_info = self.get_onnx_model_info(file)
-                onnx_file = file
-            else:
-                continue
-
-            t_engine = self.profile_tensorrt_model(str(engine_file))
-            t_onnx = self.profile_onnx_model(str(onnx_file))
-            table_rows.append(self.generate_table_row(file.stem, t_onnx, t_engine, model_info))
-            output.append(self.generate_results_dict(file.stem, t_onnx, t_engine, model_info))
-
-        self.print_table(table_rows)
-        return output
-
-    def get_files(self):
-        """Returns a list of paths for all relevant model files given by the user."""
-        files = []
-        for path in self.paths:
-            path = Path(path)
-            if path.is_dir():
-                extensions = ['*.pt', '*.onnx', '*.yaml']
-                files.extend([file for ext in extensions for file in glob.glob(str(path / ext))])
-            elif path.suffix in {'.pt', '.yaml', '.yml'}:  # add non-existing
-                files.append(str(path))
-            else:
-                files.extend(glob.glob(str(path)))
-
-        print(f'Profiling: {sorted(files)}')
-        return [Path(file) for file in sorted(files)]
-
-    def get_onnx_model_info(self, onnx_file: str):
-        """Retrieves the information including number of layers, parameters, gradients and FLOPs for an ONNX model
-        file.
-        """
-        # return (num_layers, num_params, num_gradients, num_flops)
-        return 0.0, 0.0, 0.0, 0.0
-
-    def iterative_sigma_clipping(self, data, sigma=2, max_iters=3):
-        """Applies an iterative sigma clipping algorithm to the given data times number of iterations."""
-        data = np.array(data)
-        for _ in range(max_iters):
-            mean, std = np.mean(data), np.std(data)
-            clipped_data = data[(data > mean - sigma * std) & (data < mean + sigma * std)]
-            if len(clipped_data) == len(data):
-                break
-            data = clipped_data
-        return data
-
-    def profile_tensorrt_model(self, engine_file: str, eps: float = 1e-3):
-        """Profiles the TensorRT model, measuring average run time and standard deviation among runs."""
-        if not self.trt or not Path(engine_file).is_file():
-            return 0.0, 0.0
-
-        # Model and input
-        model = YOLO(engine_file)
-        input_data = np.random.rand(self.imgsz, self.imgsz, 3).astype(np.float32)  # must be FP32
-
-        # Warmup runs
-        elapsed = 0.0
-        for _ in range(3):
-            start_time = time.time()
-            for _ in range(self.num_warmup_runs):
-                model(input_data, imgsz=self.imgsz, verbose=False)
-            elapsed = time.time() - start_time
-
-        # Compute number of runs as higher of min_time or num_timed_runs
-        num_runs = max(round(self.min_time / (elapsed + eps) * self.num_warmup_runs), self.num_timed_runs * 50)
-
-        # Timed runs
-        run_times = []
-        for _ in TQDM(range(num_runs), desc=engine_file):
-            results = model(input_data, imgsz=self.imgsz, verbose=False)
-            run_times.append(results[0].speed['inference'])  # Convert to milliseconds
-
-        run_times = self.iterative_sigma_clipping(np.array(run_times), sigma=2, max_iters=3)  # sigma clipping
-        return np.mean(run_times), np.std(run_times)
-
-    def profile_onnx_model(self, onnx_file: str, eps: float = 1e-3):
-        """Profiles an ONNX model by executing it multiple times and returns the mean and standard deviation of run
-        times.
-        """
-        check_requirements('onnxruntime')
-        import onnxruntime as ort
-
-        # Session with either 'TensorrtExecutionProvider', 'CUDAExecutionProvider', 'CPUExecutionProvider'
-        sess_options = ort.SessionOptions()
-        sess_options.graph_optimization_level = ort.GraphOptimizationLevel.ORT_ENABLE_ALL
-        sess_options.intra_op_num_threads = 8  # Limit the number of threads
-        sess = ort.InferenceSession(onnx_file, sess_options, providers=['CPUExecutionProvider'])
-
-        input_tensor = sess.get_inputs()[0]
-        input_type = input_tensor.type
-
-        # Mapping ONNX datatype to numpy datatype
-        if 'float16' in input_type:
-            input_dtype = np.float16
-        elif 'float' in input_type:
-            input_dtype = np.float32
-        elif 'double' in input_type:
-            input_dtype = np.float64
-        elif 'int64' in input_type:
-            input_dtype = np.int64
-        elif 'int32' in input_type:
-            input_dtype = np.int32
-        else:
-            raise ValueError(f'Unsupported ONNX datatype {input_type}')
-
-        input_data = np.random.rand(*input_tensor.shape).astype(input_dtype)
-        input_name = input_tensor.name
-        output_name = sess.get_outputs()[0].name
-
-        # Warmup runs
-        elapsed = 0.0
-        for _ in range(3):
-            start_time = time.time()
-            for _ in range(self.num_warmup_runs):
-                sess.run([output_name], {input_name: input_data})
-            elapsed = time.time() - start_time
-
-        # Compute number of runs as higher of min_time or num_timed_runs
-        num_runs = max(round(self.min_time / (elapsed + eps) * self.num_warmup_runs), self.num_timed_runs)
-
-        # Timed runs
-        run_times = []
-        for _ in TQDM(range(num_runs), desc=onnx_file):
-            start_time = time.time()
-            sess.run([output_name], {input_name: input_data})
-            run_times.append((time.time() - start_time) * 1000)  # Convert to milliseconds
-
-        run_times = self.iterative_sigma_clipping(np.array(run_times), sigma=2, max_iters=5)  # sigma clipping
-        return np.mean(run_times), np.std(run_times)
-
-    def generate_table_row(self, model_name, t_onnx, t_engine, model_info):
-        """Generates a formatted string for a table row that includes model performance and metric details."""
-        layers, params, gradients, flops = model_info
-        return f'| {model_name:18s} | {self.imgsz} | - | {t_onnx[0]:.2f}  {t_onnx[1]:.2f} ms | {t_engine[0]:.2f}  {t_engine[1]:.2f} ms | {params / 1e6:.1f} | {flops:.1f} |'
-
-    def generate_results_dict(self, model_name, t_onnx, t_engine, model_info):
-        """Generates a dictionary of model details including name, parameters, GFLOPS and speed metrics."""
-        layers, params, gradients, flops = model_info
-        return {
-            'model/name': model_name,
-            'model/parameters': params,
-            'model/GFLOPs': round(flops, 3),
-            'model/speed_ONNX(ms)': round(t_onnx[0], 3),
-            'model/speed_TensorRT(ms)': round(t_engine[0], 3)}
-
-    def print_table(self, table_rows):
-        """Formats and prints a comparison table for different models with given statistics and performance data."""
-        gpu = torch.cuda.get_device_name(0) if torch.cuda.is_available() else 'GPU'
-        header = f'| Model | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>{gpu} TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |'
-        separator = '|-------------|---------------------|--------------------|------------------------------|-----------------------------------|------------------|-----------------|'
-
-        print(f'\n\n{header}')
-        print(separator)
-        for row in table_rows:
-            print(row)
+        TODO
+        """
+        pass
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/base.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/base.py`

 * *Files 5% similar despite different names*

```diff
@@ -139,45 +139,43 @@
 def on_export_end(exporter):
     """Called when the model export ends."""
     pass
 
 
 default_callbacks = {
     # Run in trainer
-    'on_pretrain_routine_start': [on_pretrain_routine_start],
-    'on_pretrain_routine_end': [on_pretrain_routine_end],
-    'on_train_start': [on_train_start],
-    'on_train_epoch_start': [on_train_epoch_start],
-    'on_train_batch_start': [on_train_batch_start],
-    'optimizer_step': [optimizer_step],
-    'on_before_zero_grad': [on_before_zero_grad],
-    'on_train_batch_end': [on_train_batch_end],
-    'on_train_epoch_end': [on_train_epoch_end],
-    'on_fit_epoch_end': [on_fit_epoch_end],  # fit = train + val
-    'on_model_save': [on_model_save],
-    'on_train_end': [on_train_end],
-    'on_params_update': [on_params_update],
-    'teardown': [teardown],
-
+    "on_pretrain_routine_start": [on_pretrain_routine_start],
+    "on_pretrain_routine_end": [on_pretrain_routine_end],
+    "on_train_start": [on_train_start],
+    "on_train_epoch_start": [on_train_epoch_start],
+    "on_train_batch_start": [on_train_batch_start],
+    "optimizer_step": [optimizer_step],
+    "on_before_zero_grad": [on_before_zero_grad],
+    "on_train_batch_end": [on_train_batch_end],
+    "on_train_epoch_end": [on_train_epoch_end],
+    "on_fit_epoch_end": [on_fit_epoch_end],  # fit = train + val
+    "on_model_save": [on_model_save],
+    "on_train_end": [on_train_end],
+    "on_params_update": [on_params_update],
+    "teardown": [teardown],
     # Run in validator
-    'on_val_start': [on_val_start],
-    'on_val_batch_start': [on_val_batch_start],
-    'on_val_batch_end': [on_val_batch_end],
-    'on_val_end': [on_val_end],
-
+    "on_val_start": [on_val_start],
+    "on_val_batch_start": [on_val_batch_start],
+    "on_val_batch_end": [on_val_batch_end],
+    "on_val_end": [on_val_end],
     # Run in predictor
-    'on_predict_start': [on_predict_start],
-    'on_predict_batch_start': [on_predict_batch_start],
-    'on_predict_postprocess_end': [on_predict_postprocess_end],
-    'on_predict_batch_end': [on_predict_batch_end],
-    'on_predict_end': [on_predict_end],
-
+    "on_predict_start": [on_predict_start],
+    "on_predict_batch_start": [on_predict_batch_start],
+    "on_predict_postprocess_end": [on_predict_postprocess_end],
+    "on_predict_batch_end": [on_predict_batch_end],
+    "on_predict_end": [on_predict_end],
     # Run in exporter
-    'on_export_start': [on_export_start],
-    'on_export_end': [on_export_end]}
+    "on_export_start": [on_export_start],
+    "on_export_end": [on_export_end],
+}
 
 
 def get_default_callbacks():
     """
     Return a copy of the default_callbacks dictionary with lists as default values.
 
     Returns:
@@ -193,26 +191,28 @@
     Args:
         instance (Trainer, Predictor, Validator, Exporter): An object with a 'callbacks' attribute that is a dictionary
             of callback lists.
     """
 
     # Load HUB callbacks
     from .hub import callbacks as hub_cb
+
     callbacks_list = [hub_cb]
 
     # Load training callbacks
-    if 'Trainer' in instance.__class__.__name__:
+    if "Trainer" in instance.__class__.__name__:
         from .clearml import callbacks as clear_cb
         from .comet import callbacks as comet_cb
         from .dvc import callbacks as dvc_cb
         from .mlflow import callbacks as mlflow_cb
         from .neptune import callbacks as neptune_cb
         from .raytune import callbacks as tune_cb
         from .tensorboard import callbacks as tb_cb
         from .wb import callbacks as wb_cb
+
         callbacks_list.extend([clear_cb, comet_cb, dvc_cb, mlflow_cb, neptune_cb, tune_cb, tb_cb, wb_cb])
 
     # Add the callbacks to the callbacks dictionary
     for callbacks in callbacks_list:
         for k, v in callbacks.items():
             if v not in instance.callbacks[k]:
                 instance.callbacks[k].append(v)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/clearml.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/clearml.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,44 +1,41 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 from ultralytics.utils import LOGGER, SETTINGS, TESTS_RUNNING
 
 try:
     assert not TESTS_RUNNING  # do not log pytest
-    assert SETTINGS['clearml'] is True  # verify integration is enabled
+    assert SETTINGS["clearml"] is True  # verify integration is enabled
     import clearml
     from clearml import Task
-    from clearml.binding.frameworks.pytorch_bind import PatchPyTorchModelIO
-    from clearml.binding.matplotlib_bind import PatchedMatplotlib
 
-    assert hasattr(clearml, '__version__')  # verify package is not directory
+    assert hasattr(clearml, "__version__")  # verify package is not directory
 
 except (ImportError, AssertionError):
     clearml = None
 
 
-def _log_debug_samples(files, title='Debug Samples') -> None:
+def _log_debug_samples(files, title="Debug Samples") -> None:
     """
     Log files (images) as debug samples in the ClearML task.
 
     Args:
         files (list): A list of file paths in PosixPath format.
         title (str): A title that groups together images with the same values.
     """
     import re
 
     if task := Task.current_task():
         for f in files:
             if f.exists():
-                it = re.search(r'_batch(\d+)', f.name)
+                it = re.search(r"_batch(\d+)", f.name)
                 iteration = int(it.groups()[0]) if it else 0
-                task.get_logger().report_image(title=title,
-                                               series=f.name.replace(it.group(), ''),
-                                               local_path=str(f),
-                                               iteration=iteration)
+                task.get_logger().report_image(
+                    title=title, series=f.name.replace(it.group(), ""), local_path=str(f), iteration=iteration
+                )
 
 
 def _log_plot(title, plot_path) -> None:
     """
     Log an image as a plot in the plot section of ClearML.
 
     Args:
@@ -46,95 +43,111 @@
         plot_path (str): The path to the saved image file.
     """
     import matplotlib.image as mpimg
     import matplotlib.pyplot as plt
 
     img = mpimg.imread(plot_path)
     fig = plt.figure()
-    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect='auto', xticks=[], yticks=[])  # no ticks
+    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect="auto", xticks=[], yticks=[])  # no ticks
     ax.imshow(img)
 
-    Task.current_task().get_logger().report_matplotlib_figure(title=title,
-                                                              series='',
-                                                              figure=fig,
-                                                              report_interactive=False)
+    Task.current_task().get_logger().report_matplotlib_figure(
+        title=title, series="", figure=fig, report_interactive=False
+    )
 
 
 def on_pretrain_routine_start(trainer):
     """Runs at start of pretraining routine; initializes and connects/ logs task to ClearML."""
     try:
         if task := Task.current_task():
-            # Make sure the automatic pytorch and matplotlib bindings are disabled!
+            # WARNING: make sure the automatic pytorch and matplotlib bindings are disabled!
             # We are logging these plots and model files manually in the integration
+            from clearml.binding.frameworks.pytorch_bind import PatchPyTorchModelIO
+            from clearml.binding.matplotlib_bind import PatchedMatplotlib
+
             PatchPyTorchModelIO.update_current_task(None)
             PatchedMatplotlib.update_current_task(None)
         else:
-            task = Task.init(project_name=trainer.args.project or 'YOLOv8',
-                             task_name=trainer.args.name,
-                             tags=['YOLOv8'],
-                             output_uri=True,
-                             reuse_last_task_id=False,
-                             auto_connect_frameworks={
-                                 'pytorch': False,
-                                 'matplotlib': False})
-            LOGGER.warning('ClearML Initialized a new task. If you want to run remotely, '
-                           'please add clearml-init and connect your arguments before initializing YOLO.')
-        task.connect(vars(trainer.args), name='General')
+            task = Task.init(
+                project_name=trainer.args.project or "YOLOv8",
+                task_name=trainer.args.name,
+                tags=["YOLOv8"],
+                output_uri=True,
+                reuse_last_task_id=False,
+                auto_connect_frameworks={"pytorch": False, "matplotlib": False},
+            )
+            LOGGER.warning(
+                "ClearML Initialized a new task. If you want to run remotely, "
+                "please add clearml-init and connect your arguments before initializing YOLO."
+            )
+        task.connect(vars(trainer.args), name="General")
     except Exception as e:
-        LOGGER.warning(f'WARNING  ClearML installed but not initialized correctly, not logging this run. {e}')
+        LOGGER.warning(f"WARNING  ClearML installed but not initialized correctly, not logging this run. {e}")
 
 
 def on_train_epoch_end(trainer):
     """Logs debug samples for the first epoch of YOLO training and report current training progress."""
     if task := Task.current_task():
         # Log debug samples
         if trainer.epoch == 1:
-            _log_debug_samples(sorted(trainer.save_dir.glob('train_batch*.jpg')), 'Mosaic')
+            _log_debug_samples(sorted(trainer.save_dir.glob("train_batch*.jpg")), "Mosaic")
         # Report the current training progress
-        for k, v in trainer.validator.metrics.results_dict.items():
-            task.get_logger().report_scalar('train', k, v, iteration=trainer.epoch)
+        for k, v in trainer.label_loss_items(trainer.tloss, prefix="train").items():
+            task.get_logger().report_scalar("train", k, v, iteration=trainer.epoch)
+        for k, v in trainer.lr.items():
+            task.get_logger().report_scalar("lr", k, v, iteration=trainer.epoch)
 
 
 def on_fit_epoch_end(trainer):
     """Reports model information to logger at the end of an epoch."""
     if task := Task.current_task():
         # You should have access to the validation bboxes under jdict
-        task.get_logger().report_scalar(title='Epoch Time',
-                                        series='Epoch Time',
-                                        value=trainer.epoch_time,
-                                        iteration=trainer.epoch)
+        task.get_logger().report_scalar(
+            title="Epoch Time", series="Epoch Time", value=trainer.epoch_time, iteration=trainer.epoch
+        )
+        for k, v in trainer.metrics.items():
+            task.get_logger().report_scalar("val", k, v, iteration=trainer.epoch)
         if trainer.epoch == 0:
             from ultralytics.utils.torch_utils import model_info_for_loggers
+
             for k, v in model_info_for_loggers(trainer).items():
                 task.get_logger().report_single_value(k, v)
 
 
 def on_val_end(validator):
     """Logs validation results including labels and predictions."""
     if Task.current_task():
         # Log val_labels and val_pred
-        _log_debug_samples(sorted(validator.save_dir.glob('val*.jpg')), 'Validation')
+        _log_debug_samples(sorted(validator.save_dir.glob("val*.jpg")), "Validation")
 
 
 def on_train_end(trainer):
     """Logs final model and its name on training completion."""
     if task := Task.current_task():
         # Log final results, CM matrix + PR plots
         files = [
-            'results.png', 'confusion_matrix.png', 'confusion_matrix_normalized.png',
-            *(f'{x}_curve.png' for x in ('F1', 'PR', 'P', 'R'))]
+            "results.png",
+            "confusion_matrix.png",
+            "confusion_matrix_normalized.png",
+            *(f"{x}_curve.png" for x in ("F1", "PR", "P", "R")),
+        ]
         files = [(trainer.save_dir / f) for f in files if (trainer.save_dir / f).exists()]  # filter
         for f in files:
             _log_plot(title=f.stem, plot_path=f)
         # Report final metrics
         for k, v in trainer.validator.metrics.results_dict.items():
             task.get_logger().report_single_value(k, v)
         # Log the final model
         task.update_output_model(model_path=str(trainer.best), model_name=trainer.args.name, auto_delete_file=False)
 
 
-callbacks = {
-    'on_pretrain_routine_start': on_pretrain_routine_start,
-    'on_train_epoch_end': on_train_epoch_end,
-    'on_fit_epoch_end': on_fit_epoch_end,
-    'on_val_end': on_val_end,
-    'on_train_end': on_train_end} if clearml else {}
+callbacks = (
+    {
+        "on_pretrain_routine_start": on_pretrain_routine_start,
+        "on_train_epoch_end": on_train_epoch_end,
+        "on_fit_epoch_end": on_fit_epoch_end,
+        "on_val_end": on_val_end,
+        "on_train_end": on_train_end,
+    }
+    if clearml
+    else {}
+)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/comet.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/comet.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,96 +1,99 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 from ultralytics.utils import LOGGER, RANK, SETTINGS, TESTS_RUNNING, ops
 
 try:
     assert not TESTS_RUNNING  # do not log pytest
-    assert SETTINGS['comet'] is True  # verify integration is enabled
+    assert SETTINGS["comet"] is True  # verify integration is enabled
     import comet_ml
 
-    assert hasattr(comet_ml, '__version__')  # verify package is not directory
+    assert hasattr(comet_ml, "__version__")  # verify package is not directory
 
     import os
     from pathlib import Path
 
     # Ensures certain logging functions only run for supported tasks
-    COMET_SUPPORTED_TASKS = ['detect']
+    COMET_SUPPORTED_TASKS = ["detect"]
 
     # Names of plots created by YOLOv8 that are logged to Comet
-    EVALUATION_PLOT_NAMES = 'F1_curve', 'P_curve', 'R_curve', 'PR_curve', 'confusion_matrix'
-    LABEL_PLOT_NAMES = 'labels', 'labels_correlogram'
+    EVALUATION_PLOT_NAMES = "F1_curve", "P_curve", "R_curve", "PR_curve", "confusion_matrix"
+    LABEL_PLOT_NAMES = "labels", "labels_correlogram"
 
     _comet_image_prediction_count = 0
 
 except (ImportError, AssertionError):
     comet_ml = None
 
 
 def _get_comet_mode():
     """Returns the mode of comet set in the environment variables, defaults to 'online' if not set."""
-    return os.getenv('COMET_MODE', 'online')
+    return os.getenv("COMET_MODE", "online")
 
 
 def _get_comet_model_name():
     """Returns the model name for Comet from the environment variable 'COMET_MODEL_NAME' or defaults to 'YOLOv8'."""
-    return os.getenv('COMET_MODEL_NAME', 'YOLOv8')
+    return os.getenv("COMET_MODEL_NAME", "YOLOv8")
 
 
 def _get_eval_batch_logging_interval():
     """Get the evaluation batch logging interval from environment variable or use default value 1."""
-    return int(os.getenv('COMET_EVAL_BATCH_LOGGING_INTERVAL', 1))
+    return int(os.getenv("COMET_EVAL_BATCH_LOGGING_INTERVAL", 1))
 
 
 def _get_max_image_predictions_to_log():
     """Get the maximum number of image predictions to log from the environment variables."""
-    return int(os.getenv('COMET_MAX_IMAGE_PREDICTIONS', 100))
+    return int(os.getenv("COMET_MAX_IMAGE_PREDICTIONS", 100))
 
 
 def _scale_confidence_score(score):
     """Scales the given confidence score by a factor specified in an environment variable."""
-    scale = float(os.getenv('COMET_MAX_CONFIDENCE_SCORE', 100.0))
+    scale = float(os.getenv("COMET_MAX_CONFIDENCE_SCORE", 100.0))
     return score * scale
 
 
 def _should_log_confusion_matrix():
     """Determines if the confusion matrix should be logged based on the environment variable settings."""
-    return os.getenv('COMET_EVAL_LOG_CONFUSION_MATRIX', 'false').lower() == 'true'
+    return os.getenv("COMET_EVAL_LOG_CONFUSION_MATRIX", "false").lower() == "true"
 
 
 def _should_log_image_predictions():
     """Determines whether to log image predictions based on a specified environment variable."""
-    return os.getenv('COMET_EVAL_LOG_IMAGE_PREDICTIONS', 'true').lower() == 'true'
+    return os.getenv("COMET_EVAL_LOG_IMAGE_PREDICTIONS", "true").lower() == "true"
 
 
 def _get_experiment_type(mode, project_name):
     """Return an experiment based on mode and project name."""
-    if mode == 'offline':
+    if mode == "offline":
         return comet_ml.OfflineExperiment(project_name=project_name)
 
     return comet_ml.Experiment(project_name=project_name)
 
 
 def _create_experiment(args):
     """Ensures that the experiment object is only created in a single process during distributed training."""
-    if RANK not in (-1, 0):
+    if RANK not in {-1, 0}:
         return
     try:
         comet_mode = _get_comet_mode()
-        _project_name = os.getenv('COMET_PROJECT_NAME', args.project)
+        _project_name = os.getenv("COMET_PROJECT_NAME", args.project)
         experiment = _get_experiment_type(comet_mode, _project_name)
         experiment.log_parameters(vars(args))
-        experiment.log_others({
-            'eval_batch_logging_interval': _get_eval_batch_logging_interval(),
-            'log_confusion_matrix_on_eval': _should_log_confusion_matrix(),
-            'log_image_predictions': _should_log_image_predictions(),
-            'max_image_predictions': _get_max_image_predictions_to_log(), })
-        experiment.log_other('Created from', 'yolov8')
+        experiment.log_others(
+            {
+                "eval_batch_logging_interval": _get_eval_batch_logging_interval(),
+                "log_confusion_matrix_on_eval": _should_log_confusion_matrix(),
+                "log_image_predictions": _should_log_image_predictions(),
+                "max_image_predictions": _get_max_image_predictions_to_log(),
+            }
+        )
+        experiment.log_other("Created from", "yolov8")
 
     except Exception as e:
-        LOGGER.warning(f'WARNING  Comet installed but not initialized correctly, not logging this run. {e}')
+        LOGGER.warning(f"WARNING  Comet installed but not initialized correctly, not logging this run. {e}")
 
 
 def _fetch_trainer_metadata(trainer):
     """Returns metadata for YOLO training including epoch and asset saving status."""
     curr_epoch = trainer.epoch + 1
 
     train_num_steps_per_epoch = len(trainer.train_loader.dataset) // trainer.batch_size
@@ -98,20 +101,15 @@
     final_epoch = curr_epoch == trainer.epochs
 
     save = trainer.args.save
     save_period = trainer.args.save_period
     save_interval = curr_epoch % save_period == 0
     save_assets = save and save_period > 0 and save_interval and not final_epoch
 
-    return dict(
-        curr_epoch=curr_epoch,
-        curr_step=curr_step,
-        save_assets=save_assets,
-        final_epoch=final_epoch,
-    )
+    return dict(curr_epoch=curr_epoch, curr_step=curr_step, save_assets=save_assets, final_epoch=final_epoch)
 
 
 def _scale_bounding_box_to_original_image_shape(box, resized_image_shape, original_image_shape, ratio_pad):
     """
     YOLOv8 resizes images during training and the label values are normalized based on this resized shape.
 
     This function rescales the bounding box labels to the original image shape.
@@ -130,94 +128,96 @@
     box = box.tolist()
 
     return box
 
 
 def _format_ground_truth_annotations_for_detection(img_idx, image_path, batch, class_name_map=None):
     """Format ground truth annotations for detection."""
-    indices = batch['batch_idx'] == img_idx
-    bboxes = batch['bboxes'][indices]
+    indices = batch["batch_idx"] == img_idx
+    bboxes = batch["bboxes"][indices]
     if len(bboxes) == 0:
-        LOGGER.debug(f'COMET WARNING: Image: {image_path} has no bounding boxes labels')
+        LOGGER.debug(f"COMET WARNING: Image: {image_path} has no bounding boxes labels")
         return None
 
-    cls_labels = batch['cls'][indices].squeeze(1).tolist()
+    cls_labels = batch["cls"][indices].squeeze(1).tolist()
     if class_name_map:
         cls_labels = [str(class_name_map[label]) for label in cls_labels]
 
-    original_image_shape = batch['ori_shape'][img_idx]
-    resized_image_shape = batch['resized_shape'][img_idx]
-    ratio_pad = batch['ratio_pad'][img_idx]
+    original_image_shape = batch["ori_shape"][img_idx]
+    resized_image_shape = batch["resized_shape"][img_idx]
+    ratio_pad = batch["ratio_pad"][img_idx]
 
     data = []
     for box, label in zip(bboxes, cls_labels):
         box = _scale_bounding_box_to_original_image_shape(box, resized_image_shape, original_image_shape, ratio_pad)
-        data.append({
-            'boxes': [box],
-            'label': f'gt_{label}',
-            'score': _scale_confidence_score(1.0), })
+        data.append(
+            {
+                "boxes": [box],
+                "label": f"gt_{label}",
+                "score": _scale_confidence_score(1.0),
+            }
+        )
 
-    return {'name': 'ground_truth', 'data': data}
+    return {"name": "ground_truth", "data": data}
 
 
 def _format_prediction_annotations_for_detection(image_path, metadata, class_label_map=None):
     """Format YOLO predictions for object detection visualization."""
     stem = image_path.stem
     image_id = int(stem) if stem.isnumeric() else stem
 
     predictions = metadata.get(image_id)
     if not predictions:
-        LOGGER.debug(f'COMET WARNING: Image: {image_path} has no bounding boxes predictions')
+        LOGGER.debug(f"COMET WARNING: Image: {image_path} has no bounding boxes predictions")
         return None
 
     data = []
     for prediction in predictions:
-        boxes = prediction['bbox']
-        score = _scale_confidence_score(prediction['score'])
-        cls_label = prediction['category_id']
+        boxes = prediction["bbox"]
+        score = _scale_confidence_score(prediction["score"])
+        cls_label = prediction["category_id"]
         if class_label_map:
             cls_label = str(class_label_map[cls_label])
 
-        data.append({'boxes': [boxes], 'label': cls_label, 'score': score})
+        data.append({"boxes": [boxes], "label": cls_label, "score": score})
 
-    return {'name': 'prediction', 'data': data}
+    return {"name": "prediction", "data": data}
 
 
 def _fetch_annotations(img_idx, image_path, batch, prediction_metadata_map, class_label_map):
     """Join the ground truth and prediction annotations if they exist."""
-    ground_truth_annotations = _format_ground_truth_annotations_for_detection(img_idx, image_path, batch,
-                                                                              class_label_map)
-    prediction_annotations = _format_prediction_annotations_for_detection(image_path, prediction_metadata_map,
-                                                                          class_label_map)
+    ground_truth_annotations = _format_ground_truth_annotations_for_detection(
+        img_idx, image_path, batch, class_label_map
+    )
+    prediction_annotations = _format_prediction_annotations_for_detection(
+        image_path, prediction_metadata_map, class_label_map
+    )
 
     annotations = [
-        annotation for annotation in [ground_truth_annotations, prediction_annotations] if annotation is not None]
+        annotation for annotation in [ground_truth_annotations, prediction_annotations] if annotation is not None
+    ]
     return [annotations] if annotations else None
 
 
 def _create_prediction_metadata_map(model_predictions):
     """Create metadata map for model predictions by groupings them based on image ID."""
     pred_metadata_map = {}
     for prediction in model_predictions:
-        pred_metadata_map.setdefault(prediction['image_id'], [])
-        pred_metadata_map[prediction['image_id']].append(prediction)
+        pred_metadata_map.setdefault(prediction["image_id"], [])
+        pred_metadata_map[prediction["image_id"]].append(prediction)
 
     return pred_metadata_map
 
 
 def _log_confusion_matrix(experiment, trainer, curr_step, curr_epoch):
     """Log the confusion matrix to Comet experiment."""
     conf_mat = trainer.validator.confusion_matrix.matrix
-    names = list(trainer.data['names'].values()) + ['background']
+    names = list(trainer.data["names"].values()) + ["background"]
     experiment.log_confusion_matrix(
-        matrix=conf_mat,
-        labels=names,
-        max_categories=len(names),
-        epoch=curr_epoch,
-        step=curr_step,
+        matrix=conf_mat, labels=names, max_categories=len(names), epoch=curr_epoch, step=curr_step
     )
 
 
 def _log_images(experiment, image_paths, curr_step, annotations=None):
     """Logs images to the experiment with optional annotations."""
     if annotations:
         for image_path, annotation in zip(image_paths, annotations):
@@ -247,15 +247,15 @@
     batch_logging_interval = _get_eval_batch_logging_interval()
     max_image_predictions = _get_max_image_predictions_to_log()
 
     for batch_idx, batch in enumerate(dataloader):
         if (batch_idx + 1) % batch_logging_interval != 0:
             continue
 
-        image_paths = batch['im_file']
+        image_paths = batch["im_file"]
         for img_idx, image_path in enumerate(image_paths):
             if _comet_image_prediction_count >= max_image_predictions:
                 return
 
             image_path = Path(image_path)
             annotations = _fetch_annotations(
                 img_idx,
@@ -271,75 +271,67 @@
                 annotations=annotations,
             )
             _comet_image_prediction_count += 1
 
 
 def _log_plots(experiment, trainer):
     """Logs evaluation plots and label plots for the experiment."""
-    plot_filenames = [trainer.save_dir / f'{plots}.png' for plots in EVALUATION_PLOT_NAMES]
+    plot_filenames = [trainer.save_dir / f"{plots}.png" for plots in EVALUATION_PLOT_NAMES]
     _log_images(experiment, plot_filenames, None)
 
-    label_plot_filenames = [trainer.save_dir / f'{labels}.jpg' for labels in LABEL_PLOT_NAMES]
+    label_plot_filenames = [trainer.save_dir / f"{labels}.jpg" for labels in LABEL_PLOT_NAMES]
     _log_images(experiment, label_plot_filenames, None)
 
 
 def _log_model(experiment, trainer):
     """Log the best-trained model to Comet.ml."""
     model_name = _get_comet_model_name()
-    experiment.log_model(
-        model_name,
-        file_or_folder=str(trainer.best),
-        file_name='best.pt',
-        overwrite=True,
-    )
+    experiment.log_model(model_name, file_or_folder=str(trainer.best), file_name="best.pt", overwrite=True)
 
 
 def on_pretrain_routine_start(trainer):
     """Creates or resumes a CometML experiment at the start of a YOLO pre-training routine."""
     experiment = comet_ml.get_global_experiment()
-    is_alive = getattr(experiment, 'alive', False)
+    is_alive = getattr(experiment, "alive", False)
     if not experiment or not is_alive:
         _create_experiment(trainer.args)
 
 
 def on_train_epoch_end(trainer):
     """Log metrics and save batch images at the end of training epochs."""
     experiment = comet_ml.get_global_experiment()
     if not experiment:
         return
 
     metadata = _fetch_trainer_metadata(trainer)
-    curr_epoch = metadata['curr_epoch']
-    curr_step = metadata['curr_step']
+    curr_epoch = metadata["curr_epoch"]
+    curr_step = metadata["curr_step"]
 
-    experiment.log_metrics(
-        trainer.label_loss_items(trainer.tloss, prefix='train'),
-        step=curr_step,
-        epoch=curr_epoch,
-    )
+    experiment.log_metrics(trainer.label_loss_items(trainer.tloss, prefix="train"), step=curr_step, epoch=curr_epoch)
 
     if curr_epoch == 1:
-        _log_images(experiment, trainer.save_dir.glob('train_batch*.jpg'), curr_step)
+        _log_images(experiment, trainer.save_dir.glob("train_batch*.jpg"), curr_step)
 
 
 def on_fit_epoch_end(trainer):
     """Logs model assets at the end of each epoch."""
     experiment = comet_ml.get_global_experiment()
     if not experiment:
         return
 
     metadata = _fetch_trainer_metadata(trainer)
-    curr_epoch = metadata['curr_epoch']
-    curr_step = metadata['curr_step']
-    save_assets = metadata['save_assets']
+    curr_epoch = metadata["curr_epoch"]
+    curr_step = metadata["curr_step"]
+    save_assets = metadata["save_assets"]
 
     experiment.log_metrics(trainer.metrics, step=curr_step, epoch=curr_epoch)
     experiment.log_metrics(trainer.lr, step=curr_step, epoch=curr_epoch)
     if curr_epoch == 1:
         from ultralytics.utils.torch_utils import model_info_for_loggers
+
         experiment.log_metrics(model_info_for_loggers(trainer), step=curr_step, epoch=curr_epoch)
 
     if not save_assets:
         return
 
     _log_model(experiment, trainer)
     if _should_log_confusion_matrix():
@@ -351,28 +343,33 @@
 def on_train_end(trainer):
     """Perform operations at the end of training."""
     experiment = comet_ml.get_global_experiment()
     if not experiment:
         return
 
     metadata = _fetch_trainer_metadata(trainer)
-    curr_epoch = metadata['curr_epoch']
-    curr_step = metadata['curr_step']
+    curr_epoch = metadata["curr_epoch"]
+    curr_step = metadata["curr_step"]
     plots = trainer.args.plots
 
     _log_model(experiment, trainer)
     if plots:
         _log_plots(experiment, trainer)
 
     _log_confusion_matrix(experiment, trainer, curr_step, curr_epoch)
     _log_image_predictions(experiment, trainer.validator, curr_step)
     experiment.end()
 
     global _comet_image_prediction_count
     _comet_image_prediction_count = 0
 
 
-callbacks = {
-    'on_pretrain_routine_start': on_pretrain_routine_start,
-    'on_train_epoch_end': on_train_epoch_end,
-    'on_fit_epoch_end': on_fit_epoch_end,
-    'on_train_end': on_train_end} if comet_ml else {}
+callbacks = (
+    {
+        "on_pretrain_routine_start": on_pretrain_routine_start,
+        "on_train_epoch_end": on_train_epoch_end,
+        "on_fit_epoch_end": on_fit_epoch_end,
+        "on_train_end": on_train_end,
+    }
+    if comet_ml
+    else {}
+)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/dvc.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/dvc.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 from ultralytics.utils import LOGGER, SETTINGS, TESTS_RUNNING, checks
 
 try:
     assert not TESTS_RUNNING  # do not log pytest
-    assert SETTINGS['dvc'] is True  # verify integration is enabled
+    assert SETTINGS["dvc"] is True  # verify integration is enabled
     import dvclive
-    assert checks.check_version('dvclive', '2.11.0', verbose=True)
+
+    assert checks.check_version("dvclive", "2.11.0", verbose=True)
 
     import os
     import re
     from pathlib import Path
 
     # DVCLive logger instance
     live = None
@@ -20,67 +21,67 @@
     # distinguish final evaluation of the best model vs last epoch validation
     _training_epoch = False
 
 except (ImportError, AssertionError, TypeError):
     dvclive = None
 
 
-def _log_images(path, prefix=''):
+def _log_images(path, prefix=""):
     """Logs images at specified path with an optional prefix using DVCLive."""
     if live:
         name = path.name
 
         # Group images by batch to enable sliders in UI
-        if m := re.search(r'_batch(\d+)', name):
+        if m := re.search(r"_batch(\d+)", name):
             ni = m[1]
-            new_stem = re.sub(r'_batch(\d+)', '_batch', path.stem)
+            new_stem = re.sub(r"_batch(\d+)", "_batch", path.stem)
             name = (Path(new_stem) / ni).with_suffix(path.suffix)
 
         live.log_image(os.path.join(prefix, name), path)
 
 
-def _log_plots(plots, prefix=''):
+def _log_plots(plots, prefix=""):
     """Logs plot images for training progress if they have not been previously processed."""
     for name, params in plots.items():
-        timestamp = params['timestamp']
+        timestamp = params["timestamp"]
         if _processed_plots.get(name) != timestamp:
             _log_images(name, prefix)
             _processed_plots[name] = timestamp
 
 
 def _log_confusion_matrix(validator):
     """Logs the confusion matrix for the given validator using DVCLive."""
     targets = []
     preds = []
     matrix = validator.confusion_matrix.matrix
     names = list(validator.names.values())
-    if validator.confusion_matrix.task == 'detect':
-        names += ['background']
+    if validator.confusion_matrix.task == "detect":
+        names += ["background"]
 
     for ti, pred in enumerate(matrix.T.astype(int)):
         for pi, num in enumerate(pred):
             targets.extend([names[ti]] * num)
             preds.extend([names[pi]] * num)
 
-    live.log_sklearn_plot('confusion_matrix', targets, preds, name='cf.json', normalized=True)
+    live.log_sklearn_plot("confusion_matrix", targets, preds, name="cf.json", normalized=True)
 
 
 def on_pretrain_routine_start(trainer):
     """Initializes DVCLive logger for training metadata during pre-training routine."""
     try:
         global live
         live = dvclive.Live(save_dvc_exp=True, cache_images=True)
         LOGGER.info("DVCLive is detected and auto logging is enabled (run 'yolo settings dvc=False' to disable).")
     except Exception as e:
-        LOGGER.warning(f'WARNING  DVCLive installed but not initialized correctly, not logging this run. {e}')
+        LOGGER.warning(f"WARNING  DVCLive installed but not initialized correctly, not logging this run. {e}")
 
 
 def on_pretrain_routine_end(trainer):
     """Logs plots related to the training process at the end of the pretraining routine."""
-    _log_plots(trainer.plots, 'train')
+    _log_plots(trainer.plots, "train")
 
 
 def on_train_start(trainer):
     """Logs the training parameters if DVCLive logging is active."""
     if live:
         live.log_params(trainer.args)
 
@@ -91,48 +92,54 @@
     _training_epoch = True
 
 
 def on_fit_epoch_end(trainer):
     """Logs training metrics and model info, and advances to next step on the end of each fit epoch."""
     global _training_epoch
     if live and _training_epoch:
-        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix='train'), **trainer.metrics, **trainer.lr}
+        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix="train"), **trainer.metrics, **trainer.lr}
         for metric, value in all_metrics.items():
             live.log_metric(metric, value)
 
         if trainer.epoch == 0:
             from ultralytics.utils.torch_utils import model_info_for_loggers
+
             for metric, value in model_info_for_loggers(trainer).items():
                 live.log_metric(metric, value, plot=False)
 
-        _log_plots(trainer.plots, 'train')
-        _log_plots(trainer.validator.plots, 'val')
+        _log_plots(trainer.plots, "train")
+        _log_plots(trainer.validator.plots, "val")
 
         live.next_step()
         _training_epoch = False
 
 
 def on_train_end(trainer):
     """Logs the best metrics, plots, and confusion matrix at the end of training if DVCLive is active."""
     if live:
         # At the end log the best metrics. It runs validator on the best model internally.
-        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix='train'), **trainer.metrics, **trainer.lr}
+        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix="train"), **trainer.metrics, **trainer.lr}
         for metric, value in all_metrics.items():
             live.log_metric(metric, value, plot=False)
 
-        _log_plots(trainer.plots, 'val')
-        _log_plots(trainer.validator.plots, 'val')
+        _log_plots(trainer.plots, "val")
+        _log_plots(trainer.validator.plots, "val")
         _log_confusion_matrix(trainer.validator)
 
         if trainer.best.exists():
-            live.log_artifact(trainer.best, copy=True, type='model')
+            live.log_artifact(trainer.best, copy=True, type="model")
 
         live.end()
 
 
-callbacks = {
-    'on_pretrain_routine_start': on_pretrain_routine_start,
-    'on_pretrain_routine_end': on_pretrain_routine_end,
-    'on_train_start': on_train_start,
-    'on_train_epoch_start': on_train_epoch_start,
-    'on_fit_epoch_end': on_fit_epoch_end,
-    'on_train_end': on_train_end} if dvclive else {}
+callbacks = (
+    {
+        "on_pretrain_routine_start": on_pretrain_routine_start,
+        "on_pretrain_routine_end": on_pretrain_routine_end,
+        "on_train_start": on_train_start,
+        "on_train_epoch_start": on_train_epoch_start,
+        "on_fit_epoch_end": on_fit_epoch_end,
+        "on_train_end": on_train_end,
+    }
+    if dvclive
+    else {}
+)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/hub.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/hub.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,59 +5,72 @@
 
 from ultralytics.hub.utils import HUB_WEB_ROOT, PREFIX, events
 from ultralytics.utils import LOGGER, SETTINGS
 
 
 def on_pretrain_routine_end(trainer):
     """Logs info before starting timer for upload rate limit."""
-    session = getattr(trainer, 'hub_session', None)
+    session = getattr(trainer, "hub_session", None)
     if session:
         # Start timer for upload rate limit
-        LOGGER.info(f'{PREFIX}View model at {HUB_WEB_ROOT}/models/{session.model_id} ')
-        session.timers = {'metrics': time(), 'ckpt': time()}  # start timer on session.rate_limit
+        session.timers = {"metrics": time(), "ckpt": time()}  # start timer on session.rate_limit
 
 
 def on_fit_epoch_end(trainer):
     """Uploads training progress metrics at the end of each epoch."""
-    session = getattr(trainer, 'hub_session', None)
+    session = getattr(trainer, "hub_session", None)
     if session:
         # Upload metrics after val end
-        all_plots = {**trainer.label_loss_items(trainer.tloss, prefix='train'), **trainer.metrics}
+        all_plots = {
+            **trainer.label_loss_items(trainer.tloss, prefix="train"),
+            **trainer.metrics,
+        }
         if trainer.epoch == 0:
             from ultralytics.utils.torch_utils import model_info_for_loggers
+
             all_plots = {**all_plots, **model_info_for_loggers(trainer)}
+
         session.metrics_queue[trainer.epoch] = json.dumps(all_plots)
-        if time() - session.timers['metrics'] > session.rate_limits['metrics']:
+
+        # If any metrics fail to upload, add them to the queue to attempt uploading again.
+        if session.metrics_upload_failed_queue:
+            session.metrics_queue.update(session.metrics_upload_failed_queue)
+
+        if time() - session.timers["metrics"] > session.rate_limits["metrics"]:
             session.upload_metrics()
-            session.timers['metrics'] = time()  # reset timer
+            session.timers["metrics"] = time()  # reset timer
             session.metrics_queue = {}  # reset queue
 
 
 def on_model_save(trainer):
     """Saves checkpoints to Ultralytics HUB with rate limiting."""
-    session = getattr(trainer, 'hub_session', None)
+    session = getattr(trainer, "hub_session", None)
     if session:
         # Upload checkpoints with rate limiting
         is_best = trainer.best_fitness == trainer.fitness
-        if time() - session.timers['ckpt'] > session.rate_limits['ckpt']:
-            LOGGER.info(f'{PREFIX}Uploading checkpoint {HUB_WEB_ROOT}/models/{session.model_id}')
+        if time() - session.timers["ckpt"] > session.rate_limits["ckpt"]:
+            LOGGER.info(f"{PREFIX}Uploading checkpoint {HUB_WEB_ROOT}/models/{session.model.id}")
             session.upload_model(trainer.epoch, trainer.last, is_best)
-            session.timers['ckpt'] = time()  # reset timer
+            session.timers["ckpt"] = time()  # reset timer
 
 
 def on_train_end(trainer):
     """Upload final model and metrics to Ultralytics HUB at the end of training."""
-    session = getattr(trainer, 'hub_session', None)
+    session = getattr(trainer, "hub_session", None)
     if session:
         # Upload final model and metrics with exponential standoff
-        LOGGER.info(f'{PREFIX}Syncing final model...')
-        session.upload_model(trainer.epoch, trainer.best, map=trainer.metrics.get('metrics/mAP50-95(B)', 0), final=True)
+        LOGGER.info(f"{PREFIX}Syncing final model...")
+        session.upload_model(
+            trainer.epoch,
+            trainer.best,
+            map=trainer.metrics.get("metrics/mAP50-95(B)", 0),
+            final=True,
+        )
         session.alive = False  # stop heartbeats
-        LOGGER.info(f'{PREFIX}Done \n'
-                    f'{PREFIX}View model at {HUB_WEB_ROOT}/models/{session.model_id} ')
+        LOGGER.info(f"{PREFIX}Done \n" f"{PREFIX}View model at {session.model_url} ")
 
 
 def on_train_start(trainer):
     """Run events on train start."""
     events(trainer.args)
 
 
@@ -72,16 +85,21 @@
 
 
 def on_export_start(exporter):
     """Run events on export start."""
     events(exporter.args)
 
 
-callbacks = {
-    'on_pretrain_routine_end': on_pretrain_routine_end,
-    'on_fit_epoch_end': on_fit_epoch_end,
-    'on_model_save': on_model_save,
-    'on_train_end': on_train_end,
-    'on_train_start': on_train_start,
-    'on_val_start': on_val_start,
-    'on_predict_start': on_predict_start,
-    'on_export_start': on_export_start} if SETTINGS['hub'] is True else {}  # verify enabled
+callbacks = (
+    {
+        "on_pretrain_routine_end": on_pretrain_routine_end,
+        "on_fit_epoch_end": on_fit_epoch_end,
+        "on_model_save": on_model_save,
+        "on_train_end": on_train_end,
+        "on_train_start": on_train_start,
+        "on_val_start": on_val_start,
+        "on_predict_start": on_predict_start,
+        "on_export_start": on_export_start,
+    }
+    if SETTINGS["hub"] is True
+    else {}
+)  # verify enabled
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/mlflow.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/mlflow.py`

 * *Files 17% similar despite different names*

```diff
@@ -22,21 +22,23 @@
 """
 
 from ultralytics.utils import LOGGER, RUNS_DIR, SETTINGS, TESTS_RUNNING, colorstr
 
 try:
     import os
 
-    assert not TESTS_RUNNING or 'test_mlflow' in os.environ.get('PYTEST_CURRENT_TEST', '')  # do not log pytest
-    assert SETTINGS['mlflow'] is True  # verify integration is enabled
+    assert not TESTS_RUNNING or "test_mlflow" in os.environ.get("PYTEST_CURRENT_TEST", "")  # do not log pytest
+    assert SETTINGS["mlflow"] is True  # verify integration is enabled
     import mlflow
 
-    assert hasattr(mlflow, '__version__')  # verify package is not directory
+    assert hasattr(mlflow, "__version__")  # verify package is not directory
     from pathlib import Path
-    PREFIX = colorstr('MLflow: ')
+
+    PREFIX = colorstr("MLflow: ")
+    SANITIZE = lambda x: {k.replace("(", "").replace(")", ""): float(v) for k, v in x.items()}
 
 except (ImportError, AssertionError):
     mlflow = None
 
 
 def on_pretrain_routine_end(trainer):
     """
@@ -52,56 +54,80 @@
     Global:
         mlflow: The imported mlflow module to use for logging.
 
     Environment Variables:
         MLFLOW_TRACKING_URI: The URI for MLflow tracking. If not set, defaults to 'runs/mlflow'.
         MLFLOW_EXPERIMENT_NAME: The name of the MLflow experiment. If not set, defaults to trainer.args.project.
         MLFLOW_RUN: The name of the MLflow run. If not set, defaults to trainer.args.name.
+        MLFLOW_KEEP_RUN_ACTIVE: Boolean indicating whether to keep the MLflow run active after the end of training.
     """
     global mlflow
 
-    uri = os.environ.get('MLFLOW_TRACKING_URI') or str(RUNS_DIR / 'mlflow')
-    LOGGER.debug(f'{PREFIX} tracking uri: {uri}')
+    uri = os.environ.get("MLFLOW_TRACKING_URI") or str(RUNS_DIR / "mlflow")
+    LOGGER.debug(f"{PREFIX} tracking uri: {uri}")
     mlflow.set_tracking_uri(uri)
 
     # Set experiment and run names
-    experiment_name = os.environ.get('MLFLOW_EXPERIMENT_NAME') or trainer.args.project or '/Shared/YOLOv8'
-    run_name = os.environ.get('MLFLOW_RUN') or trainer.args.name
+    experiment_name = os.environ.get("MLFLOW_EXPERIMENT_NAME") or trainer.args.project or "/Shared/YOLOv8"
+    run_name = os.environ.get("MLFLOW_RUN") or trainer.args.name
     mlflow.set_experiment(experiment_name)
 
     mlflow.autolog()
     try:
         active_run = mlflow.active_run() or mlflow.start_run(run_name=run_name)
-        LOGGER.info(f'{PREFIX}logging run_id({active_run.info.run_id}) to {uri}')
+        LOGGER.info(f"{PREFIX}logging run_id({active_run.info.run_id}) to {uri}")
         if Path(uri).is_dir():
             LOGGER.info(f"{PREFIX}view at http://127.0.0.1:5000 with 'mlflow server --backend-store-uri {uri}'")
         LOGGER.info(f"{PREFIX}disable with 'yolo settings mlflow=False'")
         mlflow.log_params(dict(trainer.args))
     except Exception as e:
-        LOGGER.warning(f'{PREFIX}WARNING  Failed to initialize: {e}\n'
-                       f'{PREFIX}WARNING  Not tracking this run')
+        LOGGER.warning(f"{PREFIX}WARNING  Failed to initialize: {e}\n" f"{PREFIX}WARNING  Not tracking this run")
+
+
+def on_train_epoch_end(trainer):
+    """Log training metrics at the end of each train epoch to MLflow."""
+    if mlflow:
+        mlflow.log_metrics(
+            metrics={
+                **SANITIZE(trainer.lr),
+                **SANITIZE(trainer.label_loss_items(trainer.tloss, prefix="train")),
+            },
+            step=trainer.epoch,
+        )
 
 
 def on_fit_epoch_end(trainer):
     """Log training metrics at the end of each fit epoch to MLflow."""
     if mlflow:
-        sanitized_metrics = {k.replace('(', '').replace(')', ''): float(v) for k, v in trainer.metrics.items()}
-        mlflow.log_metrics(metrics=sanitized_metrics, step=trainer.epoch)
+        mlflow.log_metrics(metrics=SANITIZE(trainer.metrics), step=trainer.epoch)
 
 
 def on_train_end(trainer):
     """Log model artifacts at the end of the training."""
     if mlflow:
         mlflow.log_artifact(str(trainer.best.parent))  # log save_dir/weights directory with best.pt and last.pt
-        for f in trainer.save_dir.glob('*'):  # log all other files in save_dir
-            if f.suffix in {'.png', '.jpg', '.csv', '.pt', '.yaml'}:
+        for f in trainer.save_dir.glob("*"):  # log all other files in save_dir
+            if f.suffix in {".png", ".jpg", ".csv", ".pt", ".yaml"}:
                 mlflow.log_artifact(str(f))
-
-        mlflow.end_run()
-        LOGGER.info(f'{PREFIX}results logged to {mlflow.get_tracking_uri()}\n'
-                    f"{PREFIX}disable with 'yolo settings mlflow=False'")
-
-
-callbacks = {
-    'on_pretrain_routine_end': on_pretrain_routine_end,
-    'on_fit_epoch_end': on_fit_epoch_end,
-    'on_train_end': on_train_end} if mlflow else {}
+        keep_run_active = os.environ.get("MLFLOW_KEEP_RUN_ACTIVE", "False").lower() == "true"
+        if keep_run_active:
+            LOGGER.info(f"{PREFIX}mlflow run still alive, remember to close it using mlflow.end_run()")
+        else:
+            mlflow.end_run()
+            LOGGER.debug(f"{PREFIX}mlflow run ended")
+
+        LOGGER.info(
+            f"{PREFIX}results logged to {mlflow.get_tracking_uri()}\n"
+            f"{PREFIX}disable with 'yolo settings mlflow=False'"
+        )
+
+
+callbacks = (
+    {
+        "on_pretrain_routine_end": on_pretrain_routine_end,
+        "on_train_epoch_end": on_train_epoch_end,
+        "on_fit_epoch_end": on_fit_epoch_end,
+        "on_train_end": on_train_end,
+    }
+    if mlflow
+    else {}
+)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/neptune.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/neptune.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 from ultralytics.utils import LOGGER, SETTINGS, TESTS_RUNNING
 
 try:
     assert not TESTS_RUNNING  # do not log pytest
-    assert SETTINGS['neptune'] is True  # verify integration is enabled
+    assert SETTINGS["neptune"] is True  # verify integration is enabled
     import neptune
     from neptune.types import File
 
-    assert hasattr(neptune, '__version__')
+    assert hasattr(neptune, "__version__")
 
     run = None  # NeptuneAI experiment logger instance
 
 except (ImportError, AssertionError):
     neptune = None
 
 
 def _log_scalars(scalars, step=0):
     """Log scalars to the NeptuneAI experiment logger."""
     if run:
         for k, v in scalars.items():
             run[k].append(value=v, step=step)
 
 
-def _log_images(imgs_dict, group=''):
+def _log_images(imgs_dict, group=""):
     """Log scalars to the NeptuneAI experiment logger."""
     if run:
         for k, v in imgs_dict.items():
-            run[f'{group}/{k}'].upload(File(v))
+            run[f"{group}/{k}"].upload(File(v))
 
 
 def _log_plot(title, plot_path):
     """
     Log plots to the NeptuneAI experiment logger.
 
     Args:
@@ -39,66 +39,74 @@
         plot_path (PosixPath | str): Path to the saved image file.
     """
     import matplotlib.image as mpimg
     import matplotlib.pyplot as plt
 
     img = mpimg.imread(plot_path)
     fig = plt.figure()
-    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect='auto', xticks=[], yticks=[])  # no ticks
+    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect="auto", xticks=[], yticks=[])  # no ticks
     ax.imshow(img)
-    run[f'Plots/{title}'].upload(fig)
+    run[f"Plots/{title}"].upload(fig)
 
 
 def on_pretrain_routine_start(trainer):
     """Callback function called before the training routine starts."""
     try:
         global run
-        run = neptune.init_run(project=trainer.args.project or 'YOLOv8', name=trainer.args.name, tags=['YOLOv8'])
-        run['Configuration/Hyperparameters'] = {k: '' if v is None else v for k, v in vars(trainer.args).items()}
+        run = neptune.init_run(project=trainer.args.project or "YOLOv8", name=trainer.args.name, tags=["YOLOv8"])
+        run["Configuration/Hyperparameters"] = {k: "" if v is None else v for k, v in vars(trainer.args).items()}
     except Exception as e:
-        LOGGER.warning(f'WARNING  NeptuneAI installed but not initialized correctly, not logging this run. {e}')
+        LOGGER.warning(f"WARNING  NeptuneAI installed but not initialized correctly, not logging this run. {e}")
 
 
 def on_train_epoch_end(trainer):
     """Callback function called at end of each training epoch."""
-    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix='train'), trainer.epoch + 1)
+    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix="train"), trainer.epoch + 1)
     _log_scalars(trainer.lr, trainer.epoch + 1)
     if trainer.epoch == 1:
-        _log_images({f.stem: str(f) for f in trainer.save_dir.glob('train_batch*.jpg')}, 'Mosaic')
+        _log_images({f.stem: str(f) for f in trainer.save_dir.glob("train_batch*.jpg")}, "Mosaic")
 
 
 def on_fit_epoch_end(trainer):
     """Callback function called at end of each fit (train+val) epoch."""
     if run and trainer.epoch == 0:
         from ultralytics.utils.torch_utils import model_info_for_loggers
-        run['Configuration/Model'] = model_info_for_loggers(trainer)
+
+        run["Configuration/Model"] = model_info_for_loggers(trainer)
     _log_scalars(trainer.metrics, trainer.epoch + 1)
 
 
 def on_val_end(validator):
     """Callback function called at end of each validation."""
     if run:
         # Log val_labels and val_pred
-        _log_images({f.stem: str(f) for f in validator.save_dir.glob('val*.jpg')}, 'Validation')
+        _log_images({f.stem: str(f) for f in validator.save_dir.glob("val*.jpg")}, "Validation")
 
 
 def on_train_end(trainer):
     """Callback function called at end of training."""
     if run:
         # Log final results, CM matrix + PR plots
         files = [
-            'results.png', 'confusion_matrix.png', 'confusion_matrix_normalized.png',
-            *(f'{x}_curve.png' for x in ('F1', 'PR', 'P', 'R'))]
+            "results.png",
+            "confusion_matrix.png",
+            "confusion_matrix_normalized.png",
+            *(f"{x}_curve.png" for x in ("F1", "PR", "P", "R")),
+        ]
         files = [(trainer.save_dir / f) for f in files if (trainer.save_dir / f).exists()]  # filter
         for f in files:
             _log_plot(title=f.stem, plot_path=f)
         # Log the final model
-        run[f'weights/{trainer.args.name or trainer.args.task}/{str(trainer.best.name)}'].upload(File(str(
-            trainer.best)))
+        run[f"weights/{trainer.args.name or trainer.args.task}/{trainer.best.name}"].upload(File(str(trainer.best)))
 
 
-callbacks = {
-    'on_pretrain_routine_start': on_pretrain_routine_start,
-    'on_train_epoch_end': on_train_epoch_end,
-    'on_fit_epoch_end': on_fit_epoch_end,
-    'on_val_end': on_val_end,
-    'on_train_end': on_train_end} if neptune else {}
+callbacks = (
+    {
+        "on_pretrain_routine_start": on_pretrain_routine_start,
+        "on_train_epoch_end": on_train_epoch_end,
+        "on_fit_epoch_end": on_fit_epoch_end,
+        "on_val_end": on_val_end,
+        "on_train_end": on_train_end,
+    }
+    if neptune
+    else {}
+)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/raytune.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/raytune.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,24 +1,29 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 from ultralytics.utils import SETTINGS
 
 try:
-    assert SETTINGS['raytune'] is True  # verify integration is enabled
+    assert SETTINGS["raytune"] is True  # verify integration is enabled
     import ray
     from ray import tune
     from ray.air import session
 
 except (ImportError, AssertionError):
     tune = None
 
 
 def on_fit_epoch_end(trainer):
     """Sends training metrics to Ray Tune at end of each epoch."""
-    if ray.tune.is_session_enabled():
+    if ray.train._internal.session._get_session():  # replacement for deprecated ray.tune.is_session_enabled()
         metrics = trainer.metrics
-        metrics['epoch'] = trainer.epoch
+        metrics["epoch"] = trainer.epoch
         session.report(metrics)
 
 
-callbacks = {
-    'on_fit_epoch_end': on_fit_epoch_end, } if tune else {}
+callbacks = (
+    {
+        "on_fit_epoch_end": on_fit_epoch_end,
+    }
+    if tune
+    else {}
+)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/tensorboard.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/tensorboard.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,75 +1,107 @@
 # Ultralytics YOLO , AGPL-3.0 license
+import contextlib
 
 from ultralytics.utils import LOGGER, SETTINGS, TESTS_RUNNING, colorstr
 
 try:
-    # WARNING: do not move import due to protobuf issue in https://github.com/ultralytics/ultralytics/pull/4674
+    # WARNING: do not move SummaryWriter import due to protobuf bug https://github.com/ultralytics/ultralytics/pull/4674
     from torch.utils.tensorboard import SummaryWriter
 
     assert not TESTS_RUNNING  # do not log pytest
-    assert SETTINGS['tensorboard'] is True  # verify integration is enabled
+    assert SETTINGS["tensorboard"] is True  # verify integration is enabled
     WRITER = None  # TensorBoard SummaryWriter instance
+    PREFIX = colorstr("TensorBoard: ")
 
-except (ImportError, AssertionError, TypeError):
+    # Imports below only required if TensorBoard enabled
+    import warnings
+    from copy import deepcopy
+
+    from ultralytics.utils.torch_utils import de_parallel, torch
+
+except (ImportError, AssertionError, TypeError, AttributeError):
     # TypeError for handling 'Descriptors cannot not be created directly.' protobuf errors in Windows
+    # AttributeError: module 'tensorflow' has no attribute 'io' if 'tensorflow' not installed
     SummaryWriter = None
 
 
 def _log_scalars(scalars, step=0):
     """Logs scalar values to TensorBoard."""
     if WRITER:
         for k, v in scalars.items():
             WRITER.add_scalar(k, v, step)
 
 
 def _log_tensorboard_graph(trainer):
     """Log model graph to TensorBoard."""
-    try:
-        import warnings
-
-        from ultralytics.utils.torch_utils import de_parallel, torch
 
-        imgsz = trainer.args.imgsz
-        imgsz = (imgsz, imgsz) if isinstance(imgsz, int) else imgsz
-        p = next(trainer.model.parameters())  # for device, type
-        im = torch.zeros((1, 3, *imgsz), device=p.device, dtype=p.dtype)  # input image (must be zeros, not empty)
-        with warnings.catch_warnings():
-            warnings.simplefilter('ignore', category=UserWarning)  # suppress jit trace warning
+    # Input image
+    imgsz = trainer.args.imgsz
+    imgsz = (imgsz, imgsz) if isinstance(imgsz, int) else imgsz
+    p = next(trainer.model.parameters())  # for device, type
+    im = torch.zeros((1, 3, *imgsz), device=p.device, dtype=p.dtype)  # input image (must be zeros, not empty)
+
+    with warnings.catch_warnings():
+        warnings.simplefilter("ignore", category=UserWarning)  # suppress jit trace warning
+        warnings.simplefilter("ignore", category=torch.jit.TracerWarning)  # suppress jit trace warning
+
+        # Try simple method first (YOLO)
+        with contextlib.suppress(Exception):
+            trainer.model.eval()  # place in .eval() mode to avoid BatchNorm statistics changes
             WRITER.add_graph(torch.jit.trace(de_parallel(trainer.model), im, strict=False), [])
-    except Exception as e:
-        LOGGER.warning(f'WARNING  TensorBoard graph visualization failure {e}')
+            LOGGER.info(f"{PREFIX}model graph visualization added ")
+            return
+
+        # Fallback to TorchScript export steps (RTDETR)
+        try:
+            model = deepcopy(de_parallel(trainer.model))
+            model.eval()
+            model = model.fuse(verbose=False)
+            for m in model.modules():
+                if hasattr(m, "export"):  # Detect, RTDETRDecoder (Segment and Pose use Detect base class)
+                    m.export = True
+                    m.format = "torchscript"
+            model(im)  # dry run
+            WRITER.add_graph(torch.jit.trace(model, im, strict=False), [])
+            LOGGER.info(f"{PREFIX}model graph visualization added ")
+        except Exception as e:
+            LOGGER.warning(f"{PREFIX}WARNING  TensorBoard graph visualization failure {e}")
 
 
 def on_pretrain_routine_start(trainer):
     """Initialize TensorBoard logging with SummaryWriter."""
     if SummaryWriter:
         try:
             global WRITER
             WRITER = SummaryWriter(str(trainer.save_dir))
-            prefix = colorstr('TensorBoard: ')
-            LOGGER.info(f"{prefix}Start with 'tensorboard --logdir {trainer.save_dir}', view at http://localhost:6006/")
+            LOGGER.info(f"{PREFIX}Start with 'tensorboard --logdir {trainer.save_dir}', view at http://localhost:6006/")
         except Exception as e:
-            LOGGER.warning(f'WARNING  TensorBoard not initialized correctly, not logging this run. {e}')
+            LOGGER.warning(f"{PREFIX}WARNING  TensorBoard not initialized correctly, not logging this run. {e}")
 
 
 def on_train_start(trainer):
     """Log TensorBoard graph."""
     if WRITER:
         _log_tensorboard_graph(trainer)
 
 
-def on_batch_end(trainer):
-    """Logs scalar statistics at the end of a training batch."""
-    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix='train'), trainer.epoch + 1)
+def on_train_epoch_end(trainer):
+    """Logs scalar statistics at the end of a training epoch."""
+    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix="train"), trainer.epoch + 1)
+    _log_scalars(trainer.lr, trainer.epoch + 1)
 
 
 def on_fit_epoch_end(trainer):
     """Logs epoch metrics at end of training epoch."""
     _log_scalars(trainer.metrics, trainer.epoch + 1)
 
 
-callbacks = {
-    'on_pretrain_routine_start': on_pretrain_routine_start,
-    'on_train_start': on_train_start,
-    'on_fit_epoch_end': on_fit_epoch_end,
-    'on_batch_end': on_batch_end} if SummaryWriter else {}
+callbacks = (
+    {
+        "on_pretrain_routine_start": on_pretrain_routine_start,
+        "on_train_start": on_train_start,
+        "on_fit_epoch_end": on_fit_epoch_end,
+        "on_train_epoch_end": on_train_epoch_end,
+    }
+    if SummaryWriter
+    else {}
+)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/callbacks/wb.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/callbacks/wb.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,156 +1,163 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 from ultralytics.utils import SETTINGS, TESTS_RUNNING
 from ultralytics.utils.torch_utils import model_info_for_loggers
 
 try:
     assert not TESTS_RUNNING  # do not log pytest
-    assert SETTINGS['wandb'] is True  # verify integration is enabled
+    assert SETTINGS["wandb"] is True  # verify integration is enabled
     import wandb as wb
 
-    assert hasattr(wb, '__version__')  # verify package is not directory
-
-    import numpy as np
-    import pandas as pd
-
+    assert hasattr(wb, "__version__")  # verify package is not directory
     _processed_plots = {}
 
 except (ImportError, AssertionError):
     wb = None
 
 
-def _custom_table(x, y, classes, title='Precision Recall Curve', x_title='Recall', y_title='Precision'):
+def _custom_table(x, y, classes, title="Precision Recall Curve", x_title="Recall", y_title="Precision"):
     """
     Create and log a custom metric visualization to wandb.plot.pr_curve.
 
-    This function crafts a custom metric visualization that mimics the behavior of wandb's default precision-recall curve
-    while allowing for enhanced customization. The visual metric is useful for monitoring model performance across different classes.
+    This function crafts a custom metric visualization that mimics the behavior of wandb's default precision-recall
+    curve while allowing for enhanced customization. The visual metric is useful for monitoring model performance across
+    different classes.
 
     Args:
         x (List): Values for the x-axis; expected to have length N.
         y (List): Corresponding values for the y-axis; also expected to have length N.
         classes (List): Labels identifying the class of each point; length N.
         title (str, optional): Title for the plot; defaults to 'Precision Recall Curve'.
         x_title (str, optional): Label for the x-axis; defaults to 'Recall'.
         y_title (str, optional): Label for the y-axis; defaults to 'Precision'.
 
     Returns:
         (wandb.Object): A wandb object suitable for logging, showcasing the crafted metric visualization.
     """
-    df = pd.DataFrame({'class': classes, 'y': y, 'x': x}).round(3)
-    fields = {'x': 'x', 'y': 'y', 'class': 'class'}
-    string_fields = {'title': title, 'x-axis-title': x_title, 'y-axis-title': y_title}
-    return wb.plot_table('wandb/area-under-curve/v0',
-                         wb.Table(dataframe=df),
-                         fields=fields,
-                         string_fields=string_fields)
-
-
-def _plot_curve(x,
-                y,
-                names=None,
-                id='precision-recall',
-                title='Precision Recall Curve',
-                x_title='Recall',
-                y_title='Precision',
-                num_x=100,
-                only_mean=False):
+    import pandas  # scope for faster 'import ultralytics'
+
+    df = pandas.DataFrame({"class": classes, "y": y, "x": x}).round(3)
+    fields = {"x": "x", "y": "y", "class": "class"}
+    string_fields = {"title": title, "x-axis-title": x_title, "y-axis-title": y_title}
+    return wb.plot_table(
+        "wandb/area-under-curve/v0", wb.Table(dataframe=df), fields=fields, string_fields=string_fields
+    )
+
+
+def _plot_curve(
+    x,
+    y,
+    names=None,
+    id="precision-recall",
+    title="Precision Recall Curve",
+    x_title="Recall",
+    y_title="Precision",
+    num_x=100,
+    only_mean=False,
+):
     """
     Log a metric curve visualization.
 
     This function generates a metric curve based on input data and logs the visualization to wandb.
     The curve can represent aggregated data (mean) or individual class data, depending on the 'only_mean' flag.
 
     Args:
         x (np.ndarray): Data points for the x-axis with length N.
-        y (np.ndarray): Corresponding data points for the y-axis with shape CxN, where C represents the number of classes.
-        names (list, optional): Names of the classes corresponding to the y-axis data; length C. Defaults to an empty list.
+        y (np.ndarray): Corresponding data points for the y-axis with shape CxN, where C is the number of classes.
+        names (list, optional): Names of the classes corresponding to the y-axis data; length C. Defaults to [].
         id (str, optional): Unique identifier for the logged data in wandb. Defaults to 'precision-recall'.
         title (str, optional): Title for the visualization plot. Defaults to 'Precision Recall Curve'.
         x_title (str, optional): Label for the x-axis. Defaults to 'Recall'.
         y_title (str, optional): Label for the y-axis. Defaults to 'Precision'.
         num_x (int, optional): Number of interpolated data points for visualization. Defaults to 100.
         only_mean (bool, optional): Flag to indicate if only the mean curve should be plotted. Defaults to True.
 
     Note:
         The function leverages the '_custom_table' function to generate the actual visualization.
     """
+    import numpy as np
+
     # Create new x
     if names is None:
         names = []
     x_new = np.linspace(x[0], x[-1], num_x).round(5)
 
     # Create arrays for logging
     x_log = x_new.tolist()
     y_log = np.interp(x_new, x, np.mean(y, axis=0)).round(3).tolist()
 
     if only_mean:
         table = wb.Table(data=list(zip(x_log, y_log)), columns=[x_title, y_title])
         wb.run.log({title: wb.plot.line(table, x_title, y_title, title=title)})
     else:
-        classes = ['mean'] * len(x_log)
+        classes = ["mean"] * len(x_log)
         for i, yi in enumerate(y):
             x_log.extend(x_new)  # add new x
             y_log.extend(np.interp(x_new, x, yi))  # interpolate y to new x
             classes.extend([names[i]] * len(x_new))  # add class names
         wb.log({id: _custom_table(x_log, y_log, classes, title, x_title, y_title)}, commit=False)
 
 
 def _log_plots(plots, step):
     """Logs plots from the input dictionary if they haven't been logged already at the specified step."""
     for name, params in plots.items():
-        timestamp = params['timestamp']
+        timestamp = params["timestamp"]
         if _processed_plots.get(name) != timestamp:
             wb.run.log({name.stem: wb.Image(str(name))}, step=step)
             _processed_plots[name] = timestamp
 
 
 def on_pretrain_routine_start(trainer):
     """Initiate and start project if module is present."""
-    wb.run or wb.init(project=trainer.args.project or 'YOLOv8', name=trainer.args.name, config=vars(trainer.args))
+    wb.run or wb.init(project=trainer.args.project or "YOLOv8", name=trainer.args.name, config=vars(trainer.args))
 
 
 def on_fit_epoch_end(trainer):
     """Logs training metrics and model information at the end of an epoch."""
     wb.run.log(trainer.metrics, step=trainer.epoch + 1)
     _log_plots(trainer.plots, step=trainer.epoch + 1)
     _log_plots(trainer.validator.plots, step=trainer.epoch + 1)
     if trainer.epoch == 0:
         wb.run.log(model_info_for_loggers(trainer), step=trainer.epoch + 1)
 
 
 def on_train_epoch_end(trainer):
     """Log metrics and save images at the end of each training epoch."""
-    wb.run.log(trainer.label_loss_items(trainer.tloss, prefix='train'), step=trainer.epoch + 1)
+    wb.run.log(trainer.label_loss_items(trainer.tloss, prefix="train"), step=trainer.epoch + 1)
     wb.run.log(trainer.lr, step=trainer.epoch + 1)
     if trainer.epoch == 1:
         _log_plots(trainer.plots, step=trainer.epoch + 1)
 
 
 def on_train_end(trainer):
     """Save the best model as an artifact at end of training."""
     _log_plots(trainer.validator.plots, step=trainer.epoch + 1)
     _log_plots(trainer.plots, step=trainer.epoch + 1)
-    art = wb.Artifact(type='model', name=f'run_{wb.run.id}_model')
+    art = wb.Artifact(type="model", name=f"run_{wb.run.id}_model")
     if trainer.best.exists():
         art.add_file(trainer.best)
-        wb.run.log_artifact(art, aliases=['best'])
+        wb.run.log_artifact(art, aliases=["best"])
     for curve_name, curve_values in zip(trainer.validator.metrics.curves, trainer.validator.metrics.curves_results):
         x, y, x_title, y_title = curve_values
         _plot_curve(
             x,
             y,
             names=list(trainer.validator.metrics.names.values()),
-            id=f'curves/{curve_name}',
+            id=f"curves/{curve_name}",
             title=curve_name,
             x_title=x_title,
             y_title=y_title,
         )
     wb.run.finish()  # required or run continues on dashboard
 
 
-callbacks = {
-    'on_pretrain_routine_start': on_pretrain_routine_start,
-    'on_train_epoch_end': on_train_epoch_end,
-    'on_fit_epoch_end': on_fit_epoch_end,
-    'on_train_end': on_train_end} if wb else {}
+callbacks = (
+    {
+        "on_pretrain_routine_start": on_pretrain_routine_start,
+        "on_train_epoch_end": on_train_epoch_end,
+        "on_fit_epoch_end": on_fit_epoch_end,
+        "on_train_end": on_train_end,
+    }
+    if wb
+    else {}
+)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/checks.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/checks.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,32 +5,53 @@
 import inspect
 import math
 import os
 import platform
 import re
 import shutil
 import subprocess
-import sys
 import time
 from importlib import metadata
 from pathlib import Path
 from typing import Optional
 
 import cv2
 import numpy as np
 import requests
 import torch
-from matplotlib import font_manager
 
-from ultralytics.utils import (ASSETS, AUTOINSTALL, LINUX, LOGGER, ONLINE, ROOT, USER_CONFIG_DIR, SimpleNamespace,
-                               ThreadingLocked, TryExcept, clean_url, colorstr, downloads, emojis, is_colab, is_docker,
-                               is_github_action_running, is_jupyter, is_kaggle, is_online, is_pip_package, url2file)
+from ultralytics.utils import (
+    ASSETS,
+    AUTOINSTALL,
+    IS_COLAB,
+    IS_DOCKER,
+    IS_JUPYTER,
+    IS_KAGGLE,
+    IS_PIP_PACKAGE,
+    LINUX,
+    LOGGER,
+    ONLINE,
+    PYTHON_VERSION,
+    ROOT,
+    TORCHVISION_VERSION,
+    USER_CONFIG_DIR,
+    Retry,
+    SimpleNamespace,
+    ThreadingLocked,
+    TryExcept,
+    clean_url,
+    colorstr,
+    downloads,
+    emojis,
+    is_github_action_running,
+    url2file,
+)
 
 
-def parse_requirements(file_path=ROOT.parent / 'requirements.txt', package=''):
+def parse_requirements(file_path=ROOT.parent / "requirements.txt", package=""):
     """
     Parse a requirements.txt file, ignoring lines that start with '#' and any text after '#'.
 
     Args:
         file_path (Path): Path to the requirements.txt file.
         package (str, optional): Python package to use instead of requirements.txt file, i.e. package='ultralytics'.
 
@@ -42,57 +63,57 @@
         from ultralytics.utils.checks import parse_requirements
 
         parse_requirements(package='ultralytics')
         ```
     """
 
     if package:
-        requires = [x for x in metadata.distribution(package).requires if 'extra == ' not in x]
+        requires = [x for x in metadata.distribution(package).requires if "extra == " not in x]
     else:
         requires = Path(file_path).read_text().splitlines()
 
     requirements = []
     for line in requires:
         line = line.strip()
-        if line and not line.startswith('#'):
-            line = line.split('#')[0].strip()  # ignore inline comments
-            match = re.match(r'([a-zA-Z0-9-_]+)\s*([<>!=~]+.*)?', line)
+        if line and not line.startswith("#"):
+            line = line.split("#")[0].strip()  # ignore inline comments
+            match = re.match(r"([a-zA-Z0-9-_]+)\s*([<>!=~]+.*)?", line)
             if match:
-                requirements.append(SimpleNamespace(name=match[1], specifier=match[2].strip() if match[2] else ''))
+                requirements.append(SimpleNamespace(name=match[1], specifier=match[2].strip() if match[2] else ""))
 
     return requirements
 
 
-def parse_version(version='0.0.0') -> tuple:
+def parse_version(version="0.0.0") -> tuple:
     """
     Convert a version string to a tuple of integers, ignoring any extra non-numeric string attached to the version. This
     function replaces deprecated 'pkg_resources.parse_version(v)'.
 
     Args:
         version (str): Version string, i.e. '2.0.1+cpu'
 
     Returns:
         (tuple): Tuple of integers representing the numeric part of the version and the extra string, i.e. (2, 0, 1)
     """
     try:
-        return tuple(map(int, re.findall(r'\d+', version)[:3]))  # '2.0.1+cpu' -> (2, 0, 1)
+        return tuple(map(int, re.findall(r"\d+", version)[:3]))  # '2.0.1+cpu' -> (2, 0, 1)
     except Exception as e:
-        LOGGER.warning(f'WARNING  failure for parse_version({version}), returning (0, 0, 0): {e}')
+        LOGGER.warning(f"WARNING  failure for parse_version({version}), returning (0, 0, 0): {e}")
         return 0, 0, 0
 
 
 def is_ascii(s) -> bool:
     """
     Check if a string is composed of only ASCII characters.
 
     Args:
         s (str): String to be checked.
 
     Returns:
-        bool: True if the string is composed only of ASCII characters, False otherwise.
+        (bool): True if the string is composed only of ASCII characters, False otherwise.
     """
     # Convert list, tuple, None, etc. to string
     s = str(s)
 
     # Check if the string is composed of only ASCII characters
     return all(ord(c) < 128 for c in s)
 
@@ -116,45 +137,53 @@
     stride = int(stride.max() if isinstance(stride, torch.Tensor) else stride)
 
     # Convert image size to list if it is an integer
     if isinstance(imgsz, int):
         imgsz = [imgsz]
     elif isinstance(imgsz, (list, tuple)):
         imgsz = list(imgsz)
+    elif isinstance(imgsz, str):  # i.e. '640' or '[640,640]'
+        imgsz = [int(imgsz)] if imgsz.isnumeric() else eval(imgsz)
     else:
-        raise TypeError(f"'imgsz={imgsz}' is of invalid type {type(imgsz).__name__}. "
-                        f"Valid imgsz types are int i.e. 'imgsz=640' or list i.e. 'imgsz=[640,640]'")
+        raise TypeError(
+            f"'imgsz={imgsz}' is of invalid type {type(imgsz).__name__}. "
+            f"Valid imgsz types are int i.e. 'imgsz=640' or list i.e. 'imgsz=[640,640]'"
+        )
 
     # Apply max_dim
     if len(imgsz) > max_dim:
-        msg = "'train' and 'val' imgsz must be an integer, while 'predict' and 'export' imgsz may be a [h, w] list " \
-              "or an integer, i.e. 'yolo export imgsz=640,480' or 'yolo export imgsz=640'"
+        msg = (
+            "'train' and 'val' imgsz must be an integer, while 'predict' and 'export' imgsz may be a [h, w] list "
+            "or an integer, i.e. 'yolo export imgsz=640,480' or 'yolo export imgsz=640'"
+        )
         if max_dim != 1:
-            raise ValueError(f'imgsz={imgsz} is not a valid image size. {msg}')
+            raise ValueError(f"imgsz={imgsz} is not a valid image size. {msg}")
         LOGGER.warning(f"WARNING  updating to 'imgsz={max(imgsz)}'. {msg}")
         imgsz = [max(imgsz)]
     # Make image size a multiple of the stride
     sz = [max(math.ceil(x / stride) * stride, floor) for x in imgsz]
 
     # Print warning message if image size was updated
     if sz != imgsz:
-        LOGGER.warning(f'WARNING  imgsz={imgsz} must be multiple of max stride {stride}, updating to {sz}')
+        LOGGER.warning(f"WARNING  imgsz={imgsz} must be multiple of max stride {stride}, updating to {sz}")
 
     # Add missing dimensions if necessary
     sz = [sz[0], sz[0]] if min_dim == 2 and len(sz) == 1 else sz[0] if min_dim == 1 and len(sz) == 1 else sz
 
     return sz
 
 
-def check_version(current: str = '0.0.0',
-                  required: str = '0.0.0',
-                  name: str = 'version',
-                  hard: bool = False,
-                  verbose: bool = False,
-                  msg: str = '') -> bool:
+def check_version(
+    current: str = "0.0.0",
+    required: str = "0.0.0",
+    name: str = "version",
+    hard: bool = False,
+    verbose: bool = False,
+    msg: str = "",
+) -> bool:
     """
     Check current version against the required version or range.
 
     Args:
         current (str): Current version or package name to get version from.
         required (str): Required version or range (in pip-style format).
         name (str, optional): Name to be used in warning message.
@@ -177,136 +206,141 @@
         check_version(current='22.04', required='<=22.04')
 
         # Check if current version is between 20.04 (inclusive) and 22.04 (exclusive)
         check_version(current='21.10', required='>20.04,<22.04')
         ```
     """
     if not current:  # if current is '' or None
-        LOGGER.warning(f'WARNING  invalid check_version({current}, {required}) requested, please check values.')
+        LOGGER.warning(f"WARNING  invalid check_version({current}, {required}) requested, please check values.")
         return True
     elif not current[0].isdigit():  # current is package name rather than version string, i.e. current='ultralytics'
         try:
             name = current  # assigned package name to 'name' arg
             current = metadata.version(current)  # get version string from package name
-        except metadata.PackageNotFoundError:
+        except metadata.PackageNotFoundError as e:
             if hard:
-                raise ModuleNotFoundError(emojis(f'WARNING  {current} package is required but not installed'))
+                raise ModuleNotFoundError(emojis(f"WARNING  {current} package is required but not installed")) from e
             else:
                 return False
 
     if not required:  # if required is '' or None
         return True
 
+    op = ""
+    version = ""
     result = True
     c = parse_version(current)  # '1.2.3' -> (1, 2, 3)
-    for r in required.strip(',').split(','):
-        op, v = re.match(r'([^0-9]*)([\d.]+)', r).groups()  # split '>=22.04' -> ('>=', '22.04')
-        v = parse_version(v)  # '1.2.3' -> (1, 2, 3)
-        if op == '==' and c != v:
+    for r in required.strip(",").split(","):
+        op, version = re.match(r"([^0-9]*)([\d.]+)", r).groups()  # split '>=22.04' -> ('>=', '22.04')
+        v = parse_version(version)  # '1.2.3' -> (1, 2, 3)
+        if op == "==" and c != v:
             result = False
-        elif op == '!=' and c == v:
+        elif op == "!=" and c == v:
             result = False
-        elif op in ('>=', '') and not (c >= v):  # if no constraint passed assume '>=required'
+        elif op in {">=", ""} and not (c >= v):  # if no constraint passed assume '>=required'
             result = False
-        elif op == '<=' and not (c <= v):
+        elif op == "<=" and not (c <= v):
             result = False
-        elif op == '>' and not (c > v):
+        elif op == ">" and not (c > v):
             result = False
-        elif op == '<' and not (c < v):
+        elif op == "<" and not (c < v):
             result = False
     if not result:
-        warning_message = \
-            f'WARNING  {name}{op}{required} is required, but {name}=={current} is currently installed {msg}'
+        warning = f"WARNING  {name}{op}{version} is required, but {name}=={current} is currently installed {msg}"
         if hard:
-            raise ModuleNotFoundError(emojis(warning_message))  # assert version requirements met
+            raise ModuleNotFoundError(emojis(warning))  # assert version requirements met
         if verbose:
-            LOGGER.warning(warning_message)
+            LOGGER.warning(warning)
     return result
 
 
-def check_latest_pypi_version(package_name='ultralytics'):
+def check_latest_pypi_version(package_name="ultralytics"):
     """
     Returns the latest version of a PyPI package without downloading or installing it.
 
     Parameters:
         package_name (str): The name of the package to find the latest version for.
 
     Returns:
         (str): The latest version of the package.
     """
     with contextlib.suppress(Exception):
         requests.packages.urllib3.disable_warnings()  # Disable the InsecureRequestWarning
-        response = requests.get(f'https://pypi.org/pypi/{package_name}/json', timeout=3)
+        response = requests.get(f"https://pypi.org/pypi/{package_name}/json", timeout=3)
         if response.status_code == 200:
-            return response.json()['info']['version']
+            return response.json()["info"]["version"]
 
 
 def check_pip_update_available():
     """
     Checks if a new version of the ultralytics package is available on PyPI.
 
     Returns:
         (bool): True if an update is available, False otherwise.
     """
-    if ONLINE and is_pip_package():
+    if ONLINE and IS_PIP_PACKAGE:
         with contextlib.suppress(Exception):
             from ultralytics import __version__
+
             latest = check_latest_pypi_version()
-            if check_version(__version__, f'<{latest}'):  # check if current version is < latest version
-                LOGGER.info(f'New https://pypi.org/project/ultralytics/{latest} available  '
-                            f"Update with 'pip install -U ultralytics'")
+            if check_version(__version__, f"<{latest}"):  # check if current version is < latest version
+                LOGGER.info(
+                    f"New https://pypi.org/project/ultralytics/{latest} available  "
+                    f"Update with 'pip install -U ultralytics'"
+                )
                 return True
     return False
 
 
 @ThreadingLocked()
-def check_font(font='Arial.ttf'):
+def check_font(font="Arial.ttf"):
     """
     Find font locally or download to user's configuration directory if it does not already exist.
 
     Args:
         font (str): Path or name of font.
 
     Returns:
         file (Path): Resolved font file path.
     """
-    name = Path(font).name
+    from matplotlib import font_manager
 
     # Check USER_CONFIG_DIR
+    name = Path(font).name
     file = USER_CONFIG_DIR / name
     if file.exists():
         return file
 
     # Check system fonts
     matches = [s for s in font_manager.findSystemFonts() if font in s]
     if any(matches):
         return matches[0]
 
     # Download to USER_CONFIG_DIR if missing
-    url = f'https://ultralytics.com/assets/{name}'
-    if downloads.is_url(url):
+    url = f"https://ultralytics.com/assets/{name}"
+    if downloads.is_url(url, check=True):
         downloads.safe_download(url=url, file=file)
         return file
 
 
-def check_python(minimum: str = '3.8.0') -> bool:
+def check_python(minimum: str = "3.8.0") -> bool:
     """
     Check current python version against the required minimum version.
 
     Args:
         minimum (str): Required minimum version of python.
 
     Returns:
-        None
+        (bool): Whether the installed Python version meets the minimum constraints.
     """
-    return check_version(platform.python_version(), minimum, name='Python ', hard=True)
+    return check_version(PYTHON_VERSION, minimum, name="Python ", hard=True)
 
 
 @TryExcept()
-def check_requirements(requirements=ROOT.parent / 'requirements.txt', exclude=(), install=True, cmds=''):
+def check_requirements(requirements=ROOT.parent / "requirements.txt", exclude=(), install=True, cmds=""):
     """
     Check if installed dependencies meet YOLOv8 requirements and attempt to auto-update if needed.
 
     Args:
         requirements (Union[Path, str, List[str]]): Path to a requirements.txt file, a single package requirement as a
             string, or a list of package requirements as strings.
         exclude (Tuple[str]): Tuple of package names to exclude from checking.
@@ -324,49 +358,51 @@
         check_requirements('ultralytics>=8.0.0')
 
         # Check multiple packages
         check_requirements(['numpy', 'ultralytics>=8.0.0'])
         ```
     """
 
-    prefix = colorstr('red', 'bold', 'requirements:')
+    prefix = colorstr("red", "bold", "requirements:")
     check_python()  # check python version
     check_torchvision()  # check torch-torchvision compatibility
     if isinstance(requirements, Path):  # requirements.txt file
         file = requirements.resolve()
-        assert file.exists(), f'{prefix} {file} not found, check failed.'
-        requirements = [f'{x.name}{x.specifier}' for x in parse_requirements(file) if x.name not in exclude]
+        assert file.exists(), f"{prefix} {file} not found, check failed."
+        requirements = [f"{x.name}{x.specifier}" for x in parse_requirements(file) if x.name not in exclude]
     elif isinstance(requirements, str):
         requirements = [requirements]
 
     pkgs = []
     for r in requirements:
-        r_stripped = r.split('/')[-1].replace('.git', '')  # replace git+https://org/repo.git -> 'repo'
-        match = re.match(r'([a-zA-Z0-9-_]+)([<>!=~]+.*)?', r_stripped)
-        name, required = match[1], match[2].strip() if match[2] else ''
+        r_stripped = r.split("/")[-1].replace(".git", "")  # replace git+https://org/repo.git -> 'repo'
+        match = re.match(r"([a-zA-Z0-9-_]+)([<>!=~]+.*)?", r_stripped)
+        name, required = match[1], match[2].strip() if match[2] else ""
         try:
             assert check_version(metadata.version(name), required)  # exception if requirements not met
         except (AssertionError, metadata.PackageNotFoundError):
             pkgs.append(r)
 
-    s = ' '.join(f'"{x}"' for x in pkgs)  # console string
+    s = " ".join(f'"{x}"' for x in pkgs)  # console string
     if s:
         if install and AUTOINSTALL:  # check environment variable
             n = len(pkgs)  # number of packages updates
             LOGGER.info(f"{prefix} Ultralytics requirement{'s' * (n > 1)} {pkgs} not found, attempting AutoUpdate...")
             try:
                 t = time.time()
-                assert is_online(), 'AutoUpdate skipped (offline)'
-                LOGGER.info(subprocess.check_output(f'pip install --no-cache {s} {cmds}', shell=True).decode())
+                assert ONLINE, "AutoUpdate skipped (offline)"
+                with Retry(times=2, delay=1):  # run up to 2 times with 1-second retry delay
+                    LOGGER.info(subprocess.check_output(f"pip install --no-cache {s} {cmds}", shell=True).decode())
                 dt = time.time() - t
                 LOGGER.info(
                     f"{prefix} AutoUpdate success  {dt:.1f}s, installed {n} package{'s' * (n > 1)}: {pkgs}\n"
-                    f"{prefix}  {colorstr('bold', 'Restart runtime or rerun command for updates to take effect')}\n")
+                    f"{prefix}  {colorstr('bold', 'Restart runtime or rerun command for updates to take effect')}\n"
+                )
             except Exception as e:
-                LOGGER.warning(f'{prefix}  {e}')
+                LOGGER.warning(f"{prefix}  {e}")
                 return False
         else:
             return False
 
     return True
 
 
@@ -378,95 +414,99 @@
     to the provided compatibility table based on:
     https://github.com/pytorch/vision#installation.
 
     The compatibility table is a dictionary where the keys are PyTorch versions and the values are lists of compatible
     Torchvision versions.
     """
 
-    import torchvision
-
     # Compatibility table
-    compatibility_table = {'2.0': ['0.15'], '1.13': ['0.14'], '1.12': ['0.13']}
+    compatibility_table = {"2.0": ["0.15"], "1.13": ["0.14"], "1.12": ["0.13"]}
 
     # Extract only the major and minor versions
-    v_torch = '.'.join(torch.__version__.split('+')[0].split('.')[:2])
-    v_torchvision = '.'.join(torchvision.__version__.split('+')[0].split('.')[:2])
+    v_torch = ".".join(torch.__version__.split("+")[0].split(".")[:2])
+    v_torchvision = ".".join(TORCHVISION_VERSION.split("+")[0].split(".")[:2])
 
     if v_torch in compatibility_table:
         compatible_versions = compatibility_table[v_torch]
         if all(v_torchvision != v for v in compatible_versions):
-            print(f'WARNING  torchvision=={v_torchvision} is incompatible with torch=={v_torch}.\n'
-                  f"Run 'pip install torchvision=={compatible_versions[0]}' to fix torchvision or "
-                  "'pip install -U torch torchvision' to update both.\n"
-                  'For a full compatibility table see https://github.com/pytorch/vision#installation')
+            print(
+                f"WARNING  torchvision=={v_torchvision} is incompatible with torch=={v_torch}.\n"
+                f"Run 'pip install torchvision=={compatible_versions[0]}' to fix torchvision or "
+                "'pip install -U torch torchvision' to update both.\n"
+                "For a full compatibility table see https://github.com/pytorch/vision#installation"
+            )
 
 
-def check_suffix(file='yolov8n.pt', suffix='.pt', msg=''):
+def check_suffix(file="yolov8n.pt", suffix=".pt", msg=""):
     """Check file(s) for acceptable suffix."""
     if file and suffix:
         if isinstance(suffix, str):
-            suffix = (suffix, )
+            suffix = (suffix,)
         for f in file if isinstance(file, (list, tuple)) else [file]:
             s = Path(f).suffix.lower().strip()  # file suffix
             if len(s):
-                assert s in suffix, f'{msg}{f} acceptable suffix is {suffix}, not {s}'
+                assert s in suffix, f"{msg}{f} acceptable suffix is {suffix}, not {s}"
 
 
 def check_yolov5u_filename(file: str, verbose: bool = True):
     """Replace legacy YOLOv5 filenames with updated YOLOv5u filenames."""
-    if 'yolov3' in file or 'yolov5' in file:
-        if 'u.yaml' in file:
-            file = file.replace('u.yaml', '.yaml')  # i.e. yolov5nu.yaml -> yolov5n.yaml
-        elif '.pt' in file and 'u' not in file:
+    if "yolov3" in file or "yolov5" in file:
+        if "u.yaml" in file:
+            file = file.replace("u.yaml", ".yaml")  # i.e. yolov5nu.yaml -> yolov5n.yaml
+        elif ".pt" in file and "u" not in file:
             original_file = file
-            file = re.sub(r'(.*yolov5([nsmlx]))\.pt', '\\1u.pt', file)  # i.e. yolov5n.pt -> yolov5nu.pt
-            file = re.sub(r'(.*yolov5([nsmlx])6)\.pt', '\\1u.pt', file)  # i.e. yolov5n6.pt -> yolov5n6u.pt
-            file = re.sub(r'(.*yolov3(|-tiny|-spp))\.pt', '\\1u.pt', file)  # i.e. yolov3-spp.pt -> yolov3-sppu.pt
+            file = re.sub(r"(.*yolov5([nsmlx]))\.pt", "\\1u.pt", file)  # i.e. yolov5n.pt -> yolov5nu.pt
+            file = re.sub(r"(.*yolov5([nsmlx])6)\.pt", "\\1u.pt", file)  # i.e. yolov5n6.pt -> yolov5n6u.pt
+            file = re.sub(r"(.*yolov3(|-tiny|-spp))\.pt", "\\1u.pt", file)  # i.e. yolov3-spp.pt -> yolov3-sppu.pt
             if file != original_file and verbose:
                 LOGGER.info(
                     f"PRO TIP  Replace 'model={original_file}' with new 'model={file}'.\nYOLOv5 'u' models are "
-                    f'trained with https://github.com/ultralytics/ultralytics and feature improved performance vs '
-                    f'standard YOLOv5 models trained with https://github.com/ultralytics/yolov5.\n')
+                    f"trained with https://github.com/ultralytics/ultralytics and feature improved performance vs "
+                    f"standard YOLOv5 models trained with https://github.com/ultralytics/yolov5.\n"
+                )
     return file
 
 
-def check_model_file_from_stem(model='yolov8n'):
+def check_model_file_from_stem(model="yolov8n"):
     """Return a model filename from a valid model stem."""
     if model and not Path(model).suffix and Path(model).stem in downloads.GITHUB_ASSETS_STEMS:
-        return Path(model).with_suffix('.pt')  # add suffix, i.e. yolov8n -> yolov8n.pt
+        return Path(model).with_suffix(".pt")  # add suffix, i.e. yolov8n -> yolov8n.pt
     else:
         return model
 
 
-def check_file(file, suffix='', download=True, hard=True):
+def check_file(file, suffix="", download=True, hard=True):
     """Search/download file (if necessary) and return path."""
     check_suffix(file, suffix)  # optional
     file = str(file).strip()  # convert to string and strip spaces
     file = check_yolov5u_filename(file)  # yolov5n -> yolov5nu
-    if (not file or ('://' not in file and Path(file).exists()) or  # '://' check required in Windows Python<3.10
-            file.lower().startswith('grpc://')):  # file exists or gRPC Triton images
+    if (
+        not file
+        or ("://" not in file and Path(file).exists())  # '://' check required in Windows Python<3.10
+        or file.lower().startswith("grpc://")
+    ):  # file exists or gRPC Triton images
         return file
-    elif download and file.lower().startswith(('https://', 'http://', 'rtsp://', 'rtmp://', 'tcp://')):  # download
+    elif download and file.lower().startswith(("https://", "http://", "rtsp://", "rtmp://", "tcp://")):  # download
         url = file  # warning: Pathlib turns :// -> :/
         file = url2file(file)  # '%2F' to '/', split https://url.com/file.txt?auth
         if Path(file).exists():
-            LOGGER.info(f'Found {clean_url(url)} locally at {file}')  # file already exists
+            LOGGER.info(f"Found {clean_url(url)} locally at {file}")  # file already exists
         else:
             downloads.safe_download(url=url, file=file, unzip=False)
         return file
     else:  # search
-        files = glob.glob(str(ROOT / 'cfg' / '**' / file), recursive=True)  # find file
+        files = glob.glob(str(ROOT / "**" / file), recursive=True) or glob.glob(str(ROOT.parent / file))  # find file
         if not files and hard:
             raise FileNotFoundError(f"'{file}' does not exist")
         elif len(files) > 1 and hard:
             raise FileNotFoundError(f"Multiple files match '{file}', specify exact path: {files}")
         return files[0] if len(files) else []  # return file
 
 
-def check_yaml(file, suffix=('.yaml', '.yml'), hard=True):
+def check_yaml(file, suffix=(".yaml", ".yml"), hard=True):
     """Search/download YAML file (if necessary) and return path, checking suffix."""
     return check_file(file, suffix, hard=hard)
 
 
 def check_is_path_safe(basedir, path):
     """
     Check if the resolved path is under the intended directory to prevent path traversal.
@@ -477,95 +517,100 @@
 
     Returns:
         (bool): True if the path is safe, False otherwise.
     """
     base_dir_resolved = Path(basedir).resolve()
     path_resolved = Path(path).resolve()
 
-    return path_resolved.is_file() and path_resolved.parts[:len(base_dir_resolved.parts)] == base_dir_resolved.parts
+    return path_resolved.is_file() and path_resolved.parts[: len(base_dir_resolved.parts)] == base_dir_resolved.parts
 
 
 def check_imshow(warn=False):
     """Check if environment supports image displays."""
     try:
         if LINUX:
-            assert 'DISPLAY' in os.environ and not is_docker() and not is_colab() and not is_kaggle()
-        cv2.imshow('test', np.zeros((8, 8, 3), dtype=np.uint8))  # show a small 8-pixel image
+            assert "DISPLAY" in os.environ and not IS_DOCKER and not IS_COLAB and not IS_KAGGLE
+        cv2.imshow("test", np.zeros((8, 8, 3), dtype=np.uint8))  # show a small 8-pixel image
         cv2.waitKey(1)
         cv2.destroyAllWindows()
         cv2.waitKey(1)
         return True
     except Exception as e:
         if warn:
-            LOGGER.warning(f'WARNING  Environment does not support cv2.imshow() or PIL Image.show()\n{e}')
+            LOGGER.warning(f"WARNING  Environment does not support cv2.imshow() or PIL Image.show()\n{e}")
         return False
 
 
-def check_yolo(verbose=True, device=''):
+def check_yolo(verbose=True, device=""):
     """Return a human-readable YOLO software and hardware summary."""
     import psutil
 
     from ultralytics.utils.torch_utils import select_device
 
-    if is_jupyter():
-        if check_requirements('wandb', install=False):
-            os.system('pip uninstall -y wandb')  # uninstall wandb: unwanted account creation prompt with infinite hang
-        if is_colab():
-            shutil.rmtree('sample_data', ignore_errors=True)  # remove colab /sample_data directory
+    if IS_JUPYTER:
+        if check_requirements("wandb", install=False):
+            os.system("pip uninstall -y wandb")  # uninstall wandb: unwanted account creation prompt with infinite hang
+        if IS_COLAB:
+            shutil.rmtree("sample_data", ignore_errors=True)  # remove colab /sample_data directory
 
     if verbose:
         # System info
         gib = 1 << 30  # bytes per GiB
         ram = psutil.virtual_memory().total
-        total, used, free = shutil.disk_usage('/')
-        s = f'({os.cpu_count()} CPUs, {ram / gib:.1f} GB RAM, {(total - free) / gib:.1f}/{total / gib:.1f} GB disk)'
+        total, used, free = shutil.disk_usage("/")
+        s = f"({os.cpu_count()} CPUs, {ram / gib:.1f} GB RAM, {(total - free) / gib:.1f}/{total / gib:.1f} GB disk)"
         with contextlib.suppress(Exception):  # clear display if ipython is installed
             from IPython import display
+
             display.clear_output()
     else:
-        s = ''
+        s = ""
 
     select_device(device=device, newline=False)
-    LOGGER.info(f'Setup complete  {s}')
+    LOGGER.info(f"Setup complete  {s}")
 
 
 def collect_system_info():
     """Collect and print relevant system information including OS, Python, RAM, CPU, and CUDA."""
 
     import psutil
 
-    from ultralytics.utils import ENVIRONMENT, is_git_dir
+    from ultralytics.utils import ENVIRONMENT, IS_GIT_DIR
     from ultralytics.utils.torch_utils import get_cpu_info
 
-    ram_info = psutil.virtual_memory().total / (1024 ** 3)  # Convert bytes to GB
+    ram_info = psutil.virtual_memory().total / (1024**3)  # Convert bytes to GB
     check_yolo()
-    LOGGER.info(f"\n{'OS':<20}{platform.platform()}\n"
-                f"{'Environment':<20}{ENVIRONMENT}\n"
-                f"{'Python':<20}{sys.version.split()[0]}\n"
-                f"{'Install':<20}{'git' if is_git_dir() else 'pip' if is_pip_package() else 'other'}\n"
-                f"{'RAM':<20}{ram_info:.2f} GB\n"
-                f"{'CPU':<20}{get_cpu_info()}\n"
-                f"{'CUDA':<20}{torch.version.cuda if torch and torch.cuda.is_available() else None}\n")
+    LOGGER.info(
+        f"\n{'OS':<20}{platform.platform()}\n"
+        f"{'Environment':<20}{ENVIRONMENT}\n"
+        f"{'Python':<20}{PYTHON_VERSION}\n"
+        f"{'Install':<20}{'git' if IS_GIT_DIR else 'pip' if IS_PIP_PACKAGE else 'other'}\n"
+        f"{'RAM':<20}{ram_info:.2f} GB\n"
+        f"{'CPU':<20}{get_cpu_info()}\n"
+        f"{'CUDA':<20}{torch.version.cuda if torch and torch.cuda.is_available() else None}\n"
+    )
 
-    for r in parse_requirements(package='ultralytics'):
+    for r in parse_requirements(package="ultralytics"):
         try:
             current = metadata.version(r.name)
-            is_met = ' ' if check_version(current, str(r.specifier), hard=True) else ' '
+            is_met = " " if check_version(current, str(r.specifier), hard=True) else " "
         except metadata.PackageNotFoundError:
-            current = '(not installed)'
-            is_met = ' '
-        LOGGER.info(f'{r.name:<20}{is_met}{current}{r.specifier}')
+            current = "(not installed)"
+            is_met = " "
+        LOGGER.info(f"{r.name:<20}{is_met}{current}{r.specifier}")
 
     if is_github_action_running():
-        LOGGER.info(f"\nRUNNER_OS: {os.getenv('RUNNER_OS')}\n"
-                    f"GITHUB_EVENT_NAME: {os.getenv('GITHUB_EVENT_NAME')}\n"
-                    f"GITHUB_WORKFLOW: {os.getenv('GITHUB_WORKFLOW')}\n"
-                    f"GITHUB_ACTOR: {os.getenv('GITHUB_ACTOR')}\n"
-                    f"GITHUB_REPOSITORY: {os.getenv('GITHUB_REPOSITORY')}\n"
-                    f"GITHUB_REPOSITORY_OWNER: {os.getenv('GITHUB_REPOSITORY_OWNER')}\n")
+        LOGGER.info(
+            f"\nRUNNER_OS: {os.getenv('RUNNER_OS')}\n"
+            f"GITHUB_EVENT_NAME: {os.getenv('GITHUB_EVENT_NAME')}\n"
+            f"GITHUB_WORKFLOW: {os.getenv('GITHUB_WORKFLOW')}\n"
+            f"GITHUB_ACTOR: {os.getenv('GITHUB_ACTOR')}\n"
+            f"GITHUB_REPOSITORY: {os.getenv('GITHUB_REPOSITORY')}\n"
+            f"GITHUB_REPOSITORY_OWNER: {os.getenv('GITHUB_REPOSITORY_OWNER')}\n"
+        )
 
 
 def check_amp(model):
     """
     This function checks the PyTorch Automatic Mixed Precision (AMP) functionality of a YOLOv8 model. If the checks
     fail, it means there are anomalies with AMP on the system that may cause NaN losses or zero-mAP results, so AMP will
     be disabled during training.
@@ -582,86 +627,92 @@
         check_amp(model)
         ```
 
     Returns:
         (bool): Returns True if the AMP functionality works correctly with YOLOv8 model, else False.
     """
     device = next(model.parameters()).device  # get model device
-    if device.type in ('cpu', 'mps'):
+    if device.type in {"cpu", "mps"}:
         return False  # AMP only used on CUDA devices
 
     def amp_allclose(m, im):
         """All close FP32 vs AMP results."""
         a = m(im, device=device, verbose=False)[0].boxes.data  # FP32 inference
         with torch.cuda.amp.autocast(True):
             b = m(im, device=device, verbose=False)[0].boxes.data  # AMP inference
         del m
         return a.shape == b.shape and torch.allclose(a, b.float(), atol=0.5)  # close to 0.5 absolute tolerance
 
-    im = ASSETS / 'bus.jpg'  # image to check
-    prefix = colorstr('AMP: ')
-    LOGGER.info(f'{prefix}running Automatic Mixed Precision (AMP) checks with YOLOv8n...')
+    im = ASSETS / "bus.jpg"  # image to check
+    prefix = colorstr("AMP: ")
+    LOGGER.info(f"{prefix}running Automatic Mixed Precision (AMP) checks with YOLOv8n...")
     warning_msg = "Setting 'amp=True'. If you experience zero-mAP or NaN losses you can disable AMP with amp=False."
     try:
         from ultralytics import YOLO
-        assert amp_allclose(YOLO('yolov8n.pt'), im)
-        LOGGER.info(f'{prefix}checks passed ')
+
+        assert amp_allclose(YOLO("yolov8n.pt"), im)
+        LOGGER.info(f"{prefix}checks passed ")
     except ConnectionError:
-        LOGGER.warning(f'{prefix}checks skipped , offline and unable to download YOLOv8n. {warning_msg}')
+        LOGGER.warning(f"{prefix}checks skipped , offline and unable to download YOLOv8n. {warning_msg}")
     except (AttributeError, ModuleNotFoundError):
-        LOGGER.warning(f'{prefix}checks skipped . '
-                       f'Unable to load YOLOv8n due to possible Ultralytics package modifications. {warning_msg}')
+        LOGGER.warning(
+            f"{prefix}checks skipped . "
+            f"Unable to load YOLOv8n due to possible Ultralytics package modifications. {warning_msg}"
+        )
     except AssertionError:
-        LOGGER.warning(f'{prefix}checks failed . Anomalies were detected with AMP on your system that may lead to '
-                       f'NaN losses or zero-mAP results, so AMP will be disabled during training.')
+        LOGGER.warning(
+            f"{prefix}checks failed . Anomalies were detected with AMP on your system that may lead to "
+            f"NaN losses or zero-mAP results, so AMP will be disabled during training."
+        )
         return False
     return True
 
 
 def git_describe(path=ROOT):  # path must be a directory
     """Return human-readable git description, i.e. v5.0-5-g3e25f1e https://git-scm.com/docs/git-describe."""
     with contextlib.suppress(Exception):
-        return subprocess.check_output(f'git -C {path} describe --tags --long --always', shell=True).decode()[:-1]
-    return ''
+        return subprocess.check_output(f"git -C {path} describe --tags --long --always", shell=True).decode()[:-1]
+    return ""
 
 
 def print_args(args: Optional[dict] = None, show_file=True, show_func=False):
     """Print function arguments (optional args dict)."""
 
     def strip_auth(v):
         """Clean longer Ultralytics HUB URLs by stripping potential authentication information."""
-        return clean_url(v) if (isinstance(v, str) and v.startswith('http') and len(v) > 100) else v
+        return clean_url(v) if (isinstance(v, str) and v.startswith("http") and len(v) > 100) else v
 
     x = inspect.currentframe().f_back  # previous frame
     file, _, func, _, _ = inspect.getframeinfo(x)
     if args is None:  # get args automatically
         args, _, _, frm = inspect.getargvalues(x)
         args = {k: v for k, v in frm.items() if k in args}
     try:
-        file = Path(file).resolve().relative_to(ROOT).with_suffix('')
+        file = Path(file).resolve().relative_to(ROOT).with_suffix("")
     except ValueError:
         file = Path(file).stem
-    s = (f'{file}: ' if show_file else '') + (f'{func}: ' if show_func else '')
-    LOGGER.info(colorstr(s) + ', '.join(f'{k}={strip_auth(v)}' for k, v in args.items()))
+    s = (f"{file}: " if show_file else "") + (f"{func}: " if show_func else "")
+    LOGGER.info(colorstr(s) + ", ".join(f"{k}={strip_auth(v)}" for k, v in args.items()))
 
 
 def cuda_device_count() -> int:
     """
     Get the number of NVIDIA GPUs available in the environment.
 
     Returns:
         (int): The number of NVIDIA GPUs available.
     """
     try:
         # Run the nvidia-smi command and capture its output
-        output = subprocess.check_output(['nvidia-smi', '--query-gpu=count', '--format=csv,noheader,nounits'],
-                                         encoding='utf-8')
+        output = subprocess.check_output(
+            ["nvidia-smi", "--query-gpu=count", "--format=csv,noheader,nounits"], encoding="utf-8"
+        )
 
         # Take the first line and strip any leading/trailing white space
-        first_line = output.strip().split('\n')[0]
+        first_line = output.strip().split("\n")[0]
 
         return int(first_line)
     except (subprocess.CalledProcessError, FileNotFoundError, ValueError):
         # If the command fails, nvidia-smi is not found, or output is not an integer, assume no GPUs are available
         return 0
 
 
@@ -669,7 +720,11 @@
     """
     Check if CUDA is available in the environment.
 
     Returns:
         (bool): True if one or more NVIDIA GPUs are available, False otherwise.
     """
     return cuda_device_count() > 0
+
+
+# Define constants
+IS_PYTHON_3_12 = PYTHON_VERSION.startswith("3.12")
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/dist.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/dist.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,55 +14,58 @@
     """
     Finds a free port on localhost.
 
     It is useful in single-node training when we don't want to connect to a real main node but have to set the
     `MASTER_PORT` environment variable.
     """
     with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
-        s.bind(('127.0.0.1', 0))
+        s.bind(("127.0.0.1", 0))
         return s.getsockname()[1]  # port
 
 
 def generate_ddp_file(trainer):
     """Generates a DDP file and returns its file name."""
-    module, name = f'{trainer.__class__.__module__}.{trainer.__class__.__name__}'.rsplit('.', 1)
+    module, name = f"{trainer.__class__.__module__}.{trainer.__class__.__name__}".rsplit(".", 1)
 
     content = f"""
 # Ultralytics Multi-GPU training temp file (should be automatically deleted after use)
 overrides = {vars(trainer.args)}
 
 if __name__ == "__main__":
     from {module} import {name}
     from ultralytics.utils import DEFAULT_CFG_DICT
 
     cfg = DEFAULT_CFG_DICT.copy()
     cfg.update(save_dir='')   # handle the extra key 'save_dir'
     trainer = {name}(cfg=cfg, overrides=overrides)
     results = trainer.train()
 """
-    (USER_CONFIG_DIR / 'DDP').mkdir(exist_ok=True)
-    with tempfile.NamedTemporaryFile(prefix='_temp_',
-                                     suffix=f'{id(trainer)}.py',
-                                     mode='w+',
-                                     encoding='utf-8',
-                                     dir=USER_CONFIG_DIR / 'DDP',
-                                     delete=False) as file:
+    (USER_CONFIG_DIR / "DDP").mkdir(exist_ok=True)
+    with tempfile.NamedTemporaryFile(
+        prefix="_temp_",
+        suffix=f"{id(trainer)}.py",
+        mode="w+",
+        encoding="utf-8",
+        dir=USER_CONFIG_DIR / "DDP",
+        delete=False,
+    ) as file:
         file.write(content)
     return file.name
 
 
 def generate_ddp_command(world_size, trainer):
     """Generates and returns command for distributed training."""
     import __main__  # noqa local import to avoid https://github.com/Lightning-AI/lightning/issues/15218
+
     if not trainer.resume:
         shutil.rmtree(trainer.save_dir)  # remove the save_dir
     file = generate_ddp_file(trainer)
-    dist_cmd = 'torch.distributed.run' if TORCH_1_9 else 'torch.distributed.launch'
+    dist_cmd = "torch.distributed.run" if TORCH_1_9 else "torch.distributed.launch"
     port = find_free_network_port()
-    cmd = [sys.executable, '-m', dist_cmd, '--nproc_per_node', f'{world_size}', '--master_port', f'{port}', file]
+    cmd = [sys.executable, "-m", dist_cmd, "--nproc_per_node", f"{world_size}", "--master_port", f"{port}", file]
     return cmd, file
 
 
 def ddp_cleanup(trainer, file):
     """Delete temp file if created."""
-    if f'{id(trainer)}.py' in file:  # if temp_file suffix in file
+    if f"{id(trainer)}.py" in file:  # if temp_file suffix in file
         os.remove(file)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/downloads.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/downloads.py`

 * *Files 12% similar despite different names*

```diff
@@ -11,40 +11,62 @@
 
 import requests
 import torch
 
 from ultralytics.utils import LOGGER, TQDM, checks, clean_url, emojis, is_online, url2file
 
 # Define Ultralytics GitHub assets maintained at https://github.com/ultralytics/assets
-GITHUB_ASSETS_REPO = 'ultralytics/assets'
-GITHUB_ASSETS_NAMES = [f'yolov8{k}{suffix}.pt' for k in 'nsmlx' for suffix in ('', '-cls', '-seg', '-pose')] + \
-                      [f'yolov5{k}{resolution}u.pt' for k in 'nsmlx' for resolution in ('', '6')] + \
-                      [f'yolov3{k}u.pt' for k in ('', '-spp', '-tiny')] + \
-                      [f'yolo_nas_{k}.pt' for k in 'sml'] + \
-                      [f'sam_{k}.pt' for k in 'bl'] + \
-                      [f'FastSAM-{k}.pt' for k in 'sx'] + \
-                      [f'rtdetr-{k}.pt' for k in 'lx'] + \
-                      ['mobile_sam.pt']
+GITHUB_ASSETS_REPO = "ultralytics/assets"
+GITHUB_ASSETS_NAMES = (
+    [f"yolov8{k}{suffix}.pt" for k in "nsmlx" for suffix in ("", "-cls", "-seg", "-pose", "-obb")]
+    + [f"yolov5{k}{resolution}u.pt" for k in "nsmlx" for resolution in ("", "6")]
+    + [f"yolov3{k}u.pt" for k in ("", "-spp", "-tiny")]
+    + [f"yolov8{k}-world.pt" for k in "smlx"]
+    + [f"yolov8{k}-worldv2.pt" for k in "smlx"]
+    + [f"yolov9{k}.pt" for k in "ce"]
+    + [f"yolo_nas_{k}.pt" for k in "sml"]
+    + [f"sam_{k}.pt" for k in "bl"]
+    + [f"FastSAM-{k}.pt" for k in "sx"]
+    + [f"rtdetr-{k}.pt" for k in "lx"]
+    + ["mobile_sam.pt"]
+    + ["calibration_image_sample_data_20x128x128x3_float32.npy.zip"]
+)
 GITHUB_ASSETS_STEMS = [Path(k).stem for k in GITHUB_ASSETS_NAMES]
 
 
-def is_url(url, check=True):
-    """Check if string is URL and check if URL exists."""
+def is_url(url, check=False):
+    """
+    Validates if the given string is a URL and optionally checks if the URL exists online.
+
+    Args:
+        url (str): The string to be validated as a URL.
+        check (bool, optional): If True, performs an additional check to see if the URL exists online.
+            Defaults to True.
+
+    Returns:
+        (bool): Returns True for a valid URL. If 'check' is True, also returns True if the URL exists online.
+            Returns False otherwise.
+
+    Example:
+        ```python
+        valid = is_url("https://www.example.com")
+        ```
+    """
     with contextlib.suppress(Exception):
         url = str(url)
         result = parse.urlparse(url)
         assert all([result.scheme, result.netloc])  # check if is url
         if check:
             with request.urlopen(url) as response:
                 return response.getcode() == 200  # check if exists online
         return True
     return False
 
 
-def delete_dsstore(path, files_to_delete=('.DS_Store', '__MACOSX')):
+def delete_dsstore(path, files_to_delete=(".DS_Store", "__MACOSX")):
     """
     Deletes all ".DS_store" files under a specified directory.
 
     Args:
         path (str, optional): The directory path where the ".DS_store" files should be deleted.
         files_to_delete (tuple): The files to be deleted.
 
@@ -55,23 +77,22 @@
         delete_dsstore('path/to/dir')
         ```
 
     Note:
         ".DS_store" files are created by the Apple operating system and contain metadata about folders and files. They
         are hidden system files and can cause issues when transferring files between different operating systems.
     """
-    # Delete Apple .DS_store files
     for file in files_to_delete:
         matches = list(Path(path).rglob(file))
-        LOGGER.info(f'Deleting {file} files: {matches}')
+        LOGGER.info(f"Deleting {file} files: {matches}")
         for f in matches:
             f.unlink()
 
 
-def zip_directory(directory, compress=True, exclude=('.DS_Store', '__MACOSX'), progress=True):
+def zip_directory(directory, compress=True, exclude=(".DS_Store", "__MACOSX"), progress=True):
     """
     Zips the contents of a directory, excluding files containing strings in the exclude list. The resulting zip file is
     named after the directory and placed alongside it.
 
     Args:
         directory (str | Path): The path to the directory to be zipped.
         compress (bool): Whether to compress the files while zipping. Default is True.
@@ -92,25 +113,25 @@
 
     delete_dsstore(directory)
     directory = Path(directory)
     if not directory.is_dir():
         raise FileNotFoundError(f"Directory '{directory}' does not exist.")
 
     # Unzip with progress bar
-    files_to_zip = [f for f in directory.rglob('*') if f.is_file() and all(x not in f.name for x in exclude)]
-    zip_file = directory.with_suffix('.zip')
+    files_to_zip = [f for f in directory.rglob("*") if f.is_file() and all(x not in f.name for x in exclude)]
+    zip_file = directory.with_suffix(".zip")
     compression = ZIP_DEFLATED if compress else ZIP_STORED
-    with ZipFile(zip_file, 'w', compression) as f:
-        for file in TQDM(files_to_zip, desc=f'Zipping {directory} to {zip_file}...', unit='file', disable=not progress):
+    with ZipFile(zip_file, "w", compression) as f:
+        for file in TQDM(files_to_zip, desc=f"Zipping {directory} to {zip_file}...", unit="file", disable=not progress):
             f.write(file, file.relative_to(directory))
 
     return zip_file  # return path to zip file
 
 
-def unzip_file(file, path=None, exclude=('.DS_Store', '__MACOSX'), exist_ok=False, progress=True):
+def unzip_file(file, path=None, exclude=(".DS_Store", "__MACOSX"), exist_ok=False, progress=True):
     """
     Unzips a *.zip file to the specified path, excluding files containing strings in the exclude list.
 
     If the zipfile does not contain a single top-level directory, the function will create a new
     directory with the same name as the zipfile (without the extension) to extract its contents.
     If a path is not provided, the function will use the parent directory of the zipfile as the default path.
 
@@ -142,64 +163,70 @@
         path = Path(file).parent  # default path
 
     # Unzip the file contents
     with ZipFile(file) as zipObj:
         files = [f for f in zipObj.namelist() if all(x not in f for x in exclude)]
         top_level_dirs = {Path(f).parts[0] for f in files}
 
-        if len(top_level_dirs) > 1 or not files[0].endswith('/'):  # zip has multiple files at top level
+        if len(top_level_dirs) > 1 or (len(files) > 1 and not files[0].endswith("/")):
+            # Zip has multiple files at top level
             path = extract_path = Path(path) / Path(file).stem  # i.e. ../datasets/coco8
-        else:  # zip has 1 top-level directory
+        else:
+            # Zip has 1 top-level directory
             extract_path = path  # i.e. ../datasets
             path = Path(path) / list(top_level_dirs)[0]  # i.e. ../datasets/coco8
 
         # Check if destination directory already exists and contains files
         if path.exists() and any(path.iterdir()) and not exist_ok:
             # If it exists and is not empty, return the path without unzipping
-            LOGGER.warning(f'WARNING  Skipping {file} unzip as destination directory {path} is not empty.')
+            LOGGER.warning(f"WARNING  Skipping {file} unzip as destination directory {path} is not empty.")
             return path
 
-        for f in TQDM(files, desc=f'Unzipping {file} to {Path(path).resolve()}...', unit='file', disable=not progress):
+        for f in TQDM(files, desc=f"Unzipping {file} to {Path(path).resolve()}...", unit="file", disable=not progress):
             # Ensure the file is within the extract_path to avoid path traversal security vulnerability
-            if '..' in Path(f).parts:
-                LOGGER.warning(f'Potentially insecure file path: {f}, skipping extraction.')
+            if ".." in Path(f).parts:
+                LOGGER.warning(f"Potentially insecure file path: {f}, skipping extraction.")
                 continue
             zipObj.extract(f, extract_path)
 
     return path  # return unzip dir
 
 
-def check_disk_space(url='https://ultralytics.com/assets/coco128.zip', sf=1.5, hard=True):
+def check_disk_space(url="https://ultralytics.com/assets/coco128.zip", path=Path.cwd(), sf=1.5, hard=True):
     """
     Check if there is sufficient disk space to download and store a file.
 
     Args:
         url (str, optional): The URL to the file. Defaults to 'https://ultralytics.com/assets/coco128.zip'.
+        path (str | Path, optional): The path or drive to check the available free space on.
         sf (float, optional): Safety factor, the multiplier for the required free space. Defaults to 2.0.
         hard (bool, optional): Whether to throw an error or not on insufficient disk space. Defaults to True.
 
     Returns:
         (bool): True if there is sufficient disk space, False otherwise.
     """
     try:
         r = requests.head(url)  # response
-        assert r.status_code < 400, f'URL error for {url}: {r.status_code} {r.reason}'  # check response
+        assert r.status_code < 400, f"URL error for {url}: {r.status_code} {r.reason}"  # check response
     except Exception:
         return True  # requests issue, default to True
 
     # Check file size
     gib = 1 << 30  # bytes per GiB
-    data = int(r.headers.get('Content-Length', 0)) / gib  # file size (GB)
-    total, used, free = (x / gib for x in shutil.disk_usage('/'))  # bytes
+    data = int(r.headers.get("Content-Length", 0)) / gib  # file size (GB)
+    total, used, free = (x / gib for x in shutil.disk_usage(path))  # bytes
+
     if data * sf < free:
         return True  # sufficient space
 
     # Insufficient space
-    text = (f'WARNING  Insufficient free disk space {free:.1f} GB < {data * sf:.3f} GB required, '
-            f'Please free {data * sf - free:.1f} GB additional disk space and try again.')
+    text = (
+        f"WARNING  Insufficient free disk space {free:.1f} GB < {data * sf:.3f} GB required, "
+        f"Please free {data * sf - free:.1f} GB additional disk space and try again."
+    )
     if hard:
         raise MemoryError(text)
     LOGGER.warning(text)
     return False
 
 
 def get_google_drive_file_info(link):
@@ -217,43 +244,49 @@
         ```python
         from ultralytics.utils.downloads import get_google_drive_file_info
 
         link = "https://drive.google.com/file/d/1cqT-cJgANNrhIHCrEufUYhQ4RqiWG_lJ/view?usp=drive_link"
         url, filename = get_google_drive_file_info(link)
         ```
     """
-    file_id = link.split('/d/')[1].split('/view')[0]
-    drive_url = f'https://drive.google.com/uc?export=download&id={file_id}'
+    file_id = link.split("/d/")[1].split("/view")[0]
+    drive_url = f"https://drive.google.com/uc?export=download&id={file_id}"
     filename = None
 
     # Start session
     with requests.Session() as session:
         response = session.get(drive_url, stream=True)
-        if 'quota exceeded' in str(response.content.lower()):
+        if "quota exceeded" in str(response.content.lower()):
             raise ConnectionError(
-                emojis(f'  Google Drive file download quota exceeded. '
-                       f'Please try again later or download this file manually at {link}.'))
+                emojis(
+                    f"  Google Drive file download quota exceeded. "
+                    f"Please try again later or download this file manually at {link}."
+                )
+            )
         for k, v in response.cookies.items():
-            if k.startswith('download_warning'):
-                drive_url += f'&confirm={v}'  # v is token
-        cd = response.headers.get('content-disposition')
+            if k.startswith("download_warning"):
+                drive_url += f"&confirm={v}"  # v is token
+        cd = response.headers.get("content-disposition")
         if cd:
             filename = re.findall('filename="(.+)"', cd)[0]
     return drive_url, filename
 
 
-def safe_download(url,
-                  file=None,
-                  dir=None,
-                  unzip=True,
-                  delete=False,
-                  curl=False,
-                  retry=3,
-                  min_bytes=1E0,
-                  progress=True):
+def safe_download(
+    url,
+    file=None,
+    dir=None,
+    unzip=True,
+    delete=False,
+    curl=False,
+    retry=3,
+    min_bytes=1e0,
+    exist_ok=False,
+    progress=True,
+):
     """
     Downloads files from a URL, with options for retrying, unzipping, and deleting the downloaded file.
 
     Args:
         url (str): The URL of the file to be downloaded.
         file (str, optional): The filename of the downloaded file.
             If not provided, the file will be saved with the same name as the URL.
@@ -261,148 +294,207 @@
             If not provided, the file will be saved in the current working directory.
         unzip (bool, optional): Whether to unzip the downloaded file. Default: True.
         delete (bool, optional): Whether to delete the downloaded file after unzipping. Default: False.
         curl (bool, optional): Whether to use curl command line tool for downloading. Default: False.
         retry (int, optional): The number of times to retry the download in case of failure. Default: 3.
         min_bytes (float, optional): The minimum number of bytes that the downloaded file should have, to be considered
             a successful download. Default: 1E0.
+        exist_ok (bool, optional): Whether to overwrite existing contents during unzipping. Defaults to False.
         progress (bool, optional): Whether to display a progress bar during the download. Default: True.
 
     Example:
         ```python
         from ultralytics.utils.downloads import safe_download
 
         link = "https://ultralytics.com/assets/bus.jpg"
         path = safe_download(link)
         ```
     """
-
-    # Check if the URL is a Google Drive link
-    gdrive = url.startswith('https://drive.google.com/')
+    gdrive = url.startswith("https://drive.google.com/")  # check if the URL is a Google Drive link
     if gdrive:
         url, file = get_google_drive_file_info(url)
 
-    f = Path(dir or '.') / (file or url2file(url))  # URL converted to filename
-    if '://' not in str(url) and Path(url).is_file():  # URL exists ('://' check required in Windows Python<3.10)
+    f = Path(dir or ".") / (file or url2file(url))  # URL converted to filename
+    if "://" not in str(url) and Path(url).is_file():  # URL exists ('://' check required in Windows Python<3.10)
         f = Path(url)  # filename
     elif not f.is_file():  # URL and file do not exist
         desc = f"Downloading {url if gdrive else clean_url(url)} to '{f}'"
-        LOGGER.info(f'{desc}...')
+        LOGGER.info(f"{desc}...")
         f.parent.mkdir(parents=True, exist_ok=True)  # make directory if missing
-        check_disk_space(url)
+        check_disk_space(url, path=f.parent)
         for i in range(retry + 1):
             try:
                 if curl or i > 0:  # curl download with retry, continue
-                    s = 'sS' * (not progress)  # silent
-                    r = subprocess.run(['curl', '-#', f'-{s}L', url, '-o', f, '--retry', '3', '-C', '-']).returncode
-                    assert r == 0, f'Curl return value {r}'
+                    s = "sS" * (not progress)  # silent
+                    r = subprocess.run(["curl", "-#", f"-{s}L", url, "-o", f, "--retry", "3", "-C", "-"]).returncode
+                    assert r == 0, f"Curl return value {r}"
                 else:  # urllib download
-                    method = 'torch'
-                    if method == 'torch':
+                    method = "torch"
+                    if method == "torch":
                         torch.hub.download_url_to_file(url, f, progress=progress)
                     else:
-                        with request.urlopen(url) as response, TQDM(total=int(response.getheader('Content-Length', 0)),
-                                                                    desc=desc,
-                                                                    disable=not progress,
-                                                                    unit='B',
-                                                                    unit_scale=True,
-                                                                    unit_divisor=1024) as pbar:
-                            with open(f, 'wb') as f_opened:
+                        with request.urlopen(url) as response, TQDM(
+                            total=int(response.getheader("Content-Length", 0)),
+                            desc=desc,
+                            disable=not progress,
+                            unit="B",
+                            unit_scale=True,
+                            unit_divisor=1024,
+                        ) as pbar:
+                            with open(f, "wb") as f_opened:
                                 for data in response:
                                     f_opened.write(data)
                                     pbar.update(len(data))
 
                 if f.exists():
                     if f.stat().st_size > min_bytes:
                         break  # success
                     f.unlink()  # remove partial downloads
             except Exception as e:
                 if i == 0 and not is_online():
-                    raise ConnectionError(emojis(f'  Download failure for {url}. Environment is not online.')) from e
+                    raise ConnectionError(emojis(f"  Download failure for {url}. Environment is not online.")) from e
                 elif i >= retry:
-                    raise ConnectionError(emojis(f'  Download failure for {url}. Retry limit reached.')) from e
-                LOGGER.warning(f' Download failure, retrying {i + 1}/{retry} {url}...')
+                    raise ConnectionError(emojis(f"  Download failure for {url}. Retry limit reached.")) from e
+                LOGGER.warning(f" Download failure, retrying {i + 1}/{retry} {url}...")
 
-    if unzip and f.exists() and f.suffix in ('', '.zip', '.tar', '.gz'):
+    if unzip and f.exists() and f.suffix in {"", ".zip", ".tar", ".gz"}:
         from zipfile import is_zipfile
 
-        unzip_dir = dir or f.parent  # unzip to dir if provided else unzip in place
+        unzip_dir = (dir or f.parent).resolve()  # unzip to dir if provided else unzip in place
         if is_zipfile(f):
-            unzip_dir = unzip_file(file=f, path=unzip_dir, progress=progress)  # unzip
-        elif f.suffix in ('.tar', '.gz'):
-            LOGGER.info(f'Unzipping {f} to {unzip_dir.resolve()}...')
-            subprocess.run(['tar', 'xf' if f.suffix == '.tar' else 'xfz', f, '--directory', unzip_dir], check=True)
+            unzip_dir = unzip_file(file=f, path=unzip_dir, exist_ok=exist_ok, progress=progress)  # unzip
+        elif f.suffix in {".tar", ".gz"}:
+            LOGGER.info(f"Unzipping {f} to {unzip_dir}...")
+            subprocess.run(["tar", "xf" if f.suffix == ".tar" else "xfz", f, "--directory", unzip_dir], check=True)
         if delete:
             f.unlink()  # remove zip
         return unzip_dir
 
 
-def get_github_assets(repo='ultralytics/assets', version='latest', retry=False):
-    """Return GitHub repo tag and assets (i.e. ['yolov8n.pt', 'yolov8s.pt', ...])."""
-    if version != 'latest':
-        version = f'tags/{version}'  # i.e. tags/v6.2
-    url = f'https://api.github.com/repos/{repo}/releases/{version}'
+def get_github_assets(repo="ultralytics/assets", version="latest", retry=False):
+    """
+    Retrieve the specified version's tag and assets from a GitHub repository. If the version is not specified, the
+    function fetches the latest release assets.
+
+    Args:
+        repo (str, optional): The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.
+        version (str, optional): The release version to fetch assets from. Defaults to 'latest'.
+        retry (bool, optional): Flag to retry the request in case of a failure. Defaults to False.
+
+    Returns:
+        (tuple): A tuple containing the release tag and a list of asset names.
+
+    Example:
+        ```python
+        tag, assets = get_github_assets(repo='ultralytics/assets', version='latest')
+        ```
+    """
+
+    if version != "latest":
+        version = f"tags/{version}"  # i.e. tags/v6.2
+    url = f"https://api.github.com/repos/{repo}/releases/{version}"
     r = requests.get(url)  # github api
-    if r.status_code != 200 and r.reason != 'rate limit exceeded' and retry:  # failed and not 403 rate limit exceeded
+    if r.status_code != 200 and r.reason != "rate limit exceeded" and retry:  # failed and not 403 rate limit exceeded
         r = requests.get(url)  # try again
     if r.status_code != 200:
-        LOGGER.warning(f' GitHub assets check failure for {url}: {r.status_code} {r.reason}')
-        return '', []
+        LOGGER.warning(f" GitHub assets check failure for {url}: {r.status_code} {r.reason}")
+        return "", []
     data = r.json()
-    return data['tag_name'], [x['name'] for x in data['assets']]  # tag, assets
+    return data["tag_name"], [x["name"] for x in data["assets"]]  # tag, assets i.e. ['yolov8n.pt', 'yolov8s.pt', ...]
 
 
-def attempt_download_asset(file, repo='ultralytics/assets', release='v0.0.0'):
+def attempt_download_asset(file, repo="ultralytics/assets", release="v8.1.0", **kwargs):
     """
-    Attempt file download from GitHub release assets if not found locally.
+    Attempt to download a file from GitHub release assets if it is not found locally. The function checks for the file
+    locally first, then tries to download it from the specified GitHub repository release.
+
+    Args:
+        file (str | Path): The filename or file path to be downloaded.
+        repo (str, optional): The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.
+        release (str, optional): The specific release version to be downloaded. Defaults to 'v8.1.0'.
+        **kwargs (any): Additional keyword arguments for the download process.
+
+    Returns:
+        (str): The path to the downloaded file.
 
-    release = 'latest', 'v6.2', etc.
+    Example:
+        ```python
+        file_path = attempt_download_asset('yolov5s.pt', repo='ultralytics/assets', release='latest')
+        ```
     """
     from ultralytics.utils import SETTINGS  # scoped for circular import
 
     # YOLOv3/5u updates
     file = str(file)
     file = checks.check_yolov5u_filename(file)
-    file = Path(file.strip().replace("'", ''))
+    file = Path(file.strip().replace("'", ""))
     if file.exists():
         return str(file)
-    elif (SETTINGS['weights_dir'] / file).exists():
-        return str(SETTINGS['weights_dir'] / file)
+    elif (SETTINGS["weights_dir"] / file).exists():
+        return str(SETTINGS["weights_dir"] / file)
     else:
         # URL specified
         name = Path(parse.unquote(str(file))).name  # decode '%2F' to '/' etc.
-        if str(file).startswith(('http:/', 'https:/')):  # download
-            url = str(file).replace(':/', '://')  # Pathlib turns :// -> :/
+        download_url = f"https://github.com/{repo}/releases/download"
+        if str(file).startswith(("http:/", "https:/")):  # download
+            url = str(file).replace(":/", "://")  # Pathlib turns :// -> :/
             file = url2file(name)  # parse authentication https://url.com/file.txt?auth...
             if Path(file).is_file():
-                LOGGER.info(f'Found {clean_url(url)} locally at {file}')  # file already exists
+                LOGGER.info(f"Found {clean_url(url)} locally at {file}")  # file already exists
             else:
-                safe_download(url=url, file=file, min_bytes=1E5)
+                safe_download(url=url, file=file, min_bytes=1e5, **kwargs)
 
         elif repo == GITHUB_ASSETS_REPO and name in GITHUB_ASSETS_NAMES:
-            safe_download(url=f'https://github.com/{repo}/releases/download/{release}/{name}', file=file, min_bytes=1E5)
+            safe_download(url=f"{download_url}/{release}/{name}", file=file, min_bytes=1e5, **kwargs)
 
         else:
             tag, assets = get_github_assets(repo, release)
             if not assets:
                 tag, assets = get_github_assets(repo)  # latest release
             if name in assets:
-                safe_download(url=f'https://github.com/{repo}/releases/download/{tag}/{name}', file=file, min_bytes=1E5)
+                safe_download(url=f"{download_url}/{tag}/{name}", file=file, min_bytes=1e5, **kwargs)
 
         return str(file)
 
 
-def download(url, dir=Path.cwd(), unzip=True, delete=False, curl=False, threads=1, retry=3):
-    """Downloads and unzips files concurrently if threads > 1, else sequentially."""
+def download(url, dir=Path.cwd(), unzip=True, delete=False, curl=False, threads=1, retry=3, exist_ok=False):
+    """
+    Downloads files from specified URLs to a given directory. Supports concurrent downloads if multiple threads are
+    specified.
+
+    Args:
+        url (str | list): The URL or list of URLs of the files to be downloaded.
+        dir (Path, optional): The directory where the files will be saved. Defaults to the current working directory.
+        unzip (bool, optional): Flag to unzip the files after downloading. Defaults to True.
+        delete (bool, optional): Flag to delete the zip files after extraction. Defaults to False.
+        curl (bool, optional): Flag to use curl for downloading. Defaults to False.
+        threads (int, optional): Number of threads to use for concurrent downloads. Defaults to 1.
+        retry (int, optional): Number of retries in case of download failure. Defaults to 3.
+        exist_ok (bool, optional): Whether to overwrite existing contents during unzipping. Defaults to False.
+
+    Example:
+        ```python
+        download('https://ultralytics.com/assets/example.zip', dir='path/to/dir', unzip=True)
+        ```
+    """
     dir = Path(dir)
     dir.mkdir(parents=True, exist_ok=True)  # make directory
     if threads > 1:
         with ThreadPool(threads) as pool:
             pool.map(
                 lambda x: safe_download(
-                    url=x[0], dir=x[1], unzip=unzip, delete=delete, curl=curl, retry=retry, progress=threads <= 1),
-                zip(url, repeat(dir)))
+                    url=x[0],
+                    dir=x[1],
+                    unzip=unzip,
+                    delete=delete,
+                    curl=curl,
+                    retry=retry,
+                    exist_ok=exist_ok,
+                    progress=threads <= 1,
+                ),
+                zip(url, repeat(dir)),
+            )
             pool.close()
             pool.join()
     else:
         for u in [url] if isinstance(url, (str, Path)) else url:
-            safe_download(url=u, dir=dir, unzip=unzip, delete=delete, curl=curl, retry=retry)
+            safe_download(url=u, dir=dir, unzip=unzip, delete=delete, curl=curl, retry=retry, exist_ok=exist_ok)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/errors.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/errors.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,10 +13,10 @@
     Attributes:
         message (str): The error message displayed when the exception is raised.
 
     Note:
         The message is automatically processed through the 'emojis' function from the 'ultralytics.utils' package.
     """
 
-    def __init__(self, message='Model not found. Please check model URL and try again.'):
+    def __init__(self, message="Model not found. Please check model URL and try again."):
         """Create an exception for when a model is not found."""
         super().__init__(emojis(message))
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/files.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/files.py`

 * *Files 19% similar despite different names*

```diff
@@ -46,21 +46,21 @@
 
         with spaces_in_path('/path/with spaces') as new_path:
             # Your code here
         ```
     """
 
     # If path has spaces, replace them with underscores
-    if ' ' in str(path):
+    if " " in str(path):
         string = isinstance(path, str)  # input type
         path = Path(path)
 
         # Create a temporary directory and construct the new path
         with tempfile.TemporaryDirectory() as tmp_dir:
-            tmp_path = Path(tmp_dir) / path.name.replace(' ', '_')
+            tmp_path = Path(tmp_dir) / path.name.replace(" ", "_")
 
             # Copy file/directory
             if path.is_dir():
                 # tmp_path.mkdir(parents=True, exist_ok=True)
                 shutil.copytree(path, tmp_path)
             elif path.is_file():
                 tmp_path.parent.mkdir(parents=True, exist_ok=True)
@@ -78,15 +78,15 @@
                     shutil.copy2(tmp_path, path)  # Copy back the file
 
     else:
         # If there are no spaces, just yield the original path
         yield path
 
 
-def increment_path(path, exist_ok=False, sep='', mkdir=False):
+def increment_path(path, exist_ok=False, sep="", mkdir=False):
     """
     Increments a file or directory path, i.e. runs/exp --> runs/exp{sep}2, runs/exp{sep}3, ... etc.
 
     If the path exists and exist_ok is not set to True, the path will be incremented by appending a number and sep to
     the end of the path. If the path is a file, the file extension will be preserved. If the path is a directory, the
     number will be appended directly to the end of the path. If mkdir is set to True, the path will be created as a
     directory if it does not already exist.
@@ -98,50 +98,91 @@
         mkdir (bool, optional): Create a directory if it does not exist. Defaults to False.
 
     Returns:
         (pathlib.Path): Incremented path.
     """
     path = Path(path)  # os-agnostic
     if path.exists() and not exist_ok:
-        path, suffix = (path.with_suffix(''), path.suffix) if path.is_file() else (path, '')
+        path, suffix = (path.with_suffix(""), path.suffix) if path.is_file() else (path, "")
 
         # Method 1
         for n in range(2, 9999):
-            p = f'{path}{sep}{n}{suffix}'  # increment path
+            p = f"{path}{sep}{n}{suffix}"  # increment path
             if not os.path.exists(p):
                 break
         path = Path(p)
 
     if mkdir:
         path.mkdir(parents=True, exist_ok=True)  # make directory
 
     return path
 
 
 def file_age(path=__file__):
     """Return days since last file update."""
-    dt = (datetime.now() - datetime.fromtimestamp(Path(path).stat().st_mtime))  # delta
+    dt = datetime.now() - datetime.fromtimestamp(Path(path).stat().st_mtime)  # delta
     return dt.days  # + dt.seconds / 86400  # fractional days
 
 
 def file_date(path=__file__):
     """Return human-readable file modification date, i.e. '2021-3-26'."""
     t = datetime.fromtimestamp(Path(path).stat().st_mtime)
-    return f'{t.year}-{t.month}-{t.day}'
+    return f"{t.year}-{t.month}-{t.day}"
 
 
 def file_size(path):
     """Return file/dir size (MB)."""
     if isinstance(path, (str, Path)):
         mb = 1 << 20  # bytes to MiB (1024 ** 2)
         path = Path(path)
         if path.is_file():
             return path.stat().st_size / mb
         elif path.is_dir():
-            return sum(f.stat().st_size for f in path.glob('**/*') if f.is_file()) / mb
+            return sum(f.stat().st_size for f in path.glob("**/*") if f.is_file()) / mb
     return 0.0
 
 
-def get_latest_run(search_dir='.'):
+def get_latest_run(search_dir="."):
     """Return path to most recent 'last.pt' in /runs (i.e. to --resume from)."""
-    last_list = glob.glob(f'{search_dir}/**/last*.pt', recursive=True)
-    return max(last_list, key=os.path.getctime) if last_list else ''
+    last_list = glob.glob(f"{search_dir}/**/last*.pt", recursive=True)
+    return max(last_list, key=os.path.getctime) if last_list else ""
+
+
+def update_models(model_names=("yolov8n.pt",), source_dir=Path("."), update_names=False):
+    """
+    Updates and re-saves specified YOLO models in an 'updated_models' subdirectory.
+
+    Args:
+        model_names (tuple, optional): Model filenames to update, defaults to ("yolov8n.pt").
+        source_dir (Path, optional): Directory containing models and target subdirectory, defaults to current directory.
+        update_names (bool, optional): Update model names from a data YAML.
+
+    Example:
+        ```python
+        from ultralytics.utils.files import update_models
+
+        model_names = (f"rtdetr-{size}.pt" for size in "lx")
+        update_models(model_names)
+        ```
+    """
+    from ultralytics import YOLO
+    from ultralytics.nn.autobackend import default_class_names
+
+    target_dir = source_dir / "updated_models"
+    target_dir.mkdir(parents=True, exist_ok=True)  # Ensure target directory exists
+
+    for model_name in model_names:
+        model_path = source_dir / model_name
+        print(f"Loading model from {model_path}")
+
+        # Load model
+        model = YOLO(model_path)
+        model.half()
+        if update_names:  # update model names from a dataset YAML
+            model.model.names = default_class_names("coco8.yaml")
+
+        # Define new save path
+        save_path = target_dir / model_name
+
+        # Save model using model.save()
+        print(f"Re-saving {model_name} model to {save_path}")
+        model.save(save_path, use_dill=False)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/instance.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/instance.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 from collections import abc
 from itertools import repeat
 from numbers import Number
 from typing import List
 
 import numpy as np
 
-from .ops import ltwh2xywh, ltwh2xyxy, resample_segments, xywh2ltwh, xywh2xyxy, xyxy2ltwh, xyxy2xywh
+from .ops import ltwh2xywh, ltwh2xyxy, xywh2ltwh, xywh2xyxy, xyxy2ltwh, xyxy2xywh
 
 
 def _ntuple(n):
     """From PyTorch internals."""
 
     def parse(x):
         """Parse bounding boxes format between XYWH and LTWH."""
@@ -22,17 +22,17 @@
 
 to_2tuple = _ntuple(2)
 to_4tuple = _ntuple(4)
 
 # `xyxy` means left top and right bottom
 # `xywh` means center x, center y and width, height(YOLO format)
 # `ltwh` means left top and width, height(COCO format)
-_formats = ['xyxy', 'xywh', 'ltwh']
+_formats = ["xyxy", "xywh", "ltwh"]
 
-__all__ = 'Bboxes',  # tuple or list
+__all__ = ("Bboxes",)  # tuple or list
 
 
 class Bboxes:
     """
     A class for handling bounding boxes.
 
     The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.
@@ -42,41 +42,41 @@
         bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.
         format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').
 
     Note:
         This class does not handle normalization or denormalization of bounding boxes.
     """
 
-    def __init__(self, bboxes, format='xyxy') -> None:
+    def __init__(self, bboxes, format="xyxy") -> None:
         """Initializes the Bboxes class with bounding box data in a specified format."""
-        assert format in _formats, f'Invalid bounding box format: {format}, format must be one of {_formats}'
+        assert format in _formats, f"Invalid bounding box format: {format}, format must be one of {_formats}"
         bboxes = bboxes[None, :] if bboxes.ndim == 1 else bboxes
         assert bboxes.ndim == 2
         assert bboxes.shape[1] == 4
         self.bboxes = bboxes
         self.format = format
         # self.normalized = normalized
 
     def convert(self, format):
         """Converts bounding box format from one type to another."""
-        assert format in _formats, f'Invalid bounding box format: {format}, format must be one of {_formats}'
+        assert format in _formats, f"Invalid bounding box format: {format}, format must be one of {_formats}"
         if self.format == format:
             return
-        elif self.format == 'xyxy':
-            func = xyxy2xywh if format == 'xywh' else xyxy2ltwh
-        elif self.format == 'xywh':
-            func = xywh2xyxy if format == 'xyxy' else xywh2ltwh
+        elif self.format == "xyxy":
+            func = xyxy2xywh if format == "xywh" else xyxy2ltwh
+        elif self.format == "xywh":
+            func = xywh2xyxy if format == "xyxy" else xywh2ltwh
         else:
-            func = ltwh2xyxy if format == 'xyxy' else ltwh2xywh
+            func = ltwh2xyxy if format == "xyxy" else ltwh2xywh
         self.bboxes = func(self.bboxes)
         self.format = format
 
     def areas(self):
         """Return box areas."""
-        self.convert('xyxy')
+        self.convert("xyxy")
         return (self.bboxes[:, 2] - self.bboxes[:, 0]) * (self.bboxes[:, 3] - self.bboxes[:, 1])
 
     # def denormalize(self, w, h):
     #    if not self.normalized:
     #         return
     #     assert (self.bboxes <= 1.0).all()
     #     self.bboxes[:, 0::2] *= w
@@ -120,15 +120,15 @@
         self.bboxes[:, 3] += offset[3]
 
     def __len__(self):
         """Return the number of boxes."""
         return len(self.bboxes)
 
     @classmethod
-    def concatenate(cls, boxes_list: List['Bboxes'], axis=0) -> 'Bboxes':
+    def concatenate(cls, boxes_list: List["Bboxes"], axis=0) -> "Bboxes":
         """
         Concatenate a list of Bboxes objects into a single Bboxes object.
 
         Args:
             boxes_list (List[Bboxes]): A list of Bboxes objects to concatenate.
             axis (int, optional): The axis along which to concatenate the bounding boxes.
                                    Defaults to 0.
@@ -144,15 +144,15 @@
             return cls(np.empty(0))
         assert all(isinstance(box, Bboxes) for box in boxes_list)
 
         if len(boxes_list) == 1:
             return boxes_list[0]
         return cls(np.concatenate([b.bboxes for b in boxes_list], axis=axis))
 
-    def __getitem__(self, index) -> 'Bboxes':
+    def __getitem__(self, index) -> "Bboxes":
         """
         Retrieve a specific bounding box or a set of bounding boxes using indexing.
 
         Args:
             index (int, slice, or np.ndarray): The index, slice, or boolean array to select
                                                the desired bounding boxes.
 
@@ -165,15 +165,15 @@
         Note:
             When using boolean indexing, make sure to provide a boolean array with the same
             length as the number of bounding boxes.
         """
         if isinstance(index, int):
             return Bboxes(self.bboxes[index].view(1, -1))
         b = self.bboxes[index]
-        assert b.ndim == 2, f'Indexing on Bboxes with {index} failed to return a matrix!'
+        assert b.ndim == 2, f"Indexing on Bboxes with {index} failed to return a matrix!"
         return Bboxes(b)
 
 
 class Instances:
     """
     Container for bounding boxes, segments, and keypoints of detected objects in an image.
 
@@ -201,34 +201,24 @@
         ```
 
     Note:
         The bounding box format is either 'xywh' or 'xyxy', and is determined by the `bbox_format` argument.
         This class does not perform input validation, and it assumes the inputs are well-formed.
     """
 
-    def __init__(self, bboxes, segments=None, keypoints=None, bbox_format='xywh', normalized=True) -> None:
+    def __init__(self, bboxes, segments=None, keypoints=None, bbox_format="xywh", normalized=True) -> None:
         """
         Args:
             bboxes (ndarray): bboxes with shape [N, 4].
             segments (list | ndarray): segments.
             keypoints (ndarray): keypoints(x, y, visible) with shape [N, 17, 3].
         """
-        if segments is None:
-            segments = []
         self._bboxes = Bboxes(bboxes=bboxes, format=bbox_format)
         self.keypoints = keypoints
         self.normalized = normalized
-
-        if len(segments) > 0:
-            # List[np.array(1000, 2)] * num_samples
-            segments = resample_segments(segments)
-            # (N, 1000, 2)
-            segments = np.stack(segments, axis=0)
-        else:
-            segments = np.zeros((0, 1000, 2), dtype=np.float32)
         self.segments = segments
 
     def convert_bbox(self, format):
         """Convert bounding box format."""
         self._bboxes.convert(format=format)
 
     @property
@@ -269,23 +259,23 @@
         if self.keypoints is not None:
             self.keypoints[..., 0] /= w
             self.keypoints[..., 1] /= h
         self.normalized = True
 
     def add_padding(self, padw, padh):
         """Handle rect and mosaic situation."""
-        assert not self.normalized, 'you should add padding with absolute coordinates.'
+        assert not self.normalized, "you should add padding with absolute coordinates."
         self._bboxes.add(offset=(padw, padh, padw, padh))
         self.segments[..., 0] += padw
         self.segments[..., 1] += padh
         if self.keypoints is not None:
             self.keypoints[..., 0] += padw
             self.keypoints[..., 1] += padh
 
-    def __getitem__(self, index) -> 'Instances':
+    def __getitem__(self, index) -> "Instances":
         """
         Retrieve a specific instance or a set of instances using indexing.
 
         Args:
             index (int, slice, or np.ndarray): The index, slice, or boolean array to select
                                                the desired instances.
 
@@ -307,45 +297,45 @@
             keypoints=keypoints,
             bbox_format=bbox_format,
             normalized=self.normalized,
         )
 
     def flipud(self, h):
         """Flips the coordinates of bounding boxes, segments, and keypoints vertically."""
-        if self._bboxes.format == 'xyxy':
+        if self._bboxes.format == "xyxy":
             y1 = self.bboxes[:, 1].copy()
             y2 = self.bboxes[:, 3].copy()
             self.bboxes[:, 1] = h - y2
             self.bboxes[:, 3] = h - y1
         else:
             self.bboxes[:, 1] = h - self.bboxes[:, 1]
         self.segments[..., 1] = h - self.segments[..., 1]
         if self.keypoints is not None:
             self.keypoints[..., 1] = h - self.keypoints[..., 1]
 
     def fliplr(self, w):
         """Reverses the order of the bounding boxes and segments horizontally."""
-        if self._bboxes.format == 'xyxy':
+        if self._bboxes.format == "xyxy":
             x1 = self.bboxes[:, 0].copy()
             x2 = self.bboxes[:, 2].copy()
             self.bboxes[:, 0] = w - x2
             self.bboxes[:, 2] = w - x1
         else:
             self.bboxes[:, 0] = w - self.bboxes[:, 0]
         self.segments[..., 0] = w - self.segments[..., 0]
         if self.keypoints is not None:
             self.keypoints[..., 0] = w - self.keypoints[..., 0]
 
     def clip(self, w, h):
         """Clips bounding boxes, segments, and keypoints values to stay within image boundaries."""
         ori_format = self._bboxes.format
-        self.convert_bbox(format='xyxy')
+        self.convert_bbox(format="xyxy")
         self.bboxes[:, [0, 2]] = self.bboxes[:, [0, 2]].clip(0, w)
         self.bboxes[:, [1, 3]] = self.bboxes[:, [1, 3]].clip(0, h)
-        if ori_format != 'xyxy':
+        if ori_format != "xyxy":
             self.convert_bbox(format=ori_format)
         self.segments[..., 0] = self.segments[..., 0].clip(0, w)
         self.segments[..., 1] = self.segments[..., 1].clip(0, h)
         if self.keypoints is not None:
             self.keypoints[..., 0] = self.keypoints[..., 0].clip(0, w)
             self.keypoints[..., 1] = self.keypoints[..., 1].clip(0, h)
 
@@ -373,15 +363,15 @@
             self.keypoints = keypoints
 
     def __len__(self):
         """Return the length of the instance list."""
         return len(self.bboxes)
 
     @classmethod
-    def concatenate(cls, instances_list: List['Instances'], axis=0) -> 'Instances':
+    def concatenate(cls, instances_list: List["Instances"], axis=0) -> "Instances":
         """
         Concatenates a list of Instances objects into a single Instances object.
 
         Args:
             instances_list (List[Instances]): A list of Instances objects to concatenate.
             axis (int, optional): The axis along which the arrays will be concatenated. Defaults to 0.
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/loss.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/loss.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,17 +2,17 @@
 
 import torch
 import torch.nn as nn
 import torch.nn.functional as F
 
 from ultralytics.utils.metrics import OKS_SIGMA
 from ultralytics.utils.ops import crop_mask, xywh2xyxy, xyxy2xywh
-from ultralytics.utils.tal import TaskAlignedAssigner, dist2bbox, make_anchors
+from ultralytics.utils.tal import RotatedTaskAlignedAssigner, TaskAlignedAssigner, dist2bbox, dist2rbox, make_anchors
 
-from .metrics import bbox_iou
+from .metrics import bbox_iou, probiou
 from .tal import bbox2dist
 
 
 class VarifocalLoss(nn.Module):
     """
     Varifocal loss by Zhang et al.
 
@@ -24,30 +24,33 @@
         super().__init__()
 
     @staticmethod
     def forward(pred_score, gt_score, label, alpha=0.75, gamma=2.0):
         """Computes varfocal loss."""
         weight = alpha * pred_score.sigmoid().pow(gamma) * (1 - label) + gt_score * label
         with torch.cuda.amp.autocast(enabled=False):
-            loss = (F.binary_cross_entropy_with_logits(pred_score.float(), gt_score.float(), reduction='none') *
-                    weight).mean(1).sum()
+            loss = (
+                (F.binary_cross_entropy_with_logits(pred_score.float(), gt_score.float(), reduction="none") * weight)
+                .mean(1)
+                .sum()
+            )
         return loss
 
 
 class FocalLoss(nn.Module):
     """Wraps focal loss around existing loss_fcn(), i.e. criteria = FocalLoss(nn.BCEWithLogitsLoss(), gamma=1.5)."""
 
-    def __init__(self, ):
+    def __init__(self):
         """Initializer for FocalLoss class with no parameters."""
         super().__init__()
 
     @staticmethod
     def forward(pred, label, gamma=1.5, alpha=0.25):
         """Calculates and updates confusion matrix for object detection/classification tasks."""
-        loss = F.binary_cross_entropy_with_logits(pred, label, reduction='none')
+        loss = F.binary_cross_entropy_with_logits(pred, label, reduction="none")
         # p_t = torch.exp(-loss)
         # loss *= self.alpha * (1.000001 - p_t) ** self.gamma  # non-zero power for gradient stability
 
         # TF implementation https://github.com/tensorflow/addons/blob/v0.7.1/tensorflow_addons/losses/focal_loss.py
         pred_prob = pred.sigmoid()  # prob from logits
         p_t = label * pred_prob + (1 - label) * (1 - pred_prob)
         modulating_factor = (1.0 - p_t) ** gamma
@@ -81,55 +84,85 @@
         else:
             loss_dfl = torch.tensor(0.0).to(pred_dist.device)
 
         return loss_iou, loss_dfl
 
     @staticmethod
     def _df_loss(pred_dist, target):
-        """Return sum of left and right DFL losses."""
-        # Distribution Focal Loss (DFL) proposed in Generalized Focal Loss https://ieeexplore.ieee.org/document/9792391
+        """
+        Return sum of left and right DFL losses.
+
+        Distribution Focal Loss (DFL) proposed in Generalized Focal Loss
+        https://ieeexplore.ieee.org/document/9792391
+        """
         tl = target.long()  # target left
         tr = tl + 1  # target right
         wl = tr - target  # weight left
         wr = 1 - wl  # weight right
-        return (F.cross_entropy(pred_dist, tl.view(-1), reduction='none').view(tl.shape) * wl +
-                F.cross_entropy(pred_dist, tr.view(-1), reduction='none').view(tl.shape) * wr).mean(-1, keepdim=True)
+        return (
+            F.cross_entropy(pred_dist, tl.view(-1), reduction="none").view(tl.shape) * wl
+            + F.cross_entropy(pred_dist, tr.view(-1), reduction="none").view(tl.shape) * wr
+        ).mean(-1, keepdim=True)
+
+
+class RotatedBboxLoss(BboxLoss):
+    """Criterion class for computing training losses during training."""
+
+    def __init__(self, reg_max, use_dfl=False):
+        """Initialize the BboxLoss module with regularization maximum and DFL settings."""
+        super().__init__(reg_max, use_dfl)
+
+    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):
+        """IoU loss."""
+        weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)
+        iou = probiou(pred_bboxes[fg_mask], target_bboxes[fg_mask])
+        loss_iou = ((1.0 - iou) * weight).sum() / target_scores_sum
+
+        # DFL loss
+        if self.use_dfl:
+            target_ltrb = bbox2dist(anchor_points, xywh2xyxy(target_bboxes[..., :4]), self.reg_max)
+            loss_dfl = self._df_loss(pred_dist[fg_mask].view(-1, self.reg_max + 1), target_ltrb[fg_mask]) * weight
+            loss_dfl = loss_dfl.sum() / target_scores_sum
+        else:
+            loss_dfl = torch.tensor(0.0).to(pred_dist.device)
+
+        return loss_iou, loss_dfl
 
 
 class KeypointLoss(nn.Module):
     """Criterion class for computing training losses."""
 
     def __init__(self, sigmas) -> None:
         """Initialize the KeypointLoss class."""
         super().__init__()
         self.sigmas = sigmas
 
     def forward(self, pred_kpts, gt_kpts, kpt_mask, area):
         """Calculates keypoint loss factor and Euclidean distance loss for predicted and actual keypoints."""
-        d = (pred_kpts[..., 0] - gt_kpts[..., 0]) ** 2 + (pred_kpts[..., 1] - gt_kpts[..., 1]) ** 2
+        d = (pred_kpts[..., 0] - gt_kpts[..., 0]).pow(2) + (pred_kpts[..., 1] - gt_kpts[..., 1]).pow(2)
         kpt_loss_factor = kpt_mask.shape[1] / (torch.sum(kpt_mask != 0, dim=1) + 1e-9)
         # e = d / (2 * (area * self.sigmas) ** 2 + 1e-9)  # from formula
-        e = d / (2 * self.sigmas) ** 2 / (area + 1e-9) / 2  # from cocoeval
+        e = d / ((2 * self.sigmas).pow(2) * (area + 1e-9) * 2)  # from cocoeval
         return (kpt_loss_factor.view(-1, 1) * ((1 - torch.exp(-e)) * kpt_mask)).mean()
 
 
 class v8DetectionLoss:
     """Criterion class for computing training losses."""
 
     def __init__(self, model):  # model must be de-paralleled
         """Initializes v8DetectionLoss with the model, defining model-related properties and BCE loss function."""
         device = next(model.parameters()).device  # get model device
         h = model.args  # hyperparameters
 
         m = model.model[-1]  # Detect() module
-        self.bce = nn.BCEWithLogitsLoss(reduction='none')
+        self.bce = nn.BCEWithLogitsLoss(reduction="none")
         self.hyp = h
         self.stride = m.stride  # model strides
         self.nc = m.nc  # number of classes
-        self.no = m.no
+        self.no = m.nc + m.reg_max * 4
         self.reg_max = m.reg_max
         self.device = device
 
         self.use_dfl = m.reg_max > 1
 
         self.assigner = TaskAlignedAssigner(topk=10, num_classes=self.nc, alpha=0.5, beta=6.0)
         self.bbox_loss = BboxLoss(m.reg_max - 1, use_dfl=self.use_dfl).to(device)
@@ -162,48 +195,55 @@
         return dist2bbox(pred_dist, anchor_points, xywh=False)
 
     def __call__(self, preds, batch):
         """Calculate the sum of the loss for box, cls and dfl multiplied by batch size."""
         loss = torch.zeros(3, device=self.device)  # box, cls, dfl
         feats = preds[1] if isinstance(preds, tuple) else preds
         pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(
-            (self.reg_max * 4, self.nc), 1)
+            (self.reg_max * 4, self.nc), 1
+        )
 
         pred_scores = pred_scores.permute(0, 2, 1).contiguous()
         pred_distri = pred_distri.permute(0, 2, 1).contiguous()
 
         dtype = pred_scores.dtype
         batch_size = pred_scores.shape[0]
         imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)
         anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)
 
         # Targets
-        targets = torch.cat((batch['batch_idx'].view(-1, 1), batch['cls'].view(-1, 1), batch['bboxes']), 1)
+        targets = torch.cat((batch["batch_idx"].view(-1, 1), batch["cls"].view(-1, 1), batch["bboxes"]), 1)
         targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])
         gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy
         mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)
 
         # Pboxes
         pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)
 
         _, target_bboxes, target_scores, fg_mask, _ = self.assigner(
-            pred_scores.detach().sigmoid(), (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),
-            anchor_points * stride_tensor, gt_labels, gt_bboxes, mask_gt)
+            pred_scores.detach().sigmoid(),
+            (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),
+            anchor_points * stride_tensor,
+            gt_labels,
+            gt_bboxes,
+            mask_gt,
+        )
 
         target_scores_sum = max(target_scores.sum(), 1)
 
         # Cls loss
         # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way
         loss[1] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE
 
         # Bbox loss
         if fg_mask.sum():
             target_bboxes /= stride_tensor
-            loss[0], loss[2] = self.bbox_loss(pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores,
-                                              target_scores_sum, fg_mask)
+            loss[0], loss[2] = self.bbox_loss(
+                pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask
+            )
 
         loss[0] *= self.hyp.box  # box gain
         loss[1] *= self.hyp.cls  # cls gain
         loss[2] *= self.hyp.dfl  # dfl gain
 
         return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)
 
@@ -218,78 +258,95 @@
 
     def __call__(self, preds, batch):
         """Calculate and return the loss for the YOLO model."""
         loss = torch.zeros(4, device=self.device)  # box, cls, dfl
         feats, pred_masks, proto = preds if len(preds) == 3 else preds[1]
         batch_size, _, mask_h, mask_w = proto.shape  # batch size, number of masks, mask height, mask width
         pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(
-            (self.reg_max * 4, self.nc), 1)
+            (self.reg_max * 4, self.nc), 1
+        )
 
         # B, grids, ..
         pred_scores = pred_scores.permute(0, 2, 1).contiguous()
         pred_distri = pred_distri.permute(0, 2, 1).contiguous()
         pred_masks = pred_masks.permute(0, 2, 1).contiguous()
 
         dtype = pred_scores.dtype
         imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)
         anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)
 
         # Targets
         try:
-            batch_idx = batch['batch_idx'].view(-1, 1)
-            targets = torch.cat((batch_idx, batch['cls'].view(-1, 1), batch['bboxes']), 1)
+            batch_idx = batch["batch_idx"].view(-1, 1)
+            targets = torch.cat((batch_idx, batch["cls"].view(-1, 1), batch["bboxes"]), 1)
             targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])
             gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy
             mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)
         except RuntimeError as e:
-            raise TypeError('ERROR  segment dataset incorrectly formatted or not a segment dataset.\n'
-                            "This error can occur when incorrectly training a 'segment' model on a 'detect' dataset, "
-                            "i.e. 'yolo train model=yolov8n-seg.pt data=coco128.yaml'.\nVerify your dataset is a "
-                            "correctly formatted 'segment' dataset using 'data=coco128-seg.yaml' "
-                            'as an example.\nSee https://docs.ultralytics.com/tasks/segment/ for help.') from e
+            raise TypeError(
+                "ERROR  segment dataset incorrectly formatted or not a segment dataset.\n"
+                "This error can occur when incorrectly training a 'segment' model on a 'detect' dataset, "
+                "i.e. 'yolo train model=yolov8n-seg.pt data=coco8.yaml'.\nVerify your dataset is a "
+                "correctly formatted 'segment' dataset using 'data=coco8-seg.yaml' "
+                "as an example.\nSee https://docs.ultralytics.com/datasets/segment/ for help."
+            ) from e
 
         # Pboxes
         pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)
 
         _, target_bboxes, target_scores, fg_mask, target_gt_idx = self.assigner(
-            pred_scores.detach().sigmoid(), (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),
-            anchor_points * stride_tensor, gt_labels, gt_bboxes, mask_gt)
+            pred_scores.detach().sigmoid(),
+            (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),
+            anchor_points * stride_tensor,
+            gt_labels,
+            gt_bboxes,
+            mask_gt,
+        )
 
         target_scores_sum = max(target_scores.sum(), 1)
 
         # Cls loss
         # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way
         loss[2] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE
 
         if fg_mask.sum():
             # Bbox loss
-            loss[0], loss[3] = self.bbox_loss(pred_distri, pred_bboxes, anchor_points, target_bboxes / stride_tensor,
-                                              target_scores, target_scores_sum, fg_mask)
+            loss[0], loss[3] = self.bbox_loss(
+                pred_distri,
+                pred_bboxes,
+                anchor_points,
+                target_bboxes / stride_tensor,
+                target_scores,
+                target_scores_sum,
+                fg_mask,
+            )
             # Masks loss
-            masks = batch['masks'].to(self.device).float()
+            masks = batch["masks"].to(self.device).float()
             if tuple(masks.shape[-2:]) != (mask_h, mask_w):  # downsample
-                masks = F.interpolate(masks[None], (mask_h, mask_w), mode='nearest')[0]
+                masks = F.interpolate(masks[None], (mask_h, mask_w), mode="nearest")[0]
 
-            loss[1] = self.calculate_segmentation_loss(fg_mask, masks, target_gt_idx, target_bboxes, batch_idx, proto,
-                                                       pred_masks, imgsz, self.overlap)
+            loss[1] = self.calculate_segmentation_loss(
+                fg_mask, masks, target_gt_idx, target_bboxes, batch_idx, proto, pred_masks, imgsz, self.overlap
+            )
 
         # WARNING: lines below prevent Multi-GPU DDP 'unused gradient' PyTorch errors, do not remove
         else:
             loss[1] += (proto * 0).sum() + (pred_masks * 0).sum()  # inf sums may lead to nan loss
 
         loss[0] *= self.hyp.box  # box gain
         loss[1] *= self.hyp.box  # seg gain
         loss[2] *= self.hyp.cls  # cls gain
         loss[3] *= self.hyp.dfl  # dfl gain
 
         return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)
 
     @staticmethod
-    def single_mask_loss(gt_mask: torch.Tensor, pred: torch.Tensor, proto: torch.Tensor, xyxy: torch.Tensor,
-                         area: torch.Tensor) -> torch.Tensor:
+    def single_mask_loss(
+        gt_mask: torch.Tensor, pred: torch.Tensor, proto: torch.Tensor, xyxy: torch.Tensor, area: torch.Tensor
+    ) -> torch.Tensor:
         """
         Compute the instance segmentation loss for a single image.
 
         Args:
             gt_mask (torch.Tensor): Ground truth mask of shape (n, H, W), where n is the number of objects.
             pred (torch.Tensor): Predicted mask coefficients of shape (n, 32).
             proto (torch.Tensor): Prototype masks of shape (32, H, W).
@@ -299,16 +356,16 @@
         Returns:
             (torch.Tensor): The calculated mask loss for a single image.
 
         Notes:
             The function uses the equation pred_mask = torch.einsum('in,nhw->ihw', pred, proto) to produce the
             predicted masks from the prototype masks and predicted mask coefficients.
         """
-        pred_mask = torch.einsum('in,nhw->ihw', pred, proto)  # (n, 32) @ (32, 80, 80) -> (n, 80, 80)
-        loss = F.binary_cross_entropy_with_logits(pred_mask, gt_mask, reduction='none')
+        pred_mask = torch.einsum("in,nhw->ihw", pred, proto)  # (n, 32) @ (32, 80, 80) -> (n, 80, 80)
+        loss = F.binary_cross_entropy_with_logits(pred_mask, gt_mask, reduction="none")
         return (crop_mask(loss, xyxy).mean(dim=(1, 2)) / area).sum()
 
     def calculate_segmentation_loss(
         self,
         fg_mask: torch.Tensor,
         masks: torch.Tensor,
         target_gt_idx: torch.Tensor,
@@ -359,16 +416,17 @@
                 mask_idx = target_gt_idx_i[fg_mask_i]
                 if overlap:
                     gt_mask = masks_i == (mask_idx + 1).view(-1, 1, 1)
                     gt_mask = gt_mask.float()
                 else:
                     gt_mask = masks[batch_idx.view(-1) == i][mask_idx]
 
-                loss += self.single_mask_loss(gt_mask, pred_masks_i[fg_mask_i], proto_i, mxyxy_i[fg_mask_i],
-                                              marea_i[fg_mask_i])
+                loss += self.single_mask_loss(
+                    gt_mask, pred_masks_i[fg_mask_i], proto_i, mxyxy_i[fg_mask_i], marea_i[fg_mask_i]
+                )
 
             # WARNING: lines below prevents Multi-GPU DDP 'unused gradient' PyTorch errors, do not remove
             else:
                 loss += (proto * 0).sum() + (pred_masks * 0).sum()  # inf sums may lead to nan loss
 
         return loss / fg_mask.sum()
 
@@ -387,58 +445,66 @@
         self.keypoint_loss = KeypointLoss(sigmas=sigmas)
 
     def __call__(self, preds, batch):
         """Calculate the total loss and detach it."""
         loss = torch.zeros(5, device=self.device)  # box, cls, dfl, kpt_location, kpt_visibility
         feats, pred_kpts = preds if isinstance(preds[0], list) else preds[1]
         pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(
-            (self.reg_max * 4, self.nc), 1)
+            (self.reg_max * 4, self.nc), 1
+        )
 
         # B, grids, ..
         pred_scores = pred_scores.permute(0, 2, 1).contiguous()
         pred_distri = pred_distri.permute(0, 2, 1).contiguous()
         pred_kpts = pred_kpts.permute(0, 2, 1).contiguous()
 
         dtype = pred_scores.dtype
         imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)
         anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)
 
         # Targets
         batch_size = pred_scores.shape[0]
-        batch_idx = batch['batch_idx'].view(-1, 1)
-        targets = torch.cat((batch_idx, batch['cls'].view(-1, 1), batch['bboxes']), 1)
+        batch_idx = batch["batch_idx"].view(-1, 1)
+        targets = torch.cat((batch_idx, batch["cls"].view(-1, 1), batch["bboxes"]), 1)
         targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])
         gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy
         mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)
 
         # Pboxes
         pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)
         pred_kpts = self.kpts_decode(anchor_points, pred_kpts.view(batch_size, -1, *self.kpt_shape))  # (b, h*w, 17, 3)
 
         _, target_bboxes, target_scores, fg_mask, target_gt_idx = self.assigner(
-            pred_scores.detach().sigmoid(), (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),
-            anchor_points * stride_tensor, gt_labels, gt_bboxes, mask_gt)
+            pred_scores.detach().sigmoid(),
+            (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),
+            anchor_points * stride_tensor,
+            gt_labels,
+            gt_bboxes,
+            mask_gt,
+        )
 
         target_scores_sum = max(target_scores.sum(), 1)
 
         # Cls loss
         # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way
         loss[3] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE
 
         # Bbox loss
         if fg_mask.sum():
             target_bboxes /= stride_tensor
-            loss[0], loss[4] = self.bbox_loss(pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores,
-                                              target_scores_sum, fg_mask)
-            keypoints = batch['keypoints'].to(self.device).float().clone()
+            loss[0], loss[4] = self.bbox_loss(
+                pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask
+            )
+            keypoints = batch["keypoints"].to(self.device).float().clone()
             keypoints[..., 0] *= imgsz[1]
             keypoints[..., 1] *= imgsz[0]
 
-            loss[1], loss[2] = self.calculate_keypoints_loss(fg_mask, target_gt_idx, keypoints, batch_idx,
-                                                             stride_tensor, target_bboxes, pred_kpts)
+            loss[1], loss[2] = self.calculate_keypoints_loss(
+                fg_mask, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes, pred_kpts
+            )
 
         loss[0] *= self.hyp.box  # box gain
         loss[1] *= self.hyp.pose  # pose gain
         loss[2] *= self.hyp.kobj  # kobj gain
         loss[3] *= self.hyp.cls  # cls gain
         loss[4] *= self.hyp.dfl  # dfl gain
 
@@ -449,16 +515,17 @@
         """Decodes predicted keypoints to image coordinates."""
         y = pred_kpts.clone()
         y[..., :2] *= 2.0
         y[..., 0] += anchor_points[:, [0]] - 0.5
         y[..., 1] += anchor_points[:, [1]] - 0.5
         return y
 
-    def calculate_keypoints_loss(self, masks, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes,
-                                 pred_kpts):
+    def calculate_keypoints_loss(
+        self, masks, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes, pred_kpts
+    ):
         """
         Calculate the keypoints loss for the model.
 
         This function calculates the keypoints loss and keypoints object loss for a given batch. The keypoints loss is
         based on the difference between the predicted keypoints and ground truth keypoints. The keypoints object loss is
         a binary classification loss that classifies whether a keypoint is present or not.
 
@@ -479,29 +546,31 @@
         batch_idx = batch_idx.flatten()
         batch_size = len(masks)
 
         # Find the maximum number of keypoints in a single image
         max_kpts = torch.unique(batch_idx, return_counts=True)[1].max()
 
         # Create a tensor to hold batched keypoints
-        batched_keypoints = torch.zeros((batch_size, max_kpts, keypoints.shape[1], keypoints.shape[2]),
-                                        device=keypoints.device)
+        batched_keypoints = torch.zeros(
+            (batch_size, max_kpts, keypoints.shape[1], keypoints.shape[2]), device=keypoints.device
+        )
 
         # TODO: any idea how to vectorize this?
         # Fill batched_keypoints with keypoints based on batch_idx
         for i in range(batch_size):
             keypoints_i = keypoints[batch_idx == i]
-            batched_keypoints[i, :keypoints_i.shape[0]] = keypoints_i
+            batched_keypoints[i, : keypoints_i.shape[0]] = keypoints_i
 
         # Expand dimensions of target_gt_idx to match the shape of batched_keypoints
         target_gt_idx_expanded = target_gt_idx.unsqueeze(-1).unsqueeze(-1)
 
         # Use target_gt_idx_expanded to select keypoints from batched_keypoints
         selected_keypoints = batched_keypoints.gather(
-            1, target_gt_idx_expanded.expand(-1, -1, keypoints.shape[1], keypoints.shape[2]))
+            1, target_gt_idx_expanded.expand(-1, -1, keypoints.shape[1], keypoints.shape[2])
+        )
 
         # Divide coordinates by stride
         selected_keypoints /= stride_tensor.view(1, -1, 1, 1)
 
         kpts_loss = 0
         kpts_obj_loss = 0
 
@@ -519,10 +588,129 @@
 
 
 class v8ClassificationLoss:
     """Criterion class for computing training losses."""
 
     def __call__(self, preds, batch):
         """Compute the classification loss between predictions and true labels."""
-        loss = torch.nn.functional.cross_entropy(preds, batch['cls'], reduction='mean')
+        loss = torch.nn.functional.cross_entropy(preds, batch["cls"], reduction="mean")
         loss_items = loss.detach()
         return loss, loss_items
+
+
+class v8OBBLoss(v8DetectionLoss):
+    def __init__(self, model):
+        """
+        Initializes v8OBBLoss with model, assigner, and rotated bbox loss.
+
+        Note model must be de-paralleled.
+        """
+        super().__init__(model)
+        self.assigner = RotatedTaskAlignedAssigner(topk=10, num_classes=self.nc, alpha=0.5, beta=6.0)
+        self.bbox_loss = RotatedBboxLoss(self.reg_max - 1, use_dfl=self.use_dfl).to(self.device)
+
+    def preprocess(self, targets, batch_size, scale_tensor):
+        """Preprocesses the target counts and matches with the input batch size to output a tensor."""
+        if targets.shape[0] == 0:
+            out = torch.zeros(batch_size, 0, 6, device=self.device)
+        else:
+            i = targets[:, 0]  # image index
+            _, counts = i.unique(return_counts=True)
+            counts = counts.to(dtype=torch.int32)
+            out = torch.zeros(batch_size, counts.max(), 6, device=self.device)
+            for j in range(batch_size):
+                matches = i == j
+                n = matches.sum()
+                if n:
+                    bboxes = targets[matches, 2:]
+                    bboxes[..., :4].mul_(scale_tensor)
+                    out[j, :n] = torch.cat([targets[matches, 1:2], bboxes], dim=-1)
+        return out
+
+    def __call__(self, preds, batch):
+        """Calculate and return the loss for the YOLO model."""
+        loss = torch.zeros(3, device=self.device)  # box, cls, dfl
+        feats, pred_angle = preds if isinstance(preds[0], list) else preds[1]
+        batch_size = pred_angle.shape[0]  # batch size, number of masks, mask height, mask width
+        pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(
+            (self.reg_max * 4, self.nc), 1
+        )
+
+        # b, grids, ..
+        pred_scores = pred_scores.permute(0, 2, 1).contiguous()
+        pred_distri = pred_distri.permute(0, 2, 1).contiguous()
+        pred_angle = pred_angle.permute(0, 2, 1).contiguous()
+
+        dtype = pred_scores.dtype
+        imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)
+        anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)
+
+        # targets
+        try:
+            batch_idx = batch["batch_idx"].view(-1, 1)
+            targets = torch.cat((batch_idx, batch["cls"].view(-1, 1), batch["bboxes"].view(-1, 5)), 1)
+            rw, rh = targets[:, 4] * imgsz[0].item(), targets[:, 5] * imgsz[1].item()
+            targets = targets[(rw >= 2) & (rh >= 2)]  # filter rboxes of tiny size to stabilize training
+            targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])
+            gt_labels, gt_bboxes = targets.split((1, 5), 2)  # cls, xywhr
+            mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)
+        except RuntimeError as e:
+            raise TypeError(
+                "ERROR  OBB dataset incorrectly formatted or not a OBB dataset.\n"
+                "This error can occur when incorrectly training a 'OBB' model on a 'detect' dataset, "
+                "i.e. 'yolo train model=yolov8n-obb.pt data=dota8.yaml'.\nVerify your dataset is a "
+                "correctly formatted 'OBB' dataset using 'data=dota8.yaml' "
+                "as an example.\nSee https://docs.ultralytics.com/datasets/obb/ for help."
+            ) from e
+
+        # Pboxes
+        pred_bboxes = self.bbox_decode(anchor_points, pred_distri, pred_angle)  # xyxy, (b, h*w, 4)
+
+        bboxes_for_assigner = pred_bboxes.clone().detach()
+        # Only the first four elements need to be scaled
+        bboxes_for_assigner[..., :4] *= stride_tensor
+        _, target_bboxes, target_scores, fg_mask, _ = self.assigner(
+            pred_scores.detach().sigmoid(),
+            bboxes_for_assigner.type(gt_bboxes.dtype),
+            anchor_points * stride_tensor,
+            gt_labels,
+            gt_bboxes,
+            mask_gt,
+        )
+
+        target_scores_sum = max(target_scores.sum(), 1)
+
+        # Cls loss
+        # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way
+        loss[1] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE
+
+        # Bbox loss
+        if fg_mask.sum():
+            target_bboxes[..., :4] /= stride_tensor
+            loss[0], loss[2] = self.bbox_loss(
+                pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask
+            )
+        else:
+            loss[0] += (pred_angle * 0).sum()
+
+        loss[0] *= self.hyp.box  # box gain
+        loss[1] *= self.hyp.cls  # cls gain
+        loss[2] *= self.hyp.dfl  # dfl gain
+
+        return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)
+
+    def bbox_decode(self, anchor_points, pred_dist, pred_angle):
+        """
+        Decode predicted object bounding box coordinates from anchor points and distribution.
+
+        Args:
+            anchor_points (torch.Tensor): Anchor points, (h*w, 2).
+            pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).
+            pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).
+
+        Returns:
+            (torch.Tensor): Predicted rotated bounding boxes with angles, (bs, h*w, 5).
+        """
+        if self.use_dfl:
+            b, a, c = pred_dist.shape  # batch, anchors, channels
+            pred_dist = pred_dist.view(b, a, 4, c // 4).softmax(3).matmul(self.proj.type(pred_dist.dtype))
+        return torch.cat((dist2rbox(pred_dist, pred_angle, anchor_points), pred_angle), dim=-1)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/metrics.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/metrics.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,38 +7,42 @@
 
 import matplotlib.pyplot as plt
 import numpy as np
 import torch
 
 from ultralytics.utils import LOGGER, SimpleClass, TryExcept, plt_settings
 
-OKS_SIGMA = np.array([.26, .25, .25, .35, .35, .79, .79, .72, .72, .62, .62, 1.07, 1.07, .87, .87, .89, .89]) / 10.0
+OKS_SIGMA = (
+    np.array([0.26, 0.25, 0.25, 0.35, 0.35, 0.79, 0.79, 0.72, 0.72, 0.62, 0.62, 1.07, 1.07, 0.87, 0.87, 0.89, 0.89])
+    / 10.0
+)
 
 
 def bbox_ioa(box1, box2, iou=False, eps=1e-7):
     """
     Calculate the intersection over box2 area given box1 and box2. Boxes are in x1y1x2y2 format.
 
     Args:
-        box1 (np.array): A numpy array of shape (n, 4) representing n bounding boxes.
-        box2 (np.array): A numpy array of shape (m, 4) representing m bounding boxes.
-        iou (bool): Calculate the standard iou if True else return inter_area/box2_area.
+        box1 (np.ndarray): A numpy array of shape (n, 4) representing n bounding boxes.
+        box2 (np.ndarray): A numpy array of shape (m, 4) representing m bounding boxes.
+        iou (bool): Calculate the standard IoU if True else return inter_area/box2_area.
         eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.
 
     Returns:
-        (np.array): A numpy array of shape (n, m) representing the intersection over box2 area.
+        (np.ndarray): A numpy array of shape (n, m) representing the intersection over box2 area.
     """
 
     # Get the coordinates of bounding boxes
     b1_x1, b1_y1, b1_x2, b1_y2 = box1.T
     b2_x1, b2_y1, b2_x2, b2_y2 = box2.T
 
     # Intersection area
-    inter_area = (np.minimum(b1_x2[:, None], b2_x2) - np.maximum(b1_x1[:, None], b2_x1)).clip(0) * \
-                 (np.minimum(b1_y2[:, None], b2_y2) - np.maximum(b1_y1[:, None], b2_y1)).clip(0)
+    inter_area = (np.minimum(b1_x2[:, None], b2_x2) - np.maximum(b1_x1[:, None], b2_x1)).clip(0) * (
+        np.minimum(b1_y2[:, None], b2_y2) - np.maximum(b1_y1[:, None], b2_y1)
+    ).clip(0)
 
     # Box2 area
     area = (b2_x2 - b2_x1) * (b2_y2 - b2_y1)
     if iou:
         box1_area = (b1_x2 - b1_x1) * (b1_y2 - b1_y1)
         area = area + box1_area[:, None] - inter_area
 
@@ -95,30 +99,33 @@
     else:  # x1, y1, x2, y2 = box1
         b1_x1, b1_y1, b1_x2, b1_y2 = box1.chunk(4, -1)
         b2_x1, b2_y1, b2_x2, b2_y2 = box2.chunk(4, -1)
         w1, h1 = b1_x2 - b1_x1, b1_y2 - b1_y1 + eps
         w2, h2 = b2_x2 - b2_x1, b2_y2 - b2_y1 + eps
 
     # Intersection area
-    inter = (b1_x2.minimum(b2_x2) - b1_x1.maximum(b2_x1)).clamp_(0) * \
-            (b1_y2.minimum(b2_y2) - b1_y1.maximum(b2_y1)).clamp_(0)
+    inter = (b1_x2.minimum(b2_x2) - b1_x1.maximum(b2_x1)).clamp_(0) * (
+        b1_y2.minimum(b2_y2) - b1_y1.maximum(b2_y1)
+    ).clamp_(0)
 
     # Union Area
     union = w1 * h1 + w2 * h2 - inter + eps
 
     # IoU
     iou = inter / union
     if CIoU or DIoU or GIoU:
         cw = b1_x2.maximum(b2_x2) - b1_x1.minimum(b2_x1)  # convex (smallest enclosing box) width
         ch = b1_y2.maximum(b2_y2) - b1_y1.minimum(b2_y1)  # convex height
         if CIoU or DIoU:  # Distance or Complete IoU https://arxiv.org/abs/1911.08287v1
-            c2 = cw ** 2 + ch ** 2 + eps  # convex diagonal squared
-            rho2 = ((b2_x1 + b2_x2 - b1_x1 - b1_x2) ** 2 + (b2_y1 + b2_y2 - b1_y1 - b1_y2) ** 2) / 4  # center dist ** 2
+            c2 = cw.pow(2) + ch.pow(2) + eps  # convex diagonal squared
+            rho2 = (
+                (b2_x1 + b2_x2 - b1_x1 - b1_x2).pow(2) + (b2_y1 + b2_y2 - b1_y1 - b1_y2).pow(2)
+            ) / 4  # center dist**2
             if CIoU:  # https://github.com/Zzh-tju/DIoU-SSD-pytorch/blob/master/utils/box/box_utils.py#L47
-                v = (4 / math.pi ** 2) * (torch.atan(w2 / h2) - torch.atan(w1 / h1)).pow(2)
+                v = (4 / math.pi**2) * ((w2 / h2).atan() - (w1 / h1).atan()).pow(2)
                 with torch.no_grad():
                     alpha = v / (v - iou + (1 + eps))
                 return iou - (rho2 / c2 + v * alpha)  # CIoU
             return iou - rho2 / c2  # DIoU
         c_area = cw * ch + eps  # convex area
         return iou - (c_area - union) / c_area  # GIoU https://arxiv.org/pdf/1902.09630.pdf
     return iou  # IoU
@@ -153,20 +160,113 @@
         area (torch.Tensor): A tensor of shape (N,) representing areas from ground truth.
         sigma (list): A list containing 17 values representing keypoint scales.
         eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.
 
     Returns:
         (torch.Tensor): A tensor of shape (N, M) representing keypoint similarities.
     """
-    d = (kpt1[:, None, :, 0] - kpt2[..., 0]) ** 2 + (kpt1[:, None, :, 1] - kpt2[..., 1]) ** 2  # (N, M, 17)
+    d = (kpt1[:, None, :, 0] - kpt2[..., 0]).pow(2) + (kpt1[:, None, :, 1] - kpt2[..., 1]).pow(2)  # (N, M, 17)
     sigma = torch.tensor(sigma, device=kpt1.device, dtype=kpt1.dtype)  # (17, )
     kpt_mask = kpt1[..., 2] != 0  # (N, 17)
-    e = d / (2 * sigma) ** 2 / (area[:, None, None] + eps) / 2  # from cocoeval
+    e = d / ((2 * sigma).pow(2) * (area[:, None, None] + eps) * 2)  # from cocoeval
     # e = d / ((area[None, :, None] + eps) * sigma) ** 2 / 2  # from formula
-    return (torch.exp(-e) * kpt_mask[:, None]).sum(-1) / (kpt_mask.sum(-1)[:, None] + eps)
+    return ((-e).exp() * kpt_mask[:, None]).sum(-1) / (kpt_mask.sum(-1)[:, None] + eps)
+
+
+def _get_covariance_matrix(boxes):
+    """
+    Generating covariance matrix from obbs.
+
+    Args:
+        boxes (torch.Tensor): A tensor of shape (N, 5) representing rotated bounding boxes, with xywhr format.
+
+    Returns:
+        (torch.Tensor): Covariance metrixs corresponding to original rotated bounding boxes.
+    """
+    # Gaussian bounding boxes, ignore the center points (the first two columns) because they are not needed here.
+    gbbs = torch.cat((boxes[:, 2:4].pow(2) / 12, boxes[:, 4:]), dim=-1)
+    a, b, c = gbbs.split(1, dim=-1)
+    cos = c.cos()
+    sin = c.sin()
+    cos2 = cos.pow(2)
+    sin2 = sin.pow(2)
+    return a * cos2 + b * sin2, a * sin2 + b * cos2, (a - b) * cos * sin
+
+
+def probiou(obb1, obb2, CIoU=False, eps=1e-7):
+    """
+    Calculate the prob IoU between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.
+
+    Args:
+        obb1 (torch.Tensor): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.
+        obb2 (torch.Tensor): A tensor of shape (N, 5) representing predicted obbs, with xywhr format.
+        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.
+
+    Returns:
+        (torch.Tensor): A tensor of shape (N, ) representing obb similarities.
+    """
+    x1, y1 = obb1[..., :2].split(1, dim=-1)
+    x2, y2 = obb2[..., :2].split(1, dim=-1)
+    a1, b1, c1 = _get_covariance_matrix(obb1)
+    a2, b2, c2 = _get_covariance_matrix(obb2)
+
+    t1 = (
+        ((a1 + a2) * (y1 - y2).pow(2) + (b1 + b2) * (x1 - x2).pow(2)) / ((a1 + a2) * (b1 + b2) - (c1 + c2).pow(2) + eps)
+    ) * 0.25
+    t2 = (((c1 + c2) * (x2 - x1) * (y1 - y2)) / ((a1 + a2) * (b1 + b2) - (c1 + c2).pow(2) + eps)) * 0.5
+    t3 = (
+        ((a1 + a2) * (b1 + b2) - (c1 + c2).pow(2))
+        / (4 * ((a1 * b1 - c1.pow(2)).clamp_(0) * (a2 * b2 - c2.pow(2)).clamp_(0)).sqrt() + eps)
+        + eps
+    ).log() * 0.5
+    bd = (t1 + t2 + t3).clamp(eps, 100.0)
+    hd = (1.0 - (-bd).exp() + eps).sqrt()
+    iou = 1 - hd
+    if CIoU:  # only include the wh aspect ratio part
+        w1, h1 = obb1[..., 2:4].split(1, dim=-1)
+        w2, h2 = obb2[..., 2:4].split(1, dim=-1)
+        v = (4 / math.pi**2) * ((w2 / h2).atan() - (w1 / h1).atan()).pow(2)
+        with torch.no_grad():
+            alpha = v / (v - iou + (1 + eps))
+        return iou - v * alpha  # CIoU
+    return iou
+
+
+def batch_probiou(obb1, obb2, eps=1e-7):
+    """
+    Calculate the prob IoU between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.
+
+    Args:
+        obb1 (torch.Tensor | np.ndarray): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.
+        obb2 (torch.Tensor | np.ndarray): A tensor of shape (M, 5) representing predicted obbs, with xywhr format.
+        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.
+
+    Returns:
+        (torch.Tensor): A tensor of shape (N, M) representing obb similarities.
+    """
+    obb1 = torch.from_numpy(obb1) if isinstance(obb1, np.ndarray) else obb1
+    obb2 = torch.from_numpy(obb2) if isinstance(obb2, np.ndarray) else obb2
+
+    x1, y1 = obb1[..., :2].split(1, dim=-1)
+    x2, y2 = (x.squeeze(-1)[None] for x in obb2[..., :2].split(1, dim=-1))
+    a1, b1, c1 = _get_covariance_matrix(obb1)
+    a2, b2, c2 = (x.squeeze(-1)[None] for x in _get_covariance_matrix(obb2))
+
+    t1 = (
+        ((a1 + a2) * (y1 - y2).pow(2) + (b1 + b2) * (x1 - x2).pow(2)) / ((a1 + a2) * (b1 + b2) - (c1 + c2).pow(2) + eps)
+    ) * 0.25
+    t2 = (((c1 + c2) * (x2 - x1) * (y1 - y2)) / ((a1 + a2) * (b1 + b2) - (c1 + c2).pow(2) + eps)) * 0.5
+    t3 = (
+        ((a1 + a2) * (b1 + b2) - (c1 + c2).pow(2))
+        / (4 * ((a1 * b1 - c1.pow(2)).clamp_(0) * (a2 * b2 - c2.pow(2)).clamp_(0)).sqrt() + eps)
+        + eps
+    ).log() * 0.5
+    bd = (t1 + t2 + t3).clamp(eps, 100.0)
+    hd = (1.0 - (-bd).exp() + eps).sqrt()
+    return 1 - hd
 
 
 def smooth_BCE(eps=0.1):
     """
     Computes smoothed positive and negative Binary Cross-Entropy targets.
 
     This function calculates positive and negative label smoothing BCE targets based on a given epsilon value.
@@ -183,67 +283,73 @@
 
 class ConfusionMatrix:
     """
     A class for calculating and updating a confusion matrix for object detection and classification tasks.
 
     Attributes:
         task (str): The type of task, either 'detect' or 'classify'.
-        matrix (np.array): The confusion matrix, with dimensions depending on the task.
+        matrix (np.ndarray): The confusion matrix, with dimensions depending on the task.
         nc (int): The number of classes.
         conf (float): The confidence threshold for detections.
         iou_thres (float): The Intersection over Union threshold.
     """
 
-    def __init__(self, nc, conf=0.25, iou_thres=0.45, task='detect'):
+    def __init__(self, nc, conf=0.25, iou_thres=0.45, task="detect"):
         """Initialize attributes for the YOLO model."""
         self.task = task
-        self.matrix = np.zeros((nc + 1, nc + 1)) if self.task == 'detect' else np.zeros((nc, nc))
+        self.matrix = np.zeros((nc + 1, nc + 1)) if self.task == "detect" else np.zeros((nc, nc))
         self.nc = nc  # number of classes
-        self.conf = 0.25 if conf in (None, 0.001) else conf  # apply 0.25 if default val conf is passed
+        self.conf = 0.25 if conf in {None, 0.001} else conf  # apply 0.25 if default val conf is passed
         self.iou_thres = iou_thres
 
     def process_cls_preds(self, preds, targets):
         """
         Update confusion matrix for classification task.
 
         Args:
             preds (Array[N, min(nc,5)]): Predicted class labels.
             targets (Array[N, 1]): Ground truth class labels.
         """
         preds, targets = torch.cat(preds)[:, 0], torch.cat(targets)
         for p, t in zip(preds.cpu().numpy(), targets.cpu().numpy()):
             self.matrix[p][t] += 1
 
-    def process_batch(self, detections, labels):
+    def process_batch(self, detections, gt_bboxes, gt_cls):
         """
         Update confusion matrix for object detection task.
 
         Args:
-            detections (Array[N, 6]): Detected bounding boxes and their associated information.
-                                      Each row should contain (x1, y1, x2, y2, conf, class).
-            labels (Array[M, 5]): Ground truth bounding boxes and their associated class labels.
-                                  Each row should contain (class, x1, y1, x2, y2).
+            detections (Array[N, 6] | Array[N, 7]): Detected bounding boxes and their associated information.
+                                      Each row should contain (x1, y1, x2, y2, conf, class)
+                                      or with an additional element `angle` when it's obb.
+            gt_bboxes (Array[M, 4]| Array[N, 5]): Ground truth bounding boxes with xyxy/xyxyr format.
+            gt_cls (Array[M]): The class labels.
         """
-        if labels.size(0) == 0:  # Check if labels is empty
+        if gt_cls.shape[0] == 0:  # Check if labels is empty
             if detections is not None:
                 detections = detections[detections[:, 4] > self.conf]
                 detection_classes = detections[:, 5].int()
                 for dc in detection_classes:
                     self.matrix[dc, self.nc] += 1  # false positives
             return
         if detections is None:
-            gt_classes = labels.int()
+            gt_classes = gt_cls.int()
             for gc in gt_classes:
                 self.matrix[self.nc, gc] += 1  # background FN
             return
 
         detections = detections[detections[:, 4] > self.conf]
-        gt_classes = labels[:, 0].int()
+        gt_classes = gt_cls.int()
         detection_classes = detections[:, 5].int()
-        iou = box_iou(labels[:, 1:], detections[:, :4])
+        is_obb = detections.shape[1] == 7 and gt_bboxes.shape[1] == 5  # with additional `angle` dimension
+        iou = (
+            batch_probiou(gt_bboxes, torch.cat([detections[:, :4], detections[:, -1:]], dim=-1))
+            if is_obb
+            else box_iou(gt_bboxes, detections[:, :4])
+        )
 
         x = torch.where(iou > self.iou_thres)
         if x[0].shape[0]:
             matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()
             if x[0].shape[0] > 1:
                 matches = matches[matches[:, 2].argsort()[::-1]]
                 matches = matches[np.unique(matches[:, 1], return_index=True)[1]]
@@ -271,119 +377,120 @@
         return self.matrix
 
     def tp_fp(self):
         """Returns true positives and false positives."""
         tp = self.matrix.diagonal()  # true positives
         fp = self.matrix.sum(1) - tp  # false positives
         # fn = self.matrix.sum(0) - tp  # false negatives (missed detections)
-        return (tp[:-1], fp[:-1]) if self.task == 'detect' else (tp, fp)  # remove background class if task=detect
+        return (tp[:-1], fp[:-1]) if self.task == "detect" else (tp, fp)  # remove background class if task=detect
 
-    @TryExcept('WARNING  ConfusionMatrix plot failure')
+    @TryExcept("WARNING  ConfusionMatrix plot failure")
     @plt_settings()
-    def plot(self, normalize=True, save_dir='', names=(), on_plot=None):
+    def plot(self, normalize=True, save_dir="", names=(), on_plot=None):
         """
         Plot the confusion matrix using seaborn and save it to a file.
 
         Args:
             normalize (bool): Whether to normalize the confusion matrix.
             save_dir (str): Directory where the plot will be saved.
             names (tuple): Names of classes, used as labels on the plot.
             on_plot (func): An optional callback to pass plots path and data when they are rendered.
         """
-        import seaborn as sn
+        import seaborn  # scope for faster 'import ultralytics'
 
-        array = self.matrix / ((self.matrix.sum(0).reshape(1, -1) + 1E-9) if normalize else 1)  # normalize columns
+        array = self.matrix / ((self.matrix.sum(0).reshape(1, -1) + 1e-9) if normalize else 1)  # normalize columns
         array[array < 0.005] = np.nan  # don't annotate (would appear as 0.00)
 
         fig, ax = plt.subplots(1, 1, figsize=(12, 9), tight_layout=True)
         nc, nn = self.nc, len(names)  # number of classes, names
-        sn.set(font_scale=1.0 if nc < 50 else 0.8)  # for label size
+        seaborn.set_theme(font_scale=1.0 if nc < 50 else 0.8)  # for label size
         labels = (0 < nn < 99) and (nn == nc)  # apply names to ticklabels
-        ticklabels = (list(names) + ['background']) if labels else 'auto'
+        ticklabels = (list(names) + ["background"]) if labels else "auto"
         with warnings.catch_warnings():
-            warnings.simplefilter('ignore')  # suppress empty matrix RuntimeWarning: All-NaN slice encountered
-            sn.heatmap(array,
-                       ax=ax,
-                       annot=nc < 30,
-                       annot_kws={
-                           'size': 8},
-                       cmap='Blues',
-                       fmt='.2f' if normalize else '.0f',
-                       square=True,
-                       vmin=0.0,
-                       xticklabels=ticklabels,
-                       yticklabels=ticklabels).set_facecolor((1, 1, 1))
-        title = 'Confusion Matrix' + ' Normalized' * normalize
-        ax.set_xlabel('True')
-        ax.set_ylabel('Predicted')
+            warnings.simplefilter("ignore")  # suppress empty matrix RuntimeWarning: All-NaN slice encountered
+            seaborn.heatmap(
+                array,
+                ax=ax,
+                annot=nc < 30,
+                annot_kws={"size": 8},
+                cmap="Blues",
+                fmt=".2f" if normalize else ".0f",
+                square=True,
+                vmin=0.0,
+                xticklabels=ticklabels,
+                yticklabels=ticklabels,
+            ).set_facecolor((1, 1, 1))
+        title = "Confusion Matrix" + " Normalized" * normalize
+        ax.set_xlabel("True")
+        ax.set_ylabel("Predicted")
         ax.set_title(title)
         plot_fname = Path(save_dir) / f'{title.lower().replace(" ", "_")}.png'
         fig.savefig(plot_fname, dpi=250)
         plt.close(fig)
         if on_plot:
             on_plot(plot_fname)
 
     def print(self):
         """Print the confusion matrix to the console."""
         for i in range(self.nc + 1):
-            LOGGER.info(' '.join(map(str, self.matrix[i])))
+            LOGGER.info(" ".join(map(str, self.matrix[i])))
 
 
 def smooth(y, f=0.05):
     """Box filter of fraction f."""
     nf = round(len(y) * f * 2) // 2 + 1  # number of filter elements (must be odd)
     p = np.ones(nf // 2)  # ones padding
     yp = np.concatenate((p * y[0], y, p * y[-1]), 0)  # y padded
-    return np.convolve(yp, np.ones(nf) / nf, mode='valid')  # y-smoothed
+    return np.convolve(yp, np.ones(nf) / nf, mode="valid")  # y-smoothed
 
 
 @plt_settings()
-def plot_pr_curve(px, py, ap, save_dir=Path('pr_curve.png'), names=(), on_plot=None):
+def plot_pr_curve(px, py, ap, save_dir=Path("pr_curve.png"), names=(), on_plot=None):
     """Plots a precision-recall curve."""
     fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)
     py = np.stack(py, axis=1)
 
     if 0 < len(names) < 21:  # display per-class legend if < 21 classes
         for i, y in enumerate(py.T):
-            ax.plot(px, y, linewidth=1, label=f'{names[i]} {ap[i, 0]:.3f}')  # plot(recall, precision)
+            ax.plot(px, y, linewidth=1, label=f"{names[i]} {ap[i, 0]:.3f}")  # plot(recall, precision)
     else:
-        ax.plot(px, py, linewidth=1, color='grey')  # plot(recall, precision)
+        ax.plot(px, py, linewidth=1, color="grey")  # plot(recall, precision)
 
-    ax.plot(px, py.mean(1), linewidth=3, color='blue', label='all classes %.3f mAP@0.5' % ap[:, 0].mean())
-    ax.set_xlabel('Recall')
-    ax.set_ylabel('Precision')
+    ax.plot(px, py.mean(1), linewidth=3, color="blue", label="all classes %.3f mAP@0.5" % ap[:, 0].mean())
+    ax.set_xlabel("Recall")
+    ax.set_ylabel("Precision")
     ax.set_xlim(0, 1)
     ax.set_ylim(0, 1)
-    ax.legend(bbox_to_anchor=(1.04, 1), loc='upper left')
-    ax.set_title('Precision-Recall Curve')
+    ax.legend(bbox_to_anchor=(1.04, 1), loc="upper left")
+    ax.set_title("Precision-Recall Curve")
     fig.savefig(save_dir, dpi=250)
     plt.close(fig)
     if on_plot:
         on_plot(save_dir)
 
 
 @plt_settings()
-def plot_mc_curve(px, py, save_dir=Path('mc_curve.png'), names=(), xlabel='Confidence', ylabel='Metric', on_plot=None):
+def plot_mc_curve(px, py, save_dir=Path("mc_curve.png"), names=(), xlabel="Confidence", ylabel="Metric", on_plot=None):
     """Plots a metric-confidence curve."""
     fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)
 
     if 0 < len(names) < 21:  # display per-class legend if < 21 classes
         for i, y in enumerate(py):
-            ax.plot(px, y, linewidth=1, label=f'{names[i]}')  # plot(confidence, metric)
+            ax.plot(px, y, linewidth=1, label=f"{names[i]}")  # plot(confidence, metric)
     else:
-        ax.plot(px, py.T, linewidth=1, color='grey')  # plot(confidence, metric)
+        ax.plot(px, py.T, linewidth=1, color="grey")  # plot(confidence, metric)
 
     y = smooth(py.mean(0), 0.05)
-    ax.plot(px, y, linewidth=3, color='blue', label=f'all classes {y.max():.2f} at {px[y.argmax()]:.3f}')
+    ax.plot(px, y, linewidth=3, color="blue", label=f"all classes {y.max():.2f} at {px[y.argmax()]:.3f}")
     ax.set_xlabel(xlabel)
     ax.set_ylabel(ylabel)
     ax.set_xlim(0, 1)
     ax.set_ylim(0, 1)
-    ax.legend(bbox_to_anchor=(1.04, 1), loc='upper left')
-    ax.set_title(f'{ylabel}-Confidence Curve')
+    ax.legend(bbox_to_anchor=(1.04, 1), loc="upper left")
+    ax.set_title(f"{ylabel}-Confidence Curve")
     fig.savefig(save_dir, dpi=250)
     plt.close(fig)
     if on_plot:
         on_plot(save_dir)
 
 
 def compute_ap(recall, precision):
@@ -404,35 +511,28 @@
     mrec = np.concatenate(([0.0], recall, [1.0]))
     mpre = np.concatenate(([1.0], precision, [0.0]))
 
     # Compute the precision envelope
     mpre = np.flip(np.maximum.accumulate(np.flip(mpre)))
 
     # Integrate area under curve
-    method = 'interp'  # methods: 'continuous', 'interp'
-    if method == 'interp':
+    method = "interp"  # methods: 'continuous', 'interp'
+    if method == "interp":
         x = np.linspace(0, 1, 101)  # 101-point interp (COCO)
         ap = np.trapz(np.interp(x, mrec, mpre), x)  # integrate
     else:  # 'continuous'
         i = np.where(mrec[1:] != mrec[:-1])[0]  # points where x-axis (recall) changes
         ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])  # area under curve
 
     return ap, mpre, mrec
 
 
-def ap_per_class(tp,
-                 conf,
-                 pred_cls,
-                 target_cls,
-                 plot=False,
-                 on_plot=None,
-                 save_dir=Path(),
-                 names=(),
-                 eps=1e-16,
-                 prefix=''):
+def ap_per_class(
+    tp, conf, pred_cls, target_cls, plot=False, on_plot=None, save_dir=Path(), names=(), eps=1e-16, prefix=""
+):
     """
     Computes the average precision per class for object detection evaluation.
 
     Args:
         tp (np.ndarray): Binary array indicating whether the detection is correct (True) or not (False).
         conf (np.ndarray): Array of confidence scores of the detections.
         pred_cls (np.ndarray): Array of predicted classes of the detections.
@@ -501,18 +601,18 @@
     prec_values = np.array(prec_values)  # (nc, 1000)
 
     # Compute F1 (harmonic mean of precision and recall)
     f1_curve = 2 * p_curve * r_curve / (p_curve + r_curve + eps)
     names = [v for k, v in names.items() if k in unique_classes]  # list: only classes that have data
     names = dict(enumerate(names))  # to dict
     if plot:
-        plot_pr_curve(x, prec_values, ap, save_dir / f'{prefix}PR_curve.png', names, on_plot=on_plot)
-        plot_mc_curve(x, f1_curve, save_dir / f'{prefix}F1_curve.png', names, ylabel='F1', on_plot=on_plot)
-        plot_mc_curve(x, p_curve, save_dir / f'{prefix}P_curve.png', names, ylabel='Precision', on_plot=on_plot)
-        plot_mc_curve(x, r_curve, save_dir / f'{prefix}R_curve.png', names, ylabel='Recall', on_plot=on_plot)
+        plot_pr_curve(x, prec_values, ap, save_dir / f"{prefix}PR_curve.png", names, on_plot=on_plot)
+        plot_mc_curve(x, f1_curve, save_dir / f"{prefix}F1_curve.png", names, ylabel="F1", on_plot=on_plot)
+        plot_mc_curve(x, p_curve, save_dir / f"{prefix}P_curve.png", names, ylabel="Precision", on_plot=on_plot)
+        plot_mc_curve(x, r_curve, save_dir / f"{prefix}R_curve.png", names, ylabel="Recall", on_plot=on_plot)
 
     i = smooth(f1_curve.mean(0), 0.1).argmax()  # max F1 index
     p, r, f1 = p_curve[:, i], r_curve[:, i], f1_curve[:, i]  # max-F1 precision, recall, F1 values
     tp = (r * nt).round()  # true positives
     fp = (tp / (p + eps) - tp).round()  # false positives
     return tp, fp, p, r, f1, ap, unique_classes.astype(int), p_curve, r_curve, f1_curve, x, prec_values
 
@@ -595,25 +695,25 @@
 
     @property
     def map50(self):
         """
         Returns the mean Average Precision (mAP) at an IoU threshold of 0.5.
 
         Returns:
-            (float): The mAP50 at an IoU threshold of 0.5.
+            (float): The mAP at an IoU threshold of 0.5.
         """
         return self.all_ap[:, 0].mean() if len(self.all_ap) else 0.0
 
     @property
     def map75(self):
         """
         Returns the mean Average Precision (mAP) at an IoU threshold of 0.75.
 
         Returns:
-            (float): The mAP50 at an IoU threshold of 0.75.
+            (float): The mAP at an IoU threshold of 0.75.
         """
         return self.all_ap[:, 5].mean() if len(self.all_ap) else 0.0
 
     @property
     def map(self):
         """
         Returns the mean Average Precision (mAP) over IoU thresholds of 0.5 - 0.95 in steps of 0.05.
@@ -656,27 +756,41 @@
                 - all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).
                 - ap_class_index (list): Index of class for each AP score. Shape: (nc,).
 
         Side Effects:
             Updates the class attributes `self.p`, `self.r`, `self.f1`, `self.all_ap`, and `self.ap_class_index` based
             on the values provided in the `results` tuple.
         """
-        (self.p, self.r, self.f1, self.all_ap, self.ap_class_index, self.p_curve, self.r_curve, self.f1_curve, self.px,
-         self.prec_values) = results
+        (
+            self.p,
+            self.r,
+            self.f1,
+            self.all_ap,
+            self.ap_class_index,
+            self.p_curve,
+            self.r_curve,
+            self.f1_curve,
+            self.px,
+            self.prec_values,
+        ) = results
 
     @property
     def curves(self):
         """Returns a list of curves for accessing specific metrics curves."""
         return []
 
     @property
     def curves_results(self):
         """Returns a list of curves for accessing specific metrics curves."""
-        return [[self.px, self.prec_values, 'Recall', 'Precision'], [self.px, self.f1_curve, 'Confidence', 'F1'],
-                [self.px, self.p_curve, 'Confidence', 'Precision'], [self.px, self.r_curve, 'Confidence', 'Recall']]
+        return [
+            [self.px, self.prec_values, "Recall", "Precision"],
+            [self.px, self.f1_curve, "Confidence", "F1"],
+            [self.px, self.p_curve, "Confidence", "Precision"],
+            [self.px, self.r_curve, "Confidence", "Recall"],
+        ]
 
 
 class DetMetrics(SimpleClass):
     """
     This class is a utility class for computing detection metrics such as precision, recall, and mean average precision
     (mAP) of an object detection model.
 
@@ -703,41 +817,43 @@
         fitness: Computes the fitness score based on the computed detection metrics.
         ap_class_index: Returns a list of class indices sorted by their average precision (AP) values.
         results_dict: Returns a dictionary that maps detection metric keys to their computed values.
         curves: TODO
         curves_results: TODO
     """
 
-    def __init__(self, save_dir=Path('.'), plot=False, on_plot=None, names=()) -> None:
+    def __init__(self, save_dir=Path("."), plot=False, on_plot=None, names=()) -> None:
         """Initialize a DetMetrics instance with a save directory, plot flag, callback function, and class names."""
         self.save_dir = save_dir
         self.plot = plot
         self.on_plot = on_plot
         self.names = names
         self.box = Metric()
-        self.speed = {'preprocess': 0.0, 'inference': 0.0, 'loss': 0.0, 'postprocess': 0.0}
-        self.task = 'detect'
+        self.speed = {"preprocess": 0.0, "inference": 0.0, "loss": 0.0, "postprocess": 0.0}
+        self.task = "detect"
 
     def process(self, tp, conf, pred_cls, target_cls):
         """Process predicted results for object detection and update metrics."""
-        results = ap_per_class(tp,
-                               conf,
-                               pred_cls,
-                               target_cls,
-                               plot=self.plot,
-                               save_dir=self.save_dir,
-                               names=self.names,
-                               on_plot=self.on_plot)[2:]
+        results = ap_per_class(
+            tp,
+            conf,
+            pred_cls,
+            target_cls,
+            plot=self.plot,
+            save_dir=self.save_dir,
+            names=self.names,
+            on_plot=self.on_plot,
+        )[2:]
         self.box.nc = len(self.names)
         self.box.update(results)
 
     @property
     def keys(self):
         """Returns a list of keys for accessing specific metrics."""
-        return ['metrics/precision(B)', 'metrics/recall(B)', 'metrics/mAP50(B)', 'metrics/mAP50-95(B)']
+        return ["metrics/precision(B)", "metrics/recall(B)", "metrics/mAP50(B)", "metrics/mAP50-95(B)"]
 
     def mean_results(self):
         """Calculate mean of detected objects & return precision, recall, mAP50, and mAP50-95."""
         return self.box.mean_results()
 
     def class_result(self, i):
         """Return the result of evaluating the performance of an object detection model on a specific class."""
@@ -757,20 +873,20 @@
     def ap_class_index(self):
         """Returns the average precision index per class."""
         return self.box.ap_class_index
 
     @property
     def results_dict(self):
         """Returns dictionary of computed performance metrics and statistics."""
-        return dict(zip(self.keys + ['fitness'], self.mean_results() + [self.fitness]))
+        return dict(zip(self.keys + ["fitness"], self.mean_results() + [self.fitness]))
 
     @property
     def curves(self):
         """Returns a list of curves for accessing specific metrics curves."""
-        return ['Precision-Recall(B)', 'F1-Confidence(B)', 'Precision-Confidence(B)', 'Recall-Confidence(B)']
+        return ["Precision-Recall(B)", "F1-Confidence(B)", "Precision-Confidence(B)", "Recall-Confidence(B)"]
 
     @property
     def curves_results(self):
         """Returns dictionary of computed performance metrics and statistics."""
         return self.box.curves_results
 
 
@@ -799,66 +915,77 @@
         class_result(i): Returns the detection and segmentation metrics of class `i`.
         maps: Returns the mean Average Precision (mAP) scores for IoU thresholds ranging from 0.50 to 0.95.
         fitness: Returns the fitness scores, which are a single weighted combination of metrics.
         ap_class_index: Returns the list of indices of classes used to compute Average Precision (AP).
         results_dict: Returns the dictionary containing all the detection and segmentation metrics and fitness score.
     """
 
-    def __init__(self, save_dir=Path('.'), plot=False, on_plot=None, names=()) -> None:
+    def __init__(self, save_dir=Path("."), plot=False, on_plot=None, names=()) -> None:
         """Initialize a SegmentMetrics instance with a save directory, plot flag, callback function, and class names."""
         self.save_dir = save_dir
         self.plot = plot
         self.on_plot = on_plot
         self.names = names
         self.box = Metric()
         self.seg = Metric()
-        self.speed = {'preprocess': 0.0, 'inference': 0.0, 'loss': 0.0, 'postprocess': 0.0}
-        self.task = 'segment'
+        self.speed = {"preprocess": 0.0, "inference": 0.0, "loss": 0.0, "postprocess": 0.0}
+        self.task = "segment"
 
-    def process(self, tp_b, tp_m, conf, pred_cls, target_cls):
+    def process(self, tp, tp_m, conf, pred_cls, target_cls):
         """
         Processes the detection and segmentation metrics over the given set of predictions.
 
         Args:
-            tp_b (list): List of True Positive boxes.
+            tp (list): List of True Positive boxes.
             tp_m (list): List of True Positive masks.
             conf (list): List of confidence scores.
             pred_cls (list): List of predicted classes.
             target_cls (list): List of target classes.
         """
 
-        results_mask = ap_per_class(tp_m,
-                                    conf,
-                                    pred_cls,
-                                    target_cls,
-                                    plot=self.plot,
-                                    on_plot=self.on_plot,
-                                    save_dir=self.save_dir,
-                                    names=self.names,
-                                    prefix='Mask')[2:]
+        results_mask = ap_per_class(
+            tp_m,
+            conf,
+            pred_cls,
+            target_cls,
+            plot=self.plot,
+            on_plot=self.on_plot,
+            save_dir=self.save_dir,
+            names=self.names,
+            prefix="Mask",
+        )[2:]
         self.seg.nc = len(self.names)
         self.seg.update(results_mask)
-        results_box = ap_per_class(tp_b,
-                                   conf,
-                                   pred_cls,
-                                   target_cls,
-                                   plot=self.plot,
-                                   on_plot=self.on_plot,
-                                   save_dir=self.save_dir,
-                                   names=self.names,
-                                   prefix='Box')[2:]
+        results_box = ap_per_class(
+            tp,
+            conf,
+            pred_cls,
+            target_cls,
+            plot=self.plot,
+            on_plot=self.on_plot,
+            save_dir=self.save_dir,
+            names=self.names,
+            prefix="Box",
+        )[2:]
         self.box.nc = len(self.names)
         self.box.update(results_box)
 
     @property
     def keys(self):
         """Returns a list of keys for accessing metrics."""
         return [
-            'metrics/precision(B)', 'metrics/recall(B)', 'metrics/mAP50(B)', 'metrics/mAP50-95(B)',
-            'metrics/precision(M)', 'metrics/recall(M)', 'metrics/mAP50(M)', 'metrics/mAP50-95(M)']
+            "metrics/precision(B)",
+            "metrics/recall(B)",
+            "metrics/mAP50(B)",
+            "metrics/mAP50-95(B)",
+            "metrics/precision(M)",
+            "metrics/recall(M)",
+            "metrics/mAP50(M)",
+            "metrics/mAP50-95(M)",
+        ]
 
     def mean_results(self):
         """Return the mean metrics for bounding box and segmentation results."""
         return self.box.mean_results() + self.seg.mean_results()
 
     def class_result(self, i):
         """Returns classification results for a specified class index."""
@@ -878,22 +1005,29 @@
     def ap_class_index(self):
         """Boxes and masks have the same ap_class_index."""
         return self.box.ap_class_index
 
     @property
     def results_dict(self):
         """Returns results of object detection model for evaluation."""
-        return dict(zip(self.keys + ['fitness'], self.mean_results() + [self.fitness]))
+        return dict(zip(self.keys + ["fitness"], self.mean_results() + [self.fitness]))
 
     @property
     def curves(self):
         """Returns a list of curves for accessing specific metrics curves."""
         return [
-            'Precision-Recall(B)', 'F1-Confidence(B)', 'Precision-Confidence(B)', 'Recall-Confidence(B)',
-            'Precision-Recall(M)', 'F1-Confidence(M)', 'Precision-Confidence(M)', 'Recall-Confidence(M)']
+            "Precision-Recall(B)",
+            "F1-Confidence(B)",
+            "Precision-Confidence(B)",
+            "Recall-Confidence(B)",
+            "Precision-Recall(M)",
+            "F1-Confidence(M)",
+            "Precision-Confidence(M)",
+            "Recall-Confidence(M)",
+        ]
 
     @property
     def curves_results(self):
         """Returns dictionary of computed performance metrics and statistics."""
         return self.box.curves_results + self.seg.curves_results
 
 
@@ -922,67 +1056,78 @@
         class_result(i): Returns the detection and segmentation metrics of class `i`.
         maps: Returns the mean Average Precision (mAP) scores for IoU thresholds ranging from 0.50 to 0.95.
         fitness: Returns the fitness scores, which are a single weighted combination of metrics.
         ap_class_index: Returns the list of indices of classes used to compute Average Precision (AP).
         results_dict: Returns the dictionary containing all the detection and segmentation metrics and fitness score.
     """
 
-    def __init__(self, save_dir=Path('.'), plot=False, on_plot=None, names=()) -> None:
+    def __init__(self, save_dir=Path("."), plot=False, on_plot=None, names=()) -> None:
         """Initialize the PoseMetrics class with directory path, class names, and plotting options."""
         super().__init__(save_dir, plot, names)
         self.save_dir = save_dir
         self.plot = plot
         self.on_plot = on_plot
         self.names = names
         self.box = Metric()
         self.pose = Metric()
-        self.speed = {'preprocess': 0.0, 'inference': 0.0, 'loss': 0.0, 'postprocess': 0.0}
-        self.task = 'pose'
+        self.speed = {"preprocess": 0.0, "inference": 0.0, "loss": 0.0, "postprocess": 0.0}
+        self.task = "pose"
 
-    def process(self, tp_b, tp_p, conf, pred_cls, target_cls):
+    def process(self, tp, tp_p, conf, pred_cls, target_cls):
         """
         Processes the detection and pose metrics over the given set of predictions.
 
         Args:
-            tp_b (list): List of True Positive boxes.
+            tp (list): List of True Positive boxes.
             tp_p (list): List of True Positive keypoints.
             conf (list): List of confidence scores.
             pred_cls (list): List of predicted classes.
             target_cls (list): List of target classes.
         """
 
-        results_pose = ap_per_class(tp_p,
-                                    conf,
-                                    pred_cls,
-                                    target_cls,
-                                    plot=self.plot,
-                                    on_plot=self.on_plot,
-                                    save_dir=self.save_dir,
-                                    names=self.names,
-                                    prefix='Pose')[2:]
+        results_pose = ap_per_class(
+            tp_p,
+            conf,
+            pred_cls,
+            target_cls,
+            plot=self.plot,
+            on_plot=self.on_plot,
+            save_dir=self.save_dir,
+            names=self.names,
+            prefix="Pose",
+        )[2:]
         self.pose.nc = len(self.names)
         self.pose.update(results_pose)
-        results_box = ap_per_class(tp_b,
-                                   conf,
-                                   pred_cls,
-                                   target_cls,
-                                   plot=self.plot,
-                                   on_plot=self.on_plot,
-                                   save_dir=self.save_dir,
-                                   names=self.names,
-                                   prefix='Box')[2:]
+        results_box = ap_per_class(
+            tp,
+            conf,
+            pred_cls,
+            target_cls,
+            plot=self.plot,
+            on_plot=self.on_plot,
+            save_dir=self.save_dir,
+            names=self.names,
+            prefix="Box",
+        )[2:]
         self.box.nc = len(self.names)
         self.box.update(results_box)
 
     @property
     def keys(self):
         """Returns list of evaluation metric keys."""
         return [
-            'metrics/precision(B)', 'metrics/recall(B)', 'metrics/mAP50(B)', 'metrics/mAP50-95(B)',
-            'metrics/precision(P)', 'metrics/recall(P)', 'metrics/mAP50(P)', 'metrics/mAP50-95(P)']
+            "metrics/precision(B)",
+            "metrics/recall(B)",
+            "metrics/mAP50(B)",
+            "metrics/mAP50-95(B)",
+            "metrics/precision(P)",
+            "metrics/recall(P)",
+            "metrics/mAP50(P)",
+            "metrics/mAP50-95(P)",
+        ]
 
     def mean_results(self):
         """Return the mean results of box and pose."""
         return self.box.mean_results() + self.pose.mean_results()
 
     def class_result(self, i):
         """Return the class-wise detection results for a specific class i."""
@@ -998,16 +1143,23 @@
         """Computes classification metrics and speed using the `targets` and `pred` inputs."""
         return self.pose.fitness() + self.box.fitness()
 
     @property
     def curves(self):
         """Returns a list of curves for accessing specific metrics curves."""
         return [
-            'Precision-Recall(B)', 'F1-Confidence(B)', 'Precision-Confidence(B)', 'Recall-Confidence(B)',
-            'Precision-Recall(P)', 'F1-Confidence(P)', 'Precision-Confidence(P)', 'Recall-Confidence(P)']
+            "Precision-Recall(B)",
+            "F1-Confidence(B)",
+            "Precision-Confidence(B)",
+            "Recall-Confidence(B)",
+            "Precision-Recall(P)",
+            "F1-Confidence(P)",
+            "Precision-Confidence(P)",
+            "Recall-Confidence(P)",
+        ]
 
     @property
     def curves_results(self):
         """Returns dictionary of computed performance metrics and statistics."""
         return self.box.curves_results + self.pose.curves_results
 
 
@@ -1029,16 +1181,16 @@
         process(targets, pred): Processes the targets and predictions to compute classification metrics.
     """
 
     def __init__(self) -> None:
         """Initialize a ClassifyMetrics instance."""
         self.top1 = 0
         self.top5 = 0
-        self.speed = {'preprocess': 0.0, 'inference': 0.0, 'loss': 0.0, 'postprocess': 0.0}
-        self.task = 'classify'
+        self.speed = {"preprocess": 0.0, "inference": 0.0, "loss": 0.0, "postprocess": 0.0}
+        self.task = "classify"
 
     def process(self, targets, pred):
         """Target classes and predicted classes."""
         pred, targets = torch.cat(pred), torch.cat(targets)
         correct = (targets[:, None] == pred).float()
         acc = torch.stack((correct[:, 0], correct.max(1).values), dim=1)  # (top1, top5) accuracy
         self.top1, self.top5 = acc.mean(0).tolist()
@@ -1047,20 +1199,88 @@
     def fitness(self):
         """Returns mean of top-1 and top-5 accuracies as fitness score."""
         return (self.top1 + self.top5) / 2
 
     @property
     def results_dict(self):
         """Returns a dictionary with model's performance metrics and fitness score."""
-        return dict(zip(self.keys + ['fitness'], [self.top1, self.top5, self.fitness]))
+        return dict(zip(self.keys + ["fitness"], [self.top1, self.top5, self.fitness]))
 
     @property
     def keys(self):
         """Returns a list of keys for the results_dict property."""
-        return ['metrics/accuracy_top1', 'metrics/accuracy_top5']
+        return ["metrics/accuracy_top1", "metrics/accuracy_top5"]
+
+    @property
+    def curves(self):
+        """Returns a list of curves for accessing specific metrics curves."""
+        return []
+
+    @property
+    def curves_results(self):
+        """Returns a list of curves for accessing specific metrics curves."""
+        return []
+
+
+class OBBMetrics(SimpleClass):
+    def __init__(self, save_dir=Path("."), plot=False, on_plot=None, names=()) -> None:
+        self.save_dir = save_dir
+        self.plot = plot
+        self.on_plot = on_plot
+        self.names = names
+        self.box = Metric()
+        self.speed = {"preprocess": 0.0, "inference": 0.0, "loss": 0.0, "postprocess": 0.0}
+
+    def process(self, tp, conf, pred_cls, target_cls):
+        """Process predicted results for object detection and update metrics."""
+        results = ap_per_class(
+            tp,
+            conf,
+            pred_cls,
+            target_cls,
+            plot=self.plot,
+            save_dir=self.save_dir,
+            names=self.names,
+            on_plot=self.on_plot,
+        )[2:]
+        self.box.nc = len(self.names)
+        self.box.update(results)
+
+    @property
+    def keys(self):
+        """Returns a list of keys for accessing specific metrics."""
+        return ["metrics/precision(B)", "metrics/recall(B)", "metrics/mAP50(B)", "metrics/mAP50-95(B)"]
+
+    def mean_results(self):
+        """Calculate mean of detected objects & return precision, recall, mAP50, and mAP50-95."""
+        return self.box.mean_results()
+
+    def class_result(self, i):
+        """Return the result of evaluating the performance of an object detection model on a specific class."""
+        return self.box.class_result(i)
+
+    @property
+    def maps(self):
+        """Returns mean Average Precision (mAP) scores per class."""
+        return self.box.maps
+
+    @property
+    def fitness(self):
+        """Returns the fitness of box object."""
+        return self.box.fitness()
+
+    @property
+    def ap_class_index(self):
+        """Returns the average precision index per class."""
+        return self.box.ap_class_index
+
+    @property
+    def results_dict(self):
+        """Returns dictionary of computed performance metrics and statistics."""
+        return dict(zip(self.keys + ["fitness"], self.mean_results() + [self.fitness]))
 
     @property
     def curves(self):
         """Returns a list of curves for accessing specific metrics curves."""
         return []
 
     @property
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/ops.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/ops.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,62 +5,64 @@
 import re
 import time
 
 import cv2
 import numpy as np
 import torch
 import torch.nn.functional as F
-import torchvision
 
 from ultralytics.utils import LOGGER
+from ultralytics.utils.metrics import batch_probiou
 
 
 class Profile(contextlib.ContextDecorator):
     """
     YOLOv8 Profile class. Use as a decorator with @Profile() or as a context manager with 'with Profile():'.
 
     Example:
         ```python
         from ultralytics.utils.ops import Profile
 
-        with Profile() as dt:
+        with Profile(device=device) as dt:
             pass  # slow operation here
 
         print(dt)  # prints "Elapsed time is 9.5367431640625e-07 s"
         ```
     """
 
-    def __init__(self, t=0.0):
+    def __init__(self, t=0.0, device: torch.device = None):
         """
         Initialize the Profile class.
 
         Args:
             t (float): Initial time. Defaults to 0.0.
+            device (torch.device): Devices used for model inference. Defaults to None (cpu).
         """
         self.t = t
-        self.cuda = torch.cuda.is_available()
+        self.device = device
+        self.cuda = bool(device and str(device).startswith("cuda"))
 
     def __enter__(self):
         """Start timing."""
         self.start = self.time()
         return self
 
     def __exit__(self, type, value, traceback):  # noqa
         """Stop timing."""
         self.dt = self.time() - self.start  # delta-time
         self.t += self.dt  # accumulate dt
 
     def __str__(self):
         """Returns a human-readable string representing the accumulated elapsed time in the profiler."""
-        return f'Elapsed time is {self.t} s'
+        return f"Elapsed time is {self.t} s"
 
     def time(self):
         """Get current time."""
         if self.cuda:
-            torch.cuda.synchronize()
+            torch.cuda.synchronize(self.device)
         return time.time()
 
 
 def segment2box(segment, width=640, height=640):
     """
     Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy).
 
@@ -68,53 +70,61 @@
         segment (torch.Tensor): the segment label
         width (int): the width of the image. Defaults to 640
         height (int): The height of the image. Defaults to 640
 
     Returns:
         (np.ndarray): the minimum and maximum x and y values of the segment.
     """
-    # Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy)
     x, y = segment.T  # segment xy
     inside = (x >= 0) & (y >= 0) & (x <= width) & (y <= height)
-    x, y, = x[inside], y[inside]
-    return np.array([x.min(), y.min(), x.max(), y.max()], dtype=segment.dtype) if any(x) else np.zeros(
-        4, dtype=segment.dtype)  # xyxy
+    x = x[inside]
+    y = y[inside]
+    return (
+        np.array([x.min(), y.min(), x.max(), y.max()], dtype=segment.dtype)
+        if any(x)
+        else np.zeros(4, dtype=segment.dtype)
+    )  # xyxy
 
 
-def scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=None, padding=True):
+def scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=None, padding=True, xywh=False):
     """
-    Rescales bounding boxes (in the format of xyxy) from the shape of the image they were originally specified in
-    (img1_shape) to the shape of a different image (img0_shape).
+    Rescales bounding boxes (in the format of xyxy by default) from the shape of the image they were originally
+    specified in (img1_shape) to the shape of a different image (img0_shape).
 
     Args:
         img1_shape (tuple): The shape of the image that the bounding boxes are for, in the format of (height, width).
         boxes (torch.Tensor): the bounding boxes of the objects in the image, in the format of (x1, y1, x2, y2)
         img0_shape (tuple): the shape of the target image, in the format of (height, width).
         ratio_pad (tuple): a tuple of (ratio, pad) for scaling the boxes. If not provided, the ratio and pad will be
             calculated based on the size difference between the two images.
         padding (bool): If True, assuming the boxes is based on image augmented by yolo style. If False then do regular
             rescaling.
+        xywh (bool): The box format is xywh or not, default=False.
 
     Returns:
         boxes (torch.Tensor): The scaled bounding boxes, in the format of (x1, y1, x2, y2)
     """
     if ratio_pad is None:  # calculate from img0_shape
         gain = min(img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1])  # gain  = old / new
-        pad = round((img1_shape[1] - img0_shape[1] * gain) / 2 - 0.1), round(
-            (img1_shape[0] - img0_shape[0] * gain) / 2 - 0.1)  # wh padding
+        pad = (
+            round((img1_shape[1] - img0_shape[1] * gain) / 2 - 0.1),
+            round((img1_shape[0] - img0_shape[0] * gain) / 2 - 0.1),
+        )  # wh padding
     else:
         gain = ratio_pad[0][0]
         pad = ratio_pad[1]
 
     if padding:
-        boxes[..., [0, 2]] -= pad[0]  # x padding
-        boxes[..., [1, 3]] -= pad[1]  # y padding
+        boxes[..., 0] -= pad[0]  # x padding
+        boxes[..., 1] -= pad[1]  # y padding
+        if not xywh:
+            boxes[..., 2] -= pad[0]  # x padding
+            boxes[..., 3] -= pad[1]  # y padding
     boxes[..., :4] /= gain
-    clip_boxes(boxes, img0_shape)
-    return boxes
+    return clip_boxes(boxes, img0_shape)
 
 
 def make_divisible(x, divisor):
     """
     Returns the nearest number that is divisible by the given divisor.
 
     Args:
@@ -125,27 +135,49 @@
         (int): The nearest number divisible by the divisor.
     """
     if isinstance(divisor, torch.Tensor):
         divisor = int(divisor.max())  # to int
     return math.ceil(x / divisor) * divisor
 
 
+def nms_rotated(boxes, scores, threshold=0.45):
+    """
+    NMS for obbs, powered by probiou and fast-nms.
+
+    Args:
+        boxes (torch.Tensor): (N, 5), xywhr.
+        scores (torch.Tensor): (N, ).
+        threshold (float): IoU threshold.
+
+    Returns:
+    """
+    if len(boxes) == 0:
+        return np.empty((0,), dtype=np.int8)
+    sorted_idx = torch.argsort(scores, descending=True)
+    boxes = boxes[sorted_idx]
+    ious = batch_probiou(boxes, boxes).triu_(diagonal=1)
+    pick = torch.nonzero(ious.max(dim=0)[0] < threshold).squeeze_(-1)
+    return sorted_idx[pick]
+
+
 def non_max_suppression(
-        prediction,
-        conf_thres=0.25,
-        iou_thres=0.45,
-        classes=None,
-        agnostic=False,
-        multi_label=False,
-        labels=(),
-        max_det=300,
-        nc=0,  # number of classes (optional)
-        max_time_img=0.05,
-        max_nms=30000,
-        max_wh=7680,
+    prediction,
+    conf_thres=0.25,
+    iou_thres=0.45,
+    classes=None,
+    agnostic=False,
+    multi_label=False,
+    labels=(),
+    max_det=300,
+    nc=0,  # number of classes (optional)
+    max_time_img=0.05,
+    max_nms=30000,
+    max_wh=7680,
+    in_place=True,
+    rotated=False,
 ):
     """
     Perform non-maximum suppression (NMS) on a set of boxes, with support for masks and multiple labels per box.
 
     Args:
         prediction (torch.Tensor): A tensor of shape (batch_size, num_classes + 4 + num_masks, num_boxes)
             containing the predicted boxes, classes, and masks. The tensor should be in the format
@@ -161,55 +193,57 @@
         labels (List[List[Union[int, float, torch.Tensor]]]): A list of lists, where each inner
             list contains the apriori labels for a given image. The list should be in the format
             output by a dataloader, with each label being a tuple of (class_index, x1, y1, x2, y2).
         max_det (int): The maximum number of boxes to keep after NMS.
         nc (int, optional): The number of classes output by the model. Any indices after this will be considered masks.
         max_time_img (float): The maximum time (seconds) for processing one image.
         max_nms (int): The maximum number of boxes into torchvision.ops.nms().
-        max_wh (int): The maximum box width and height in pixels
+        max_wh (int): The maximum box width and height in pixels.
+        in_place (bool): If True, the input prediction tensor will be modified in place.
 
     Returns:
         (List[torch.Tensor]): A list of length batch_size, where each element is a tensor of
             shape (num_boxes, 6 + num_masks) containing the kept boxes, with columns
             (x1, y1, x2, y2, confidence, class, mask1, mask2, ...).
     """
+    import torchvision  # scope for faster 'import ultralytics'
 
     # Checks
-    assert 0 <= conf_thres <= 1, f'Invalid Confidence threshold {conf_thres}, valid values are between 0.0 and 1.0'
-    assert 0 <= iou_thres <= 1, f'Invalid IoU {iou_thres}, valid values are between 0.0 and 1.0'
+    assert 0 <= conf_thres <= 1, f"Invalid Confidence threshold {conf_thres}, valid values are between 0.0 and 1.0"
+    assert 0 <= iou_thres <= 1, f"Invalid IoU {iou_thres}, valid values are between 0.0 and 1.0"
     if isinstance(prediction, (list, tuple)):  # YOLOv8 model in validation model, output = (inference_out, loss_out)
         prediction = prediction[0]  # select only inference output
 
-    device = prediction.device
-    mps = 'mps' in device.type  # Apple MPS
-    if mps:  # MPS not fully supported yet, convert tensors to CPU before NMS
-        prediction = prediction.cpu()
     bs = prediction.shape[0]  # batch size
     nc = nc or (prediction.shape[1] - 4)  # number of classes
     nm = prediction.shape[1] - nc - 4
     mi = 4 + nc  # mask start index
     xc = prediction[:, 4:mi].amax(1) > conf_thres  # candidates
 
     # Settings
     # min_wh = 2  # (pixels) minimum box width and height
-    time_limit = 0.5 + max_time_img * bs  # seconds to quit after
+    time_limit = 2.0 + max_time_img * bs  # seconds to quit after
     multi_label &= nc > 1  # multiple labels per box (adds 0.5ms/img)
 
     prediction = prediction.transpose(-1, -2)  # shape(1,84,6300) to shape(1,6300,84)
-    prediction[..., :4] = xywh2xyxy(prediction[..., :4])  # xywh to xyxy
+    if not rotated:
+        if in_place:
+            prediction[..., :4] = xywh2xyxy(prediction[..., :4])  # xywh to xyxy
+        else:
+            prediction = torch.cat((xywh2xyxy(prediction[..., :4]), prediction[..., 4:]), dim=-1)  # xywh to xyxy
 
     t = time.time()
     output = [torch.zeros((0, 6 + nm), device=prediction.device)] * bs
     for xi, x in enumerate(prediction):  # image index, image inference
         # Apply constraints
         # x[((x[:, 2:4] < min_wh) | (x[:, 2:4] > max_wh)).any(1), 4] = 0  # width-height
         x = x[xc[xi]]  # confidence
 
         # Cat apriori labels if autolabelling
-        if labels and len(labels[xi]):
+        if labels and len(labels[xi]) and not rotated:
             lb = labels[xi]
             v = torch.zeros((len(lb), nc + nm + 4), device=x.device)
             v[:, :4] = xywh2xyxy(lb[:, 1:5])  # box
             v[range(len(lb)), lb[:, 0].long() + 4] = 1.0  # cls
             x = torch.cat((x, v), 0)
 
         # If none remain process next image
@@ -235,75 +269,83 @@
         if not n:  # no boxes
             continue
         if n > max_nms:  # excess boxes
             x = x[x[:, 4].argsort(descending=True)[:max_nms]]  # sort by confidence and remove excess boxes
 
         # Batched NMS
         c = x[:, 5:6] * (0 if agnostic else max_wh)  # classes
-        boxes, scores = x[:, :4] + c, x[:, 4]  # boxes (offset by class), scores
-        i = torchvision.ops.nms(boxes, scores, iou_thres)  # NMS
+        scores = x[:, 4]  # scores
+        if rotated:
+            boxes = torch.cat((x[:, :2] + c, x[:, 2:4], x[:, -1:]), dim=-1)  # xywhr
+            i = nms_rotated(boxes, scores, iou_thres)
+        else:
+            boxes = x[:, :4] + c  # boxes (offset by class)
+            i = torchvision.ops.nms(boxes, scores, iou_thres)  # NMS
         i = i[:max_det]  # limit detections
 
         # # Experimental
         # merge = False  # use merge-NMS
         # if merge and (1 < n < 3E3):  # Merge NMS (boxes merged using weighted mean)
         #     # Update boxes as boxes(i,4) = weights(i,n) * boxes(n,4)
         #     from .metrics import box_iou
-        #     iou = box_iou(boxes[i], boxes) > iou_thres  # iou matrix
+        #     iou = box_iou(boxes[i], boxes) > iou_thres  # IoU matrix
         #     weights = iou * scores[None]  # box weights
         #     x[i, :4] = torch.mm(weights, x[:, :4]).float() / weights.sum(1, keepdim=True)  # merged boxes
         #     redundant = True  # require redundant detections
         #     if redundant:
         #         i = i[iou.sum(1) > 1]  # require redundancy
 
         output[xi] = x[i]
-        if mps:
-            output[xi] = output[xi].to(device)
         if (time.time() - t) > time_limit:
-            LOGGER.warning(f'WARNING  NMS time limit {time_limit:.3f}s exceeded')
+            LOGGER.warning(f"WARNING  NMS time limit {time_limit:.3f}s exceeded")
             break  # time limit exceeded
 
     return output
 
 
 def clip_boxes(boxes, shape):
     """
     Takes a list of bounding boxes and a shape (height, width) and clips the bounding boxes to the shape.
 
     Args:
-      boxes (torch.Tensor): the bounding boxes to clip
-      shape (tuple): the shape of the image
+        boxes (torch.Tensor): the bounding boxes to clip
+        shape (tuple): the shape of the image
+
+    Returns:
+        (torch.Tensor | numpy.ndarray): Clipped boxes
     """
-    if isinstance(boxes, torch.Tensor):  # faster individually
-        boxes[..., 0].clamp_(0, shape[1])  # x1
-        boxes[..., 1].clamp_(0, shape[0])  # y1
-        boxes[..., 2].clamp_(0, shape[1])  # x2
-        boxes[..., 3].clamp_(0, shape[0])  # y2
+    if isinstance(boxes, torch.Tensor):  # faster individually (WARNING: inplace .clamp_() Apple MPS bug)
+        boxes[..., 0] = boxes[..., 0].clamp(0, shape[1])  # x1
+        boxes[..., 1] = boxes[..., 1].clamp(0, shape[0])  # y1
+        boxes[..., 2] = boxes[..., 2].clamp(0, shape[1])  # x2
+        boxes[..., 3] = boxes[..., 3].clamp(0, shape[0])  # y2
     else:  # np.array (faster grouped)
         boxes[..., [0, 2]] = boxes[..., [0, 2]].clip(0, shape[1])  # x1, x2
         boxes[..., [1, 3]] = boxes[..., [1, 3]].clip(0, shape[0])  # y1, y2
+    return boxes
 
 
 def clip_coords(coords, shape):
     """
     Clip line coordinates to the image boundaries.
 
     Args:
         coords (torch.Tensor | numpy.ndarray): A list of line coordinates.
         shape (tuple): A tuple of integers representing the size of the image in the format (height, width).
 
     Returns:
-        (None): The function modifies the input `coordinates` in place, by clipping each coordinate to the image boundaries.
+        (torch.Tensor | numpy.ndarray): Clipped coordinates
     """
-    if isinstance(coords, torch.Tensor):  # faster individually
-        coords[..., 0].clamp_(0, shape[1])  # x
-        coords[..., 1].clamp_(0, shape[0])  # y
+    if isinstance(coords, torch.Tensor):  # faster individually (WARNING: inplace .clamp_() Apple MPS bug)
+        coords[..., 0] = coords[..., 0].clamp(0, shape[1])  # x
+        coords[..., 1] = coords[..., 1].clamp(0, shape[0])  # y
     else:  # np.array (faster grouped)
         coords[..., 0] = coords[..., 0].clip(0, shape[1])  # x
         coords[..., 1] = coords[..., 1].clip(0, shape[0])  # y
+    return coords
 
 
 def scale_image(masks, im0_shape, ratio_pad=None):
     """
     Takes a mask, and resizes it to the original image size.
 
     Args:
@@ -318,18 +360,18 @@
     im1_shape = masks.shape
     if im1_shape[:2] == im0_shape[:2]:
         return masks
     if ratio_pad is None:  # calculate from im0_shape
         gain = min(im1_shape[0] / im0_shape[0], im1_shape[1] / im0_shape[1])  # gain  = old / new
         pad = (im1_shape[1] - im0_shape[1] * gain) / 2, (im1_shape[0] - im0_shape[0] * gain) / 2  # wh padding
     else:
-        gain = ratio_pad[0][0]
+        # gain = ratio_pad[0][0]
         pad = ratio_pad[1]
-    top, left = (int(round(pad[1] - 0.1)), int(round(pad[0] - 0.1)))  # y, x
-    bottom, right = (int(round(im1_shape[0] - pad[1] + 0.1)), int(round(im1_shape[1] - pad[0] + 0.1)))
+    top, left = int(pad[1]), int(pad[0])  # y, x
+    bottom, right = int(im1_shape[0] - pad[1]), int(im1_shape[1] - pad[0])
 
     if len(masks.shape) < 2:
         raise ValueError(f'"len of masks shape" should be 2 or 3, but got {len(masks.shape)}')
     masks = masks[top:bottom, left:right]
     masks = cv2.resize(masks, (im0_shape[1], im0_shape[0]))
     if len(masks.shape) == 2:
         masks = masks[:, :, None]
@@ -344,15 +386,15 @@
 
     Args:
         x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x1, y1, x2, y2) format.
 
     Returns:
         y (np.ndarray | torch.Tensor): The bounding box coordinates in (x, y, width, height) format.
     """
-    assert x.shape[-1] == 4, f'input shape last dimension expected 4 but input shape is {x.shape}'
+    assert x.shape[-1] == 4, f"input shape last dimension expected 4 but input shape is {x.shape}"
     y = torch.empty_like(x) if isinstance(x, torch.Tensor) else np.empty_like(x)  # faster than clone/copy
     y[..., 0] = (x[..., 0] + x[..., 2]) / 2  # x center
     y[..., 1] = (x[..., 1] + x[..., 3]) / 2  # y center
     y[..., 2] = x[..., 2] - x[..., 0]  # width
     y[..., 3] = x[..., 3] - x[..., 1]  # height
     return y
 
@@ -364,15 +406,15 @@
 
     Args:
         x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x, y, width, height) format.
 
     Returns:
         y (np.ndarray | torch.Tensor): The bounding box coordinates in (x1, y1, x2, y2) format.
     """
-    assert x.shape[-1] == 4, f'input shape last dimension expected 4 but input shape is {x.shape}'
+    assert x.shape[-1] == 4, f"input shape last dimension expected 4 but input shape is {x.shape}"
     y = torch.empty_like(x) if isinstance(x, torch.Tensor) else np.empty_like(x)  # faster than clone/copy
     dw = x[..., 2] / 2  # half-width
     dh = x[..., 3] / 2  # half-height
     y[..., 0] = x[..., 0] - dw  # top left x
     y[..., 1] = x[..., 1] - dh  # top left y
     y[..., 2] = x[..., 0] + dw  # bottom right x
     y[..., 3] = x[..., 1] + dh  # bottom right y
@@ -389,15 +431,15 @@
         h (int): Height of the image. Defaults to 640
         padw (int): Padding width. Defaults to 0
         padh (int): Padding height. Defaults to 0
     Returns:
         y (np.ndarray | torch.Tensor): The coordinates of the bounding box in the format [x1, y1, x2, y2] where
             x1,y1 is the top-left corner, x2,y2 is the bottom-right corner of the bounding box.
     """
-    assert x.shape[-1] == 4, f'input shape last dimension expected 4 but input shape is {x.shape}'
+    assert x.shape[-1] == 4, f"input shape last dimension expected 4 but input shape is {x.shape}"
     y = torch.empty_like(x) if isinstance(x, torch.Tensor) else np.empty_like(x)  # faster than clone/copy
     y[..., 0] = w * (x[..., 0] - x[..., 2] / 2) + padw  # top left x
     y[..., 1] = h * (x[..., 1] - x[..., 3] / 2) + padh  # top left y
     y[..., 2] = w * (x[..., 0] + x[..., 2] / 2) + padw  # bottom right x
     y[..., 3] = h * (x[..., 1] + x[..., 3] / 2) + padh  # bottom right y
     return y
 
@@ -414,16 +456,16 @@
         clip (bool): If True, the boxes will be clipped to the image boundaries. Defaults to False
         eps (float): The minimum value of the box's width and height. Defaults to 0.0
 
     Returns:
         y (np.ndarray | torch.Tensor): The bounding box coordinates in (x, y, width, height, normalized) format
     """
     if clip:
-        clip_boxes(x, (h - eps, w - eps))  # warning: inplace clip
-    assert x.shape[-1] == 4, f'input shape last dimension expected 4 but input shape is {x.shape}'
+        x = clip_boxes(x, (h - eps, w - eps))
+    assert x.shape[-1] == 4, f"input shape last dimension expected 4 but input shape is {x.shape}"
     y = torch.empty_like(x) if isinstance(x, torch.Tensor) else np.empty_like(x)  # faster than clone/copy
     y[..., 0] = ((x[..., 0] + x[..., 2]) / 2) / w  # x center
     y[..., 1] = ((x[..., 1] + x[..., 3]) / 2) / h  # y center
     y[..., 2] = (x[..., 2] - x[..., 0]) / w  # width
     y[..., 3] = (x[..., 3] - x[..., 1]) / h  # height
     return y
 
@@ -474,77 +516,65 @@
     y[..., 0] = x[..., 0] + x[..., 2] / 2  # center x
     y[..., 1] = x[..., 1] + x[..., 3] / 2  # center y
     return y
 
 
 def xyxyxyxy2xywhr(corners):
     """
-    Convert batched Oriented Bounding Boxes (OBB) from [xy1, xy2, xy3, xy4] to [xywh, rotation].
+    Convert batched Oriented Bounding Boxes (OBB) from [xy1, xy2, xy3, xy4] to [xywh, rotation]. Rotation values are
+    expected in degrees from 0 to 90.
 
     Args:
         corners (numpy.ndarray | torch.Tensor): Input corners of shape (n, 8).
 
     Returns:
         (numpy.ndarray | torch.Tensor): Converted data in [cx, cy, w, h, rotation] format of shape (n, 5).
     """
-    is_numpy = isinstance(corners, np.ndarray)
-    atan2, sqrt = (np.arctan2, np.sqrt) if is_numpy else (torch.atan2, torch.sqrt)
+    is_torch = isinstance(corners, torch.Tensor)
+    points = corners.cpu().numpy() if is_torch else corners
+    points = points.reshape(len(corners), -1, 2)
+    rboxes = []
+    for pts in points:
+        # NOTE: Use cv2.minAreaRect to get accurate xywhr,
+        # especially some objects are cut off by augmentations in dataloader.
+        (x, y), (w, h), angle = cv2.minAreaRect(pts)
+        rboxes.append([x, y, w, h, angle / 180 * np.pi])
+    return (
+        torch.tensor(rboxes, device=corners.device, dtype=corners.dtype)
+        if is_torch
+        else np.asarray(rboxes, dtype=points.dtype)
+    )  # rboxes
 
-    x1, y1, x2, y2, x3, y3, x4, y4 = corners.T
-    cx = (x1 + x3) / 2
-    cy = (y1 + y3) / 2
-    dx21 = x2 - x1
-    dy21 = y2 - y1
 
-    w = sqrt(dx21 ** 2 + dy21 ** 2)
-    h = sqrt((x2 - x3) ** 2 + (y2 - y3) ** 2)
-
-    rotation = atan2(-dy21, dx21)
-    rotation *= 180.0 / math.pi  # radians to degrees
-
-    return np.vstack((cx, cy, w, h, rotation)).T if is_numpy else torch.stack((cx, cy, w, h, rotation), dim=1)
-
-
-def xywhr2xyxyxyxy(center):
+def xywhr2xyxyxyxy(rboxes):
     """
-    Convert batched Oriented Bounding Boxes (OBB) from [xywh, rotation] to [xy1, xy2, xy3, xy4].
+    Convert batched Oriented Bounding Boxes (OBB) from [xywh, rotation] to [xy1, xy2, xy3, xy4]. Rotation values should
+    be in degrees from 0 to 90.
 
     Args:
-        center (numpy.ndarray | torch.Tensor): Input data in [cx, cy, w, h, rotation] format of shape (n, 5).
+        rboxes (numpy.ndarray | torch.Tensor): Boxes in [cx, cy, w, h, rotation] format of shape (n, 5) or (b, n, 5).
 
     Returns:
-        (numpy.ndarray | torch.Tensor): Converted corner points of shape (n, 8).
+        (numpy.ndarray | torch.Tensor): Converted corner points of shape (n, 4, 2) or (b, n, 4, 2).
     """
-    is_numpy = isinstance(center, np.ndarray)
+    is_numpy = isinstance(rboxes, np.ndarray)
     cos, sin = (np.cos, np.sin) if is_numpy else (torch.cos, torch.sin)
 
-    cx, cy, w, h, rotation = center.T
-    rotation *= math.pi / 180.0  # degrees to radians
-
-    dx = w / 2
-    dy = h / 2
-
-    cos_rot = cos(rotation)
-    sin_rot = sin(rotation)
-    dx_cos_rot = dx * cos_rot
-    dx_sin_rot = dx * sin_rot
-    dy_cos_rot = dy * cos_rot
-    dy_sin_rot = dy * sin_rot
-
-    x1 = cx - dx_cos_rot - dy_sin_rot
-    y1 = cy + dx_sin_rot - dy_cos_rot
-    x2 = cx + dx_cos_rot - dy_sin_rot
-    y2 = cy - dx_sin_rot - dy_cos_rot
-    x3 = cx + dx_cos_rot + dy_sin_rot
-    y3 = cy - dx_sin_rot + dy_cos_rot
-    x4 = cx - dx_cos_rot + dy_sin_rot
-    y4 = cy + dx_sin_rot + dy_cos_rot
-
-    return np.vstack((x1, y1, x2, y2, x3, y3, x4, y4)).T if is_numpy else torch.stack(
-        (x1, y1, x2, y2, x3, y3, x4, y4), dim=1)
+    ctr = rboxes[..., :2]
+    w, h, angle = (rboxes[..., i : i + 1] for i in range(2, 5))
+    cos_value, sin_value = cos(angle), sin(angle)
+    vec1 = [w / 2 * cos_value, w / 2 * sin_value]
+    vec2 = [-h / 2 * sin_value, h / 2 * cos_value]
+    vec1 = np.concatenate(vec1, axis=-1) if is_numpy else torch.cat(vec1, dim=-1)
+    vec2 = np.concatenate(vec2, axis=-1) if is_numpy else torch.cat(vec2, dim=-1)
+    pt1 = ctr + vec1 + vec2
+    pt2 = ctr + vec1 - vec2
+    pt3 = ctr - vec1 - vec2
+    pt4 = ctr - vec1 + vec2
+    return np.stack([pt1, pt2, pt3, pt4], axis=-2) if is_numpy else torch.stack([pt1, pt2, pt3, pt4], dim=-2)
 
 
 def ltwh2xyxy(x):
     """
     It converts the bounding box from [x1, y1, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right.
 
     Args:
@@ -587,31 +617,32 @@
     Returns:
         segments (list): the resampled segments.
     """
     for i, s in enumerate(segments):
         s = np.concatenate((s, s[0:1, :]), axis=0)
         x = np.linspace(0, len(s) - 1, n)
         xp = np.arange(len(s))
-        segments[i] = np.concatenate([np.interp(x, xp, s[:, i]) for i in range(2)],
-                                     dtype=np.float32).reshape(2, -1).T  # segment xy
+        segments[i] = (
+            np.concatenate([np.interp(x, xp, s[:, i]) for i in range(2)], dtype=np.float32).reshape(2, -1).T
+        )  # segment xy
     return segments
 
 
 def crop_mask(masks, boxes):
     """
     It takes a mask and a bounding box, and returns a mask that is cropped to the bounding box.
 
     Args:
         masks (torch.Tensor): [n, h, w] tensor of masks
         boxes (torch.Tensor): [n, 4] tensor of bbox coordinates in relative point form
 
     Returns:
         (torch.Tensor): The masks are being cropped to the bounding box.
     """
-    n, h, w = masks.shape
+    _, h, w = masks.shape
     x1, y1, x2, y2 = torch.chunk(boxes[:, :, None], 4, 1)  # x1 shape(n,1,1)
     r = torch.arange(w, device=masks.device, dtype=x1.dtype)[None, None, :]  # rows shape(1,1,w)
     c = torch.arange(h, device=masks.device, dtype=x1.dtype)[None, :, None]  # cols shape(1,h,1)
 
     return masks * ((r >= x1) * (r < x2) * (c >= y1) * (c < y2))
 
 
@@ -627,15 +658,15 @@
         shape (tuple): the size of the input image (h,w)
 
     Returns:
         (torch.Tensor): The upsampled masks.
     """
     c, mh, mw = protos.shape  # CHW
     masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)
-    masks = F.interpolate(masks[None], shape, mode='bilinear', align_corners=False)[0]  # CHW
+    masks = F.interpolate(masks[None], shape, mode="bilinear", align_corners=False)[0]  # CHW
     masks = crop_mask(masks, bboxes)  # CHW
     return masks.gt_(0.5)
 
 
 def process_mask(protos, masks_in, bboxes, shape, upsample=False):
     """
     Apply masks to bounding boxes using the output of the mask head.
@@ -651,24 +682,26 @@
         (torch.Tensor): A binary mask tensor of shape [n, h, w], where n is the number of masks after NMS, and h and w
             are the height and width of the input image. The mask is applied to the bounding boxes.
     """
 
     c, mh, mw = protos.shape  # CHW
     ih, iw = shape
     masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)  # CHW
+    width_ratio = mw / iw
+    height_ratio = mh / ih
 
     downsampled_bboxes = bboxes.clone()
-    downsampled_bboxes[:, 0] *= mw / iw
-    downsampled_bboxes[:, 2] *= mw / iw
-    downsampled_bboxes[:, 3] *= mh / ih
-    downsampled_bboxes[:, 1] *= mh / ih
+    downsampled_bboxes[:, 0] *= width_ratio
+    downsampled_bboxes[:, 2] *= width_ratio
+    downsampled_bboxes[:, 3] *= height_ratio
+    downsampled_bboxes[:, 1] *= height_ratio
 
     masks = crop_mask(masks, downsampled_bboxes)  # CHW
     if upsample:
-        masks = F.interpolate(masks[None], shape, mode='bilinear', align_corners=False)[0]  # CHW
+        masks = F.interpolate(masks[None], shape, mode="bilinear", align_corners=False)[0]  # CHW
     return masks.gt_(0.5)
 
 
 def process_mask_native(protos, masks_in, bboxes, shape):
     """
     It takes the output of the mask head, and crops it after upsampling to the bounding boxes.
 
@@ -700,19 +733,19 @@
     """
     mh, mw = masks.shape[2:]
     gain = min(mh / shape[0], mw / shape[1])  # gain  = old / new
     pad = [mw - shape[1] * gain, mh - shape[0] * gain]  # wh padding
     if padding:
         pad[0] /= 2
         pad[1] /= 2
-    top, left = (int(round(pad[1] - 0.1)), int(round(pad[0] - 0.1))) if padding else (0, 0)  # y, x
-    bottom, right = (int(round(mh - pad[1] + 0.1)), int(round(mw - pad[0] + 0.1)))
+    top, left = (int(pad[1]), int(pad[0])) if padding else (0, 0)  # y, x
+    bottom, right = (int(mh - pad[1]), int(mw - pad[0]))
     masks = masks[..., top:bottom, left:right]
 
-    masks = F.interpolate(masks, shape, mode='bilinear', align_corners=False)  # NCHW
+    masks = F.interpolate(masks, shape, mode="bilinear", align_corners=False)  # NCHW
     return masks
 
 
 def scale_coords(img1_shape, coords, img0_shape, ratio_pad=None, normalize=False, padding=True):
     """
     Rescale segment coordinates (xy) from img1_shape to img0_shape.
 
@@ -736,43 +769,61 @@
         pad = ratio_pad[1]
 
     if padding:
         coords[..., 0] -= pad[0]  # x padding
         coords[..., 1] -= pad[1]  # y padding
     coords[..., 0] /= gain
     coords[..., 1] /= gain
-    clip_coords(coords, img0_shape)
+    coords = clip_coords(coords, img0_shape)
     if normalize:
         coords[..., 0] /= img0_shape[1]  # width
         coords[..., 1] /= img0_shape[0]  # height
     return coords
 
 
-def masks2segments(masks, strategy='largest'):
+def regularize_rboxes(rboxes):
+    """
+    Regularize rotated boxes in range [0, pi/2].
+
+    Args:
+        rboxes (torch.Tensor): (N, 5), xywhr.
+
+    Returns:
+        (torch.Tensor): The regularized boxes.
+    """
+    x, y, w, h, t = rboxes.unbind(dim=-1)
+    # Swap edge and angle if h >= w
+    w_ = torch.where(w > h, w, h)
+    h_ = torch.where(w > h, h, w)
+    t = torch.where(w > h, t, t + math.pi / 2) % math.pi
+    return torch.stack([x, y, w_, h_, t], dim=-1)  # regularized boxes
+
+
+def masks2segments(masks, strategy="largest"):
     """
     It takes a list of masks(n,h,w) and returns a list of segments(n,xy)
 
     Args:
         masks (torch.Tensor): the output of the model, which is a tensor of shape (batch_size, 160, 160)
         strategy (str): 'concat' or 'largest'. Defaults to largest
 
     Returns:
         segments (List): list of segment masks
     """
     segments = []
-    for x in masks.int().cpu().numpy().astype('uint8'):
+    for x in masks.int().cpu().numpy().astype("uint8"):
         c = cv2.findContours(x, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[0]
         if c:
-            if strategy == 'concat':  # concatenate all segments
+            if strategy == "concat":  # concatenate all segments
                 c = np.concatenate([x.reshape(-1, 2) for x in c])
-            elif strategy == 'largest':  # select largest segment
+            elif strategy == "largest":  # select largest segment
                 c = np.array(c[np.array([len(x) for x in c]).argmax()]).reshape(-1, 2)
         else:
             c = np.zeros((0, 2))  # no segments found
-        segments.append(c.astype('float32'))
+        segments.append(c.astype("float32"))
     return segments
 
 
 def convert_torch2numpy_batch(batch: torch.Tensor) -> np.ndarray:
     """
     Convert a batch of FP32 torch tensors (0.0-1.0) to a NumPy uint8 array (0-255), changing from BCHW to BHWC layout.
 
@@ -791,8 +842,8 @@
 
     Args:
         s (str): a string needing special characters replaced
 
     Returns:
         (str): a string with special characters replaced by an underscore _
     """
-    return re.sub(pattern='[|@#!$%&()=?^*;:,><+]', repl='_', string=s)
+    return re.sub(pattern="[|@#!$%&()=?^*;:,><+]", repl="_", string=s)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/patches.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/patches.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 # Ultralytics YOLO , AGPL-3.0 license
 """Monkey patches to update/extend functionality of existing functions."""
 
+import time
 from pathlib import Path
 
 import cv2
 import numpy as np
 import torch
 
 # OpenCV Multilanguage-friendly functions ------------------------------------------------------------------------------
@@ -48,30 +49,40 @@
     """
     Displays an image in the specified window.
 
     Args:
         winname (str): Name of the window.
         mat (np.ndarray): Image to be shown.
     """
-    _imshow(winname.encode('unicode_escape').decode(), mat)
+    _imshow(winname.encode("unicode_escape").decode(), mat)
 
 
 # PyTorch functions ----------------------------------------------------------------------------------------------------
 _torch_save = torch.save  # copy to avoid recursion errors
 
 
-def torch_save(*args, **kwargs):
+def torch_save(*args, use_dill=True, **kwargs):
     """
-    Use dill (if exists) to serialize the lambda functions where pickle does not do this.
+    Optionally use dill to serialize lambda functions where pickle does not, adding robustness with 3 retries and
+    exponential standoff in case of save failure.
 
     Args:
         *args (tuple): Positional arguments to pass to torch.save.
-        **kwargs (dict): Keyword arguments to pass to torch.save.
+        use_dill (bool): Whether to try using dill for serialization if available. Defaults to True.
+        **kwargs (any): Keyword arguments to pass to torch.save.
     """
     try:
-        import dill as pickle  # noqa
-    except ImportError:
+        assert use_dill
+        import dill as pickle
+    except (AssertionError, ImportError):
         import pickle
 
-    if 'pickle_module' not in kwargs:
-        kwargs['pickle_module'] = pickle  # noqa
-    return _torch_save(*args, **kwargs)
+    if "pickle_module" not in kwargs:
+        kwargs["pickle_module"] = pickle
+
+    for i in range(4):  # 3 retries
+        try:
+            return _torch_save(*args, **kwargs)
+        except RuntimeError as e:  # unable to save, possibly waiting for device to flush or antivirus scan
+            if i == 3:
+                raise e
+            time.sleep((2**i) / 2)  # exponential standoff: 0.5s, 1.0s, 2.0s
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/plotting.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/plotting.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,53 +9,92 @@
 import matplotlib.pyplot as plt
 import numpy as np
 import torch
 from PIL import Image, ImageDraw, ImageFont
 from PIL import __version__ as pil_version
 
 from ultralytics.utils import LOGGER, TryExcept, ops, plt_settings, threaded
-
-from .checks import check_font, check_version, is_ascii
-from .files import increment_path
+from ultralytics.utils.checks import check_font, check_version, is_ascii
+from ultralytics.utils.files import increment_path
 
 
 class Colors:
     """
     Ultralytics default color palette https://ultralytics.com/.
 
     This class provides methods to work with the Ultralytics color palette, including converting hex color codes to
     RGB values.
 
     Attributes:
         palette (list of tuple): List of RGB color values.
         n (int): The number of colors in the palette.
-        pose_palette (np.array): A specific color palette array with dtype np.uint8.
+        pose_palette (np.ndarray): A specific color palette array with dtype np.uint8.
     """
 
     def __init__(self):
         """Initialize colors as hex = matplotlib.colors.TABLEAU_COLORS.values()."""
-        hexs = ('FF3838', 'FF9D97', 'FF701F', 'FFB21D', 'CFD231', '48F90A', '92CC17', '3DDB86', '1A9334', '00D4BB',
-                '2C99A8', '00C2FF', '344593', '6473FF', '0018EC', '8438FF', '520085', 'CB38FF', 'FF95C8', 'FF37C7')
-        self.palette = [self.hex2rgb(f'#{c}') for c in hexs]
+        hexs = (
+            "FF3838",
+            "FF9D97",
+            "FF701F",
+            "FFB21D",
+            "CFD231",
+            "48F90A",
+            "92CC17",
+            "3DDB86",
+            "1A9334",
+            "00D4BB",
+            "2C99A8",
+            "00C2FF",
+            "344593",
+            "6473FF",
+            "0018EC",
+            "8438FF",
+            "520085",
+            "CB38FF",
+            "FF95C8",
+            "FF37C7",
+        )
+        self.palette = [self.hex2rgb(f"#{c}") for c in hexs]
         self.n = len(self.palette)
-        self.pose_palette = np.array([[255, 128, 0], [255, 153, 51], [255, 178, 102], [230, 230, 0], [255, 153, 255],
-                                      [153, 204, 255], [255, 102, 255], [255, 51, 255], [102, 178, 255], [51, 153, 255],
-                                      [255, 153, 153], [255, 102, 102], [255, 51, 51], [153, 255, 153], [102, 255, 102],
-                                      [51, 255, 51], [0, 255, 0], [0, 0, 255], [255, 0, 0], [255, 255, 255]],
-                                     dtype=np.uint8)
+        self.pose_palette = np.array(
+            [
+                [255, 128, 0],
+                [255, 153, 51],
+                [255, 178, 102],
+                [230, 230, 0],
+                [255, 153, 255],
+                [153, 204, 255],
+                [255, 102, 255],
+                [255, 51, 255],
+                [102, 178, 255],
+                [51, 153, 255],
+                [255, 153, 153],
+                [255, 102, 102],
+                [255, 51, 51],
+                [153, 255, 153],
+                [102, 255, 102],
+                [51, 255, 51],
+                [0, 255, 0],
+                [0, 0, 255],
+                [255, 0, 0],
+                [255, 255, 255],
+            ],
+            dtype=np.uint8,
+        )
 
     def __call__(self, i, bgr=False):
         """Converts hex color codes to RGB values."""
         c = self.palette[int(i) % self.n]
         return (c[2], c[1], c[0]) if bgr else c
 
     @staticmethod
     def hex2rgb(h):
         """Converts hex color codes to RGB values (i.e. default PIL order)."""
-        return tuple(int(h[1 + i:1 + i + 2], 16) for i in (0, 2, 4))
+        return tuple(int(h[1 + i : 1 + i + 2], 16) for i in (0, 2, 4))
 
 
 colors = Colors()  # create instance for 'from utils.plots import colors'
 
 
 class Annotator:
     """
@@ -67,74 +106,107 @@
         font (ImageFont.truetype or ImageFont.load_default): Font used for text annotations.
         lw (float): Line width for drawing.
         skeleton (List[List[int]]): Skeleton structure for keypoints.
         limb_color (List[int]): Color palette for limbs.
         kpt_color (List[int]): Color palette for keypoints.
     """
 
-    def __init__(self, im, line_width=None, font_size=None, font='Arial.ttf', pil=False, example='abc'):
+    def __init__(self, im, line_width=None, font_size=None, font="Arial.ttf", pil=False, example="abc"):
         """Initialize the Annotator class with image and line width along with color palette for keypoints and limbs."""
-        assert im.data.contiguous, 'Image not contiguous. Apply np.ascontiguousarray(im) to Annotator() input images.'
         non_ascii = not is_ascii(example)  # non-latin labels, i.e. asian, arabic, cyrillic
-        self.pil = pil or non_ascii
-        self.lw = line_width or max(round(sum(im.shape) / 2 * 0.003), 2)  # line width
+        input_is_pil = isinstance(im, Image.Image)
+        self.pil = pil or non_ascii or input_is_pil
+        self.lw = line_width or max(round(sum(im.size if input_is_pil else im.shape) / 2 * 0.003), 2)
         if self.pil:  # use PIL
-            self.im = im if isinstance(im, Image.Image) else Image.fromarray(im)
+            self.im = im if input_is_pil else Image.fromarray(im)
             self.draw = ImageDraw.Draw(self.im)
             try:
-                font = check_font('Arial.Unicode.ttf' if non_ascii else font)
+                font = check_font("Arial.Unicode.ttf" if non_ascii else font)
                 size = font_size or max(round(sum(self.im.size) / 2 * 0.035), 12)
                 self.font = ImageFont.truetype(str(font), size)
             except Exception:
                 self.font = ImageFont.load_default()
             # Deprecation fix for w, h = getsize(string) -> _, _, w, h = getbox(string)
-            if check_version(pil_version, '9.2.0'):
+            if check_version(pil_version, "9.2.0"):
                 self.font.getsize = lambda x: self.font.getbbox(x)[2:4]  # text width, height
         else:  # use cv2
-            self.im = im
+            assert im.data.contiguous, "Image not contiguous. Apply np.ascontiguousarray(im) to Annotator input images."
+            self.im = im if im.flags.writeable else im.copy()
             self.tf = max(self.lw - 1, 1)  # font thickness
             self.sf = self.lw / 3  # font scale
         # Pose
-        self.skeleton = [[16, 14], [14, 12], [17, 15], [15, 13], [12, 13], [6, 12], [7, 13], [6, 7], [6, 8], [7, 9],
-                         [8, 10], [9, 11], [2, 3], [1, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 7]]
+        self.skeleton = [
+            [16, 14],
+            [14, 12],
+            [17, 15],
+            [15, 13],
+            [12, 13],
+            [6, 12],
+            [7, 13],
+            [6, 7],
+            [6, 8],
+            [7, 9],
+            [8, 10],
+            [9, 11],
+            [2, 3],
+            [1, 2],
+            [1, 3],
+            [2, 4],
+            [3, 5],
+            [4, 6],
+            [5, 7],
+        ]
 
         self.limb_color = colors.pose_palette[[9, 9, 9, 9, 7, 7, 7, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16]]
         self.kpt_color = colors.pose_palette[[16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9]]
 
-    def box_label(self, box, label='', color=(128, 128, 128), txt_color=(255, 255, 255)):
+    def box_label(self, box, label="", color=(128, 128, 128), txt_color=(255, 255, 255), rotated=False):
         """Add one xyxy box to image with label."""
         if isinstance(box, torch.Tensor):
             box = box.tolist()
         if self.pil or not is_ascii(label):
-            self.draw.rectangle(box, width=self.lw, outline=color)  # box
+            if rotated:
+                p1 = box[0]
+                # NOTE: PIL-version polygon needs tuple type.
+                self.draw.polygon([tuple(b) for b in box], width=self.lw, outline=color)
+            else:
+                p1 = (box[0], box[1])
+                self.draw.rectangle(box, width=self.lw, outline=color)  # box
             if label:
                 w, h = self.font.getsize(label)  # text width, height
-                outside = box[1] - h >= 0  # label fits outside box
+                outside = p1[1] - h >= 0  # label fits outside box
                 self.draw.rectangle(
-                    (box[0], box[1] - h if outside else box[1], box[0] + w + 1,
-                     box[1] + 1 if outside else box[1] + h + 1),
+                    (p1[0], p1[1] - h if outside else p1[1], p1[0] + w + 1, p1[1] + 1 if outside else p1[1] + h + 1),
                     fill=color,
                 )
                 # self.draw.text((box[0], box[1]), label, fill=txt_color, font=self.font, anchor='ls')  # for PIL>8.0
-                self.draw.text((box[0], box[1] - h if outside else box[1]), label, fill=txt_color, font=self.font)
+                self.draw.text((p1[0], p1[1] - h if outside else p1[1]), label, fill=txt_color, font=self.font)
         else:  # cv2
-            p1, p2 = (int(box[0]), int(box[1])), (int(box[2]), int(box[3]))
-            cv2.rectangle(self.im, p1, p2, color, thickness=self.lw, lineType=cv2.LINE_AA)
+            if rotated:
+                p1 = [int(b) for b in box[0]]
+                # NOTE: cv2-version polylines needs np.asarray type.
+                cv2.polylines(self.im, [np.asarray(box, dtype=int)], True, color, self.lw)
+            else:
+                p1, p2 = (int(box[0]), int(box[1])), (int(box[2]), int(box[3]))
+                cv2.rectangle(self.im, p1, p2, color, thickness=self.lw, lineType=cv2.LINE_AA)
             if label:
                 w, h = cv2.getTextSize(label, 0, fontScale=self.sf, thickness=self.tf)[0]  # text width, height
                 outside = p1[1] - h >= 3
                 p2 = p1[0] + w, p1[1] - h - 3 if outside else p1[1] + h + 3
                 cv2.rectangle(self.im, p1, p2, color, -1, cv2.LINE_AA)  # filled
-                cv2.putText(self.im,
-                            label, (p1[0], p1[1] - 2 if outside else p1[1] + h + 2),
-                            0,
-                            self.sf,
-                            txt_color,
-                            thickness=self.tf,
-                            lineType=cv2.LINE_AA)
+                cv2.putText(
+                    self.im,
+                    label,
+                    (p1[0], p1[1] - 2 if outside else p1[1] + h + 2),
+                    0,
+                    self.sf,
+                    txt_color,
+                    thickness=self.tf,
+                    lineType=cv2.LINE_AA,
+                )
 
     def masks(self, masks, colors, im_gpu, alpha=0.5, retina_masks=False):
         """
         Plot masks on image.
 
         Args:
             masks (tensor): Predicted masks on cuda, shape: [n, h, w]
@@ -157,86 +229,87 @@
 
         inv_alpha_masks = (1 - masks * alpha).cumprod(0)  # shape(n,h,w,1)
         mcs = masks_color.max(dim=0).values  # shape(n,h,w,3)
 
         im_gpu = im_gpu.flip(dims=[0])  # flip channel
         im_gpu = im_gpu.permute(1, 2, 0).contiguous()  # shape(h,w,3)
         im_gpu = im_gpu * inv_alpha_masks[-1] + mcs
-        im_mask = (im_gpu * 255)
+        im_mask = im_gpu * 255
         im_mask_np = im_mask.byte().cpu().numpy()
         self.im[:] = im_mask_np if retina_masks else ops.scale_image(im_mask_np, self.im.shape)
         if self.pil:
             # Convert im back to PIL and update draw
             self.fromarray(self.im)
 
-    def kpts(self, kpts, shape=(640, 640), radius=5, kpt_line=True):
+    def kpts(self, kpts, shape=(640, 640), radius=5, kpt_line=True, conf_thres=0.25):
         """
         Plot keypoints on the image.
 
         Args:
             kpts (tensor): Predicted keypoints with shape [17, 3]. Each keypoint has (x, y, confidence).
             shape (tuple): Image shape as a tuple (h, w), where h is the height and w is the width.
             radius (int, optional): Radius of the drawn keypoints. Default is 5.
             kpt_line (bool, optional): If True, the function will draw lines connecting keypoints
                                        for human pose. Default is True.
 
-        Note: `kpt_line=True` currently only supports human pose plotting.
+        Note:
+            `kpt_line=True` currently only supports human pose plotting.
         """
         if self.pil:
             # Convert to numpy first
             self.im = np.asarray(self.im).copy()
         nkpt, ndim = kpts.shape
-        is_pose = nkpt == 17 and ndim == 3
+        is_pose = nkpt == 17 and ndim in {2, 3}
         kpt_line &= is_pose  # `kpt_line=True` for now only supports human pose plotting
         for i, k in enumerate(kpts):
             color_k = [int(x) for x in self.kpt_color[i]] if is_pose else colors(i)
             x_coord, y_coord = k[0], k[1]
             if x_coord % shape[1] != 0 and y_coord % shape[0] != 0:
                 if len(k) == 3:
                     conf = k[2]
-                    if conf < 0.5:
+                    if conf < conf_thres:
                         continue
                 cv2.circle(self.im, (int(x_coord), int(y_coord)), radius, color_k, -1, lineType=cv2.LINE_AA)
 
         if kpt_line:
             ndim = kpts.shape[-1]
             for i, sk in enumerate(self.skeleton):
                 pos1 = (int(kpts[(sk[0] - 1), 0]), int(kpts[(sk[0] - 1), 1]))
                 pos2 = (int(kpts[(sk[1] - 1), 0]), int(kpts[(sk[1] - 1), 1]))
                 if ndim == 3:
                     conf1 = kpts[(sk[0] - 1), 2]
                     conf2 = kpts[(sk[1] - 1), 2]
-                    if conf1 < 0.5 or conf2 < 0.5:
+                    if conf1 < conf_thres or conf2 < conf_thres:
                         continue
                 if pos1[0] % shape[1] == 0 or pos1[1] % shape[0] == 0 or pos1[0] < 0 or pos1[1] < 0:
                     continue
                 if pos2[0] % shape[1] == 0 or pos2[1] % shape[0] == 0 or pos2[0] < 0 or pos2[1] < 0:
                     continue
                 cv2.line(self.im, pos1, pos2, [int(x) for x in self.limb_color[i]], thickness=2, lineType=cv2.LINE_AA)
         if self.pil:
             # Convert im back to PIL and update draw
             self.fromarray(self.im)
 
     def rectangle(self, xy, fill=None, outline=None, width=1):
         """Add rectangle to image (PIL-only)."""
         self.draw.rectangle(xy, fill, outline, width)
 
-    def text(self, xy, text, txt_color=(255, 255, 255), anchor='top', box_style=False):
+    def text(self, xy, text, txt_color=(255, 255, 255), anchor="top", box_style=False):
         """Adds text to an image using PIL or cv2."""
-        if anchor == 'bottom':  # start y from font bottom
+        if anchor == "bottom":  # start y from font bottom
             w, h = self.font.getsize(text)  # text width, height
             xy[1] += 1 - h
         if self.pil:
             if box_style:
                 w, h = self.font.getsize(text)
                 self.draw.rectangle((xy[0], xy[1], xy[0] + w + 1, xy[1] + h + 1), fill=txt_color)
                 # Using `txt_color` for background and draw fg with white color
                 txt_color = (255, 255, 255)
-            if '\n' in text:
-                lines = text.split('\n')
+            if "\n" in text:
+                lines = text.split("\n")
                 _, h = self.font.getsize(text)
                 for line in lines:
                     self.draw.text(xy, line, fill=txt_color, font=self.font)
                     xy[1] += h
             else:
                 self.draw.text(xy, text, fill=txt_color, font=self.font)
         else:
@@ -254,72 +327,407 @@
         self.im = im if isinstance(im, Image.Image) else Image.fromarray(im)
         self.draw = ImageDraw.Draw(self.im)
 
     def result(self):
         """Return annotated image as array."""
         return np.asarray(self.im)
 
+    def show(self, title=None):
+        """Show the annotated image."""
+        Image.fromarray(np.asarray(self.im)[..., ::-1]).show(title)
+
+    def save(self, filename="image.jpg"):
+        """Save the annotated image to 'filename'."""
+        cv2.imwrite(filename, np.asarray(self.im))
+
+    def get_bbox_dimension(self, bbox=None):
+        """
+        Calculate the area of a bounding box.
+
+        Args:
+            bbox (tuple): Bounding box coordinates in the format (x_min, y_min, x_max, y_max).
+
+        Returns:
+            angle (degree): Degree value of angle between three points
+        """
+        x_min, y_min, x_max, y_max = bbox
+        width = x_max - x_min
+        height = y_max - y_min
+        return width, height, width * height
+
+    def draw_region(self, reg_pts=None, color=(0, 255, 0), thickness=5):
+        """
+        Draw region line.
+
+        Args:
+            reg_pts (list): Region Points (for line 2 points, for region 4 points)
+            color (tuple): Region Color value
+            thickness (int): Region area thickness value
+        """
+        cv2.polylines(self.im, [np.array(reg_pts, dtype=np.int32)], isClosed=True, color=color, thickness=thickness)
+
+    def draw_centroid_and_tracks(self, track, color=(255, 0, 255), track_thickness=2):
+        """
+        Draw centroid point and track trails.
+
+        Args:
+            track (list): object tracking points for trails display
+            color (tuple): tracks line color
+            track_thickness (int): track line thickness value
+        """
+        points = np.hstack(track).astype(np.int32).reshape((-1, 1, 2))
+        cv2.polylines(self.im, [points], isClosed=False, color=color, thickness=track_thickness)
+        cv2.circle(self.im, (int(track[-1][0]), int(track[-1][1])), track_thickness * 2, color, -1)
+
+    def queue_counts_display(self, label, points=None, region_color=(255, 255, 255), txt_color=(0, 0, 0), fontsize=0.7):
+        """
+        Displays queue counts on an image centered at the points with customizable font size and colors.
+
+        Args:
+            label (str): queue counts label
+            points (tuple): region points for center point calculation to display text
+            region_color (RGB): queue region color
+            txt_color (RGB): text display color
+            fontsize (float): text fontsize
+        """
+        x_values = [point[0] for point in points]
+        y_values = [point[1] for point in points]
+        center_x = sum(x_values) // len(points)
+        center_y = sum(y_values) // len(points)
+
+        text_size = cv2.getTextSize(label, 0, fontScale=fontsize, thickness=self.tf)[0]
+        text_width = text_size[0]
+        text_height = text_size[1]
+
+        rect_width = text_width + 20
+        rect_height = text_height + 20
+        rect_top_left = (center_x - rect_width // 2, center_y - rect_height // 2)
+        rect_bottom_right = (center_x + rect_width // 2, center_y + rect_height // 2)
+        cv2.rectangle(self.im, rect_top_left, rect_bottom_right, region_color, -1)
+
+        text_x = center_x - text_width // 2
+        text_y = center_y + text_height // 2
+
+        # Draw text
+        cv2.putText(
+            self.im,
+            label,
+            (text_x, text_y),
+            0,
+            fontScale=fontsize,
+            color=txt_color,
+            thickness=self.tf,
+            lineType=cv2.LINE_AA,
+        )
+
+    def display_counts(self, counts=None, count_bg_color=(0, 0, 0), count_txt_color=(255, 255, 255)):
+        """
+        Display counts on im0 with text background and border.
+
+        Args:
+            counts (str): objects count data
+            count_bg_color (RGB Color): counts highlighter color
+            count_txt_color (RGB Color): counts display color
+        """
+
+        tl = self.tf or round(0.002 * (self.im.shape[0] + self.im.shape[1]) / 2) + 1
+        tf = max(tl - 1, 1)
+
+        t_sizes = [cv2.getTextSize(str(count), 0, fontScale=self.sf, thickness=self.tf)[0] for count in counts]
+
+        max_text_width = max([size[0] for size in t_sizes])
+        max_text_height = max([size[1] for size in t_sizes])
+
+        text_x = self.im.shape[1] - int(self.im.shape[1] * 0.025 + max_text_width)
+        text_y = int(self.im.shape[0] * 0.025)
+
+        # Calculate dynamic gap between each count value based on the width of the image
+        dynamic_gap = max(1, self.im.shape[1] // 100) * tf
+
+        for i, count in enumerate(counts):
+            text_x_pos = text_x
+            text_y_pos = text_y + i * dynamic_gap  # Adjust vertical position with dynamic gap
+
+            # Draw the border
+            cv2.rectangle(
+                self.im,
+                (text_x_pos - (10 * tf), text_y_pos - (10 * tf)),
+                (text_x_pos + max_text_width + (10 * tf), text_y_pos + max_text_height + (10 * tf)),
+                count_bg_color,
+                -1,
+            )
+
+            # Draw the count text
+            cv2.putText(
+                self.im,
+                str(count),
+                (text_x_pos, text_y_pos + max_text_height),
+                0,
+                fontScale=self.sf,
+                color=count_txt_color,
+                thickness=self.tf,
+                lineType=cv2.LINE_AA,
+            )
+
+            text_y_pos += tf * max_text_height
+
+    @staticmethod
+    def estimate_pose_angle(a, b, c):
+        """
+        Calculate the pose angle for object.
+
+        Args:
+            a (float) : The value of pose point a
+            b (float): The value of pose point b
+            c (float): The value o pose point c
+
+        Returns:
+            angle (degree): Degree value of angle between three points
+        """
+        a, b, c = np.array(a), np.array(b), np.array(c)
+        radians = np.arctan2(c[1] - b[1], c[0] - b[0]) - np.arctan2(a[1] - b[1], a[0] - b[0])
+        angle = np.abs(radians * 180.0 / np.pi)
+        if angle > 180.0:
+            angle = 360 - angle
+        return angle
+
+    def draw_specific_points(self, keypoints, indices=[2, 5, 7], shape=(640, 640), radius=2, conf_thres=0.25):
+        """
+        Draw specific keypoints for gym steps counting.
+
+        Args:
+            keypoints (list): list of keypoints data to be plotted
+            indices (list): keypoints ids list to be plotted
+            shape (tuple): imgsz for model inference
+            radius (int): Keypoint radius value
+        """
+        for i, k in enumerate(keypoints):
+            if i in indices:
+                x_coord, y_coord = k[0], k[1]
+                if x_coord % shape[1] != 0 and y_coord % shape[0] != 0:
+                    if len(k) == 3:
+                        conf = k[2]
+                        if conf < conf_thres:
+                            continue
+                    cv2.circle(self.im, (int(x_coord), int(y_coord)), radius, (0, 255, 0), -1, lineType=cv2.LINE_AA)
+        return self.im
+
+    def plot_angle_and_count_and_stage(self, angle_text, count_text, stage_text, center_kpt, line_thickness=2):
+        """
+        Plot the pose angle, count value and step stage.
+
+        Args:
+            angle_text (str): angle value for workout monitoring
+            count_text (str): counts value for workout monitoring
+            stage_text (str): stage decision for workout monitoring
+            center_kpt (int): centroid pose index for workout monitoring
+            line_thickness (int): thickness for text display
+        """
+        angle_text, count_text, stage_text = (f" {angle_text:.2f}", f"Steps : {count_text}", f" {stage_text}")
+        font_scale = 0.6 + (line_thickness / 10.0)
+
+        # Draw angle
+        (angle_text_width, angle_text_height), _ = cv2.getTextSize(angle_text, 0, font_scale, line_thickness)
+        angle_text_position = (int(center_kpt[0]), int(center_kpt[1]))
+        angle_background_position = (angle_text_position[0], angle_text_position[1] - angle_text_height - 5)
+        angle_background_size = (angle_text_width + 2 * 5, angle_text_height + 2 * 5 + (line_thickness * 2))
+        cv2.rectangle(
+            self.im,
+            angle_background_position,
+            (
+                angle_background_position[0] + angle_background_size[0],
+                angle_background_position[1] + angle_background_size[1],
+            ),
+            (255, 255, 255),
+            -1,
+        )
+        cv2.putText(self.im, angle_text, angle_text_position, 0, font_scale, (0, 0, 0), line_thickness)
+
+        # Draw Counts
+        (count_text_width, count_text_height), _ = cv2.getTextSize(count_text, 0, font_scale, line_thickness)
+        count_text_position = (angle_text_position[0], angle_text_position[1] + angle_text_height + 20)
+        count_background_position = (
+            angle_background_position[0],
+            angle_background_position[1] + angle_background_size[1] + 5,
+        )
+        count_background_size = (count_text_width + 10, count_text_height + 10 + (line_thickness * 2))
+
+        cv2.rectangle(
+            self.im,
+            count_background_position,
+            (
+                count_background_position[0] + count_background_size[0],
+                count_background_position[1] + count_background_size[1],
+            ),
+            (255, 255, 255),
+            -1,
+        )
+        cv2.putText(self.im, count_text, count_text_position, 0, font_scale, (0, 0, 0), line_thickness)
+
+        # Draw Stage
+        (stage_text_width, stage_text_height), _ = cv2.getTextSize(stage_text, 0, font_scale, line_thickness)
+        stage_text_position = (int(center_kpt[0]), int(center_kpt[1]) + angle_text_height + count_text_height + 40)
+        stage_background_position = (stage_text_position[0], stage_text_position[1] - stage_text_height - 5)
+        stage_background_size = (stage_text_width + 10, stage_text_height + 10)
+
+        cv2.rectangle(
+            self.im,
+            stage_background_position,
+            (
+                stage_background_position[0] + stage_background_size[0],
+                stage_background_position[1] + stage_background_size[1],
+            ),
+            (255, 255, 255),
+            -1,
+        )
+        cv2.putText(self.im, stage_text, stage_text_position, 0, font_scale, (0, 0, 0), line_thickness)
+
+    def seg_bbox(self, mask, mask_color=(255, 0, 255), det_label=None, track_label=None):
+        """
+        Function for drawing segmented object in bounding box shape.
+
+        Args:
+            mask (list): masks data list for instance segmentation area plotting
+            mask_color (tuple): mask foreground color
+            det_label (str): Detection label text
+            track_label (str): Tracking label text
+        """
+        cv2.polylines(self.im, [np.int32([mask])], isClosed=True, color=mask_color, thickness=2)
+
+        label = f"Track ID: {track_label}" if track_label else det_label
+        text_size, _ = cv2.getTextSize(label, 0, 0.7, 1)
+
+        cv2.rectangle(
+            self.im,
+            (int(mask[0][0]) - text_size[0] // 2 - 10, int(mask[0][1]) - text_size[1] - 10),
+            (int(mask[0][0]) + text_size[0] // 2 + 5, int(mask[0][1] + 5)),
+            mask_color,
+            -1,
+        )
+
+        cv2.putText(
+            self.im, label, (int(mask[0][0]) - text_size[0] // 2, int(mask[0][1]) - 5), 0, 0.7, (255, 255, 255), 2
+        )
+
+    def plot_distance_and_line(self, distance_m, distance_mm, centroids, line_color, centroid_color):
+        """
+        Plot the distance and line on frame.
+
+        Args:
+            distance_m (float): Distance between two bbox centroids in meters.
+            distance_mm (float): Distance between two bbox centroids in millimeters.
+            centroids (list): Bounding box centroids data.
+            line_color (RGB): Distance line color.
+            centroid_color (RGB): Bounding box centroid color.
+        """
+        (text_width_m, text_height_m), _ = cv2.getTextSize(f"Distance M: {distance_m:.2f}m", 0, 0.8, 2)
+        cv2.rectangle(self.im, (15, 25), (15 + text_width_m + 10, 25 + text_height_m + 20), (255, 255, 255), -1)
+        cv2.putText(
+            self.im,
+            f"Distance M: {distance_m:.2f}m",
+            (20, 50),
+            0,
+            0.8,
+            (0, 0, 0),
+            2,
+            cv2.LINE_AA,
+        )
+
+        (text_width_mm, text_height_mm), _ = cv2.getTextSize(f"Distance MM: {distance_mm:.2f}mm", 0, 0.8, 2)
+        cv2.rectangle(self.im, (15, 75), (15 + text_width_mm + 10, 75 + text_height_mm + 20), (255, 255, 255), -1)
+        cv2.putText(
+            self.im,
+            f"Distance MM: {distance_mm:.2f}mm",
+            (20, 100),
+            0,
+            0.8,
+            (0, 0, 0),
+            2,
+            cv2.LINE_AA,
+        )
+
+        cv2.line(self.im, centroids[0], centroids[1], line_color, 3)
+        cv2.circle(self.im, centroids[0], 6, centroid_color, -1)
+        cv2.circle(self.im, centroids[1], 6, centroid_color, -1)
+
+    def visioneye(self, box, center_point, color=(235, 219, 11), pin_color=(255, 0, 255), thickness=2, pins_radius=10):
+        """
+        Function for pinpoint human-vision eye mapping and plotting.
+
+        Args:
+            box (list): Bounding box coordinates
+            center_point (tuple): center point for vision eye view
+            color (tuple): object centroid and line color value
+            pin_color (tuple): visioneye point color value
+            thickness (int): int value for line thickness
+            pins_radius (int): visioneye point radius value
+        """
+        center_bbox = int((box[0] + box[2]) / 2), int((box[1] + box[3]) / 2)
+        cv2.circle(self.im, center_point, pins_radius, pin_color, -1)
+        cv2.circle(self.im, center_bbox, pins_radius, color, -1)
+        cv2.line(self.im, center_point, center_bbox, color, thickness)
+
 
 @TryExcept()  # known issue https://github.com/ultralytics/yolov5/issues/5395
 @plt_settings()
-def plot_labels(boxes, cls, names=(), save_dir=Path(''), on_plot=None):
+def plot_labels(boxes, cls, names=(), save_dir=Path(""), on_plot=None):
     """Plot training labels including class histograms and box statistics."""
-    import pandas as pd
-    import seaborn as sn
+    import pandas  # scope for faster 'import ultralytics'
+    import seaborn  # scope for faster 'import ultralytics'
 
     # Filter matplotlib>=3.7.2 warning and Seaborn use_inf and is_categorical FutureWarnings
-    warnings.filterwarnings('ignore', category=UserWarning, message='The figure layout has changed to tight')
-    warnings.filterwarnings('ignore', category=FutureWarning)
+    warnings.filterwarnings("ignore", category=UserWarning, message="The figure layout has changed to tight")
+    warnings.filterwarnings("ignore", category=FutureWarning)
 
     # Plot dataset labels
     LOGGER.info(f"Plotting labels to {save_dir / 'labels.jpg'}... ")
     nc = int(cls.max() + 1)  # number of classes
     boxes = boxes[:1000000]  # limit to 1M boxes
-    x = pd.DataFrame(boxes, columns=['x', 'y', 'width', 'height'])
+    x = pandas.DataFrame(boxes, columns=["x", "y", "width", "height"])
 
     # Seaborn correlogram
-    sn.pairplot(x, corner=True, diag_kind='auto', kind='hist', diag_kws=dict(bins=50), plot_kws=dict(pmax=0.9))
-    plt.savefig(save_dir / 'labels_correlogram.jpg', dpi=200)
+    seaborn.pairplot(x, corner=True, diag_kind="auto", kind="hist", diag_kws=dict(bins=50), plot_kws=dict(pmax=0.9))
+    plt.savefig(save_dir / "labels_correlogram.jpg", dpi=200)
     plt.close()
 
     # Matplotlib labels
     ax = plt.subplots(2, 2, figsize=(8, 8), tight_layout=True)[1].ravel()
     y = ax[0].hist(cls, bins=np.linspace(0, nc, nc + 1) - 0.5, rwidth=0.8)
     for i in range(nc):
         y[2].patches[i].set_color([x / 255 for x in colors(i)])
-    ax[0].set_ylabel('instances')
+    ax[0].set_ylabel("instances")
     if 0 < len(names) < 30:
         ax[0].set_xticks(range(len(names)))
         ax[0].set_xticklabels(list(names.values()), rotation=90, fontsize=10)
     else:
-        ax[0].set_xlabel('classes')
-    sn.histplot(x, x='x', y='y', ax=ax[2], bins=50, pmax=0.9)
-    sn.histplot(x, x='width', y='height', ax=ax[3], bins=50, pmax=0.9)
+        ax[0].set_xlabel("classes")
+    seaborn.histplot(x, x="x", y="y", ax=ax[2], bins=50, pmax=0.9)
+    seaborn.histplot(x, x="width", y="height", ax=ax[3], bins=50, pmax=0.9)
 
     # Rectangles
     boxes[:, 0:2] = 0.5  # center
     boxes = ops.xywh2xyxy(boxes) * 1000
     img = Image.fromarray(np.ones((1000, 1000, 3), dtype=np.uint8) * 255)
     for cls, box in zip(cls[:500], boxes[:500]):
         ImageDraw.Draw(img).rectangle(box, width=1, outline=colors(cls))  # plot
     ax[1].imshow(img)
-    ax[1].axis('off')
+    ax[1].axis("off")
 
     for a in [0, 1, 2, 3]:
-        for s in ['top', 'right', 'left', 'bottom']:
+        for s in ["top", "right", "left", "bottom"]:
             ax[a].spines[s].set_visible(False)
 
-    fname = save_dir / 'labels.jpg'
+    fname = save_dir / "labels.jpg"
     plt.savefig(fname, dpi=200)
     plt.close()
     if on_plot:
         on_plot(fname)
 
 
-def save_one_box(xyxy, im, file=Path('im.jpg'), gain=1.02, pad=10, square=False, BGR=False, save=True):
+def save_one_box(xyxy, im, file=Path("im.jpg"), gain=1.02, pad=10, square=False, BGR=False, save=True):
     """
     Save image crop as {file} with crop size multiple {gain} and {pad} pixels. Save and/or return crop.
 
     This function takes a bounding box and an image, and then saves a cropped portion of the image according
     to the bounding box. Optionally, the crop can be squared, and the function allows for gain and padding
     adjustments to the bounding box.
 
@@ -349,35 +757,41 @@
     if not isinstance(xyxy, torch.Tensor):  # may be list
         xyxy = torch.stack(xyxy)
     b = ops.xyxy2xywh(xyxy.view(-1, 4))  # boxes
     if square:
         b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # attempt rectangle to square
     b[:, 2:] = b[:, 2:] * gain + pad  # box wh * gain + pad
     xyxy = ops.xywh2xyxy(b).long()
-    ops.clip_boxes(xyxy, im.shape)
-    crop = im[int(xyxy[0, 1]):int(xyxy[0, 3]), int(xyxy[0, 0]):int(xyxy[0, 2]), ::(1 if BGR else -1)]
+    xyxy = ops.clip_boxes(xyxy, im.shape)
+    crop = im[int(xyxy[0, 1]) : int(xyxy[0, 3]), int(xyxy[0, 0]) : int(xyxy[0, 2]), :: (1 if BGR else -1)]
     if save:
         file.parent.mkdir(parents=True, exist_ok=True)  # make directory
-        f = str(increment_path(file).with_suffix('.jpg'))
+        f = str(increment_path(file).with_suffix(".jpg"))
         # cv2.imwrite(f, crop)  # save BGR, https://github.com/ultralytics/yolov5/issues/7007 chroma subsampling issue
         Image.fromarray(crop[..., ::-1]).save(f, quality=95, subsampling=0)  # save RGB
     return crop
 
 
 @threaded
-def plot_images(images,
-                batch_idx,
-                cls,
-                bboxes=np.zeros(0, dtype=np.float32),
-                masks=np.zeros(0, dtype=np.uint8),
-                kpts=np.zeros((0, 51), dtype=np.float32),
-                paths=None,
-                fname='images.jpg',
-                names=None,
-                on_plot=None):
+def plot_images(
+    images,
+    batch_idx,
+    cls,
+    bboxes=np.zeros(0, dtype=np.float32),
+    confs=None,
+    masks=np.zeros(0, dtype=np.uint8),
+    kpts=np.zeros((0, 51), dtype=np.float32),
+    paths=None,
+    fname="images.jpg",
+    names=None,
+    on_plot=None,
+    max_subplots=16,
+    save=True,
+    conf_thres=0.25,
+):
     """Plot image grid with labels."""
     if isinstance(images, torch.Tensor):
         images = images.cpu().float().numpy()
     if isinstance(cls, torch.Tensor):
         cls = cls.cpu().numpy()
     if isinstance(bboxes, torch.Tensor):
         bboxes = bboxes.cpu().numpy()
@@ -385,122 +799,124 @@
         masks = masks.cpu().numpy().astype(int)
     if isinstance(kpts, torch.Tensor):
         kpts = kpts.cpu().numpy()
     if isinstance(batch_idx, torch.Tensor):
         batch_idx = batch_idx.cpu().numpy()
 
     max_size = 1920  # max image size
-    max_subplots = 16  # max image subplots, i.e. 4x4
     bs, _, h, w = images.shape  # batch size, _, height, width
     bs = min(bs, max_subplots)  # limit plot images
-    ns = np.ceil(bs ** 0.5)  # number of subplots (square)
+    ns = np.ceil(bs**0.5)  # number of subplots (square)
     if np.max(images[0]) <= 1:
         images *= 255  # de-normalise (optional)
 
     # Build Image
     mosaic = np.full((int(ns * h), int(ns * w), 3), 255, dtype=np.uint8)  # init
-    for i, im in enumerate(images):
-        if i == max_subplots:  # if last batch has fewer images than we expect
-            break
+    for i in range(bs):
         x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin
-        im = im.transpose(1, 2, 0)
-        mosaic[y:y + h, x:x + w, :] = im
+        mosaic[y : y + h, x : x + w, :] = images[i].transpose(1, 2, 0)
 
     # Resize (optional)
     scale = max_size / ns / max(h, w)
     if scale < 1:
         h = math.ceil(scale * h)
         w = math.ceil(scale * w)
         mosaic = cv2.resize(mosaic, tuple(int(x * ns) for x in (w, h)))
 
     # Annotate
     fs = int((h + w) * ns * 0.01)  # font size
     annotator = Annotator(mosaic, line_width=round(fs / 10), font_size=fs, pil=True, example=names)
-    for i in range(i + 1):
+    for i in range(bs):
         x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin
         annotator.rectangle([x, y, x + w, y + h], None, (255, 255, 255), width=2)  # borders
         if paths:
             annotator.text((x + 5, y + 5), text=Path(paths[i]).name[:40], txt_color=(220, 220, 220))  # filenames
         if len(cls) > 0:
             idx = batch_idx == i
-            classes = cls[idx].astype('int')
+            classes = cls[idx].astype("int")
+            labels = confs is None
 
             if len(bboxes):
-                boxes = ops.xywh2xyxy(bboxes[idx, :4]).T
-                labels = bboxes.shape[1] == 4  # labels if no conf column
-                conf = None if labels else bboxes[idx, 4]  # check for confidence presence (label vs pred)
-
-                if boxes.shape[1]:
-                    if boxes.max() <= 1.01:  # if normalized with tolerance 0.01
-                        boxes[[0, 2]] *= w  # scale to pixels
-                        boxes[[1, 3]] *= h
+                boxes = bboxes[idx]
+                conf = confs[idx] if confs is not None else None  # check for confidence presence (label vs pred)
+                if len(boxes):
+                    if boxes[:, :4].max() <= 1.1:  # if normalized with tolerance 0.1
+                        boxes[..., [0, 2]] *= w  # scale to pixels
+                        boxes[..., [1, 3]] *= h
                     elif scale < 1:  # absolute coords need scale if image scales
-                        boxes *= scale
-                boxes[[0, 2]] += x
-                boxes[[1, 3]] += y
-                for j, box in enumerate(boxes.T.tolist()):
+                        boxes[..., :4] *= scale
+                boxes[..., 0] += x
+                boxes[..., 1] += y
+                is_obb = boxes.shape[-1] == 5  # xywhr
+                boxes = ops.xywhr2xyxyxyxy(boxes) if is_obb else ops.xywh2xyxy(boxes)
+                for j, box in enumerate(boxes.astype(np.int64).tolist()):
                     c = classes[j]
                     color = colors(c)
                     c = names.get(c, c) if names else c
-                    if labels or conf[j] > 0.25:  # 0.25 conf thresh
-                        label = f'{c}' if labels else f'{c} {conf[j]:.1f}'
-                        annotator.box_label(box, label, color=color)
+                    if labels or conf[j] > conf_thres:
+                        label = f"{c}" if labels else f"{c} {conf[j]:.1f}"
+                        annotator.box_label(box, label, color=color, rotated=is_obb)
+
             elif len(classes):
                 for c in classes:
                     color = colors(c)
                     c = names.get(c, c) if names else c
-                    annotator.text((x, y), f'{c}', txt_color=color, box_style=True)
+                    annotator.text((x, y), f"{c}", txt_color=color, box_style=True)
 
             # Plot keypoints
             if len(kpts):
                 kpts_ = kpts[idx].copy()
                 if len(kpts_):
                     if kpts_[..., 0].max() <= 1.01 or kpts_[..., 1].max() <= 1.01:  # if normalized with tolerance .01
                         kpts_[..., 0] *= w  # scale to pixels
                         kpts_[..., 1] *= h
                     elif scale < 1:  # absolute coords need scale if image scales
                         kpts_ *= scale
                 kpts_[..., 0] += x
                 kpts_[..., 1] += y
                 for j in range(len(kpts_)):
-                    if labels or conf[j] > 0.25:  # 0.25 conf thresh
-                        annotator.kpts(kpts_[j])
+                    if labels or conf[j] > conf_thres:
+                        annotator.kpts(kpts_[j], conf_thres=conf_thres)
 
             # Plot masks
             if len(masks):
                 if idx.shape[0] == masks.shape[0]:  # overlap_masks=False
                     image_masks = masks[idx]
                 else:  # overlap_masks=True
                     image_masks = masks[[i]]  # (1, 640, 640)
                     nl = idx.sum()
                     index = np.arange(nl).reshape((nl, 1, 1)) + 1
                     image_masks = np.repeat(image_masks, nl, axis=0)
                     image_masks = np.where(image_masks == index, 1.0, 0.0)
 
                 im = np.asarray(annotator.im).copy()
-                for j, box in enumerate(boxes.T.tolist()):
-                    if labels or conf[j] > 0.25:  # 0.25 conf thresh
+                for j in range(len(image_masks)):
+                    if labels or conf[j] > conf_thres:
                         color = colors(classes[j])
                         mh, mw = image_masks[j].shape
                         if mh != h or mw != w:
                             mask = image_masks[j].astype(np.uint8)
                             mask = cv2.resize(mask, (w, h))
                             mask = mask.astype(bool)
                         else:
                             mask = image_masks[j].astype(bool)
                         with contextlib.suppress(Exception):
-                            im[y:y + h, x:x + w, :][mask] = im[y:y + h, x:x + w, :][mask] * 0.4 + np.array(color) * 0.6
+                            im[y : y + h, x : x + w, :][mask] = (
+                                im[y : y + h, x : x + w, :][mask] * 0.4 + np.array(color) * 0.6
+                            )
                 annotator.fromarray(im)
+    if not save:
+        return np.asarray(annotator.im)
     annotator.im.save(fname)  # save
     if on_plot:
         on_plot(fname)
 
 
 @plt_settings()
-def plot_results(file='path/to/results.csv', dir='', segment=False, pose=False, classify=False, on_plot=None):
+def plot_results(file="path/to/results.csv", dir="", segment=False, pose=False, classify=False, on_plot=None):
     """
     Plot training results from a results CSV file. The function supports various types of data including segmentation,
     pose estimation, and classification. Plots are saved as 'results.png' in the directory where the CSV is located.
 
     Args:
         file (str, optional): Path to the CSV file containing the training results. Defaults to 'path/to/results.csv'.
         dir (str, optional): Directory where the CSV file is located if 'file' is not provided. Defaults to ''.
@@ -513,56 +929,57 @@
     Example:
         ```python
         from ultralytics.utils.plotting import plot_results
 
         plot_results('path/to/results.csv', segment=True)
         ```
     """
-    import pandas as pd
+    import pandas as pd  # scope for faster 'import ultralytics'
     from scipy.ndimage import gaussian_filter1d
+
     save_dir = Path(file).parent if file else Path(dir)
     if classify:
         fig, ax = plt.subplots(2, 2, figsize=(6, 6), tight_layout=True)
         index = [1, 4, 2, 3]
     elif segment:
         fig, ax = plt.subplots(2, 8, figsize=(18, 6), tight_layout=True)
         index = [1, 2, 3, 4, 5, 6, 9, 10, 13, 14, 15, 16, 7, 8, 11, 12]
     elif pose:
         fig, ax = plt.subplots(2, 9, figsize=(21, 6), tight_layout=True)
         index = [1, 2, 3, 4, 5, 6, 7, 10, 11, 14, 15, 16, 17, 18, 8, 9, 12, 13]
     else:
         fig, ax = plt.subplots(2, 5, figsize=(12, 6), tight_layout=True)
         index = [1, 2, 3, 4, 5, 8, 9, 10, 6, 7]
     ax = ax.ravel()
-    files = list(save_dir.glob('results*.csv'))
-    assert len(files), f'No results.csv files found in {save_dir.resolve()}, nothing to plot.'
+    files = list(save_dir.glob("results*.csv"))
+    assert len(files), f"No results.csv files found in {save_dir.resolve()}, nothing to plot."
     for f in files:
         try:
             data = pd.read_csv(f)
             s = [x.strip() for x in data.columns]
             x = data.values[:, 0]
             for i, j in enumerate(index):
-                y = data.values[:, j].astype('float')
+                y = data.values[:, j].astype("float")
                 # y[y == 0] = np.nan  # don't show zero values
-                ax[i].plot(x, y, marker='.', label=f.stem, linewidth=2, markersize=8)  # actual results
-                ax[i].plot(x, gaussian_filter1d(y, sigma=3), ':', label='smooth', linewidth=2)  # smoothing line
+                ax[i].plot(x, y, marker=".", label=f.stem, linewidth=2, markersize=8)  # actual results
+                ax[i].plot(x, gaussian_filter1d(y, sigma=3), ":", label="smooth", linewidth=2)  # smoothing line
                 ax[i].set_title(s[j], fontsize=12)
-                # if j in [8, 9, 10]:  # share train and val loss y axes
+                # if j in {8, 9, 10}:  # share train and val loss y axes
                 #     ax[i].get_shared_y_axes().join(ax[i], ax[i - 5])
         except Exception as e:
-            LOGGER.warning(f'WARNING: Plotting error for {f}: {e}')
+            LOGGER.warning(f"WARNING: Plotting error for {f}: {e}")
     ax[1].legend()
-    fname = save_dir / 'results.png'
+    fname = save_dir / "results.png"
     fig.savefig(fname, dpi=200)
     plt.close()
     if on_plot:
         on_plot(fname)
 
 
-def plt_color_scatter(v, f, bins=20, cmap='viridis', alpha=0.8, edgecolors='none'):
+def plt_color_scatter(v, f, bins=20, cmap="viridis", alpha=0.8, edgecolors="none"):
     """
     Plots a scatter plot with points colored based on a 2D histogram.
 
     Args:
         v (array-like): Values for the x-axis.
         f (array-like): Values for the y-axis.
         bins (int, optional): Number of bins for the histogram. Defaults to 20.
@@ -575,34 +992,38 @@
         >>> f = np.random.rand(100)
         >>> plt_color_scatter(v, f)
     """
 
     # Calculate 2D histogram and corresponding colors
     hist, xedges, yedges = np.histogram2d(v, f, bins=bins)
     colors = [
-        hist[min(np.digitize(v[i], xedges, right=True) - 1, hist.shape[0] - 1),
-             min(np.digitize(f[i], yedges, right=True) - 1, hist.shape[1] - 1)] for i in range(len(v))]
+        hist[
+            min(np.digitize(v[i], xedges, right=True) - 1, hist.shape[0] - 1),
+            min(np.digitize(f[i], yedges, right=True) - 1, hist.shape[1] - 1),
+        ]
+        for i in range(len(v))
+    ]
 
     # Scatter plot
     plt.scatter(v, f, c=colors, cmap=cmap, alpha=alpha, edgecolors=edgecolors)
 
 
-def plot_tune_results(csv_file='tune_results.csv'):
+def plot_tune_results(csv_file="tune_results.csv"):
     """
     Plot the evolution results stored in an 'tune_results.csv' file. The function generates a scatter plot for each key
     in the CSV, color-coded based on fitness scores. The best-performing configurations are highlighted on the plots.
 
     Args:
         csv_file (str, optional): Path to the CSV file containing the tuning results. Defaults to 'tune_results.csv'.
 
     Examples:
         >>> plot_tune_results('path/to/tune_results.csv')
     """
 
-    import pandas as pd
+    import pandas as pd  # scope for faster 'import ultralytics'
     from scipy.ndimage import gaussian_filter1d
 
     # Scatter plots for each hyperparameter
     csv_file = Path(csv_file)
     data = pd.read_csv(csv_file)
     num_metrics_columns = 1
     keys = [x.strip() for x in data.columns][num_metrics_columns:]
@@ -611,78 +1032,89 @@
     j = np.argmax(fitness)  # max fitness index
     n = math.ceil(len(keys) ** 0.5)  # columns and rows in plot
     plt.figure(figsize=(10, 10), tight_layout=True)
     for i, k in enumerate(keys):
         v = x[:, i + num_metrics_columns]
         mu = v[j]  # best single result
         plt.subplot(n, n, i + 1)
-        plt_color_scatter(v, fitness, cmap='viridis', alpha=.8, edgecolors='none')
-        plt.plot(mu, fitness.max(), 'k+', markersize=15)
-        plt.title(f'{k} = {mu:.3g}', fontdict={'size': 9})  # limit to 40 characters
-        plt.tick_params(axis='both', labelsize=8)  # Set axis label size to 8
+        plt_color_scatter(v, fitness, cmap="viridis", alpha=0.8, edgecolors="none")
+        plt.plot(mu, fitness.max(), "k+", markersize=15)
+        plt.title(f"{k} = {mu:.3g}", fontdict={"size": 9})  # limit to 40 characters
+        plt.tick_params(axis="both", labelsize=8)  # Set axis label size to 8
         if i % n != 0:
             plt.yticks([])
 
-    file = csv_file.with_name('tune_scatter_plots.png')  # filename
+    file = csv_file.with_name("tune_scatter_plots.png")  # filename
     plt.savefig(file, dpi=200)
     plt.close()
-    LOGGER.info(f'Saved {file}')
+    LOGGER.info(f"Saved {file}")
 
     # Fitness vs iteration
     x = range(1, len(fitness) + 1)
     plt.figure(figsize=(10, 6), tight_layout=True)
-    plt.plot(x, fitness, marker='o', linestyle='none', label='fitness')
-    plt.plot(x, gaussian_filter1d(fitness, sigma=3), ':', label='smoothed', linewidth=2)  # smoothing line
-    plt.title('Fitness vs Iteration')
-    plt.xlabel('Iteration')
-    plt.ylabel('Fitness')
+    plt.plot(x, fitness, marker="o", linestyle="none", label="fitness")
+    plt.plot(x, gaussian_filter1d(fitness, sigma=3), ":", label="smoothed", linewidth=2)  # smoothing line
+    plt.title("Fitness vs Iteration")
+    plt.xlabel("Iteration")
+    plt.ylabel("Fitness")
     plt.grid(True)
     plt.legend()
 
-    file = csv_file.with_name('tune_fitness.png')  # filename
+    file = csv_file.with_name("tune_fitness.png")  # filename
     plt.savefig(file, dpi=200)
     plt.close()
-    LOGGER.info(f'Saved {file}')
+    LOGGER.info(f"Saved {file}")
 
 
 def output_to_target(output, max_det=300):
     """Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting."""
     targets = []
     for i, o in enumerate(output):
         box, conf, cls = o[:max_det, :6].cpu().split((4, 1, 1), 1)
         j = torch.full((conf.shape[0], 1), i)
         targets.append(torch.cat((j, cls, ops.xyxy2xywh(box), conf), 1))
     targets = torch.cat(targets, 0).numpy()
-    return targets[:, 0], targets[:, 1], targets[:, 2:]
+    return targets[:, 0], targets[:, 1], targets[:, 2:-1], targets[:, -1]
+
+
+def output_to_rotated_target(output, max_det=300):
+    """Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting."""
+    targets = []
+    for i, o in enumerate(output):
+        box, conf, cls, angle = o[:max_det].cpu().split((4, 1, 1, 1), 1)
+        j = torch.full((conf.shape[0], 1), i)
+        targets.append(torch.cat((j, cls, box, angle, conf), 1))
+    targets = torch.cat(targets, 0).numpy()
+    return targets[:, 0], targets[:, 1], targets[:, 2:-1], targets[:, -1]
 
 
-def feature_visualization(x, module_type, stage, n=32, save_dir=Path('runs/detect/exp')):
+def feature_visualization(x, module_type, stage, n=32, save_dir=Path("runs/detect/exp")):
     """
     Visualize feature maps of a given model module during inference.
 
     Args:
         x (torch.Tensor): Features to be visualized.
         module_type (str): Module type.
         stage (int): Module stage within the model.
         n (int, optional): Maximum number of feature maps to plot. Defaults to 32.
         save_dir (Path, optional): Directory to save results. Defaults to Path('runs/detect/exp').
     """
-    for m in ['Detect', 'Pose', 'Segment']:
+    for m in ["Detect", "Pose", "Segment"]:
         if m in module_type:
             return
-    batch, channels, height, width = x.shape  # batch, channels, height, width
+    _, channels, height, width = x.shape  # batch, channels, height, width
     if height > 1 and width > 1:
         f = save_dir / f"stage{stage}_{module_type.split('.')[-1]}_features.png"  # filename
 
         blocks = torch.chunk(x[0].cpu(), channels, dim=0)  # select batch index 0, block by channels
         n = min(n, channels)  # number of plots
-        fig, ax = plt.subplots(math.ceil(n / 8), 8, tight_layout=True)  # 8 rows x n/8 cols
+        _, ax = plt.subplots(math.ceil(n / 8), 8, tight_layout=True)  # 8 rows x n/8 cols
         ax = ax.ravel()
         plt.subplots_adjust(wspace=0.05, hspace=0.05)
         for i in range(n):
             ax[i].imshow(blocks[i].squeeze())  # cmap='gray'
-            ax[i].axis('off')
+            ax[i].axis("off")
 
-        LOGGER.info(f'Saving {f}... ({n}/{channels})')
-        plt.savefig(f, dpi=300, bbox_inches='tight')
+        LOGGER.info(f"Saving {f}... ({n}/{channels})")
+        plt.savefig(f, dpi=300, bbox_inches="tight")
         plt.close()
-        np.save(str(f.with_suffix('.npy')), x[0].cpu().numpy())  # npy save
+        np.save(str(f.with_suffix(".npy")), x[0].cpu().numpy())  # npy save
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/tal.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/tal.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,64 +1,17 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import torch
 import torch.nn as nn
 
 from .checks import check_version
-from .metrics import bbox_iou
+from .metrics import bbox_iou, probiou
+from .ops import xywhr2xyxyxyxy
 
-TORCH_1_10 = check_version(torch.__version__, '1.10.0')
-
-
-def select_candidates_in_gts(xy_centers, gt_bboxes, eps=1e-9):
-    """
-    Select the positive anchor center in gt.
-
-    Args:
-        xy_centers (Tensor): shape(h*w, 2)
-        gt_bboxes (Tensor): shape(b, n_boxes, 4)
-
-    Returns:
-        (Tensor): shape(b, n_boxes, h*w)
-    """
-    n_anchors = xy_centers.shape[0]
-    bs, n_boxes, _ = gt_bboxes.shape
-    lt, rb = gt_bboxes.view(-1, 1, 4).chunk(2, 2)  # left-top, right-bottom
-    bbox_deltas = torch.cat((xy_centers[None] - lt, rb - xy_centers[None]), dim=2).view(bs, n_boxes, n_anchors, -1)
-    # return (bbox_deltas.min(3)[0] > eps).to(gt_bboxes.dtype)
-    return bbox_deltas.amin(3).gt_(eps)
-
-
-def select_highest_overlaps(mask_pos, overlaps, n_max_boxes):
-    """
-    If an anchor box is assigned to multiple gts, the one with the highest IoI will be selected.
-
-    Args:
-        mask_pos (Tensor): shape(b, n_max_boxes, h*w)
-        overlaps (Tensor): shape(b, n_max_boxes, h*w)
-
-    Returns:
-        target_gt_idx (Tensor): shape(b, h*w)
-        fg_mask (Tensor): shape(b, h*w)
-        mask_pos (Tensor): shape(b, n_max_boxes, h*w)
-    """
-    # (b, n_max_boxes, h*w) -> (b, h*w)
-    fg_mask = mask_pos.sum(-2)
-    if fg_mask.max() > 1:  # one anchor is assigned to multiple gt_bboxes
-        mask_multi_gts = (fg_mask.unsqueeze(1) > 1).expand(-1, n_max_boxes, -1)  # (b, n_max_boxes, h*w)
-        max_overlaps_idx = overlaps.argmax(1)  # (b, h*w)
-
-        is_max_overlaps = torch.zeros(mask_pos.shape, dtype=mask_pos.dtype, device=mask_pos.device)
-        is_max_overlaps.scatter_(1, max_overlaps_idx.unsqueeze(1), 1)
-
-        mask_pos = torch.where(mask_multi_gts, is_max_overlaps, mask_pos).float()  # (b, n_max_boxes, h*w)
-        fg_mask = mask_pos.sum(-2)
-    # Find each grid serve which gt(index)
-    target_gt_idx = mask_pos.argmax(-2)  # (b, h*w)
-    return target_gt_idx, fg_mask, mask_pos
+TORCH_1_10 = check_version(torch.__version__, "1.10.0")
 
 
 class TaskAlignedAssigner(nn.Module):
     """
     A task-aligned assigner for object detection.
 
     This class assigns ground-truth (gt) objects to anchors based on the task-aligned metric, which combines both
@@ -99,27 +52,32 @@
         Returns:
             target_labels (Tensor): shape(bs, num_total_anchors)
             target_bboxes (Tensor): shape(bs, num_total_anchors, 4)
             target_scores (Tensor): shape(bs, num_total_anchors, num_classes)
             fg_mask (Tensor): shape(bs, num_total_anchors)
             target_gt_idx (Tensor): shape(bs, num_total_anchors)
         """
-        self.bs = pd_scores.size(0)
-        self.n_max_boxes = gt_bboxes.size(1)
+        self.bs = pd_scores.shape[0]
+        self.n_max_boxes = gt_bboxes.shape[1]
 
         if self.n_max_boxes == 0:
             device = gt_bboxes.device
-            return (torch.full_like(pd_scores[..., 0], self.bg_idx).to(device), torch.zeros_like(pd_bboxes).to(device),
-                    torch.zeros_like(pd_scores).to(device), torch.zeros_like(pd_scores[..., 0]).to(device),
-                    torch.zeros_like(pd_scores[..., 0]).to(device))
+            return (
+                torch.full_like(pd_scores[..., 0], self.bg_idx).to(device),
+                torch.zeros_like(pd_bboxes).to(device),
+                torch.zeros_like(pd_scores).to(device),
+                torch.zeros_like(pd_scores[..., 0]).to(device),
+                torch.zeros_like(pd_scores[..., 0]).to(device),
+            )
+
+        mask_pos, align_metric, overlaps = self.get_pos_mask(
+            pd_scores, pd_bboxes, gt_labels, gt_bboxes, anc_points, mask_gt
+        )
 
-        mask_pos, align_metric, overlaps = self.get_pos_mask(pd_scores, pd_bboxes, gt_labels, gt_bboxes, anc_points,
-                                                             mask_gt)
-
-        target_gt_idx, fg_mask, mask_pos = select_highest_overlaps(mask_pos, overlaps, self.n_max_boxes)
+        target_gt_idx, fg_mask, mask_pos = self.select_highest_overlaps(mask_pos, overlaps, self.n_max_boxes)
 
         # Assigned target
         target_labels, target_bboxes, target_scores = self.get_targets(gt_labels, gt_bboxes, target_gt_idx, fg_mask)
 
         # Normalize
         align_metric *= mask_pos
         pos_align_metrics = align_metric.amax(dim=-1, keepdim=True)  # b, max_num_obj
@@ -127,15 +85,15 @@
         norm_align_metric = (align_metric * pos_overlaps / (pos_align_metrics + self.eps)).amax(-2).unsqueeze(-1)
         target_scores = target_scores * norm_align_metric
 
         return target_labels, target_bboxes, target_scores, fg_mask.bool(), target_gt_idx
 
     def get_pos_mask(self, pd_scores, pd_bboxes, gt_labels, gt_bboxes, anc_points, mask_gt):
         """Get in_gts mask, (b, max_num_obj, h*w)."""
-        mask_in_gts = select_candidates_in_gts(anc_points, gt_bboxes)
+        mask_in_gts = self.select_candidates_in_gts(anc_points, gt_bboxes)
         # Get anchor_align metric, (b, max_num_obj, h*w)
         align_metric, overlaps = self.get_box_metrics(pd_scores, pd_bboxes, gt_labels, gt_bboxes, mask_in_gts * mask_gt)
         # Get topk_metric mask, (b, max_num_obj, h*w)
         mask_topk = self.select_topk_candidates(align_metric, topk_mask=mask_gt.expand(-1, -1, self.topk).bool())
         # Merge all mask to a final mask, (b, max_num_obj, h*w)
         mask_pos = mask_topk * mask_in_gts * mask_gt
 
@@ -153,19 +111,23 @@
         ind[1] = gt_labels.squeeze(-1)  # b, max_num_obj
         # Get the scores of each grid for each gt cls
         bbox_scores[mask_gt] = pd_scores[ind[0], :, ind[1]][mask_gt]  # b, max_num_obj, h*w
 
         # (b, max_num_obj, 1, 4), (b, 1, h*w, 4)
         pd_boxes = pd_bboxes.unsqueeze(1).expand(-1, self.n_max_boxes, -1, -1)[mask_gt]
         gt_boxes = gt_bboxes.unsqueeze(2).expand(-1, -1, na, -1)[mask_gt]
-        overlaps[mask_gt] = bbox_iou(gt_boxes, pd_boxes, xywh=False, CIoU=True).squeeze(-1).clamp_(0)
+        overlaps[mask_gt] = self.iou_calculation(gt_boxes, pd_boxes)
 
         align_metric = bbox_scores.pow(self.alpha) * overlaps.pow(self.beta)
         return align_metric, overlaps
 
+    def iou_calculation(self, gt_bboxes, pd_bboxes):
+        """IoU calculation for horizontal bounding boxes."""
+        return bbox_iou(gt_bboxes, pd_bboxes, xywh=False, CIoU=True).squeeze(-1).clamp_(0)
+
     def select_topk_candidates(self, metrics, largest=True, topk_mask=None):
         """
         Select the top-k candidates based on the given metrics.
 
         Args:
             metrics (Tensor): A tensor of shape (b, max_num_obj, h*w), where b is the batch size,
                               max_num_obj is the maximum number of objects, and h*w represents the
@@ -187,15 +149,15 @@
         topk_idxs.masked_fill_(~topk_mask, 0)
 
         # (b, max_num_obj, topk, h*w) -> (b, max_num_obj, h*w)
         count_tensor = torch.zeros(metrics.shape, dtype=torch.int8, device=topk_idxs.device)
         ones = torch.ones_like(topk_idxs[:, :, :1], dtype=torch.int8, device=topk_idxs.device)
         for k in range(self.topk):
             # Expand topk_idxs for each value of k and add 1 at the specified positions
-            count_tensor.scatter_add_(-1, topk_idxs[:, :, k:k + 1], ones)
+            count_tensor.scatter_add_(-1, topk_idxs[:, :, k : k + 1], ones)
         # count_tensor.scatter_add_(-1, topk_idxs, torch.ones_like(topk_idxs, dtype=torch.int8, device=topk_idxs.device))
         # Filter invalid bboxes
         count_tensor.masked_fill_(count_tensor > 1, 0)
 
         return count_tensor.to(metrics.dtype)
 
     def get_targets(self, gt_labels, gt_bboxes, target_gt_idx, fg_mask):
@@ -225,41 +187,124 @@
 
         # Assigned target labels, (b, 1)
         batch_ind = torch.arange(end=self.bs, dtype=torch.int64, device=gt_labels.device)[..., None]
         target_gt_idx = target_gt_idx + batch_ind * self.n_max_boxes  # (b, h*w)
         target_labels = gt_labels.long().flatten()[target_gt_idx]  # (b, h*w)
 
         # Assigned target boxes, (b, max_num_obj, 4) -> (b, h*w, 4)
-        target_bboxes = gt_bboxes.view(-1, 4)[target_gt_idx]
+        target_bboxes = gt_bboxes.view(-1, gt_bboxes.shape[-1])[target_gt_idx]
 
         # Assigned target scores
         target_labels.clamp_(0)
 
         # 10x faster than F.one_hot()
-        target_scores = torch.zeros((target_labels.shape[0], target_labels.shape[1], self.num_classes),
-                                    dtype=torch.int64,
-                                    device=target_labels.device)  # (b, h*w, 80)
+        target_scores = torch.zeros(
+            (target_labels.shape[0], target_labels.shape[1], self.num_classes),
+            dtype=torch.int64,
+            device=target_labels.device,
+        )  # (b, h*w, 80)
         target_scores.scatter_(2, target_labels.unsqueeze(-1), 1)
 
         fg_scores_mask = fg_mask[:, :, None].repeat(1, 1, self.num_classes)  # (b, h*w, 80)
         target_scores = torch.where(fg_scores_mask > 0, target_scores, 0)
 
         return target_labels, target_bboxes, target_scores
 
+    @staticmethod
+    def select_candidates_in_gts(xy_centers, gt_bboxes, eps=1e-9):
+        """
+        Select the positive anchor center in gt.
+
+        Args:
+            xy_centers (Tensor): shape(h*w, 2)
+            gt_bboxes (Tensor): shape(b, n_boxes, 4)
+
+        Returns:
+            (Tensor): shape(b, n_boxes, h*w)
+        """
+        n_anchors = xy_centers.shape[0]
+        bs, n_boxes, _ = gt_bboxes.shape
+        lt, rb = gt_bboxes.view(-1, 1, 4).chunk(2, 2)  # left-top, right-bottom
+        bbox_deltas = torch.cat((xy_centers[None] - lt, rb - xy_centers[None]), dim=2).view(bs, n_boxes, n_anchors, -1)
+        # return (bbox_deltas.min(3)[0] > eps).to(gt_bboxes.dtype)
+        return bbox_deltas.amin(3).gt_(eps)
+
+    @staticmethod
+    def select_highest_overlaps(mask_pos, overlaps, n_max_boxes):
+        """
+        If an anchor box is assigned to multiple gts, the one with the highest IoU will be selected.
+
+        Args:
+            mask_pos (Tensor): shape(b, n_max_boxes, h*w)
+            overlaps (Tensor): shape(b, n_max_boxes, h*w)
+
+        Returns:
+            target_gt_idx (Tensor): shape(b, h*w)
+            fg_mask (Tensor): shape(b, h*w)
+            mask_pos (Tensor): shape(b, n_max_boxes, h*w)
+        """
+        # (b, n_max_boxes, h*w) -> (b, h*w)
+        fg_mask = mask_pos.sum(-2)
+        if fg_mask.max() > 1:  # one anchor is assigned to multiple gt_bboxes
+            mask_multi_gts = (fg_mask.unsqueeze(1) > 1).expand(-1, n_max_boxes, -1)  # (b, n_max_boxes, h*w)
+            max_overlaps_idx = overlaps.argmax(1)  # (b, h*w)
+
+            is_max_overlaps = torch.zeros(mask_pos.shape, dtype=mask_pos.dtype, device=mask_pos.device)
+            is_max_overlaps.scatter_(1, max_overlaps_idx.unsqueeze(1), 1)
+
+            mask_pos = torch.where(mask_multi_gts, is_max_overlaps, mask_pos).float()  # (b, n_max_boxes, h*w)
+            fg_mask = mask_pos.sum(-2)
+        # Find each grid serve which gt(index)
+        target_gt_idx = mask_pos.argmax(-2)  # (b, h*w)
+        return target_gt_idx, fg_mask, mask_pos
+
+
+class RotatedTaskAlignedAssigner(TaskAlignedAssigner):
+    def iou_calculation(self, gt_bboxes, pd_bboxes):
+        """IoU calculation for rotated bounding boxes."""
+        return probiou(gt_bboxes, pd_bboxes).squeeze(-1).clamp_(0)
+
+    @staticmethod
+    def select_candidates_in_gts(xy_centers, gt_bboxes):
+        """
+        Select the positive anchor center in gt for rotated bounding boxes.
+
+        Args:
+            xy_centers (Tensor): shape(h*w, 2)
+            gt_bboxes (Tensor): shape(b, n_boxes, 5)
+
+        Returns:
+            (Tensor): shape(b, n_boxes, h*w)
+        """
+        # (b, n_boxes, 5) --> (b, n_boxes, 4, 2)
+        corners = xywhr2xyxyxyxy(gt_bboxes)
+        # (b, n_boxes, 1, 2)
+        a, b, _, d = corners.split(1, dim=-2)
+        ab = b - a
+        ad = d - a
+
+        # (b, n_boxes, h*w, 2)
+        ap = xy_centers - a
+        norm_ab = (ab * ab).sum(dim=-1)
+        norm_ad = (ad * ad).sum(dim=-1)
+        ap_dot_ab = (ap * ab).sum(dim=-1)
+        ap_dot_ad = (ap * ad).sum(dim=-1)
+        return (ap_dot_ab >= 0) & (ap_dot_ab <= norm_ab) & (ap_dot_ad >= 0) & (ap_dot_ad <= norm_ad)  # is_in_box
+
 
 def make_anchors(feats, strides, grid_cell_offset=0.5):
     """Generate anchors from features."""
     anchor_points, stride_tensor = [], []
     assert feats is not None
     dtype, device = feats[0].dtype, feats[0].device
     for i, stride in enumerate(strides):
         _, _, h, w = feats[i].shape
         sx = torch.arange(end=w, device=device, dtype=dtype) + grid_cell_offset  # shift x
         sy = torch.arange(end=h, device=device, dtype=dtype) + grid_cell_offset  # shift y
-        sy, sx = torch.meshgrid(sy, sx, indexing='ij') if TORCH_1_10 else torch.meshgrid(sy, sx)
+        sy, sx = torch.meshgrid(sy, sx, indexing="ij") if TORCH_1_10 else torch.meshgrid(sy, sx)
         anchor_points.append(torch.stack((sx, sy), -1).view(-1, 2))
         stride_tensor.append(torch.full((h * w, 1), stride, dtype=dtype, device=device))
     return torch.cat(anchor_points), torch.cat(stride_tensor)
 
 
 def dist2bbox(distance, anchor_points, xywh=True, dim=-1):
     """Transform distance(ltrb) to box(xywh or xyxy)."""
@@ -273,7 +318,27 @@
     return torch.cat((x1y1, x2y2), dim)  # xyxy bbox
 
 
 def bbox2dist(anchor_points, bbox, reg_max):
     """Transform bbox(xyxy) to dist(ltrb)."""
     x1y1, x2y2 = bbox.chunk(2, -1)
     return torch.cat((anchor_points - x1y1, x2y2 - anchor_points), -1).clamp_(0, reg_max - 0.01)  # dist (lt, rb)
+
+
+def dist2rbox(pred_dist, pred_angle, anchor_points, dim=-1):
+    """
+    Decode predicted object bounding box coordinates from anchor points and distribution.
+
+    Args:
+        pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).
+        pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).
+        anchor_points (torch.Tensor): Anchor points, (h*w, 2).
+    Returns:
+        (torch.Tensor): Predicted rotated bounding boxes, (bs, h*w, 4).
+    """
+    lt, rb = pred_dist.split(2, dim=dim)
+    cos, sin = torch.cos(pred_angle), torch.sin(pred_angle)
+    # (bs, h*w, 1)
+    xf, yf = ((rb - lt) / 2).split(1, dim=dim)
+    x, y = xf * cos - yf * sin, xf * sin + yf * cos
+    xy = torch.cat([x, y], dim=dim) + anchor_points
+    return torch.cat([xy, lt + rb], dim=dim)
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/torch_utils.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/torch_utils.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,42 +1,54 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import math
 import os
-import platform
 import random
 import time
 from contextlib import contextmanager
 from copy import deepcopy
 from pathlib import Path
 from typing import Union
 
 import numpy as np
 import torch
 import torch.distributed as dist
 import torch.nn as nn
 import torch.nn.functional as F
 
-from ultralytics.utils import DEFAULT_CFG_DICT, DEFAULT_CFG_KEYS, LOGGER, __version__
+from ultralytics.utils import (
+    DEFAULT_CFG_DICT,
+    DEFAULT_CFG_KEYS,
+    LOGGER,
+    PYTHON_VERSION,
+    TORCHVISION_VERSION,
+    __version__,
+    colorstr,
+)
 from ultralytics.utils.checks import check_version
 
 try:
     import thop
 except ImportError:
     thop = None
 
-TORCH_1_9 = check_version(torch.__version__, '1.9.0')
-TORCH_2_0 = check_version(torch.__version__, '2.0.0')
+# Version checks (all default to version>=min_version)
+TORCH_1_9 = check_version(torch.__version__, "1.9.0")
+TORCH_1_13 = check_version(torch.__version__, "1.13.0")
+TORCH_2_0 = check_version(torch.__version__, "2.0.0")
+TORCHVISION_0_10 = check_version(TORCHVISION_VERSION, "0.10.0")
+TORCHVISION_0_11 = check_version(TORCHVISION_VERSION, "0.11.0")
+TORCHVISION_0_13 = check_version(TORCHVISION_VERSION, "0.13.0")
 
 
 @contextmanager
 def torch_distributed_zero_first(local_rank: int):
     """Decorator to make all processes in distributed training wait for each local_master to do something."""
     initialized = torch.distributed.is_available() and torch.distributed.is_initialized()
-    if initialized and local_rank not in (-1, 0):
+    if initialized and local_rank not in {-1, 0}:
         dist.barrier(device_ids=[local_rank])
     yield
     if initialized and local_rank == 0:
         dist.barrier(device_ids=[0])
 
 
 def smart_inference_mode():
@@ -52,21 +64,21 @@
     return decorate
 
 
 def get_cpu_info():
     """Return a string with system CPU information, i.e. 'Apple M2'."""
     import cpuinfo  # pip install py-cpuinfo
 
-    k = 'brand_raw', 'hardware_raw', 'arch_string_raw'  # info keys sorted by preference (not all keys always available)
+    k = "brand_raw", "hardware_raw", "arch_string_raw"  # info keys sorted by preference (not all keys always available)
     info = cpuinfo.get_cpu_info()  # info dict
-    string = info.get(k[0] if k[0] in info else k[1] if k[1] in info else k[2], 'unknown')
-    return string.replace('(R)', '').replace('CPU ', '').replace('@ ', '')
+    string = info.get(k[0] if k[0] in info else k[1] if k[1] in info else k[2], "unknown")
+    return string.replace("(R)", "").replace("CPU ", "").replace("@ ", "")
 
 
-def select_device(device='', batch=0, newline=False, verbose=True):
+def select_device(device="", batch=0, newline=False, verbose=True):
     """
     Selects the appropriate PyTorch device based on the provided arguments.
 
     The function takes a string specifying the device or a torch.device object and returns a torch.device object
     representing the selected device. The function also validates the number of available devices and raises an
     exception if the requested device(s) are not available.
 
@@ -95,57 +107,65 @@
     Note:
         Sets the 'CUDA_VISIBLE_DEVICES' environment variable for specifying which GPUs to use.
     """
 
     if isinstance(device, torch.device):
         return device
 
-    s = f'Ultralytics YOLOv{__version__}  Python-{platform.python_version()} torch-{torch.__version__} '
+    s = f"Ultralytics YOLOv{__version__}  Python-{PYTHON_VERSION} torch-{torch.__version__} "
     device = str(device).lower()
-    for remove in 'cuda:', 'none', '(', ')', '[', ']', "'", ' ':
-        device = device.replace(remove, '')  # to string, 'cuda:0' -> '0' and '(0, 1)' -> '0,1'
-    cpu = device == 'cpu'
-    mps = device in ('mps', 'mps:0')  # Apple Metal Performance Shaders (MPS)
+    for remove in "cuda:", "none", "(", ")", "[", "]", "'", " ":
+        device = device.replace(remove, "")  # to string, 'cuda:0' -> '0' and '(0, 1)' -> '0,1'
+    cpu = device == "cpu"
+    mps = device in {"mps", "mps:0"}  # Apple Metal Performance Shaders (MPS)
     if cpu or mps:
-        os.environ['CUDA_VISIBLE_DEVICES'] = '-1'  # force torch.cuda.is_available() = False
+        os.environ["CUDA_VISIBLE_DEVICES"] = "-1"  # force torch.cuda.is_available() = False
     elif device:  # non-cpu device requested
-        if device == 'cuda':
-            device = '0'
-        visible = os.environ.get('CUDA_VISIBLE_DEVICES', None)
-        os.environ['CUDA_VISIBLE_DEVICES'] = device  # set environment variable - must be before assert is_available()
-        if not (torch.cuda.is_available() and torch.cuda.device_count() >= len(device.replace(',', ''))):
+        if device == "cuda":
+            device = "0"
+        visible = os.environ.get("CUDA_VISIBLE_DEVICES", None)
+        os.environ["CUDA_VISIBLE_DEVICES"] = device  # set environment variable - must be before assert is_available()
+        if not (torch.cuda.is_available() and torch.cuda.device_count() >= len(device.split(","))):
             LOGGER.info(s)
-            install = 'See https://pytorch.org/get-started/locally/ for up-to-date torch install instructions if no ' \
-                      'CUDA devices are seen by torch.\n' if torch.cuda.device_count() == 0 else ''
-            raise ValueError(f"Invalid CUDA 'device={device}' requested."
-                             f" Use 'device=cpu' or pass valid CUDA device(s) if available,"
-                             f" i.e. 'device=0' or 'device=0,1,2,3' for Multi-GPU.\n"
-                             f'\ntorch.cuda.is_available(): {torch.cuda.is_available()}'
-                             f'\ntorch.cuda.device_count(): {torch.cuda.device_count()}'
-                             f"\nos.environ['CUDA_VISIBLE_DEVICES']: {visible}\n"
-                             f'{install}')
+            install = (
+                "See https://pytorch.org/get-started/locally/ for up-to-date torch install instructions if no "
+                "CUDA devices are seen by torch.\n"
+                if torch.cuda.device_count() == 0
+                else ""
+            )
+            raise ValueError(
+                f"Invalid CUDA 'device={device}' requested."
+                f" Use 'device=cpu' or pass valid CUDA device(s) if available,"
+                f" i.e. 'device=0' or 'device=0,1,2,3' for Multi-GPU.\n"
+                f"\ntorch.cuda.is_available(): {torch.cuda.is_available()}"
+                f"\ntorch.cuda.device_count(): {torch.cuda.device_count()}"
+                f"\nos.environ['CUDA_VISIBLE_DEVICES']: {visible}\n"
+                f"{install}"
+            )
 
     if not cpu and not mps and torch.cuda.is_available():  # prefer GPU if available
-        devices = device.split(',') if device else '0'  # range(torch.cuda.device_count())  # i.e. 0,1,6,7
+        devices = device.split(",") if device else "0"  # range(torch.cuda.device_count())  # i.e. 0,1,6,7
         n = len(devices)  # device count
         if n > 1 and batch > 0 and batch % n != 0:  # check batch_size is divisible by device_count
-            raise ValueError(f"'batch={batch}' must be a multiple of GPU count {n}. Try 'batch={batch // n * n}' or "
-                             f"'batch={batch // n * n + n}', the nearest batch sizes evenly divisible by {n}.")
-        space = ' ' * (len(s) + 1)
+            raise ValueError(
+                f"'batch={batch}' must be a multiple of GPU count {n}. Try 'batch={batch // n * n}' or "
+                f"'batch={batch // n * n + n}', the nearest batch sizes evenly divisible by {n}."
+            )
+        space = " " * (len(s) + 1)
         for i, d in enumerate(devices):
             p = torch.cuda.get_device_properties(i)
             s += f"{'' if i == 0 else space}CUDA:{d} ({p.name}, {p.total_memory / (1 << 20):.0f}MiB)\n"  # bytes to MB
-        arg = 'cuda:0'
+        arg = "cuda:0"
     elif mps and TORCH_2_0 and torch.backends.mps.is_available():
         # Prefer MPS if available
-        s += f'MPS ({get_cpu_info()})\n'
-        arg = 'mps'
+        s += f"MPS ({get_cpu_info()})\n"
+        arg = "mps"
     else:  # revert to CPU
-        s += f'CPU ({get_cpu_info()})\n'
-        arg = 'cpu'
+        s += f"CPU ({get_cpu_info()})\n"
+        arg = "cpu"
 
     if verbose:
         LOGGER.info(s if newline else s.rstrip())
     return torch.device(arg)
 
 
 def time_sync():
@@ -153,55 +173,67 @@
     if torch.cuda.is_available():
         torch.cuda.synchronize()
     return time.time()
 
 
 def fuse_conv_and_bn(conv, bn):
     """Fuse Conv2d() and BatchNorm2d() layers https://tehnokv.com/posts/fusing-batchnorm-and-conv/."""
-    fusedconv = nn.Conv2d(conv.in_channels,
-                          conv.out_channels,
-                          kernel_size=conv.kernel_size,
-                          stride=conv.stride,
-                          padding=conv.padding,
-                          dilation=conv.dilation,
-                          groups=conv.groups,
-                          bias=True).requires_grad_(False).to(conv.weight.device)
+    fusedconv = (
+        nn.Conv2d(
+            conv.in_channels,
+            conv.out_channels,
+            kernel_size=conv.kernel_size,
+            stride=conv.stride,
+            padding=conv.padding,
+            dilation=conv.dilation,
+            groups=conv.groups,
+            bias=True,
+        )
+        .requires_grad_(False)
+        .to(conv.weight.device)
+    )
 
     # Prepare filters
     w_conv = conv.weight.clone().view(conv.out_channels, -1)
     w_bn = torch.diag(bn.weight.div(torch.sqrt(bn.eps + bn.running_var)))
     fusedconv.weight.copy_(torch.mm(w_bn, w_conv).view(fusedconv.weight.shape))
 
     # Prepare spatial bias
-    b_conv = torch.zeros(conv.weight.size(0), device=conv.weight.device) if conv.bias is None else conv.bias
+    b_conv = torch.zeros(conv.weight.shape[0], device=conv.weight.device) if conv.bias is None else conv.bias
     b_bn = bn.bias - bn.weight.mul(bn.running_mean).div(torch.sqrt(bn.running_var + bn.eps))
     fusedconv.bias.copy_(torch.mm(w_bn, b_conv.reshape(-1, 1)).reshape(-1) + b_bn)
 
     return fusedconv
 
 
 def fuse_deconv_and_bn(deconv, bn):
     """Fuse ConvTranspose2d() and BatchNorm2d() layers."""
-    fuseddconv = nn.ConvTranspose2d(deconv.in_channels,
-                                    deconv.out_channels,
-                                    kernel_size=deconv.kernel_size,
-                                    stride=deconv.stride,
-                                    padding=deconv.padding,
-                                    output_padding=deconv.output_padding,
-                                    dilation=deconv.dilation,
-                                    groups=deconv.groups,
-                                    bias=True).requires_grad_(False).to(deconv.weight.device)
+    fuseddconv = (
+        nn.ConvTranspose2d(
+            deconv.in_channels,
+            deconv.out_channels,
+            kernel_size=deconv.kernel_size,
+            stride=deconv.stride,
+            padding=deconv.padding,
+            output_padding=deconv.output_padding,
+            dilation=deconv.dilation,
+            groups=deconv.groups,
+            bias=True,
+        )
+        .requires_grad_(False)
+        .to(deconv.weight.device)
+    )
 
     # Prepare filters
     w_deconv = deconv.weight.clone().view(deconv.out_channels, -1)
     w_bn = torch.diag(bn.weight.div(torch.sqrt(bn.eps + bn.running_var)))
     fuseddconv.weight.copy_(torch.mm(w_bn, w_deconv).view(fuseddconv.weight.shape))
 
     # Prepare spatial bias
-    b_conv = torch.zeros(deconv.weight.size(1), device=deconv.weight.device) if deconv.bias is None else deconv.bias
+    b_conv = torch.zeros(deconv.weight.shape[1], device=deconv.weight.device) if deconv.bias is None else deconv.bias
     b_bn = bn.bias - bn.weight.mul(bn.running_mean).div(torch.sqrt(bn.running_var + bn.eps))
     fuseddconv.bias.copy_(torch.mm(w_bn, b_conv.reshape(-1, 1)).reshape(-1) + b_bn)
 
     return fuseddconv
 
 
 def model_info(model, detailed=False, verbose=True, imgsz=640):
@@ -213,26 +245,29 @@
     if not verbose:
         return
     n_p = get_num_params(model)  # number of parameters
     n_g = get_num_gradients(model)  # number of gradients
     n_l = len(list(model.modules()))  # number of layers
     if detailed:
         LOGGER.info(
-            f"{'layer':>5} {'name':>40} {'gradient':>9} {'parameters':>12} {'shape':>20} {'mu':>10} {'sigma':>10}")
+            f"{'layer':>5} {'name':>40} {'gradient':>9} {'parameters':>12} {'shape':>20} {'mu':>10} {'sigma':>10}"
+        )
         for i, (name, p) in enumerate(model.named_parameters()):
-            name = name.replace('module_list.', '')
-            LOGGER.info('%5g %40s %9s %12g %20s %10.3g %10.3g %10s' %
-                        (i, name, p.requires_grad, p.numel(), list(p.shape), p.mean(), p.std(), p.dtype))
+            name = name.replace("module_list.", "")
+            LOGGER.info(
+                "%5g %40s %9s %12g %20s %10.3g %10.3g %10s"
+                % (i, name, p.requires_grad, p.numel(), list(p.shape), p.mean(), p.std(), p.dtype)
+            )
 
     flops = get_flops(model, imgsz)
-    fused = ' (fused)' if getattr(model, 'is_fused', lambda: False)() else ''
-    fs = f', {flops:.1f} GFLOPs' if flops else ''
-    yaml_file = getattr(model, 'yaml_file', '') or getattr(model, 'yaml', {}).get('yaml_file', '')
-    model_name = Path(yaml_file).stem.replace('yolo', 'YOLO') or 'Model'
-    LOGGER.info(f'{model_name} summary{fused}: {n_l} layers, {n_p} parameters, {n_g} gradients{fs}')
+    fused = " (fused)" if getattr(model, "is_fused", lambda: False)() else ""
+    fs = f", {flops:.1f} GFLOPs" if flops else ""
+    yaml_file = getattr(model, "yaml_file", "") or getattr(model, "yaml", {}).get("yaml_file", "")
+    model_name = Path(yaml_file).stem.replace("yolo", "YOLO") or "Model"
+    LOGGER.info(f"{model_name} summary{fused}: {n_l} layers, {n_p} parameters, {n_g} gradients{fs}")
     return n_l, n_p, n_g, flops
 
 
 def get_num_params(model):
     """Return the total number of parameters in a YOLO model."""
     return sum(x.numel() for x in model.parameters())
 
@@ -254,48 +289,60 @@
                    'model/speed_ONNX(ms)': 41.244,
                    'model/speed_TensorRT(ms)': 3.211,
                    'model/speed_PyTorch(ms)': 18.755}
         ```
     """
     if trainer.args.profile:  # profile ONNX and TensorRT times
         from ultralytics.utils.benchmarks import ProfileModels
+
         results = ProfileModels([trainer.last], device=trainer.device).profile()[0]
-        results.pop('model/name')
+        results.pop("model/name")
     else:  # only return PyTorch times from most recent validation
         results = {
-            'model/parameters': get_num_params(trainer.model),
-            'model/GFLOPs': round(get_flops(trainer.model), 3)}
-    results['model/speed_PyTorch(ms)'] = round(trainer.validator.speed['inference'], 3)
+            "model/parameters": get_num_params(trainer.model),
+            "model/GFLOPs": round(get_flops(trainer.model), 3),
+        }
+    results["model/speed_PyTorch(ms)"] = round(trainer.validator.speed["inference"], 3)
     return results
 
 
 def get_flops(model, imgsz=640):
     """Return a YOLO model's FLOPs."""
+    if not thop:
+        return 0.0  # if not installed return 0.0 GFLOPs
+
     try:
         model = de_parallel(model)
         p = next(model.parameters())
-        stride = max(int(model.stride.max()), 32) if hasattr(model, 'stride') else 32  # max stride
-        im = torch.empty((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format
-        flops = thop.profile(deepcopy(model), inputs=[im], verbose=False)[0] / 1E9 * 2 if thop else 0  # stride GFLOPs
-        imgsz = imgsz if isinstance(imgsz, list) else [imgsz, imgsz]  # expand if int/float
-        return flops * imgsz[0] / stride * imgsz[1] / stride  # 640x640 GFLOPs
+        if not isinstance(imgsz, list):
+            imgsz = [imgsz, imgsz]  # expand if int/float
+        try:
+            # Use stride size for input tensor
+            stride = max(int(model.stride.max()), 32) if hasattr(model, "stride") else 32  # max stride
+            im = torch.empty((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format
+            flops = thop.profile(deepcopy(model), inputs=[im], verbose=False)[0] / 1e9 * 2  # stride GFLOPs
+            return flops * imgsz[0] / stride * imgsz[1] / stride  # imgsz GFLOPs
+        except Exception:
+            # Use actual image size for input tensor (i.e. required for RTDETR models)
+            im = torch.empty((1, p.shape[1], *imgsz), device=p.device)  # input image in BCHW format
+            return thop.profile(deepcopy(model), inputs=[im], verbose=False)[0] / 1e9 * 2  # imgsz GFLOPs
     except Exception:
-        return 0
+        return 0.0
 
 
 def get_flops_with_torch_profiler(model, imgsz=640):
     """Compute model FLOPs (thop alternative)."""
     if TORCH_2_0:
         model = de_parallel(model)
         p = next(model.parameters())
-        stride = (max(int(model.stride.max()), 32) if hasattr(model, 'stride') else 32) * 2  # max stride
+        stride = (max(int(model.stride.max()), 32) if hasattr(model, "stride") else 32) * 2  # max stride
         im = torch.zeros((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format
         with torch.profiler.profile(with_flops=True) as prof:
             model(im)
-        flops = sum(x.flops for x in prof.key_averages()) / 1E9
+        flops = sum(x.flops for x in prof.key_averages()) / 1e9
         imgsz = imgsz if isinstance(imgsz, list) else [imgsz, imgsz]  # expand if int/float
         flops = flops * imgsz[0] / stride * imgsz[1] / stride  # 640x640 GFLOPs
         return flops
     return 0
 
 
 def initialize_weights(model):
@@ -303,27 +350,27 @@
     for m in model.modules():
         t = type(m)
         if t is nn.Conv2d:
             pass  # nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')
         elif t is nn.BatchNorm2d:
             m.eps = 1e-3
             m.momentum = 0.03
-        elif t in [nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU]:
+        elif t in {nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU}:
             m.inplace = True
 
 
 def scale_img(img, ratio=1.0, same_shape=False, gs=32):
     """Scales and pads an image tensor of shape img(bs,3,y,x) based on given ratio and grid size gs, optionally
     retaining the original shape.
     """
     if ratio == 1.0:
         return img
     h, w = img.shape[2:]
     s = (int(h * ratio), int(w * ratio))  # new size
-    img = F.interpolate(img, size=s, mode='bilinear', align_corners=False)  # resize
+    img = F.interpolate(img, size=s, mode="bilinear", align_corners=False)  # resize
     if not same_shape:  # pad/crop img
         h, w = (math.ceil(x * ratio / gs) * gs for x in (h, w))
     return F.pad(img, [0, w - s[1], 0, h - s[0]], value=0.447)  # value = imagenet mean
 
 
 def make_divisible(x, divisor):
     """Returns nearest x divisible by divisor."""
@@ -331,23 +378,23 @@
         divisor = int(divisor.max())  # to int
     return math.ceil(x / divisor) * divisor
 
 
 def copy_attr(a, b, include=(), exclude=()):
     """Copies attributes from object 'b' to object 'a', with options to include/exclude certain attributes."""
     for k, v in b.__dict__.items():
-        if (len(include) and k not in include) or k.startswith('_') or k in exclude:
+        if (len(include) and k not in include) or k.startswith("_") or k in exclude:
             continue
         else:
             setattr(a, k, v)
 
 
 def get_latest_opset():
     """Return second-most (for maturity) recently supported ONNX opset by this version of torch."""
-    return max(int(k[14:]) for k in vars(torch.onnx) if 'symbolic_opset' in k) - 1  # opset
+    return max(int(k[14:]) for k in vars(torch.onnx) if "symbolic_opset" in k) - 1  # opset
 
 
 def intersect_dicts(da, db, exclude=()):
     """Returns a dictionary of intersecting keys with matching shapes, excluding 'exclude' keys, using da values."""
     return {k: v for k, v in da.items() if k in db and all(x not in k for x in exclude) and v.shape == db[k].shape}
 
 
@@ -359,33 +406,33 @@
 def de_parallel(model):
     """De-parallelize a model: returns single-GPU model if model is of type DP or DDP."""
     return model.module if is_parallel(model) else model
 
 
 def one_cycle(y1=0.0, y2=1.0, steps=100):
     """Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf."""
-    return lambda x: ((1 - math.cos(x * math.pi / steps)) / 2) * (y2 - y1) + y1
+    return lambda x: max((1 - math.cos(x * math.pi / steps)) / 2, 0) * (y2 - y1) + y1
 
 
 def init_seeds(seed=0, deterministic=False):
     """Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html."""
     random.seed(seed)
     np.random.seed(seed)
     torch.manual_seed(seed)
     torch.cuda.manual_seed(seed)
     torch.cuda.manual_seed_all(seed)  # for Multi-GPU, exception safe
     # torch.backends.cudnn.benchmark = True  # AutoBatch problem https://github.com/ultralytics/yolov5/issues/9287
     if deterministic:
         if TORCH_2_0:
             torch.use_deterministic_algorithms(True, warn_only=True)  # warn if deterministic is not possible
             torch.backends.cudnn.deterministic = True
-            os.environ['CUBLAS_WORKSPACE_CONFIG'] = ':4096:8'
-            os.environ['PYTHONHASHSEED'] = str(seed)
+            os.environ["CUBLAS_WORKSPACE_CONFIG"] = ":4096:8"
+            os.environ["PYTHONHASHSEED"] = str(seed)
         else:
-            LOGGER.warning('WARNING  Upgrade to torch>=2.0.0 for deterministic training.')
+            LOGGER.warning("WARNING  Upgrade to torch>=2.0.0 for deterministic training.")
     else:
         torch.use_deterministic_algorithms(False)
         torch.backends.cudnn.deterministic = False
 
 
 class ModelEMA:
     """Updated Exponential Moving Average (EMA) from https://github.com/rwightman/pytorch-image-models
@@ -412,21 +459,21 @@
             msd = de_parallel(model).state_dict()  # model state_dict
             for k, v in self.ema.state_dict().items():
                 if v.dtype.is_floating_point:  # true for FP16 and FP32
                     v *= d
                     v += (1 - d) * msd[k].detach()
                     # assert v.dtype == msd[k].dtype == torch.float32, f'{k}: EMA {v.dtype},  model {msd[k].dtype}'
 
-    def update_attr(self, model, include=(), exclude=('process_group', 'reducer')):
+    def update_attr(self, model, include=(), exclude=("process_group", "reducer")):
         """Updates attributes and saves stripped model with optimizer removed."""
         if self.enabled:
             copy_attr(self.ema, model, include, exclude)
 
 
-def strip_optimizer(f: Union[str, Path] = 'best.pt', s: str = '') -> None:
+def strip_optimizer(f: Union[str, Path] = "best.pt", s: str = "") -> None:
     """
     Strip optimizer from 'f' to finalize training, optionally save as 's'.
 
     Args:
         f (str): file path to model to strip the optimizer from. Default is 'best.pt'.
         s (str): file path to save the model with stripped optimizer to. If not provided, 'f' will be overwritten.
 
@@ -438,37 +485,51 @@
         from pathlib import Path
         from ultralytics.utils.torch_utils import strip_optimizer
 
         for f in Path('path/to/weights').rglob('*.pt'):
             strip_optimizer(f)
         ```
     """
-    x = torch.load(f, map_location=torch.device('cpu'))
-    if 'model' not in x:
-        LOGGER.info(f'Skipping {f}, not a valid Ultralytics model.')
+    x = torch.load(f, map_location=torch.device("cpu"))
+    if "model" not in x:
+        LOGGER.info(f"Skipping {f}, not a valid Ultralytics model.")
         return
 
-    if hasattr(x['model'], 'args'):
-        x['model'].args = dict(x['model'].args)  # convert from IterableSimpleNamespace to dict
-    args = {**DEFAULT_CFG_DICT, **x['train_args']} if 'train_args' in x else None  # combine args
-    if x.get('ema'):
-        x['model'] = x['ema']  # replace model with ema
-    for k in 'optimizer', 'best_fitness', 'ema', 'updates':  # keys
+    if hasattr(x["model"], "args"):
+        x["model"].args = dict(x["model"].args)  # convert from IterableSimpleNamespace to dict
+    args = {**DEFAULT_CFG_DICT, **x["train_args"]} if "train_args" in x else None  # combine args
+    if x.get("ema"):
+        x["model"] = x["ema"]  # replace model with ema
+    for k in "optimizer", "best_fitness", "ema", "updates":  # keys
         x[k] = None
-    x['epoch'] = -1
-    x['model'].half()  # to FP16
-    for p in x['model'].parameters():
+    x["epoch"] = -1
+    x["model"].half()  # to FP16
+    for p in x["model"].parameters():
         p.requires_grad = False
-    x['train_args'] = {k: v for k, v in args.items() if k in DEFAULT_CFG_KEYS}  # strip non-default keys
+    x["train_args"] = {k: v for k, v in args.items() if k in DEFAULT_CFG_KEYS}  # strip non-default keys
     # x['model'].args = x['train_args']
     torch.save(x, s or f)
-    mb = os.path.getsize(s or f) / 1E6  # file size
+    mb = os.path.getsize(s or f) / 1e6  # file size
     LOGGER.info(f"Optimizer stripped from {f},{f' saved as {s},' if s else ''} {mb:.1f}MB")
 
 
+def convert_optimizer_state_dict_to_fp16(state_dict):
+    """
+    Converts the state_dict of a given optimizer to FP16, focusing on the 'state' key for tensor conversions.
+
+    This method aims to reduce storage size without altering 'param_groups' as they contain non-tensor data.
+    """
+    for state in state_dict["state"].values():
+        for k, v in state.items():
+            if k != "step" and isinstance(v, torch.Tensor) and v.dtype is torch.float32:
+                state[k] = v.half()
+
+    return state_dict
+
+
 def profile(input, ops, n=10, device=None):
     """
     Ultralytics speed, memory and FLOPs profiler.
 
     Example:
         ```python
         from ultralytics.utils.torch_utils import profile
@@ -478,46 +539,48 @@
         m2 = nn.SiLU()
         profile(input, [m1, m2], n=100)  # profile over 100 iterations
         ```
     """
     results = []
     if not isinstance(device, torch.device):
         device = select_device(device)
-    LOGGER.info(f"{'Params':>12s}{'GFLOPs':>12s}{'GPU_mem (GB)':>14s}{'forward (ms)':>14s}{'backward (ms)':>14s}"
-                f"{'input':>24s}{'output':>24s}")
+    LOGGER.info(
+        f"{'Params':>12s}{'GFLOPs':>12s}{'GPU_mem (GB)':>14s}{'forward (ms)':>14s}{'backward (ms)':>14s}"
+        f"{'input':>24s}{'output':>24s}"
+    )
 
     for x in input if isinstance(input, list) else [input]:
         x = x.to(device)
         x.requires_grad = True
         for m in ops if isinstance(ops, list) else [ops]:
-            m = m.to(device) if hasattr(m, 'to') else m  # device
-            m = m.half() if hasattr(m, 'half') and isinstance(x, torch.Tensor) and x.dtype is torch.float16 else m
+            m = m.to(device) if hasattr(m, "to") else m  # device
+            m = m.half() if hasattr(m, "half") and isinstance(x, torch.Tensor) and x.dtype is torch.float16 else m
             tf, tb, t = 0, 0, [0, 0, 0]  # dt forward, backward
             try:
-                flops = thop.profile(m, inputs=[x], verbose=False)[0] / 1E9 * 2 if thop else 0  # GFLOPs
+                flops = thop.profile(m, inputs=[x], verbose=False)[0] / 1e9 * 2 if thop else 0  # GFLOPs
             except Exception:
                 flops = 0
 
             try:
                 for _ in range(n):
                     t[0] = time_sync()
                     y = m(x)
                     t[1] = time_sync()
                     try:
                         (sum(yi.sum() for yi in y) if isinstance(y, list) else y).sum().backward()
                         t[2] = time_sync()
                     except Exception:  # no backward method
                         # print(e)  # for debug
-                        t[2] = float('nan')
+                        t[2] = float("nan")
                     tf += (t[1] - t[0]) * 1000 / n  # ms per op forward
                     tb += (t[2] - t[1]) * 1000 / n  # ms per op backward
-                mem = torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0  # (GB)
-                s_in, s_out = (tuple(x.shape) if isinstance(x, torch.Tensor) else 'list' for x in (x, y))  # shapes
+                mem = torch.cuda.memory_reserved() / 1e9 if torch.cuda.is_available() else 0  # (GB)
+                s_in, s_out = (tuple(x.shape) if isinstance(x, torch.Tensor) else "list" for x in (x, y))  # shapes
                 p = sum(x.numel() for x in m.parameters()) if isinstance(m, nn.Module) else 0  # parameters
-                LOGGER.info(f'{p:12}{flops:12.4g}{mem:>14.3f}{tf:14.4g}{tb:14.4g}{str(s_in):>24s}{str(s_out):>24s}')
+                LOGGER.info(f"{p:12}{flops:12.4g}{mem:>14.3f}{tf:14.4g}{tb:14.4g}{str(s_in):>24s}{str(s_out):>24s}")
                 results.append([p, flops, mem, tf, tb, s_in, s_out])
             except Exception as e:
                 LOGGER.info(e)
                 results.append(None)
             torch.cuda.empty_cache()
     return results
 
@@ -530,15 +593,15 @@
         Initialize early stopping object.
 
         Args:
             patience (int, optional): Number of epochs to wait after fitness stops improving before stopping.
         """
         self.best_fitness = 0.0  # i.e. mAP
         self.best_epoch = 0
-        self.patience = patience or float('inf')  # epochs to wait after fitness stops improving to stop
+        self.patience = patience or float("inf")  # epochs to wait after fitness stops improving to stop
         self.possible_stop = False  # possible stop may occur next epoch
 
     def __call__(self, epoch, fitness):
         """
         Check whether to stop training.
 
         Args:
@@ -554,12 +617,15 @@
         if fitness >= self.best_fitness:  # >= 0 to allow for early zero-fitness stage of training
             self.best_epoch = epoch
             self.best_fitness = fitness
         delta = epoch - self.best_epoch  # epochs without improvement
         self.possible_stop = delta >= (self.patience - 1)  # possible stop may occur next epoch
         stop = delta >= self.patience  # stop training if patience exceeded
         if stop:
-            LOGGER.info(f'Stopping training early as no improvement observed in last {self.patience} epochs. '
-                        f'Best results observed at epoch {self.best_epoch}, best model saved as best.pt.\n'
-                        f'To update EarlyStopping(patience={self.patience}) pass a new patience value, '
-                        f'i.e. `patience=300` or use `patience=0` to disable EarlyStopping.')
+            prefix = colorstr("EarlyStopping: ")
+            LOGGER.info(
+                f"{prefix}Training stopped early as no improvement observed in last {self.patience} epochs. "
+                f"Best results observed at epoch {self.best_epoch}, best model saved as best.pt.\n"
+                f"To update EarlyStopping(patience={self.patience}) pass a new patience value, "
+                f"i.e. `patience=300` or use `patience=0` to disable EarlyStopping."
+            )
         return stop
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/triton.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/triton.py`

 * *Files 6% similar despite different names*

```diff
@@ -18,83 +18,84 @@
         InferRequestedOutput: The output request class for the Triton client.
         input_formats (List[str]): The data types of the model inputs.
         np_input_formats (List[type]): The numpy data types of the model inputs.
         input_names (List[str]): The names of the model inputs.
         output_names (List[str]): The names of the model outputs.
     """
 
-    def __init__(self, url: str, endpoint: str = '', scheme: str = ''):
+    def __init__(self, url: str, endpoint: str = "", scheme: str = ""):
         """
         Initialize the TritonRemoteModel.
 
         Arguments may be provided individually or parsed from a collective 'url' argument of the form
             <scheme>://<netloc>/<endpoint>/<task_name>
 
         Args:
             url (str): The URL of the Triton server.
             endpoint (str): The name of the model on the Triton server.
             scheme (str): The communication scheme ('http' or 'grpc').
         """
         if not endpoint and not scheme:  # Parse all args from URL string
             splits = urlsplit(url)
-            endpoint = splits.path.strip('/').split('/')[0]
+            endpoint = splits.path.strip("/").split("/")[0]
             scheme = splits.scheme
             url = splits.netloc
 
         self.endpoint = endpoint
         self.url = url
 
         # Choose the Triton client based on the communication scheme
-        if scheme == 'http':
+        if scheme == "http":
             import tritonclient.http as client  # noqa
+
             self.triton_client = client.InferenceServerClient(url=self.url, verbose=False, ssl=False)
             config = self.triton_client.get_model_config(endpoint)
         else:
             import tritonclient.grpc as client  # noqa
+
             self.triton_client = client.InferenceServerClient(url=self.url, verbose=False, ssl=False)
-            config = self.triton_client.get_model_config(endpoint, as_json=True)['config']
+            config = self.triton_client.get_model_config(endpoint, as_json=True)["config"]
 
         # Sort output names alphabetically, i.e. 'output0', 'output1', etc.
-        config['output'] = sorted(config['output'], key=lambda x: x.get('name'))
+        config["output"] = sorted(config["output"], key=lambda x: x.get("name"))
 
         # Pose model
         if config['parameters'].get('kpt_shape'):
-            self.kpt_shape = [
-                int(x) for x in config['parameters']['kpt_shape'].get('string_value').strip('[]').split(',')]
+            self.kpt_shape = [int(x) for x in config['parameters']['kpt_shape'].get('string_value').strip('[]').split(',')]
 
         if config['parameters'].get('names'):
             class_labels = config['parameters']['names'].get('string_value')
             if class_labels:
                 self.names = [v for k, v in sorted(eval(class_labels).items())]
 
         # Define model attributes
-        type_map = {'TYPE_FP32': np.float32, 'TYPE_FP16': np.float16, 'TYPE_UINT8': np.uint8}
+        type_map = {"TYPE_FP32": np.float32, "TYPE_FP16": np.float16, "TYPE_UINT8": np.uint8}
         self.InferRequestedOutput = client.InferRequestedOutput
         self.InferInput = client.InferInput
-        self.input_formats = [x['data_type'] for x in config['input']]
+        self.input_formats = [x["data_type"] for x in config["input"]]
         self.np_input_formats = [type_map[x] for x in self.input_formats]
-        self.input_names = [x['name'] for x in config['input']]
-        self.output_names = [x['name'] for x in config['output']]
+        self.input_names = [x["name"] for x in config["input"]]
+        self.output_names = [x["name"] for x in config["output"]]
 
     def __call__(self, *inputs: np.ndarray) -> List[np.ndarray]:
         """
         Call the model with the given inputs.
 
         Args:
             *inputs (List[np.ndarray]): Input data to the model.
 
         Returns:
-            List[np.ndarray]: Model outputs.
+            (List[np.ndarray]): Model outputs.
         """
         infer_inputs = []
         input_format = inputs[0].dtype
         for i, x in enumerate(inputs):
             if x.dtype != self.np_input_formats[i]:
                 x = x.astype(self.np_input_formats[i])
-            infer_input = self.InferInput(self.input_names[i], [*x.shape], self.input_formats[i].replace('TYPE_', ''))
+            infer_input = self.InferInput(self.input_names[i], [*x.shape], self.input_formats[i].replace("TYPE_", ""))
             infer_input.set_data_from_numpy(x)
             infer_inputs.append(infer_input)
 
         infer_outputs = [self.InferRequestedOutput(output_name) for output_name in self.output_names]
         outputs = self.triton_client.infer(model_name=self.endpoint, inputs=infer_inputs, outputs=infer_outputs)
 
         return [outputs.as_numpy(output_name).astype(input_format) for output_name in self.output_names]
```

### Comparing `yolov8-pose-triton-8.1.0/ultralytics/utils/tuner.py` & `yolov8_pose_triton-8.2.0/ultralytics/utils/tuner.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,18 @@
 # Ultralytics YOLO , AGPL-3.0 license
 
 import subprocess
 
 from ultralytics.cfg import TASK2DATA, TASK2METRIC, get_save_dir
-from ultralytics.utils import DEFAULT_CFG, DEFAULT_CFG_DICT, LOGGER, NUM_THREADS
+from ultralytics.utils import DEFAULT_CFG, DEFAULT_CFG_DICT, LOGGER, NUM_THREADS, checks
 
 
-def run_ray_tune(model,
-                 space: dict = None,
-                 grace_period: int = 10,
-                 gpu_per_trial: int = None,
-                 max_samples: int = 10,
-                 **train_args):
+def run_ray_tune(
+    model, space: dict = None, grace_period: int = 10, gpu_per_trial: int = None, max_samples: int = 10, **train_args
+):
     """
     Runs hyperparameter tuning using Ray Tune.
 
     Args:
         model (YOLO): Model to run the tuner on.
         space (dict, optional): The hyperparameter search space. Defaults to None.
         grace_period (int, optional): The grace period in epochs of the ASHA scheduler. Defaults to 10.
@@ -34,111 +31,118 @@
         model = YOLO('yolov8n.pt')
 
         # Start tuning hyperparameters for YOLOv8n training on the COCO8 dataset
         result_grid = model.tune(data='coco8.yaml', use_ray=True)
         ```
     """
 
-    LOGGER.info(' Learn about RayTune at https://docs.ultralytics.com/integrations/ray-tune')
+    LOGGER.info(" Learn about RayTune at https://docs.ultralytics.com/integrations/ray-tune")
     if train_args is None:
         train_args = {}
 
     try:
-        subprocess.run('pip install ray[tune]'.split(), check=True)
+        subprocess.run("pip install ray[tune]".split(), check=True)  # do not add single quotes here
 
         import ray
         from ray import tune
         from ray.air import RunConfig
         from ray.air.integrations.wandb import WandbLoggerCallback
         from ray.tune.schedulers import ASHAScheduler
     except ImportError:
-        raise ModuleNotFoundError('Tuning hyperparameters requires Ray Tune. Install with: pip install "ray[tune]"')
+        raise ModuleNotFoundError('Ray Tune required but not found. To install run: pip install "ray[tune]"')
 
     try:
         import wandb
 
-        assert hasattr(wandb, '__version__')
+        assert hasattr(wandb, "__version__")
     except (ImportError, AssertionError):
         wandb = False
 
+    checks.check_version(ray.__version__, "<=2.9.3", "ray")
     default_space = {
         # 'optimizer': tune.choice(['SGD', 'Adam', 'AdamW', 'NAdam', 'RAdam', 'RMSProp']),
-        'lr0': tune.uniform(1e-5, 1e-1),
-        'lrf': tune.uniform(0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)
-        'momentum': tune.uniform(0.6, 0.98),  # SGD momentum/Adam beta1
-        'weight_decay': tune.uniform(0.0, 0.001),  # optimizer weight decay 5e-4
-        'warmup_epochs': tune.uniform(0.0, 5.0),  # warmup epochs (fractions ok)
-        'warmup_momentum': tune.uniform(0.0, 0.95),  # warmup initial momentum
-        'box': tune.uniform(0.02, 0.2),  # box loss gain
-        'cls': tune.uniform(0.2, 4.0),  # cls loss gain (scale with pixels)
-        'hsv_h': tune.uniform(0.0, 0.1),  # image HSV-Hue augmentation (fraction)
-        'hsv_s': tune.uniform(0.0, 0.9),  # image HSV-Saturation augmentation (fraction)
-        'hsv_v': tune.uniform(0.0, 0.9),  # image HSV-Value augmentation (fraction)
-        'degrees': tune.uniform(0.0, 45.0),  # image rotation (+/- deg)
-        'translate': tune.uniform(0.0, 0.9),  # image translation (+/- fraction)
-        'scale': tune.uniform(0.0, 0.9),  # image scale (+/- gain)
-        'shear': tune.uniform(0.0, 10.0),  # image shear (+/- deg)
-        'perspective': tune.uniform(0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001
-        'flipud': tune.uniform(0.0, 1.0),  # image flip up-down (probability)
-        'fliplr': tune.uniform(0.0, 1.0),  # image flip left-right (probability)
-        'mosaic': tune.uniform(0.0, 1.0),  # image mixup (probability)
-        'mixup': tune.uniform(0.0, 1.0),  # image mixup (probability)
-        'copy_paste': tune.uniform(0.0, 1.0)}  # segment copy-paste (probability)
+        "lr0": tune.uniform(1e-5, 1e-1),
+        "lrf": tune.uniform(0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)
+        "momentum": tune.uniform(0.6, 0.98),  # SGD momentum/Adam beta1
+        "weight_decay": tune.uniform(0.0, 0.001),  # optimizer weight decay 5e-4
+        "warmup_epochs": tune.uniform(0.0, 5.0),  # warmup epochs (fractions ok)
+        "warmup_momentum": tune.uniform(0.0, 0.95),  # warmup initial momentum
+        "box": tune.uniform(0.02, 0.2),  # box loss gain
+        "cls": tune.uniform(0.2, 4.0),  # cls loss gain (scale with pixels)
+        "hsv_h": tune.uniform(0.0, 0.1),  # image HSV-Hue augmentation (fraction)
+        "hsv_s": tune.uniform(0.0, 0.9),  # image HSV-Saturation augmentation (fraction)
+        "hsv_v": tune.uniform(0.0, 0.9),  # image HSV-Value augmentation (fraction)
+        "degrees": tune.uniform(0.0, 45.0),  # image rotation (+/- deg)
+        "translate": tune.uniform(0.0, 0.9),  # image translation (+/- fraction)
+        "scale": tune.uniform(0.0, 0.9),  # image scale (+/- gain)
+        "shear": tune.uniform(0.0, 10.0),  # image shear (+/- deg)
+        "perspective": tune.uniform(0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001
+        "flipud": tune.uniform(0.0, 1.0),  # image flip up-down (probability)
+        "fliplr": tune.uniform(0.0, 1.0),  # image flip left-right (probability)
+        "bgr": tune.uniform(0.0, 1.0),  # image channel BGR (probability)
+        "mosaic": tune.uniform(0.0, 1.0),  # image mixup (probability)
+        "mixup": tune.uniform(0.0, 1.0),  # image mixup (probability)
+        "copy_paste": tune.uniform(0.0, 1.0),  # segment copy-paste (probability)
+    }
 
     # Put the model in ray store
     task = model.task
     model_in_store = ray.put(model)
 
     def _tune(config):
         """
         Trains the YOLO model with the specified hyperparameters and additional arguments.
 
         Args:
             config (dict): A dictionary of hyperparameters to use for training.
 
         Returns:
-            None.
+            None
         """
         model_to_train = ray.get(model_in_store)  # get the model from ray store for tuning
         model_to_train.reset_callbacks()
         config.update(train_args)
         results = model_to_train.train(**config)
         return results.results_dict
 
     # Get search space
     if not space:
         space = default_space
-        LOGGER.warning('WARNING  search space not provided, using default search space.')
+        LOGGER.warning("WARNING  search space not provided, using default search space.")
 
     # Get dataset
-    data = train_args.get('data', TASK2DATA[task])
-    space['data'] = data
-    if 'data' not in train_args:
+    data = train_args.get("data", TASK2DATA[task])
+    space["data"] = data
+    if "data" not in train_args:
         LOGGER.warning(f'WARNING  data not provided, using default "data={data}".')
 
     # Define the trainable function with allocated resources
-    trainable_with_resources = tune.with_resources(_tune, {'cpu': NUM_THREADS, 'gpu': gpu_per_trial or 0})
+    trainable_with_resources = tune.with_resources(_tune, {"cpu": NUM_THREADS, "gpu": gpu_per_trial or 0})
 
     # Define the ASHA scheduler for hyperparameter search
-    asha_scheduler = ASHAScheduler(time_attr='epoch',
-                                   metric=TASK2METRIC[task],
-                                   mode='max',
-                                   max_t=train_args.get('epochs') or DEFAULT_CFG_DICT['epochs'] or 100,
-                                   grace_period=grace_period,
-                                   reduction_factor=3)
+    asha_scheduler = ASHAScheduler(
+        time_attr="epoch",
+        metric=TASK2METRIC[task],
+        mode="max",
+        max_t=train_args.get("epochs") or DEFAULT_CFG_DICT["epochs"] or 100,
+        grace_period=grace_period,
+        reduction_factor=3,
+    )
 
     # Define the callbacks for the hyperparameter search
-    tuner_callbacks = [WandbLoggerCallback(project='YOLOv8-tune')] if wandb else []
+    tuner_callbacks = [WandbLoggerCallback(project="YOLOv8-tune")] if wandb else []
 
     # Create the Ray Tune hyperparameter search tuner
-    tune_dir = get_save_dir(DEFAULT_CFG, name='tune').resolve()  # must be absolute dir
+    tune_dir = get_save_dir(DEFAULT_CFG, name="tune").resolve()  # must be absolute dir
     tune_dir.mkdir(parents=True, exist_ok=True)
-    tuner = tune.Tuner(trainable_with_resources,
-                       param_space=space,
-                       tune_config=tune.TuneConfig(scheduler=asha_scheduler, num_samples=max_samples),
-                       run_config=RunConfig(callbacks=tuner_callbacks, storage_path=tune_dir))
+    tuner = tune.Tuner(
+        trainable_with_resources,
+        param_space=space,
+        tune_config=tune.TuneConfig(scheduler=asha_scheduler, num_samples=max_samples),
+        run_config=RunConfig(callbacks=tuner_callbacks, storage_path=tune_dir),
+    )
 
     # Run the hyperparameter search
     tuner.fit()
 
     # Return the results of the hyperparameter search
     return tuner.get_results()
```

### Comparing `yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/PKG-INFO` & `yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/PKG-INFO`

 * *Files 16% similar despite different names*

```diff
@@ -1,150 +1,166 @@
 Metadata-Version: 2.1
 Name: yolov8-pose-triton
-Version: 8.1.0
+Version: 8.2.0
 Summary: Ultralytics YOLOv8 for SOTA object detection, multi-object tracking, instance segmentation, pose estimation and image classification.
-Home-page: https://github.com/ultralytics/ultralytics
-Author: Ultralytics
-Author-email: hello@ultralytics.com
+Author: Glenn Jocher, Ayush Chaurasia, Jing Qiu
+Maintainer: Glenn Jocher, Ayush Chaurasia, Jing Qiu
 License: AGPL-3.0
 Project-URL: Bug Reports, https://github.com/ultralytics/ultralytics/issues
 Project-URL: Funding, https://ultralytics.com
-Project-URL: Source, https://github.com/hmurari/ultralytics
-Keywords: machine-learning,deep-learning,vision,ML,DL,AI,YOLO,YOLOv3,YOLOv5,YOLOv8,HUB,Ultralytics
+Project-URL: Source, https://github.com/hmurari/ultralytics/
+Keywords: machine-learning,deep-learning,computer-vision,ML,DL,AI,YOLO,YOLOv3,YOLOv5,YOLOv8,HUB,Ultralytics
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Education
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Classifier: Topic :: Software Development
 Classifier: Topic :: Scientific/Engineering
 Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
 Classifier: Topic :: Scientific/Engineering :: Image Recognition
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Operating System :: MacOS
 Classifier: Operating System :: Microsoft :: Windows
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: matplotlib>=3.3.0
-Requires-Dist: numpy>=1.22.2
 Requires-Dist: opencv-python>=4.6.0
 Requires-Dist: pillow>=7.1.2
 Requires-Dist: pyyaml>=5.3.1
 Requires-Dist: requests>=2.23.0
 Requires-Dist: scipy>=1.4.1
 Requires-Dist: torch>=1.8.0
 Requires-Dist: torchvision>=0.9.0
 Requires-Dist: tqdm>=4.64.0
-Requires-Dist: pandas>=1.1.4
-Requires-Dist: seaborn>=0.11.0
 Requires-Dist: psutil
 Requires-Dist: py-cpuinfo
 Requires-Dist: thop>=0.1.1
+Requires-Dist: pandas>=1.1.4
+Requires-Dist: seaborn>=0.11.0
 Provides-Extra: dev
 Requires-Dist: ipython; extra == "dev"
 Requires-Dist: check-manifest; extra == "dev"
 Requires-Dist: pre-commit; extra == "dev"
 Requires-Dist: pytest; extra == "dev"
 Requires-Dist: pytest-cov; extra == "dev"
-Requires-Dist: coverage; extra == "dev"
-Requires-Dist: mkdocs-material; extra == "dev"
+Requires-Dist: coverage[toml]; extra == "dev"
+Requires-Dist: mkdocs-material>=9.5.9; extra == "dev"
 Requires-Dist: mkdocstrings[python]; extra == "dev"
+Requires-Dist: mkdocs-jupyter; extra == "dev"
 Requires-Dist: mkdocs-redirects; extra == "dev"
-Requires-Dist: mkdocs-ultralytics-plugin>=0.0.34; extra == "dev"
+Requires-Dist: mkdocs-ultralytics-plugin>=0.0.44; extra == "dev"
 Provides-Extra: export
-Requires-Dist: coremltools>=7.0; extra == "export"
-Requires-Dist: openvino-dev>=2023.0; extra == "export"
-Requires-Dist: tensorflow<=2.13.1; extra == "export"
-Requires-Dist: tensorflowjs; extra == "export"
+Requires-Dist: onnx>=1.12.0; extra == "export"
+Requires-Dist: coremltools>=7.0; (platform_system != "Windows" and python_version <= "3.11") and extra == "export"
+Requires-Dist: openvino>=2024.0.0; extra == "export"
+Requires-Dist: tensorflow<=2.13.1; python_version <= "3.11" and extra == "export"
+Requires-Dist: tensorflowjs>=3.9.0; python_version <= "3.11" and extra == "export"
+Requires-Dist: numpy==1.23.5; platform_machine == "aarch64" and extra == "export"
+Requires-Dist: h5py!=3.11.0; platform_machine == "aarch64" and extra == "export"
+Provides-Extra: explorer
+Requires-Dist: lancedb; extra == "explorer"
+Requires-Dist: duckdb<=0.9.2; extra == "explorer"
+Requires-Dist: streamlit; extra == "explorer"
+Provides-Extra: logging
+Requires-Dist: comet; extra == "logging"
+Requires-Dist: tensorboard>=2.13.0; extra == "logging"
+Requires-Dist: dvclive>=2.12.0; extra == "logging"
+Provides-Extra: extra
+Requires-Dist: hub-sdk>=0.0.5; extra == "extra"
+Requires-Dist: ipython; extra == "extra"
+Requires-Dist: albumentations>=1.0.3; extra == "extra"
+Requires-Dist: pycocotools>=2.0.7; extra == "extra"
 
 <div align="center">
   <p>
-    <a href="https://yolovision.ultralytics.com/" target="_blank">
-      <img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/im/banner-yolo-vision-2023.png"></a>
+    <a href="https://github.com/ultralytics/assets/releases/tag/v8.2.0" target="_blank">
+      <img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/banner-yolov8.png" alt="YOLO Vision banner"></a>
   </p>
 
-[](https://docs.ultralytics.com/zh/) | [](https://docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) | [](https://docs.ultralytics.com/ru/) | [Deutsch](https://docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) | [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/hi/) | [](https://docs.ultralytics.com/ar/)
-<br>
+[](https://docs.ultralytics.com/zh/) | [](https://docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) | [](https://docs.ultralytics.com/ru/) | [Deutsch](https://docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) | [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/hi/) | [](https://docs.ultralytics.com/ar/) <br>
 
 <div>
     <a href="https://github.com/ultralytics/ultralytics/actions/workflows/ci.yaml"><img src="https://github.com/ultralytics/ultralytics/actions/workflows/ci.yaml/badge.svg" alt="Ultralytics CI"></a>
     <a href="https://codecov.io/github/ultralytics/ultralytics"><img src="https://codecov.io/github/ultralytics/ultralytics/branch/main/graph/badge.svg?token=HHW7IIVFVY" alt="Ultralytics Code Coverage"></a>
     <a href="https://zenodo.org/badge/latestdoi/264818686"><img src="https://zenodo.org/badge/264818686.svg" alt="YOLOv8 Citation"></a>
     <a href="https://hub.docker.com/r/ultralytics/ultralytics"><img src="https://img.shields.io/docker/pulls/ultralytics/ultralytics?logo=docker" alt="Docker Pulls"></a>
+    <a href="https://ultralytics.com/discord"><img alt="Discord" src="https://img.shields.io/discord/1089800235347353640?logo=discord&logoColor=white&label=Discord&color=blue"></a>
     <br>
-    <a href="https://console.paperspace.com/github/ultralytics/ultralytics"><img src="https://assets.paperspace.io/img/gradient-badge.svg" alt="Run on Gradient"/></a>
+    <a href="https://console.paperspace.com/github/ultralytics/ultralytics"><img src="https://assets.paperspace.io/img/gradient-badge.svg" alt="Run on Gradient"></a>
     <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/tutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>
     <a href="https://www.kaggle.com/ultralytics/yolov8"><img src="https://kaggle.com/static/images/open-in-kaggle.svg" alt="Open In Kaggle"></a>
 </div>
 <br>
 
 [Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/ultralytics) is a cutting-edge, state-of-the-art (SOTA) model that builds upon the success of previous YOLO versions and introduces new features and improvements to further boost performance and flexibility. YOLOv8 is designed to be fast, accurate, and easy to use, making it an excellent choice for a wide range of object detection and tracking, instance segmentation, image classification and pose estimation tasks.
 
 We hope that the resources here will help you get the most out of YOLOv8. Please browse the YOLOv8 <a href="https://docs.ultralytics.com/">Docs</a> for details, raise an issue on <a href="https://github.com/ultralytics/ultralytics/issues/new/choose">GitHub</a> for support, and join our <a href="https://ultralytics.com/discord">Discord</a> community for questions and discussions!
 
 To request an Enterprise License please complete the form at [Ultralytics Licensing](https://ultralytics.com/license).
 
-<img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-plots.png"></a>
+<img width="100%" src="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-plots.png" alt="YOLOv8 performance plots"></a>
 
 <div align="center">
   <a href="https://github.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-github.png" width="2%" alt="Ultralytics GitHub"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.linkedin.com/company/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-linkedin.png" width="2%" alt="Ultralytics LinkedIn"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://twitter.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-twitter.png" width="2%" alt="Ultralytics Twitter"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://youtube.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-youtube.png" width="2%" alt="Ultralytics YouTube"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.tiktok.com/@ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-tiktok.png" width="2%" alt="Ultralytics TikTok"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://www.instagram.com/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-instagram.png" width="2%" alt="Ultralytics Instagram"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="2%" alt="space">
   <a href="https://ultralytics.com/discord"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-discord.png" width="2%" alt="Ultralytics Discord"></a>
 </div>
 </div>
 
 ## <div align="center">Documentation</div>
 
 See below for a quickstart installation and usage example, and see the [YOLOv8 Docs](https://docs.ultralytics.com) for full documentation on training, validation, prediction and deployment.
 
 <details open>
 <summary>Install</summary>
 
-Pip install the ultralytics package including all [requirements](https://github.com/ultralytics/ultralytics/blob/main/requirements.txt) in a [**Python>=3.8**](https://www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-started/locally/).
+Pip install the ultralytics package including all [requirements](https://github.com/ultralytics/ultralytics/blob/main/pyproject.toml) in a [**Python>=3.8**](https://www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-started/locally/).
 
 [![PyPI version](https://badge.fury.io/py/ultralytics.svg)](https://badge.fury.io/py/ultralytics) [![Downloads](https://static.pepy.tech/badge/ultralytics)](https://pepy.tech/project/ultralytics)
 
 ```bash
 pip install ultralytics
 ```
 
 For alternative installation methods including [Conda](https://anaconda.org/conda-forge/ultralytics), [Docker](https://hub.docker.com/r/ultralytics/ultralytics), and Git, please refer to the [Quickstart Guide](https://docs.ultralytics.com/quickstart).
 
 </details>
 
 <details open>
 <summary>Usage</summary>
 
-#### CLI
+### CLI
 
 YOLOv8 may be used directly in the Command Line Interface (CLI) with a `yolo` command:
 
 ```bash
 yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'
 ```
 
 `yolo` can be used for a variety of tasks and modes and accepts additional arguments, i.e. `imgsz=640`. See the YOLOv8 [CLI Docs](https://docs.ultralytics.com/usage/cli) for examples.
 
-#### Python
+### Python
 
 YOLOv8 may also be used directly in a Python environment, and accepts the same [arguments](https://docs.ultralytics.com/usage/cfg/) as in the CLI example above:
 
 ```python
 from ultralytics import YOLO
 
 # Load a model
@@ -158,146 +174,165 @@
 path = model.export(format="onnx")  # export the model to ONNX format
 ```
 
 See YOLOv8 [Python Docs](https://docs.ultralytics.com/usage/python) for more examples.
 
 </details>
 
+### Notebooks
+
+Ultralytics provides interactive notebooks for YOLOv8, covering training, validation, tracking, and more. Each notebook is paired with a [YouTube](https://youtube.com/ultralytics) tutorial, making it easy to learn and implement advanced YOLOv8 features.
+
+| Docs                                                                                                                              | Notebook                                                                                                                                                                                                                   |                                                                                                     YouTube                                                                                                     |
+| --------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
+| <a href="https://docs.ultralytics.com/modes/">YOLOv8 Train, Val, Predict and Export Modes</a>                                     | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/tutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                  | <a href="https://youtu.be/j8uQc0qB91s"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/hub/quickstart/">Ultralytics HUB QuickStart</a>                                             | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/hub.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                       | <a href="https://youtu.be/lveF9iCMIzc"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/modes/track/">YOLOv8 Multi-Object Tracking in Videos</a>                                    | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/object_tracking.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>           | <a href="https://youtu.be/hHyHmOtmEgs"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/guides/object-counting/">YOLOv8 Object Counting in Videos</a>                               | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/object_counting.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>           | <a href="https://youtu.be/Ag2e-5_NpS0"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/guides/heatmaps/">YOLOv8 Heatmaps in Videos</a>                                             | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/examples/heatmaps.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a>                  | <a href="https://youtu.be/4ezde5-nZZw"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+| <a href="https://docs.ultralytics.com/datasets/explorer/">Ultralytics Datasets Explorer with SQL and OpenAI Integration  New</a> | <a href="https://colab.research.google.com/github/ultralytics/ultralytics/blob/main/docs/en/datasets/explorer/explorer.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a> | <a href="https://youtu.be/3VryynorQeo"><center><img width=30% src="https://raw.githubusercontent.com/ultralytics/assets/main/social/logo-social-youtube-rect.png" alt="Ultralytics Youtube Video"></center></a> |
+
 ## <div align="center">Models</div>
 
 YOLOv8 [Detect](https://docs.ultralytics.com/tasks/detect), [Segment](https://docs.ultralytics.com/tasks/segment) and [Pose](https://docs.ultralytics.com/tasks/pose) models pretrained on the [COCO](https://docs.ultralytics.com/datasets/detect/coco) dataset are available here, as well as YOLOv8 [Classify](https://docs.ultralytics.com/tasks/classify) models pretrained on the [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet) dataset. [Track](https://docs.ultralytics.com/modes/track) mode is available for all Detect, Segment and Pose models.
 
 <img width="1024" src="https://raw.githubusercontent.com/ultralytics/assets/main/im/banner-tasks.png" alt="Ultralytics YOLO supported tasks">
 
 All [Models](https://github.com/ultralytics/ultralytics/tree/main/ultralytics/cfg/models) download automatically from the latest Ultralytics [release](https://github.com/ultralytics/assets/releases) on first use.
 
 <details open><summary>Detection (COCO)</summary>
 
 See [Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples with these models trained on [COCO](https://docs.ultralytics.com/datasets/detect/coco/), which include 80 pre-trained classes.
 
 | Model                                                                                | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
 | ------------------------------------------------------------------------------------ | --------------------- | -------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt) | 640                   | 37.3                 | 80.4                           | 0.99                                | 3.2                | 8.7               |
-| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s.pt) | 640                   | 44.9                 | 128.4                          | 1.20                                | 11.2               | 28.6              |
-| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m.pt) | 640                   | 50.2                 | 234.7                          | 1.83                                | 25.9               | 78.9              |
-| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l.pt) | 640                   | 52.9                 | 375.2                          | 2.39                                | 43.7               | 165.2             |
-| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x.pt) | 640                   | 53.9                 | 479.1                          | 3.53                                | 68.2               | 257.8             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](http://cocodataset.org) dataset.
-  <br>Reproduce by `yolo val detect data=coco.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu`
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n.pt) | 640                   | 37.3                 | 80.4                           | 0.99                                | 3.2                | 8.7               |
+| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s.pt) | 640                   | 44.9                 | 128.4                          | 1.20                                | 11.2               | 28.6              |
+| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m.pt) | 640                   | 50.2                 | 234.7                          | 1.83                                | 25.9               | 78.9              |
+| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l.pt) | 640                   | 52.9                 | 375.2                          | 2.39                                | 43.7               | 165.2             |
+| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x.pt) | 640                   | 53.9                 | 479.1                          | 3.53                                | 68.2               | 257.8             |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val detect data=coco.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu`
 
 </details>
 
 <details><summary>Detection (Open Image V7)</summary>
 
 See [Detection Docs](https://docs.ultralytics.com/tasks/detect/) for usage examples with these models trained on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/), which include 600 pre-trained classes.
 
 | Model                                                                                     | size<br><sup>(pixels) | mAP<sup>val<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
 | ----------------------------------------------------------------------------------------- | --------------------- | -------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-oiv7.pt) | 640                   | 18.4                 | 142.4                          | 1.21                                | 3.5                | 10.5              |
-| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-oiv7.pt) | 640                   | 27.7                 | 183.1                          | 1.40                                | 11.4               | 29.7              |
-| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-oiv7.pt) | 640                   | 33.6                 | 408.5                          | 2.26                                | 26.2               | 80.6              |
-| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-oiv7.pt) | 640                   | 34.9                 | 596.9                          | 2.43                                | 44.1               | 167.4             |
-| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-oiv7.pt) | 640                   | 36.3                 | 860.6                          | 3.56                                | 68.7               | 260.6             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/) dataset.
-  <br>Reproduce by `yolo val detect data=open-images-v7.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
+| [YOLOv8n](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-oiv7.pt) | 640                   | 18.4                 | 142.4                          | 1.21                                | 3.5                | 10.5              |
+| [YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-oiv7.pt) | 640                   | 27.7                 | 183.1                          | 1.40                                | 11.4               | 29.7              |
+| [YOLOv8m](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-oiv7.pt) | 640                   | 33.6                 | 408.5                          | 2.26                                | 26.2               | 80.6              |
+| [YOLOv8l](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-oiv7.pt) | 640                   | 34.9                 | 596.9                          | 2.43                                | 44.1               | 167.4             |
+| [YOLOv8x](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-oiv7.pt) | 640                   | 36.3                 | 860.6                          | 3.56                                | 68.7               | 260.6             |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-images-v7/) dataset. <br>Reproduce by `yolo val detect data=open-images-v7.yaml device=0`
+- **Speed** averaged over Open Image V7 val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
 
 </details>
 
 <details><summary>Segmentation (COCO)</summary>
 
 See [Segmentation Docs](https://docs.ultralytics.com/tasks/segment/) for usage examples with these models trained on [COCO-Seg](https://docs.ultralytics.com/datasets/segment/coco/), which include 80 pre-trained classes.
 
 | Model                                                                                        | size<br><sup>(pixels) | mAP<sup>box<br>50-95 | mAP<sup>mask<br>50-95 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
 | -------------------------------------------------------------------------------------------- | --------------------- | -------------------- | --------------------- | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-seg.pt) | 640                   | 36.7                 | 30.5                  | 96.1                           | 1.21                                | 3.4                | 12.6              |
-| [YOLOv8s-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-seg.pt) | 640                   | 44.6                 | 36.8                  | 155.7                          | 1.47                                | 11.8               | 42.6              |
-| [YOLOv8m-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-seg.pt) | 640                   | 49.9                 | 40.8                  | 317.0                          | 2.18                                | 27.3               | 110.2             |
-| [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-seg.pt) | 640                   | 52.3                 | 42.6                  | 572.4                          | 2.79                                | 46.0               | 220.5             |
-| [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-seg.pt) | 640                   | 53.4                 | 43.4                  | 712.1                          | 4.02                                | 71.8               | 344.1             |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](http://cocodataset.org) dataset.
-  <br>Reproduce by `yolo val segment data=coco-seg.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu`
+| [YOLOv8n-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-seg.pt) | 640                   | 36.7                 | 30.5                  | 96.1                           | 1.21                                | 3.4                | 12.6              |
+| [YOLOv8s-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-seg.pt) | 640                   | 44.6                 | 36.8                  | 155.7                          | 1.47                                | 11.8               | 42.6              |
+| [YOLOv8m-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-seg.pt) | 640                   | 49.9                 | 40.8                  | 317.0                          | 2.18                                | 27.3               | 110.2             |
+| [YOLOv8l-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-seg.pt) | 640                   | 52.3                 | 42.6                  | 572.4                          | 2.79                                | 46.0               | 220.5             |
+| [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-seg.pt) | 640                   | 53.4                 | 43.4                  | 712.1                          | 4.02                                | 71.8               | 344.1             |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val segment data=coco-seg.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu`
 
 </details>
 
 <details><summary>Pose (COCO)</summary>
 
 See [Pose Docs](https://docs.ultralytics.com/tasks/pose/) for usage examples with these models trained on [COCO-Pose](https://docs.ultralytics.com/datasets/pose/coco/), which include 1 pre-trained class, person.
 
 | Model                                                                                                | size<br><sup>(pixels) | mAP<sup>pose<br>50-95 | mAP<sup>pose<br>50 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
 | ---------------------------------------------------------------------------------------------------- | --------------------- | --------------------- | ------------------ | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
-| [YOLOv8n-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-pose.pt)       | 640                   | 50.4                  | 80.1               | 131.8                          | 1.18                                | 3.3                | 9.2               |
-| [YOLOv8s-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-pose.pt)       | 640                   | 60.0                  | 86.2               | 233.2                          | 1.42                                | 11.6               | 30.2              |
-| [YOLOv8m-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-pose.pt)       | 640                   | 65.0                  | 88.8               | 456.3                          | 2.00                                | 26.4               | 81.0              |
-| [YOLOv8l-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-pose.pt)       | 640                   | 67.6                  | 90.0               | 784.5                          | 2.59                                | 44.4               | 168.6             |
-| [YOLOv8x-pose](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-pose.pt)       | 640                   | 69.2                  | 90.2               | 1607.1                         | 3.73                                | 69.4               | 263.2             |
-| [YOLOv8x-pose-p6](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-pose-p6.pt) | 1280                  | 71.6                  | 91.2               | 4088.7                         | 10.04                               | 99.1               | 1066.4            |
-
-- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO Keypoints val2017](http://cocodataset.org)
-  dataset.
-  <br>Reproduce by `yolo val pose data=coco-pose.yaml device=0`
-- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
+| [YOLOv8n-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-pose.pt)       | 640                   | 50.4                  | 80.1               | 131.8                          | 1.18                                | 3.3                | 9.2               |
+| [YOLOv8s-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-pose.pt)       | 640                   | 60.0                  | 86.2               | 233.2                          | 1.42                                | 11.6               | 30.2              |
+| [YOLOv8m-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-pose.pt)       | 640                   | 65.0                  | 88.8               | 456.3                          | 2.00                                | 26.4               | 81.0              |
+| [YOLOv8l-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-pose.pt)       | 640                   | 67.6                  | 90.0               | 784.5                          | 2.59                                | 44.4               | 168.6             |
+| [YOLOv8x-pose](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-pose.pt)       | 640                   | 69.2                  | 90.2               | 1607.1                         | 3.73                                | 69.4               | 263.2             |
+| [YOLOv8x-pose-p6](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-pose-p6.pt) | 1280                  | 71.6                  | 91.2               | 4088.7                         | 10.04                               | 99.1               | 1066.4            |
+
+- **mAP<sup>val</sup>** values are for single-model single-scale on [COCO Keypoints val2017](https://cocodataset.org) dataset. <br>Reproduce by `yolo val pose data=coco-pose.yaml device=0`
+- **Speed** averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
+
+</details>
+
+<details><summary>OBB (DOTAv1)</summary>
+
+See [OBB Docs](https://docs.ultralytics.com/tasks/obb/) for usage examples with these models trained on [DOTAv1](https://docs.ultralytics.com/datasets/obb/dota-v2/#dota-v10/), which include 15 pre-trained classes.
+
+| Model                                                                                        | size<br><sup>(pixels) | mAP<sup>test<br>50 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) |
+| -------------------------------------------------------------------------------------------- | --------------------- | ------------------ | ------------------------------ | ----------------------------------- | ------------------ | ----------------- |
+| [YOLOv8n-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-obb.pt) | 1024                  | 78.0               | 204.77                         | 3.57                                | 3.1                | 23.3              |
+| [YOLOv8s-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-obb.pt) | 1024                  | 79.5               | 424.88                         | 4.07                                | 11.4               | 76.3              |
+| [YOLOv8m-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-obb.pt) | 1024                  | 80.5               | 763.48                         | 7.61                                | 26.4               | 208.6             |
+| [YOLOv8l-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-obb.pt) | 1024                  | 80.7               | 1278.42                        | 11.83                               | 44.5               | 433.8             |
+| [YOLOv8x-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-obb.pt) | 1024                  | 81.36              | 1759.10                        | 13.23                               | 69.5               | 676.7             |
+
+- **mAP<sup>test</sup>** values are for single-model multiscale on [DOTAv1](https://captain-whu.github.io/DOTA/index.html) dataset. <br>Reproduce by `yolo val obb data=DOTAv1.yaml device=0 split=test` and submit merged results to [DOTA evaluation](https://captain-whu.github.io/DOTA/evaluation.html).
+- **Speed** averaged over DOTAv1 val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu`
 
 </details>
 
 <details><summary>Classification (ImageNet)</summary>
 
 See [Classification Docs](https://docs.ultralytics.com/tasks/classify/) for usage examples with these models trained on [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/), which include 1000 pretrained classes.
 
 | Model                                                                                        | size<br><sup>(pixels) | acc<br><sup>top1 | acc<br><sup>top5 | Speed<br><sup>CPU ONNX<br>(ms) | Speed<br><sup>A100 TensorRT<br>(ms) | params<br><sup>(M) | FLOPs<br><sup>(B) at 640 |
 | -------------------------------------------------------------------------------------------- | --------------------- | ---------------- | ---------------- | ------------------------------ | ----------------------------------- | ------------------ | ------------------------ |
-| [YOLOv8n-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-cls.pt) | 224                   | 66.6             | 87.0             | 12.9                           | 0.31                                | 2.7                | 4.3                      |
-| [YOLOv8s-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s-cls.pt) | 224                   | 72.3             | 91.1             | 23.4                           | 0.35                                | 6.4                | 13.5                     |
-| [YOLOv8m-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-cls.pt) | 224                   | 76.4             | 93.2             | 85.4                           | 0.62                                | 17.0               | 42.7                     |
-| [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-cls.pt) | 224                   | 78.0             | 94.1             | 163.0                          | 0.87                                | 37.5               | 99.7                     |
-| [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8x-cls.pt) | 224                   | 78.4             | 94.3             | 232.0                          | 1.01                                | 57.4               | 154.8                    |
-
-- **acc** values are model accuracies on the [ImageNet](https://www.image-net.org/) dataset validation set.
-  <br>Reproduce by `yolo val classify data=path/to/ImageNet device=0`
-- **Speed** averaged over ImageNet val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
-  <br>Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu`
+| [YOLOv8n-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-cls.pt) | 224                   | 69.0             | 88.3             | 12.9                           | 0.31                                | 2.7                | 4.3                      |
+| [YOLOv8s-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8s-cls.pt) | 224                   | 73.8             | 91.7             | 23.4                           | 0.35                                | 6.4                | 13.5                     |
+| [YOLOv8m-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-cls.pt) | 224                   | 76.8             | 93.5             | 85.4                           | 0.62                                | 17.0               | 42.7                     |
+| [YOLOv8l-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-cls.pt) | 224                   | 76.8             | 93.5             | 163.0                          | 0.87                                | 37.5               | 99.7                     |
+| [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-cls.pt) | 224                   | 79.0             | 94.6             | 232.0                          | 1.01                                | 57.4               | 154.8                    |
+
+- **acc** values are model accuracies on the [ImageNet](https://www.image-net.org/) dataset validation set. <br>Reproduce by `yolo val classify data=path/to/ImageNet device=0`
+- **Speed** averaged over ImageNet val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance. <br>Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu`
 
 </details>
 
 ## <div align="center">Integrations</div>
 
 Our key integrations with leading AI platforms extend the functionality of Ultralytics' offerings, enhancing tasks like dataset labeling, training, visualization, and model management. Discover how Ultralytics, in collaboration with [Roboflow](https://roboflow.com/?ref=ultralytics), ClearML, [Comet](https://bit.ly/yolov8-readme-comet), Neural Magic and [OpenVINO](https://docs.ultralytics.com/integrations/openvino), can optimize your AI workflow.
 
 <br>
 <a href="https://bit.ly/ultralytics_hub" target="_blank">
-<img width="100%" src="https://github.com/ultralytics/assets/raw/main/yolov8/banner-integrations.png"></a>
+<img width="100%" src="https://github.com/ultralytics/assets/raw/main/yolov8/banner-integrations.png" alt="Ultralytics active learning integrations"></a>
 <br>
 <br>
 
 <div align="center">
   <a href="https://roboflow.com/?ref=ultralytics">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-roboflow.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
-  <a href="https://cutt.ly/yolov5-readme-clearml">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-clearml.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-roboflow.png" width="10%" alt="Roboflow logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
+  <a href="https://clear.ml/">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-clearml.png" width="10%" alt="ClearML logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
   <a href="https://bit.ly/yolov8-readme-comet">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-comet.png" width="10%"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="">
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-comet.png" width="10%" alt="Comet ML logo"></a>
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="15%" height="0" alt="space">
   <a href="https://bit.ly/yolov5-neuralmagic">
-    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-neuralmagic.png" width="10%"></a>
+    <img src="https://github.com/ultralytics/assets/raw/main/partners/logo-neuralmagic.png" width="10%" alt="NeuralMagic logo"></a>
 </div>
 
-|                                                           Roboflow                                                           |                                                            ClearML  NEW                                                            |                                                                        Comet  NEW                                                                        |                                           Neural Magic  NEW                                           |
-| :--------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------: |
-| Label and export your custom datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/?ref=ultralytics) | Automatically track, visualize and even remotely train YOLOv8 using [ClearML](https://cutt.ly/yolov5-readme-clearml) (open-source!) | Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8 models, resume training, and interactively visualize and debug predictions | Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) |
+|                                                           Roboflow                                                           |                                                  ClearML  NEW                                                  |                                                                        Comet  NEW                                                                        |                                           Neural Magic  NEW                                           |
+| :--------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------: |
+| Label and export your custom datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/?ref=ultralytics) | Automatically track, visualize and even remotely train YOLOv8 using [ClearML](https://clear.ml/) (open-source!) | Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8 models, resume training, and interactively visualize and debug predictions | Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) |
 
 ## <div align="center">Ultralytics HUB</div>
 
 Experience seamless AI with [Ultralytics HUB](https://bit.ly/ultralytics_hub) , the all-in-one solution for data visualization, YOLOv5 and YOLOv8  model training and deployment, without any coding. Transform images into actionable insights and bring your AI visions to life with ease using our cutting-edge platform and user-friendly [Ultralytics App](https://ultralytics.com/app_install). Start your journey for **Free** now!
 
 <a href="https://bit.ly/ultralytics_hub" target="_blank">
 <img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/ultralytics-hub.png" alt="Ultralytics HUB preview image"></a>
@@ -305,15 +340,15 @@
 ## <div align="center">Contribute</div>
 
 We love your input! YOLOv5 and YOLOv8 would not be possible without help from our community. Please see our [Contributing Guide](https://docs.ultralytics.com/help/contributing) to get started, and fill out our [Survey](https://ultralytics.com/survey?utm_source=github&utm_medium=social&utm_campaign=Survey) to send us feedback on your experience. Thank you  to all our contributors!
 
 <!-- SVG image from https://opencollective.com/ultralytics/contributors.svg?width=990 -->
 
 <a href="https://github.com/ultralytics/yolov5/graphs/contributors">
-<img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/image-contributors.png"></a>
+<img width="100%" src="https://github.com/ultralytics/assets/raw/main/im/image-contributors.png" alt="Ultralytics open-source contributors"></a>
 
 ## <div align="center">License</div>
 
 Ultralytics offers two licensing options to accommodate diverse use cases:
 
 - **AGPL-3.0 License**: This [OSI-approved](https://opensource.org/licenses/) open-source license is ideal for students and enthusiasts, promoting open collaboration and knowledge sharing. See the [LICENSE](https://github.com/ultralytics/ultralytics/blob/main/LICENSE) file for more details.
 - **Enterprise License**: Designed for commercial use, this license permits seamless integration of Ultralytics software and AI models into commercial goods and services, bypassing the open-source requirements of AGPL-3.0. If your scenario involves embedding our solutions into a commercial offering, reach out through [Ultralytics Licensing](https://ultralytics.com/license).
@@ -321,20 +356,20 @@
 ## <div align="center">Contact</div>
 
 For Ultralytics bug reports and feature requests please visit [GitHub Issues](https://github.com/ultralytics/ultralytics/issues), and join our [Discord](https://ultralytics.com/discord) community for questions and discussions!
 
 <br>
 <div align="center">
   <a href="https://github.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-github.png" width="3%" alt="Ultralytics GitHub"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.linkedin.com/company/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-linkedin.png" width="3%" alt="Ultralytics LinkedIn"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://twitter.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-twitter.png" width="3%" alt="Ultralytics Twitter"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://youtube.com/ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-youtube.png" width="3%" alt="Ultralytics YouTube"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.tiktok.com/@ultralytics"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-tiktok.png" width="3%" alt="Ultralytics TikTok"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://www.instagram.com/ultralytics/"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-instagram.png" width="3%" alt="Ultralytics Instagram"></a>
-  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%">
+  <img src="https://github.com/ultralytics/assets/raw/main/social/logo-transparent.png" width="3%" alt="space">
   <a href="https://ultralytics.com/discord"><img src="https://github.com/ultralytics/assets/raw/main/social/logo-social-discord.png" width="3%" alt="Ultralytics Discord"></a>
 </div>
```

#### html2text {}

```diff
@@ -1,107 +1,139 @@
-Metadata-Version: 2.1 Name: yolov8-pose-triton Version: 8.1.0 Summary:
+Metadata-Version: 2.1 Name: yolov8-pose-triton Version: 8.2.0 Summary:
 Ultralytics YOLOv8 for SOTA object detection, multi-object tracking, instance
-segmentation, pose estimation and image classification. Home-page: https://
-github.com/ultralytics/ultralytics Author: Ultralytics Author-email:
-hello@ultralytics.com License: AGPL-3.0 Project-URL: Bug Reports, https://
-github.com/ultralytics/ultralytics/issues Project-URL: Funding, https://
-ultralytics.com Project-URL: Source, https://github.com/hmurari/ultralytics
-Keywords: machine-learning,deep-
-learning,vision,ML,DL,AI,YOLO,YOLOv3,YOLOv5,YOLOv8,HUB,Ultralytics Classifier:
+segmentation, pose estimation and image classification. Author: Glenn Jocher,
+Ayush Chaurasia, Jing Qiu Maintainer: Glenn Jocher, Ayush Chaurasia, Jing Qiu
+License: AGPL-3.0 Project-URL: Bug Reports, https://github.com/ultralytics/
+ultralytics/issues Project-URL: Funding, https://ultralytics.com Project-URL:
+Source, https://github.com/hmurari/ultralytics/ Keywords: machine-
+learning,deep-learning,computer-
+vision,ML,DL,AI,YOLO,YOLOv3,YOLOv5,YOLOv8,HUB,Ultralytics Classifier:
 Development Status :: 4 - Beta Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Education Classifier: Intended Audience ::
 Science/Research Classifier: License :: OSI Approved :: GNU Affero General
 Public License v3 or later (AGPLv3+) Classifier: Programming Language :: Python
 :: 3 Classifier: Programming Language :: Python :: 3.8 Classifier: Programming
 Language :: Python :: 3.9 Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11 Classifier: Topic ::
-Software Development Classifier: Topic :: Scientific/Engineering Classifier:
-Topic :: Scientific/Engineering :: Artificial Intelligence Classifier: Topic ::
-Scientific/Engineering :: Image Recognition Classifier: Operating System ::
-POSIX :: Linux Classifier: Operating System :: MacOS Classifier: Operating
-System :: Microsoft :: Windows Requires-Python: >=3.8 Description-Content-Type:
-text/markdown License-File: LICENSE Requires-Dist: matplotlib>=3.3.0 Requires-
-Dist: numpy>=1.22.2 Requires-Dist: opencv-python>=4.6.0 Requires-Dist:
-pillow>=7.1.2 Requires-Dist: pyyaml>=5.3.1 Requires-Dist: requests>=2.23.0
-Requires-Dist: scipy>=1.4.1 Requires-Dist: torch>=1.8.0 Requires-Dist:
-torchvision>=0.9.0 Requires-Dist: tqdm>=4.64.0 Requires-Dist: pandas>=1.1.4
-Requires-Dist: seaborn>=0.11.0 Requires-Dist: psutil Requires-Dist: py-cpuinfo
-Requires-Dist: thop>=0.1.1 Provides-Extra: dev Requires-Dist: ipython; extra ==
-"dev" Requires-Dist: check-manifest; extra == "dev" Requires-Dist: pre-commit;
-extra == "dev" Requires-Dist: pytest; extra == "dev" Requires-Dist: pytest-cov;
-extra == "dev" Requires-Dist: coverage; extra == "dev" Requires-Dist: mkdocs-
-material; extra == "dev" Requires-Dist: mkdocstrings[python]; extra == "dev"
-Requires-Dist: mkdocs-redirects; extra == "dev" Requires-Dist: mkdocs-
-ultralytics-plugin>=0.0.34; extra == "dev" Provides-Extra: export Requires-
-Dist: coremltools>=7.0; extra == "export" Requires-Dist: openvino-dev>=2023.0;
-extra == "export" Requires-Dist: tensorflow<=2.13.1; extra == "export"
-Requires-Dist: tensorflowjs; extra == "export"
-  _[_h_t_t_p_s_:_/_/_r_a_w_._g_i_t_h_u_b_u_s_e_r_c_o_n_t_e_n_t_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_m_a_i_n_/_i_m_/_b_a_n_n_e_r_-_y_o_l_o_-
-                               _v_i_s_i_o_n_-_2_0_2_3_._p_n_g_]
+Classifier: Programming Language :: Python :: 3.11 Classifier: Programming
+Language :: Python :: 3.12 Classifier: Topic :: Software Development
+Classifier: Topic :: Scientific/Engineering Classifier: Topic :: Scientific/
+Engineering :: Artificial Intelligence Classifier: Topic :: Scientific/
+Engineering :: Image Recognition Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: MacOS Classifier: Operating System :: Microsoft
+:: Windows Requires-Python: >=3.8 Description-Content-Type: text/markdown
+License-File: LICENSE Requires-Dist: matplotlib>=3.3.0 Requires-Dist: opencv-
+python>=4.6.0 Requires-Dist: pillow>=7.1.2 Requires-Dist: pyyaml>=5.3.1
+Requires-Dist: requests>=2.23.0 Requires-Dist: scipy>=1.4.1 Requires-Dist:
+torch>=1.8.0 Requires-Dist: torchvision>=0.9.0 Requires-Dist: tqdm>=4.64.0
+Requires-Dist: psutil Requires-Dist: py-cpuinfo Requires-Dist: thop>=0.1.1
+Requires-Dist: pandas>=1.1.4 Requires-Dist: seaborn>=0.11.0 Provides-Extra: dev
+Requires-Dist: ipython; extra == "dev" Requires-Dist: check-manifest; extra ==
+"dev" Requires-Dist: pre-commit; extra == "dev" Requires-Dist: pytest; extra ==
+"dev" Requires-Dist: pytest-cov; extra == "dev" Requires-Dist: coverage[toml];
+extra == "dev" Requires-Dist: mkdocs-material>=9.5.9; extra == "dev" Requires-
+Dist: mkdocstrings[python]; extra == "dev" Requires-Dist: mkdocs-jupyter; extra
+== "dev" Requires-Dist: mkdocs-redirects; extra == "dev" Requires-Dist: mkdocs-
+ultralytics-plugin>=0.0.44; extra == "dev" Provides-Extra: export Requires-
+Dist: onnx>=1.12.0; extra == "export" Requires-Dist: coremltools>=7.0;
+(platform_system != "Windows" and python_version <= "3.11") and extra ==
+"export" Requires-Dist: openvino>=2024.0.0; extra == "export" Requires-Dist:
+tensorflow<=2.13.1; python_version <= "3.11" and extra == "export" Requires-
+Dist: tensorflowjs>=3.9.0; python_version <= "3.11" and extra == "export"
+Requires-Dist: numpy==1.23.5; platform_machine == "aarch64" and extra ==
+"export" Requires-Dist: h5py!=3.11.0; platform_machine == "aarch64" and extra
+== "export" Provides-Extra: explorer Requires-Dist: lancedb; extra ==
+"explorer" Requires-Dist: duckdb<=0.9.2; extra == "explorer" Requires-Dist:
+streamlit; extra == "explorer" Provides-Extra: logging Requires-Dist: comet;
+extra == "logging" Requires-Dist: tensorboard>=2.13.0; extra == "logging"
+Requires-Dist: dvclive>=2.12.0; extra == "logging" Provides-Extra: extra
+Requires-Dist: hub-sdk>=0.0.5; extra == "extra" Requires-Dist: ipython; extra
+== "extra" Requires-Dist: albumentations>=1.0.3; extra == "extra" Requires-
+Dist: pycocotools>=2.0.7; extra == "extra"
+                             _[_Y_O_L_O_ _V_i_s_i_o_n_ _b_a_n_n_e_r_]
        [](https://docs.ultralytics.com/zh/) | [](https://
  docs.ultralytics.com/ko/) | [](https://docs.ultralytics.com/ja/) |
     [](https://docs.ultralytics.com/ru/) | [Deutsch](https://
  docs.ultralytics.com/de/) | [Franais](https://docs.ultralytics.com/fr/) |
      [Espaol](https://docs.ultralytics.com/es/) | [Portugus](https://
 docs.ultralytics.com/pt/) | [](https://docs.ultralytics.com/
            hi/) | [](https://docs.ultralytics.com/ar/)
   _[_U_l_t_r_a_l_y_t_i_c_s_ _C_I_]_[_U_l_t_r_a_l_y_t_i_c_s_ _C_o_d_e_ _C_o_v_e_r_a_g_e_]_[_Y_O_L_O_v_8_ _C_i_t_a_t_i_o_n_]_[_D_o_c_k_e_r_ _P_u_l_l_s_]
+                                   _[_D_i_s_c_o_r_d_]
                _[_R_u_n_ _o_n_ _G_r_a_d_i_e_n_t_]_[_O_p_e_n_ _I_n_ _C_o_l_a_b_]_[_O_p_e_n_ _I_n_ _K_a_g_g_l_e_]
 
 [Ultralytics](https://ultralytics.com) [YOLOv8](https://github.com/ultralytics/
 ultralytics) is a cutting-edge, state-of-the-art (SOTA) model that builds upon
      the success of previous YOLO versions and introduces new features and
  improvements to further boost performance and flexibility. YOLOv8 is designed
 to be fast, accurate, and easy to use, making it an excellent choice for a wide
      range of object detection and tracking, instance segmentation, image
 classification and pose estimation tasks. We hope that the resources here will
 help you get the most out of YOLOv8. Please browse the YOLOv8 _D_o_c_s for details,
    raise an issue on _G_i_t_H_u_b for support, and join our _D_i_s_c_o_r_d community for
 questions and discussions! To request an Enterprise License please complete the
-  form at [Ultralytics Licensing](https://ultralytics.com/license).[https://
-   raw.githubusercontent.com/ultralytics/assets/main/yolov8/yolo-comparison-
-                                  plots.png]
-  _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][https://github.com/ultralytics/assets/raw/main/social/
-  logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][https://github.com/ultralytics/
-  assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_][https://
-github.com/ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s
-     _Y_o_u_T_u_b_e_][https://github.com/ultralytics/assets/raw/main/social/logo-
-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][https://github.com/ultralytics/assets/raw/
- main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _I_n_s_t_a_g_r_a_m_][https://github.com/
- ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
+   form at [Ultralytics Licensing](https://ultralytics.com/license).[YOLOv8
+                              performance plots]
+ _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_]
+  [space]_[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_T_u_b_e_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][space]_[_U_l_t_r_a_l_y_t_i_c_s
+                    _I_n_s_t_a_g_r_a_m_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
 ##
                                  Documentation
 See below for a quickstart installation and usage example, and see the [YOLOv8
 Docs](https://docs.ultralytics.com) for full documentation on training,
 validation, prediction and deployment. Install Pip install the ultralytics
 package including all [requirements](https://github.com/ultralytics/
-ultralytics/blob/main/requirements.txt) in a [**Python>=3.8**](https://
+ultralytics/blob/main/pyproject.toml) in a [**Python>=3.8**](https://
 www.python.org/) environment with [**PyTorch>=1.8**](https://pytorch.org/get-
 started/locally/). [![PyPI version](https://badge.fury.io/py/ultralytics.svg)]
 (https://badge.fury.io/py/ultralytics) [![Downloads](https://static.pepy.tech/
 badge/ultralytics)](https://pepy.tech/project/ultralytics) ```bash pip install
 ultralytics ``` For alternative installation methods including [Conda](https://
 anaconda.org/conda-forge/ultralytics), [Docker](https://hub.docker.com/r/
 ultralytics/ultralytics), and Git, please refer to the [Quickstart Guide]
-(https://docs.ultralytics.com/quickstart). Usage #### CLI YOLOv8 may be used
+(https://docs.ultralytics.com/quickstart). Usage ### CLI YOLOv8 may be used
 directly in the Command Line Interface (CLI) with a `yolo` command: ```bash
 yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'
 ``` `yolo` can be used for a variety of tasks and modes and accepts additional
 arguments, i.e. `imgsz=640`. See the YOLOv8 [CLI Docs](https://
-docs.ultralytics.com/usage/cli) for examples. #### Python YOLOv8 may also be
+docs.ultralytics.com/usage/cli) for examples. ### Python YOLOv8 may also be
 used directly in a Python environment, and accepts the same [arguments](https:/
 /docs.ultralytics.com/usage/cfg/) as in the CLI example above: ```python from
 ultralytics import YOLO # Load a model model = YOLO("yolov8n.yaml") # build a
 new model from scratch model = YOLO("yolov8n.pt") # load a pretrained model
 (recommended for training) # Use the model model.train(data="coco128.yaml",
 epochs=3) # train the model metrics = model.val() # evaluate model performance
 on the validation set results = model("https://ultralytics.com/images/bus.jpg")
 # predict on an image path = model.export(format="onnx") # export the model to
 ONNX format ``` See YOLOv8 [Python Docs](https://docs.ultralytics.com/usage/
-python) for more examples. ##
+python) for more examples. ### Notebooks Ultralytics provides interactive
+notebooks for YOLOv8, covering training, validation, tracking, and more. Each
+notebook is paired with a [YouTube](https://youtube.com/ultralytics) tutorial,
+making it easy to learn and implement advanced YOLOv8 features. | Docs |
+Notebook | YouTube | | --------------------------------------------------------
+------------------------------------------------------------------------- | ---
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+--------------------------------------------------------- | :------------------
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+-----------------------------: | | _Y_O_L_O_v_8_ _T_r_a_i_n_,_ _V_a_l_,_ _P_r_e_d_i_c_t_ _a_n_d_ _E_x_p_o_r_t_ _M_o_d_e_s
+| _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _U_l_t_r_a_l_y_t_i_c_s_ _H_U_B_ _Q_u_i_c_k_S_t_a_r_t | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _M_u_l_t_i_-_O_b_j_e_c_t_ _T_r_a_c_k_i_n_g_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _O_b_j_e_c_t_ _C_o_u_n_t_i_n_g_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _Y_O_L_O_v_8_ _H_e_a_t_m_a_p_s_ _i_n_ _V_i_d_e_o_s | _[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| | _U_l_t_r_a_l_y_t_i_c_s_ _D_a_t_a_s_e_t_s_ _E_x_p_l_o_r_e_r_ _w_i_t_h_ _S_Q_L_ _a_n_d_ _O_p_e_n_A_I_ _I_n_t_e_g_r_a_t_i_o_n_ _____ _N_e_w |
+_[_O_p_e_n_ _I_n_ _C_o_l_a_b_]|
+                          _[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_t_u_b_e_ _V_i_d_e_o_]
+| ##
                                     Models
 YOLOv8 [Detect](https://docs.ultralytics.com/tasks/detect), [Segment](https://
 docs.ultralytics.com/tasks/segment) and [Pose](https://docs.ultralytics.com/
 tasks/pose) models pretrained on the [COCO](https://docs.ultralytics.com/
 datasets/detect/coco) dataset are available here, as well as YOLOv8 [Classify]
 (https://docs.ultralytics.com/tasks/classify) models pretrained on the
 [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet) dataset.
@@ -120,23 +152,23 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
 ------------- | --------------------- | -------------------- | ----------------
 -------------- | ----------------------------------- | ------------------ | ---
 -------------- | | [YOLOv8n](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8n.pt) | 640 | 37.3 | 80.4 | 0.99 | 3.2 | 8.7 | |
-[YOLOv8s](https://github.com/ultralytics/assets/releases/download/v0.0.0/
+download/v8.1.0/yolov8n.pt) | 640 | 37.3 | 80.4 | 0.99 | 3.2 | 8.7 | |
+[YOLOv8s](https://github.com/ultralytics/assets/releases/download/v8.1.0/
 yolov8s.pt) | 640 | 44.9 | 128.4 | 1.20 | 11.2 | 28.6 | | [YOLOv8m](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m.pt) | 640 | 50.2
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m.pt) | 640 | 50.2
 | 234.7 | 1.83 | 25.9 | 78.9 | | [YOLOv8l](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8l.pt) | 640 | 52.9 | 375.2 | 2.39 | 43.7
+assets/releases/download/v8.1.0/yolov8l.pt) | 640 | 52.9 | 375.2 | 2.39 | 43.7
 | 165.2 | | [YOLOv8x](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8x.pt) | 640 | 53.9 | 479.1 | 3.53 | 68.2 | 257.8 | - **mAPval**
-values are for single-model single-scale on [COCO val2017](http://
+v8.1.0/yolov8x.pt) | 640 | 53.9 | 479.1 | 3.53 | 68.2 | 257.8 | - **mAPval**
+values are for single-model single-scale on [COCO val2017](https://
 cocodataset.org) dataset.
 Reproduce by `yolo val detect data=coco.yaml device=0` - **Speed** averaged
 over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/
 instance-types/p4/) instance.
 Reproduce by `yolo val detect data=coco.yaml batch=1 device=0|cpu` Detection
 (Open Image V7) See [Detection Docs](https://docs.ultralytics.com/tasks/detect/
 ) for usage examples with these models trained on [Open Image V7](https://
@@ -149,28 +181,28 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
 ------------------ | --------------------- | -------------------- | -----------
 ------------------- | ----------------------------------- | -----------------
 - | ----------------- | | [YOLOv8n](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8n-oiv7.pt) | 640 | 18.4 | 142.4 | 1.21 | 3.5 |
+releases/download/v8.1.0/yolov8n-oiv7.pt) | 640 | 18.4 | 142.4 | 1.21 | 3.5 |
 10.5 | | [YOLOv8s](https://github.com/ultralytics/assets/releases/download/
-v0.0.0/yolov8s-oiv7.pt) | 640 | 27.7 | 183.1 | 1.40 | 11.4 | 29.7 | | [YOLOv8m]
-(https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8m-
+v8.1.0/yolov8s-oiv7.pt) | 640 | 27.7 | 183.1 | 1.40 | 11.4 | 29.7 | | [YOLOv8m]
+(https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8m-
 oiv7.pt) | 640 | 33.6 | 408.5 | 2.26 | 26.2 | 80.6 | | [YOLOv8l](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8l-oiv7.pt) | 640 |
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-oiv7.pt) | 640 |
 34.9 | 596.9 | 2.43 | 44.1 | 167.4 | | [YOLOv8x](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-oiv7.pt) | 640 | 36.3 |
+ultralytics/assets/releases/download/v8.1.0/yolov8x-oiv7.pt) | 640 | 36.3 |
 860.6 | 3.56 | 68.7 | 260.6 | - **mAPval** values are for single-model single-
 scale on [Open Image V7](https://docs.ultralytics.com/datasets/detect/open-
 images-v7/) dataset.
 Reproduce by `yolo val detect data=open-images-v7.yaml device=0` - **Speed**
-averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/
-ec2/instance-types/p4/) instance.
+averaged over Open Image V7 val images using an [Amazon EC2 P4d](https://
+aws.amazon.com/ec2/instance-types/p4/) instance.
 Reproduce by `yolo val detect data=open-images-v7.yaml batch=1 device=0|cpu`
 Segmentation (COCO) See [Segmentation Docs](https://docs.ultralytics.com/tasks/
 segment/) for usage examples with these models trained on [COCO-Seg](https://
 docs.ultralytics.com/datasets/segment/coco/), which include 80 pre-trained
 classes. | Model | size
 (pixels) | mAPbox
 50-95 | mAPmask
@@ -180,25 +212,25 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
 --------------------- | --------------------- | -------------------- | --------
 ------------- | ------------------------------ | ------------------------------
 ----- | ------------------ | ----------------- | | [YOLOv8n-seg](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-seg.pt) | 640 |
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-seg.pt) | 640 |
 36.7 | 30.5 | 96.1 | 1.21 | 3.4 | 12.6 | | [YOLOv8s-seg](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-seg.pt) | 640 | 44.6 | 36.8
+ultralytics/assets/releases/download/v8.1.0/yolov8s-seg.pt) | 640 | 44.6 | 36.8
 | 155.7 | 1.47 | 11.8 | 42.6 | | [YOLOv8m-seg](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8m-seg.pt) | 640 | 49.9 | 40.8 | 317.0 |
+assets/releases/download/v8.1.0/yolov8m-seg.pt) | 640 | 49.9 | 40.8 | 317.0 |
 2.18 | 27.3 | 110.2 | | [YOLOv8l-seg](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8l-seg.pt) | 640 | 52.3 | 42.6 | 572.4 | 2.79 |
+releases/download/v8.1.0/yolov8l-seg.pt) | 640 | 52.3 | 42.6 | 572.4 | 2.79 |
 46.0 | 220.5 | | [YOLOv8x-seg](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8x-seg.pt) | 640 | 53.4 | 43.4 | 712.1 | 4.02 | 71.8 |
+download/v8.1.0/yolov8x-seg.pt) | 640 | 53.4 | 43.4 | 712.1 | 4.02 | 71.8 |
 344.1 | - **mAPval** values are for single-model single-scale on [COCO val2017]
-(http://cocodataset.org) dataset.
+(https://cocodataset.org) dataset.
 Reproduce by `yolo val segment data=coco-seg.yaml device=0` - **Speed**
 averaged over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/
 ec2/instance-types/p4/) instance.
 Reproduce by `yolo val segment data=coco-seg.yaml batch=1 device=0|cpu` Pose
 (COCO) See [Pose Docs](https://docs.ultralytics.com/tasks/pose/) for usage
 examples with these models trained on [COCO-Pose](https://docs.ultralytics.com/
 datasets/pose/coco/), which include 1 pre-trained class, person. | Model | size
@@ -210,32 +242,63 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) | | -----------------------------------------------------------------------
 ----------------------------- | --------------------- | --------------------- |
 ------------------ | ------------------------------ | -------------------------
 ---------- | ------------------ | ----------------- | | [YOLOv8n-pose](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-pose.pt) | 640 |
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-pose.pt) | 640 |
 50.4 | 80.1 | 131.8 | 1.18 | 3.3 | 9.2 | | [YOLOv8s-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-pose.pt) | 640 | 60.0 |
+ultralytics/assets/releases/download/v8.1.0/yolov8s-pose.pt) | 640 | 60.0 |
 86.2 | 233.2 | 1.42 | 11.6 | 30.2 | | [YOLOv8m-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8m-pose.pt) | 640 | 65.0 |
+ultralytics/assets/releases/download/v8.1.0/yolov8m-pose.pt) | 640 | 65.0 |
 88.8 | 456.3 | 2.00 | 26.4 | 81.0 | | [YOLOv8l-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8l-pose.pt) | 640 | 67.6 |
+ultralytics/assets/releases/download/v8.1.0/yolov8l-pose.pt) | 640 | 67.6 |
 90.0 | 784.5 | 2.59 | 44.4 | 168.6 | | [YOLOv8x-pose](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-pose.pt) | 640 | 69.2 |
+ultralytics/assets/releases/download/v8.1.0/yolov8x-pose.pt) | 640 | 69.2 |
 90.2 | 1607.1 | 3.73 | 69.4 | 263.2 | | [YOLOv8x-pose-p6](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8x-pose-p6.pt) | 1280 | 71.6 |
+ultralytics/assets/releases/download/v8.1.0/yolov8x-pose-p6.pt) | 1280 | 71.6 |
 91.2 | 4088.7 | 10.04 | 99.1 | 1066.4 | - **mAPval** values are for single-
-model single-scale on [COCO Keypoints val2017](http://cocodataset.org) dataset.
-
+model single-scale on [COCO Keypoints val2017](https://cocodataset.org)
+dataset.
 Reproduce by `yolo val pose data=coco-pose.yaml device=0` - **Speed** averaged
 over COCO val images using an [Amazon EC2 P4d](https://aws.amazon.com/ec2/
 instance-types/p4/) instance.
-Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu`
+Reproduce by `yolo val pose data=coco-pose.yaml batch=1 device=0|cpu` OBB
+(DOTAv1) See [OBB Docs](https://docs.ultralytics.com/tasks/obb/) for usage
+examples with these models trained on [DOTAv1](https://docs.ultralytics.com/
+datasets/obb/dota-v2/#dota-v10/), which include 15 pre-trained classes. | Model
+| size
+(pixels) | mAPtest
+50 | Speed
+CPU ONNX
+(ms) | Speed
+A100 TensorRT
+(ms) | params
+(M) | FLOPs
+(B) | | -----------------------------------------------------------------------
+--------------------- | --------------------- | ------------------ | ----------
+-------------------- | ----------------------------------- | -----------------
+- | ----------------- | | [YOLOv8n-obb](https://github.com/ultralytics/assets/
+releases/download/v8.1.0/yolov8n-obb.pt) | 1024 | 78.0 | 204.77 | 3.57 | 3.1 |
+23.3 | | [YOLOv8s-obb](https://github.com/ultralytics/assets/releases/download/
+v8.1.0/yolov8s-obb.pt) | 1024 | 79.5 | 424.88 | 4.07 | 11.4 | 76.3 | |
+[YOLOv8m-obb](https://github.com/ultralytics/assets/releases/download/v8.1.0/
+yolov8m-obb.pt) | 1024 | 80.5 | 763.48 | 7.61 | 26.4 | 208.6 | | [YOLOv8l-obb]
+(https://github.com/ultralytics/assets/releases/download/v8.1.0/yolov8l-obb.pt)
+| 1024 | 80.7 | 1278.42 | 11.83 | 44.5 | 433.8 | | [YOLOv8x-obb](https://
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8x-obb.pt) | 1024 |
+81.36 | 1759.10 | 13.23 | 69.5 | 676.7 | - **mAPtest** values are for single-
+model multiscale on [DOTAv1](https://captain-whu.github.io/DOTA/index.html)
+dataset.
+Reproduce by `yolo val obb data=DOTAv1.yaml device=0 split=test` and submit
+merged results to [DOTA evaluation](https://captain-whu.github.io/DOTA/
+evaluation.html). - **Speed** averaged over DOTAv1 val images using an [Amazon
+EC2 P4d](https://aws.amazon.com/ec2/instance-types/p4/) instance.
+Reproduce by `yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu`
 Classification (ImageNet) See [Classification Docs](https://
 docs.ultralytics.com/tasks/classify/) for usage examples with these models
 trained on [ImageNet](https://docs.ultralytics.com/datasets/classify/imagenet/
 ), which include 1000 pretrained classes. | Model | size
 (pixels) | acc
 top1 | acc
 top5 | Speed
@@ -244,73 +307,70 @@
 A100 TensorRT
 (ms) | params
 (M) | FLOPs
 (B) at 640 | | ----------------------------------------------------------------
 ---------------------------- | --------------------- | ---------------- | -----
 ----------- | ------------------------------ | --------------------------------
 --- | ------------------ | ------------------------ | | [YOLOv8n-cls](https://
-github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n-cls.pt) | 224 |
-66.6 | 87.0 | 12.9 | 0.31 | 2.7 | 4.3 | | [YOLOv8s-cls](https://github.com/
-ultralytics/assets/releases/download/v0.0.0/yolov8s-cls.pt) | 224 | 72.3 | 91.1
+github.com/ultralytics/assets/releases/download/v8.1.0/yolov8n-cls.pt) | 224 |
+69.0 | 88.3 | 12.9 | 0.31 | 2.7 | 4.3 | | [YOLOv8s-cls](https://github.com/
+ultralytics/assets/releases/download/v8.1.0/yolov8s-cls.pt) | 224 | 73.8 | 91.7
 | 23.4 | 0.35 | 6.4 | 13.5 | | [YOLOv8m-cls](https://github.com/ultralytics/
-assets/releases/download/v0.0.0/yolov8m-cls.pt) | 224 | 76.4 | 93.2 | 85.4 |
+assets/releases/download/v8.1.0/yolov8m-cls.pt) | 224 | 76.8 | 93.5 | 85.4 |
 0.62 | 17.0 | 42.7 | | [YOLOv8l-cls](https://github.com/ultralytics/assets/
-releases/download/v0.0.0/yolov8l-cls.pt) | 224 | 78.0 | 94.1 | 163.0 | 0.87 |
+releases/download/v8.1.0/yolov8l-cls.pt) | 224 | 76.8 | 93.5 | 163.0 | 0.87 |
 37.5 | 99.7 | | [YOLOv8x-cls](https://github.com/ultralytics/assets/releases/
-download/v0.0.0/yolov8x-cls.pt) | 224 | 78.4 | 94.3 | 232.0 | 1.01 | 57.4 |
+download/v8.1.0/yolov8x-cls.pt) | 224 | 79.0 | 94.6 | 232.0 | 1.01 | 57.4 |
 154.8 | - **acc** values are model accuracies on the [ImageNet](https://
 www.image-net.org/) dataset validation set.
 Reproduce by `yolo val classify data=path/to/ImageNet device=0` - **Speed**
 averaged over ImageNet val images using an [Amazon EC2 P4d](https://
 aws.amazon.com/ec2/instance-types/p4/) instance.
 Reproduce by `yolo val classify data=path/to/ImageNet batch=1 device=0|cpu` ##
                                  Integrations
 Our key integrations with leading AI platforms extend the functionality of
 Ultralytics' offerings, enhancing tasks like dataset labeling, training,
 visualization, and model management. Discover how Ultralytics, in collaboration
 with [Roboflow](https://roboflow.com/?ref=ultralytics), ClearML, [Comet](https:
 //bit.ly/yolov8-readme-comet), Neural Magic and [OpenVINO](https://
 docs.ultralytics.com/integrations/openvino), can optimize your AI workflow.
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_y_o_l_o_v_8_/_b_a_n_n_e_r_-_i_n_t_e_g_r_a_t_i_o_n_s_._p_n_g_]
+_[_U_l_t_r_a_l_y_t_i_c_s_ _a_c_t_i_v_e_ _l_e_a_r_n_i_n_g_ _i_n_t_e_g_r_a_t_i_o_n_s_]
 
-  _[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_r_o_b_o_f_l_o_w_._p_n_g_]
-  _[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_c_l_e_a_r_m_l_._p_n_g_]
-_[_h_t_t_p_s_:_/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_c_o_m_e_t_._p_n_g_]_[_h_t_t_p_s_:
-    _/_/_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_p_a_r_t_n_e_r_s_/_l_o_g_o_-_n_e_u_r_a_l_m_a_g_i_c_._p_n_g_]
+ _[_R_o_b_o_f_l_o_w_ _l_o_g_o_][space]_[_C_l_e_a_r_M_L_ _l_o_g_o_][space]_[_C_o_m_e_t_ _M_L_ _l_o_g_o_][space]_[_N_e_u_r_a_l_M_a_g_i_c
+                                     _l_o_g_o_]
 | Roboflow | ClearML  NEW | Comet  NEW | Neural Magic  NEW | | :------
 -------------------------------------------------------------------------------
 -------------------------------------: | :-------------------------------------
+------------------------------------------------------------------------: | :--
 -------------------------------------------------------------------------------
--------------: | :-------------------------------------------------------------
+----------------------------------------------------------------------: | :----
 -------------------------------------------------------------------------------
------------: | :---------------------------------------------------------------
--------------------------------------: | | Label and export your custom
-datasets directly to YOLOv8 for training with [Roboflow](https://roboflow.com/
-?ref=ultralytics) | Automatically track, visualize and even remotely train
-YOLOv8 using [ClearML](https://cutt.ly/yolov5-readme-clearml) (open-source!) |
-Free forever, [Comet](https://bit.ly/yolov8-readme-comet) lets you save YOLOv8
-models, resume training, and interactively visualize and debug predictions |
-Run YOLOv8 inference up to 6x faster with [Neural Magic DeepSparse](https://
-bit.ly/yolov5-neuralmagic) | ##
+-----------------: | | Label and export your custom datasets directly to YOLOv8
+for training with [Roboflow](https://roboflow.com/?ref=ultralytics) |
+Automatically track, visualize and even remotely train YOLOv8 using [ClearML]
+(https://clear.ml/) (open-source!) | Free forever, [Comet](https://bit.ly/
+yolov8-readme-comet) lets you save YOLOv8 models, resume training, and
+interactively visualize and debug predictions | Run YOLOv8 inference up to 6x
+faster with [Neural Magic DeepSparse](https://bit.ly/yolov5-neuralmagic) | ##
                                 Ultralytics HUB
 Experience seamless AI with [Ultralytics HUB](https://bit.ly/ultralytics_hub)
 , the all-in-one solution for data visualization, YOLOv5 and YOLOv8 
 model training and deployment, without any coding. Transform images into
 actionable insights and bring your AI visions to life with ease using our
 cutting-edge platform and user-friendly [Ultralytics App](https://
 ultralytics.com/app_install). Start your journey for **Free** now! _[_U_l_t_r_a_l_y_t_i_c_s
 _H_U_B_ _p_r_e_v_i_e_w_ _i_m_a_g_e_]##
                                   Contribute
 We love your input! YOLOv5 and YOLOv8 would not be possible without help from
 our community. Please see our [Contributing Guide](https://
 docs.ultralytics.com/help/contributing) to get started, and fill out our
 [Survey](https://ultralytics.com/
 survey?utm_source=github&utm_medium=social&utm_campaign=Survey) to send us
-feedback on your experience. Thank you  to all our contributors! _[_h_t_t_p_s_:_/_/
-_g_i_t_h_u_b_._c_o_m_/_u_l_t_r_a_l_y_t_i_c_s_/_a_s_s_e_t_s_/_r_a_w_/_m_a_i_n_/_i_m_/_i_m_a_g_e_-_c_o_n_t_r_i_b_u_t_o_r_s_._p_n_g_]##
+feedback on your experience. Thank you  to all our contributors!
+_[_U_l_t_r_a_l_y_t_i_c_s_ _o_p_e_n_-_s_o_u_r_c_e_ _c_o_n_t_r_i_b_u_t_o_r_s_]##
                                     License
 Ultralytics offers two licensing options to accommodate diverse use cases: -
 **AGPL-3.0 License**: This [OSI-approved](https://opensource.org/licenses/
 ) open-source license is ideal for students and enthusiasts, promoting open
 collaboration and knowledge sharing. See the [LICENSE](https://github.com/
 ultralytics/ultralytics/blob/main/LICENSE) file for more details. -
 **Enterprise License**: Designed for commercial use, this license permits
@@ -318,15 +378,10 @@
 goods and services, bypassing the open-source requirements of AGPL-3.0. If your
 scenario involves embedding our solutions into a commercial offering, reach out
 through [Ultralytics Licensing](https://ultralytics.com/license). ##
                                     Contact
 For Ultralytics bug reports and feature requests please visit [GitHub Issues]
 (https://github.com/ultralytics/ultralytics/issues), and join our [Discord]
 (https://ultralytics.com/discord) community for questions and discussions!
-  _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][https://github.com/ultralytics/assets/raw/main/social/
-  logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][https://github.com/ultralytics/
-  assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_][https://
-github.com/ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s
-     _Y_o_u_T_u_b_e_][https://github.com/ultralytics/assets/raw/main/social/logo-
-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][https://github.com/ultralytics/assets/raw/
- main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _I_n_s_t_a_g_r_a_m_][https://github.com/
- ultralytics/assets/raw/main/social/logo-transparent.png]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
+ _[_U_l_t_r_a_l_y_t_i_c_s_ _G_i_t_H_u_b_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _L_i_n_k_e_d_I_n_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_w_i_t_t_e_r_]
+  [space]_[_U_l_t_r_a_l_y_t_i_c_s_ _Y_o_u_T_u_b_e_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _T_i_k_T_o_k_][space]_[_U_l_t_r_a_l_y_t_i_c_s
+                    _I_n_s_t_a_g_r_a_m_][space]_[_U_l_t_r_a_l_y_t_i_c_s_ _D_i_s_c_o_r_d_]
```

### Comparing `yolov8-pose-triton-8.1.0/yolov8_pose_triton.egg-info/SOURCES.txt` & `yolov8_pose_triton-8.2.0/yolov8_pose_triton.egg-info/SOURCES.txt`

 * *Files 12% similar despite different names*

```diff
@@ -1,72 +1,98 @@
 CONTRIBUTING.md
 LICENSE
-MANIFEST.in
 README.md
 README.zh-CN.md
-requirements.txt
-setup.cfg
-setup.py
+pyproject.toml
 tests/conftest.py
 tests/test_cli.py
 tests/test_cuda.py
 tests/test_engine.py
+tests/test_explorer.py
 tests/test_integrations.py
 tests/test_python.py
 ultralytics/__init__.py
 ultralytics/assets/bus.jpg
 ultralytics/assets/zidane.jpg
 ultralytics/cfg/__init__.py
 ultralytics/cfg/default.yaml
 ultralytics/cfg/datasets/Argoverse.yaml
-ultralytics/cfg/datasets/DOTAv2.yaml
+ultralytics/cfg/datasets/DOTAv1.5.yaml
+ultralytics/cfg/datasets/DOTAv1.yaml
 ultralytics/cfg/datasets/GlobalWheat2020.yaml
 ultralytics/cfg/datasets/ImageNet.yaml
 ultralytics/cfg/datasets/Objects365.yaml
 ultralytics/cfg/datasets/SKU-110K.yaml
 ultralytics/cfg/datasets/VOC.yaml
 ultralytics/cfg/datasets/VisDrone.yaml
+ultralytics/cfg/datasets/african-wildlife.yaml
+ultralytics/cfg/datasets/brain-tumor.yaml
+ultralytics/cfg/datasets/carparts-seg.yaml
 ultralytics/cfg/datasets/coco-pose.yaml
 ultralytics/cfg/datasets/coco.yaml
 ultralytics/cfg/datasets/coco128-seg.yaml
 ultralytics/cfg/datasets/coco128.yaml
 ultralytics/cfg/datasets/coco8-pose.yaml
 ultralytics/cfg/datasets/coco8-seg.yaml
 ultralytics/cfg/datasets/coco8.yaml
+ultralytics/cfg/datasets/crack-seg.yaml
+ultralytics/cfg/datasets/dota8.yaml
+ultralytics/cfg/datasets/lvis.yaml
 ultralytics/cfg/datasets/open-images-v7.yaml
+ultralytics/cfg/datasets/package-seg.yaml
 ultralytics/cfg/datasets/tiger-pose.yaml
 ultralytics/cfg/datasets/xView.yaml
 ultralytics/cfg/models/rt-detr/rtdetr-l.yaml
+ultralytics/cfg/models/rt-detr/rtdetr-resnet101.yaml
+ultralytics/cfg/models/rt-detr/rtdetr-resnet50.yaml
 ultralytics/cfg/models/rt-detr/rtdetr-x.yaml
 ultralytics/cfg/models/v3/yolov3-spp.yaml
 ultralytics/cfg/models/v3/yolov3-tiny.yaml
 ultralytics/cfg/models/v3/yolov3.yaml
 ultralytics/cfg/models/v5/yolov5-p6.yaml
 ultralytics/cfg/models/v5/yolov5.yaml
 ultralytics/cfg/models/v6/yolov6.yaml
+ultralytics/cfg/models/v8/yolov8-cls-resnet101.yaml
+ultralytics/cfg/models/v8/yolov8-cls-resnet50.yaml
 ultralytics/cfg/models/v8/yolov8-cls.yaml
+ultralytics/cfg/models/v8/yolov8-ghost-p2.yaml
+ultralytics/cfg/models/v8/yolov8-ghost-p6.yaml
+ultralytics/cfg/models/v8/yolov8-ghost.yaml
+ultralytics/cfg/models/v8/yolov8-obb.yaml
 ultralytics/cfg/models/v8/yolov8-p2.yaml
 ultralytics/cfg/models/v8/yolov8-p6.yaml
 ultralytics/cfg/models/v8/yolov8-pose-p6.yaml
 ultralytics/cfg/models/v8/yolov8-pose.yaml
 ultralytics/cfg/models/v8/yolov8-rtdetr.yaml
 ultralytics/cfg/models/v8/yolov8-seg-p6.yaml
 ultralytics/cfg/models/v8/yolov8-seg.yaml
+ultralytics/cfg/models/v8/yolov8-world.yaml
+ultralytics/cfg/models/v8/yolov8-worldv2.yaml
 ultralytics/cfg/models/v8/yolov8.yaml
+ultralytics/cfg/models/v9/yolov9c-seg.yaml
+ultralytics/cfg/models/v9/yolov9c.yaml
+ultralytics/cfg/models/v9/yolov9e-seg.yaml
+ultralytics/cfg/models/v9/yolov9e.yaml
 ultralytics/cfg/trackers/botsort.yaml
 ultralytics/cfg/trackers/bytetrack.yaml
 ultralytics/data/__init__.py
 ultralytics/data/annotator.py
 ultralytics/data/augment.py
 ultralytics/data/base.py
 ultralytics/data/build.py
 ultralytics/data/converter.py
 ultralytics/data/dataset.py
 ultralytics/data/loaders.py
+ultralytics/data/split_dota.py
 ultralytics/data/utils.py
+ultralytics/data/explorer/__init__.py
+ultralytics/data/explorer/explorer.py
+ultralytics/data/explorer/utils.py
+ultralytics/data/explorer/gui/__init__.py
+ultralytics/data/explorer/gui/dash.py
 ultralytics/engine/__init__.py
 ultralytics/engine/exporter.py
 ultralytics/engine/model.py
 ultralytics/engine/predictor.py
 ultralytics/engine/results.py
 ultralytics/engine/trainer.py
 ultralytics/engine/tuner.py
@@ -111,31 +137,45 @@
 ultralytics/models/yolo/classify/predict.py
 ultralytics/models/yolo/classify/train.py
 ultralytics/models/yolo/classify/val.py
 ultralytics/models/yolo/detect/__init__.py
 ultralytics/models/yolo/detect/predict.py
 ultralytics/models/yolo/detect/train.py
 ultralytics/models/yolo/detect/val.py
+ultralytics/models/yolo/obb/__init__.py
+ultralytics/models/yolo/obb/predict.py
+ultralytics/models/yolo/obb/train.py
+ultralytics/models/yolo/obb/val.py
 ultralytics/models/yolo/pose/__init__.py
 ultralytics/models/yolo/pose/predict.py
 ultralytics/models/yolo/pose/train.py
 ultralytics/models/yolo/pose/val.py
 ultralytics/models/yolo/segment/__init__.py
 ultralytics/models/yolo/segment/predict.py
 ultralytics/models/yolo/segment/train.py
 ultralytics/models/yolo/segment/val.py
+ultralytics/models/yolo/world/__init__.py
+ultralytics/models/yolo/world/train.py
+ultralytics/models/yolo/world/train_world.py
 ultralytics/nn/__init__.py
 ultralytics/nn/autobackend.py
 ultralytics/nn/tasks.py
 ultralytics/nn/modules/__init__.py
 ultralytics/nn/modules/block.py
 ultralytics/nn/modules/conv.py
 ultralytics/nn/modules/head.py
 ultralytics/nn/modules/transformer.py
 ultralytics/nn/modules/utils.py
+ultralytics/solutions/__init__.py
+ultralytics/solutions/ai_gym.py
+ultralytics/solutions/distance_calculation.py
+ultralytics/solutions/heatmap.py
+ultralytics/solutions/object_counter.py
+ultralytics/solutions/queue_management.py
+ultralytics/solutions/speed_estimation.py
 ultralytics/trackers/__init__.py
 ultralytics/trackers/basetrack.py
 ultralytics/trackers/bot_sort.py
 ultralytics/trackers/byte_tracker.py
 ultralytics/trackers/track.py
 ultralytics/trackers/utils/__init__.py
 ultralytics/trackers/utils/gmc.py
```

